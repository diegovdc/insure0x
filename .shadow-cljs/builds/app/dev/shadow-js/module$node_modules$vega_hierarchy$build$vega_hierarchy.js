["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-hierarchy/build/vega-hierarchy.js"],"~:js","shadow$provide.module$node_modules$vega_hierarchy$build$vega_hierarchy=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_dataflow$build$vega_dataflow\"),require(\"module$node_modules$vega_util$build$vega_util\"),require(\"module$node_modules$d3_hierarchy$dist$d3_hierarchy\")):\"function\"===typeof define&&define.amd?define([\"exports\",\"vega-dataflow\",\n\"vega-util\",\"d3-hierarchy\"],factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory((global.vega=global.vega||{},global.vega.transforms={}),global.vega,global.vega,global.d3))})(this,function(exports,vegaDataflow,vegaUtil,d3Hierarchy){function lookup(tree,key,filter){var map={};tree.each(function(node){var t=node.data;filter(t)&&(map[key(t)]=node)});tree.lookup=map;return tree}function Nest(params){vegaDataflow.Transform.call(this,null,params)}function nest$jscomp$0(){function apply(array,\ndepth){if(depth>=keys.length)return array;for(var n=array.length,key=keys[depth++],valuesByKey={},result={},i=-1,keyValue,value,values;++i<n;)keyValue=key(value=array[i])+\"\",(values=valuesByKey[keyValue])?values.push(value):valuesByKey[keyValue]=[value];for(keyValue in valuesByKey)result[keyValue]=apply(valuesByKey[keyValue],depth);return result}function entries(map,depth){if(++depth>keys.length)return map;var array=[],key;for(key in map)array.push({key:key,values:entries(map[key],depth)});return array}\nvar keys=[],nest={entries:function(array){return entries(apply(array,0),0)},key:function(d){return keys.push(d),nest}};return nest}function HierarchyLayout(params){vegaDataflow.Transform.call(this,null,params)}function setParams(layout,params,_){for(var p,i=0,n=params.length;i<n;++i)if(p=params[i],p in _)layout[p](_[p])}function Pack(params){HierarchyLayout.call(this,params)}function Partition(params){HierarchyLayout.call(this,params)}function Stratify(params){vegaDataflow.Transform.call(this,null,\nparams)}function Tree(params){HierarchyLayout.call(this,params)}function TreeLinks(params){vegaDataflow.Transform.call(this,[],params)}function Treemap(params){HierarchyLayout.call(this,params)}Nest.Definition={type:\"Nest\",metadata:{treesource:!0,changes:!0},params:[{name:\"keys\",type:\"field\",array:!0},{name:\"generate\",type:\"boolean\"}]};var children=function(n){return n.values};vegaUtil.inherits(Nest,vegaDataflow.Transform,{transform:function(_,pulse){pulse.source||vegaUtil.error(\"Nest transform requires an upstream data source.\");\nvar gen=_.generate,mod=_.modified(),out=pulse.clone(),tree=this.value;if(!tree||mod||pulse.changed())tree&&tree.each(function(node){node.children&&vegaDataflow.isTuple(node.data)&&out.rem.push(node.data)}),this.value=tree=d3Hierarchy.hierarchy({values:vegaUtil.array(_.keys).reduce(function(n,k){n.key(k);return n},nest$jscomp$0()).entries(out.source)},children),gen&&tree.each(function(node){node.children&&(node=vegaDataflow.ingest(node.data),out.add.push(node),out.source.push(node))}),lookup(tree,\nvegaDataflow.tupleid,vegaDataflow.tupleid);out.source.root=tree;return out}});var defaultSeparation=function(a,b){return a.parent===b.parent?1:2};vegaUtil.inherits(HierarchyLayout,vegaDataflow.Transform,{transform:function(_,pulse){pulse.source&&pulse.source.root||vegaUtil.error(this.constructor.name+\" transform requires a backing tree data source.\");var layout=this.layout(_.method),fields=this.fields,root=pulse.source.root,as=_.as||fields;_.field?root.sum(_.field):root.count();_.sort&&root.sort(vegaDataflow.stableCompare(_.sort,\nfunction(d){return d.data}));setParams(layout,this.params,_);layout.separation&&layout.separation(!1!==_.separation?defaultSeparation:vegaUtil.one);try{this.value=layout(root)}catch(err){vegaUtil.error(err)}root.each(function(node){for(var t=node.data,n=fields.length-1,i=0;i<n;++i)t[as[i]]=node[fields[i]];t[as[n]]=node.children?node.children.length:0});return pulse.reflow(_.modified()).modifies(as).modifies(\"leaf\")}});var Output=[\"x\",\"y\",\"r\",\"depth\",\"children\"];Pack.Definition={type:\"Pack\",metadata:{tree:!0,\nmodifies:!0},params:[{name:\"field\",type:\"field\"},{name:\"sort\",type:\"compare\"},{name:\"padding\",type:\"number\",\"default\":0},{name:\"radius\",type:\"field\",\"default\":null},{name:\"size\",type:\"number\",array:!0,length:2},{name:\"as\",type:\"string\",array:!0,length:Output.length,\"default\":Output}]};vegaUtil.inherits(Pack,HierarchyLayout,{layout:d3Hierarchy.pack,params:[\"radius\",\"size\",\"padding\"],fields:Output});Output=\"x0 y0 x1 y1 depth children\".split(\" \");Partition.Definition={type:\"Partition\",metadata:{tree:!0,\nmodifies:!0},params:[{name:\"field\",type:\"field\"},{name:\"sort\",type:\"compare\"},{name:\"padding\",type:\"number\",\"default\":0},{name:\"round\",type:\"boolean\",\"default\":!1},{name:\"size\",type:\"number\",array:!0,length:2},{name:\"as\",type:\"string\",array:!0,length:Output.length,\"default\":Output}]};vegaUtil.inherits(Partition,HierarchyLayout,{layout:d3Hierarchy.partition,params:[\"size\",\"round\",\"padding\"],fields:Output});Stratify.Definition={type:\"Stratify\",metadata:{treesource:!0},params:[{name:\"key\",type:\"field\",\nrequired:!0},{name:\"parentKey\",type:\"field\",required:!0}]};vegaUtil.inherits(Stratify,vegaDataflow.Transform,{transform:function(_,pulse){pulse.source||vegaUtil.error(\"Stratify transform requires an upstream data source.\");var tree=this.value,mod=_.modified(),out=pulse.fork(pulse.ALL).materialize(pulse.SOURCE);pulse=!tree||mod||pulse.changed(pulse.ADD_REM)||pulse.modified(_.key.fields)||pulse.modified(_.parentKey.fields);out.source=out.source.slice();pulse&&(tree=out.source.length?lookup(d3Hierarchy.stratify().id(_.key).parentId(_.parentKey)(out.source),\n_.key,vegaUtil.truthy):lookup(d3Hierarchy.stratify()([{}]),_.key,_.key));out.source.root=this.value=tree;return out}});var Layouts={tidy:d3Hierarchy.tree,cluster:d3Hierarchy.cluster};Output=[\"x\",\"y\",\"depth\",\"children\"];Tree.Definition={type:\"Tree\",metadata:{tree:!0,modifies:!0},params:[{name:\"field\",type:\"field\"},{name:\"sort\",type:\"compare\"},{name:\"method\",type:\"enum\",\"default\":\"tidy\",values:[\"tidy\",\"cluster\"]},{name:\"size\",type:\"number\",array:!0,length:2},{name:\"nodeSize\",type:\"number\",array:!0,\nlength:2},{name:\"separation\",type:\"boolean\",\"default\":!0},{name:\"as\",type:\"string\",array:!0,length:Output.length,\"default\":Output}]};vegaUtil.inherits(Tree,HierarchyLayout,{layout:function(method){method=method||\"tidy\";if(vegaUtil.hasOwnProperty(Layouts,method))return Layouts[method]();vegaUtil.error(\"Unrecognized Tree layout method: \"+method)},params:[\"size\",\"nodeSize\"],fields:Output});TreeLinks.Definition={type:\"TreeLinks\",metadata:{tree:!0,generates:!0,changes:!0},params:[]};vegaUtil.inherits(TreeLinks,\nvegaDataflow.Transform,{transform:function(_,pulse){_=this.value;var tree=pulse.source&&pulse.source.root,out=pulse.fork(pulse.NO_SOURCE),lut={};tree||vegaUtil.error(\"TreeLinks transform requires a tree data source.\");pulse.changed(pulse.ADD_REM)?(out.rem=_,pulse.visit(pulse.SOURCE,function(t){return lut[vegaDataflow.tupleid(t)]=1}),tree.each(function(node){var t=node.data;(node=node.parent&&node.parent.data)&&lut[vegaDataflow.tupleid(t)]&&lut[vegaDataflow.tupleid(node)]&&out.add.push(vegaDataflow.ingest({source:node,\ntarget:t}))}),this.value=out.add):pulse.changed(pulse.MOD)&&(pulse.visit(pulse.MOD,function(t){return lut[vegaDataflow.tupleid(t)]=1}),_.forEach(function(link){(lut[vegaDataflow.tupleid(link.source)]||lut[vegaDataflow.tupleid(link.target)])&&out.mod.push(link)}));return out}});var Tiles={binary:d3Hierarchy.treemapBinary,dice:d3Hierarchy.treemapDice,slice:d3Hierarchy.treemapSlice,slicedice:d3Hierarchy.treemapSliceDice,squarify:d3Hierarchy.treemapSquarify,resquarify:d3Hierarchy.treemapResquarify};Output=\n\"x0 y0 x1 y1 depth children\".split(\" \");Treemap.Definition={type:\"Treemap\",metadata:{tree:!0,modifies:!0},params:[{name:\"field\",type:\"field\"},{name:\"sort\",type:\"compare\"},{name:\"method\",type:\"enum\",\"default\":\"squarify\",values:\"squarify resquarify binary dice slice slicedice\".split(\" \")},{name:\"padding\",type:\"number\",\"default\":0},{name:\"paddingInner\",type:\"number\",\"default\":0},{name:\"paddingOuter\",type:\"number\",\"default\":0},{name:\"paddingTop\",type:\"number\",\"default\":0},{name:\"paddingRight\",type:\"number\",\n\"default\":0},{name:\"paddingBottom\",type:\"number\",\"default\":0},{name:\"paddingLeft\",type:\"number\",\"default\":0},{name:\"ratio\",type:\"number\",\"default\":1.618033988749895},{name:\"round\",type:\"boolean\",\"default\":!1},{name:\"size\",type:\"number\",array:!0,length:2},{name:\"as\",type:\"string\",array:!0,length:Output.length,\"default\":Output}]};vegaUtil.inherits(Treemap,HierarchyLayout,{layout:function(){var x=d3Hierarchy.treemap();x.ratio=function(_){var t=x.tile();t.ratio&&x.tile(t.ratio(_))};x.method=function(_){vegaUtil.hasOwnProperty(Tiles,\n_)?x.tile(Tiles[_]):vegaUtil.error(\"Unrecognized Treemap layout method: \"+_)};return x},params:\"method ratio size round padding paddingInner paddingOuter paddingTop paddingRight paddingBottom paddingLeft\".split(\" \"),fields:Output});exports.nest=Nest;exports.pack=Pack;exports.partition=Partition;exports.stratify=Stratify;exports.tree=Tree;exports.treelinks=TreeLinks;exports.treemap=Treemap;Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_hierarchy$build$vega_hierarchy\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-dataflow'), require('vega-util'), require('d3-hierarchy')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-dataflow', 'vega-util', 'd3-hierarchy'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.d3));\n}(this, (function (exports, vegaDataflow, vegaUtil, d3Hierarchy) { 'use strict';\n\n  // Build lookup table mapping tuple keys to tree node instances\n  function lookup(tree, key, filter) {\n    var map = {};\n    tree.each(node => {\n      var t = node.data;\n      if (filter(t)) map[key(t)] = node;\n    });\n    tree.lookup = map;\n    return tree;\n  }\n\n  /**\n    * Nest tuples into a tree structure, grouped by key values.\n    * @constructor\n    * @param {object} params - The parameters for this operator.\n    * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\n    * @param {boolean} [params.generate=false] - A boolean flag indicating if\n    *   non-leaf nodes generated by this transform should be included in the\n    *   output. The default (false) includes only the input data (leaf nodes)\n    *   in the data stream.\n    */\n  function Nest(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Nest.Definition = {\n    'type': 'Nest',\n    'metadata': {'treesource': true, 'changes': true},\n    'params': [\n      { 'name': 'keys', 'type': 'field', 'array': true },\n      { 'name': 'generate', 'type': 'boolean' }\n    ]\n  };\n\n  const children = n => n.values;\n\n  vegaUtil.inherits(Nest, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      if (!pulse.source) {\n        vegaUtil.error('Nest transform requires an upstream data source.');\n      }\n\n      var gen = _.generate,\n          mod = _.modified(),\n          out = pulse.clone(),\n          tree = this.value;\n\n      if (!tree || mod || pulse.changed()) {\n        // collect nodes to remove\n        if (tree) {\n          tree.each(node => {\n            if (node.children && vegaDataflow.isTuple(node.data)) {\n              out.rem.push(node.data);\n            }\n          });\n        }\n\n        // generate new tree structure\n        this.value = tree = d3Hierarchy.hierarchy({\n          values: vegaUtil.array(_.keys)\n            .reduce((n, k) => { n.key(k); return n; }, nest())\n            .entries(out.source)\n        }, children);\n\n        // collect nodes to add\n        if (gen) {\n          tree.each(node => {\n            if (node.children) {\n              node = vegaDataflow.ingest(node.data);\n              out.add.push(node);\n              out.source.push(node);\n            }\n          });\n        }\n\n        // build lookup table\n        lookup(tree, vegaDataflow.tupleid, vegaDataflow.tupleid);\n      }\n\n      out.source.root = tree;\n      return out;\n    }\n  });\n\n  function nest() {\n    const keys = [],\n          nest = {\n            entries: array => entries(apply(array, 0), 0),\n            key: d => (keys.push(d), nest)\n          };\n\n    function apply(array, depth) {\n      if (depth >= keys.length) {\n        return array;\n      }\n\n      const n = array.length,\n            key = keys[depth++],\n            valuesByKey = {},\n            result = {};\n\n      let i = -1, keyValue, value, values;\n\n      while (++i < n) {\n        keyValue = key(value = array[i]) + '';\n        if (values = valuesByKey[keyValue]) {\n          values.push(value);\n        } else {\n          valuesByKey[keyValue] = [value];\n        }\n      }\n\n      for (keyValue in valuesByKey) {\n        result[keyValue] = apply(valuesByKey[keyValue], depth);\n      }\n\n      return result;\n    }\n\n    function entries(map, depth) {\n      if (++depth > keys.length) return map;\n      const array = [];\n      for (const key in map) {\n        array.push({\n          key,\n          values: entries(map[key], depth)\n        });\n      }\n      return array;\n    }\n\n    return nest;\n  }\n\n  /**\n   * Abstract class for tree layout.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   */\n  function HierarchyLayout(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  const defaultSeparation = (a, b) => a.parent === b.parent ? 1 : 2;\n\n  vegaUtil.inherits(HierarchyLayout, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      if (!pulse.source || !pulse.source.root) {\n        vegaUtil.error(this.constructor.name\n          + ' transform requires a backing tree data source.');\n      }\n\n      const layout = this.layout(_.method),\n            fields = this.fields,\n            root = pulse.source.root,\n            as = _.as || fields;\n\n      if (_.field) root.sum(_.field); else root.count();\n      if (_.sort) root.sort(vegaDataflow.stableCompare(_.sort, d => d.data));\n\n      setParams(layout, this.params, _);\n      if (layout.separation) {\n        layout.separation(_.separation !== false ? defaultSeparation : vegaUtil.one);\n      }\n\n      try {\n        this.value = layout(root);\n      } catch (err) {\n        vegaUtil.error(err);\n      }\n      root.each(node => setFields(node, fields, as));\n\n      return pulse.reflow(_.modified()).modifies(as).modifies('leaf');\n    }\n  });\n\n  function setParams(layout, params, _) {\n    for (let p, i=0, n=params.length; i<n; ++i) {\n      p = params[i];\n      if (p in _) layout[p](_[p]);\n    }\n  }\n\n  function setFields(node, fields, as) {\n    const t = node.data,\n          n = fields.length - 1;\n    for (let i=0; i<n; ++i) {\n      t[as[i]] = node[fields[i]];\n    }\n    t[as[n]] = node.children ? node.children.length : 0;\n  }\n\n  const Output = ['x', 'y', 'r', 'depth', 'children'];\n\n  /**\n   * Packed circle tree layout.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - The value field to size nodes.\n   */\n  function Pack(params) {\n    HierarchyLayout.call(this, params);\n  }\n\n  Pack.Definition = {\n    'type': 'Pack',\n    'metadata': {'tree': true, 'modifies': true},\n    'params': [\n      { 'name': 'field', 'type': 'field' },\n      { 'name': 'sort', 'type': 'compare' },\n      { 'name': 'padding', 'type': 'number', 'default': 0 },\n      { 'name': 'radius', 'type': 'field', 'default': null },\n      { 'name': 'size', 'type': 'number', 'array': true, 'length': 2 },\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': Output.length, 'default': Output }\n    ]\n  };\n\n  vegaUtil.inherits(Pack, HierarchyLayout, {\n    layout: d3Hierarchy.pack,\n    params: ['radius', 'size', 'padding'],\n    fields: Output\n  });\n\n  const Output$1 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n\n  /**\n   * Partition tree layout.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - The value field to size nodes.\n   */\n  function Partition(params) {\n    HierarchyLayout.call(this, params);\n  }\n\n  Partition.Definition = {\n    'type': 'Partition',\n    'metadata': {'tree': true, 'modifies': true},\n    'params': [\n      { 'name': 'field', 'type': 'field' },\n      { 'name': 'sort', 'type': 'compare' },\n      { 'name': 'padding', 'type': 'number', 'default': 0 },\n      { 'name': 'round', 'type': 'boolean', 'default': false },\n      { 'name': 'size', 'type': 'number', 'array': true, 'length': 2 },\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': Output$1.length, 'default': Output$1 }\n    ]\n  };\n\n  vegaUtil.inherits(Partition, HierarchyLayout, {\n    layout: d3Hierarchy.partition,\n    params: ['size', 'round', 'padding'],\n    fields: Output$1\n  });\n\n  /**\n    * Stratify a collection of tuples into a tree structure based on\n    * id and parent id fields.\n    * @constructor\n    * @param {object} params - The parameters for this operator.\n    * @param {function(object): *} params.key - Unique key field for each tuple.\n    * @param {function(object): *} params.parentKey - Field with key for parent tuple.\n    */\n  function Stratify(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Stratify.Definition = {\n    'type': 'Stratify',\n    'metadata': {'treesource': true},\n    'params': [\n      { 'name': 'key', 'type': 'field', 'required': true },\n      { 'name': 'parentKey', 'type': 'field', 'required': true  }\n    ]\n  };\n\n  vegaUtil.inherits(Stratify, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      if (!pulse.source) {\n        vegaUtil.error('Stratify transform requires an upstream data source.');\n      }\n\n      let tree = this.value;\n\n      const mod = _.modified(),\n            out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),\n            run = !tree\n              || mod\n              || pulse.changed(pulse.ADD_REM)\n              || pulse.modified(_.key.fields)\n              || pulse.modified(_.parentKey.fields);\n\n      // prevent upstream source pollution\n      out.source = out.source.slice();\n\n      if (run) {\n        tree = out.source.length\n          ? lookup(\n              d3Hierarchy.stratify().id(_.key).parentId(_.parentKey)(out.source),\n              _.key,\n              vegaUtil.truthy\n            )\n          : lookup(d3Hierarchy.stratify()([{}]), _.key, _.key);\n      }\n\n      out.source.root = this.value = tree;\n      return out;\n    }\n  });\n\n  var Layouts = {\n    tidy: d3Hierarchy.tree,\n    cluster: d3Hierarchy.cluster\n  };\n\n  const Output$2 = ['x', 'y', 'depth', 'children'];\n\n  /**\n   * Tree layout. Depending on the method parameter, performs either\n   * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   */\n  function Tree(params) {\n    HierarchyLayout.call(this, params);\n  }\n\n  Tree.Definition = {\n    'type': 'Tree',\n    'metadata': {'tree': true, 'modifies': true},\n    'params': [\n      { 'name': 'field', 'type': 'field' },\n      { 'name': 'sort', 'type': 'compare' },\n      { 'name': 'method', 'type': 'enum', 'default': 'tidy', 'values': ['tidy', 'cluster'] },\n      { 'name': 'size', 'type': 'number', 'array': true, 'length': 2 },\n      { 'name': 'nodeSize', 'type': 'number', 'array': true, 'length': 2 },\n      { 'name': 'separation', 'type': 'boolean', 'default': true },\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': Output$2.length, 'default': Output$2 }\n    ]\n  };\n\n  vegaUtil.inherits(Tree, HierarchyLayout, {\n    /**\n     * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.\n     */\n    layout(method) {\n      var m = method || 'tidy';\n      if (vegaUtil.hasOwnProperty(Layouts, m)) return Layouts[m]();\n      else vegaUtil.error('Unrecognized Tree layout method: ' + m);\n    },\n    params: ['size', 'nodeSize'],\n    fields: Output$2\n  });\n\n  /**\n    * Generate tuples representing links between tree nodes.\n    * The resulting tuples will contain 'source' and 'target' fields,\n    * which point to parent and child node tuples, respectively.\n    * @constructor\n    * @param {object} params - The parameters for this operator.\n    */\n  function TreeLinks(params) {\n    vegaDataflow.Transform.call(this, [], params);\n  }\n\n  TreeLinks.Definition = {\n    'type': 'TreeLinks',\n    'metadata': {'tree': true, 'generates': true, 'changes': true},\n    'params': []\n  };\n\n  vegaUtil.inherits(TreeLinks, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const links = this.value,\n            tree = pulse.source && pulse.source.root,\n            out = pulse.fork(pulse.NO_SOURCE),\n            lut = {};\n\n      if (!tree) vegaUtil.error('TreeLinks transform requires a tree data source.');\n\n      if (pulse.changed(pulse.ADD_REM)) {\n        // remove previous links\n        out.rem = links;\n\n        // build lookup table of valid tuples\n        pulse.visit(pulse.SOURCE, t => lut[vegaDataflow.tupleid(t)] = 1);\n\n        // generate links for all edges incident on valid tuples\n        tree.each(node => {\n          const t = node.data,\n                p = node.parent && node.parent.data;\n          if (p && lut[vegaDataflow.tupleid(t)] && lut[vegaDataflow.tupleid(p)]) {\n            out.add.push(vegaDataflow.ingest({source: p, target: t}));\n          }\n        });\n        this.value = out.add;\n      }\n\n      else if (pulse.changed(pulse.MOD)) {\n        // build lookup table of modified tuples\n        pulse.visit(pulse.MOD, t => lut[vegaDataflow.tupleid(t)] = 1);\n\n        // gather links incident on modified tuples\n        links.forEach(link => {\n          if (lut[vegaDataflow.tupleid(link.source)] || lut[vegaDataflow.tupleid(link.target)]) {\n            out.mod.push(link);\n          }\n        });\n      }\n\n      return out;\n    }\n  });\n\n  const Tiles = {\n    binary: d3Hierarchy.treemapBinary,\n    dice: d3Hierarchy.treemapDice,\n    slice: d3Hierarchy.treemapSlice,\n    slicedice: d3Hierarchy.treemapSliceDice,\n    squarify: d3Hierarchy.treemapSquarify,\n    resquarify: d3Hierarchy.treemapResquarify\n  };\n\n  const Output$3 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n\n  /**\n   * Treemap layout.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - The value field to size nodes.\n   */\n  function Treemap(params) {\n    HierarchyLayout.call(this, params);\n  }\n\n  Treemap.Definition = {\n    'type': 'Treemap',\n    'metadata': {'tree': true, 'modifies': true},\n    'params': [\n      { 'name': 'field', 'type': 'field' },\n      { 'name': 'sort', 'type': 'compare' },\n      { 'name': 'method', 'type': 'enum', 'default': 'squarify',\n        'values': ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice'] },\n      { 'name': 'padding', 'type': 'number', 'default': 0 },\n      { 'name': 'paddingInner', 'type': 'number', 'default': 0 },\n      { 'name': 'paddingOuter', 'type': 'number', 'default': 0 },\n      { 'name': 'paddingTop', 'type': 'number', 'default': 0 },\n      { 'name': 'paddingRight', 'type': 'number', 'default': 0 },\n      { 'name': 'paddingBottom', 'type': 'number', 'default': 0 },\n      { 'name': 'paddingLeft', 'type': 'number', 'default': 0 },\n      { 'name': 'ratio', 'type': 'number', 'default': 1.618033988749895 },\n      { 'name': 'round', 'type': 'boolean', 'default': false },\n      { 'name': 'size', 'type': 'number', 'array': true, 'length': 2 },\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': Output$3.length, 'default': Output$3 }\n    ]\n  };\n\n  vegaUtil.inherits(Treemap, HierarchyLayout, {\n    /**\n     * Treemap layout generator. Adds 'method' and 'ratio' parameters\n     * to configure the underlying tile method.\n     */\n    layout() {\n      const x = d3Hierarchy.treemap();\n\n      x.ratio = _ => {\n        const t = x.tile();\n        if (t.ratio) x.tile(t.ratio(_));\n      };\n\n      x.method = _ => {\n        if (vegaUtil.hasOwnProperty(Tiles, _)) x.tile(Tiles[_]);\n        else vegaUtil.error('Unrecognized Treemap layout method: ' + _);\n      };\n\n      return x;\n    },\n\n    params: [\n      'method', 'ratio', 'size', 'round',\n      'padding', 'paddingInner', 'paddingOuter',\n      'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'\n    ],\n\n    fields: Output$3\n  });\n\n  exports.nest = Nest;\n  exports.pack = Pack;\n  exports.partition = Partition;\n  exports.stratify = Stratify;\n  exports.tree = Tree;\n  exports.treelinks = TreeLinks;\n  exports.treemap = Treemap;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vega_dataflow$build$vega_dataflow","~$shadow.js","~$module$node_modules$d3_hierarchy$dist$d3_hierarchy","~$module$node_modules$vega_util$build$vega_util"]],"~:properties",["^5",["values","dice","tidy","ratio","cluster","params","pack","method","nest","resquarify","key","treemap","__esModule","binary","treelinks","partition","transform","lookup","slicedice","root","vega","squarify","rem","value","tree","layout","entries","source","Definition","stratify","fields","target","slice","transforms"]],"~:compiled-at",1600144479992,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_hierarchy$build$vega_hierarchy.js\",\n\"lineCount\":18,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-hierarchy/build/vega-hierarchy.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_hierarchy$build$vega_hierarchy\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-dataflow'), require('vega-util'), require('d3-hierarchy')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-dataflow', 'vega-util', 'd3-hierarchy'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.d3));\\n}(this, (function (exports, vegaDataflow, vegaUtil, d3Hierarchy) { 'use strict';\\n\\n  // Build lookup table mapping tuple keys to tree node instances\\n  function lookup(tree, key, filter) {\\n    var map = {};\\n    tree.each(node => {\\n      var t = node.data;\\n      if (filter(t)) map[key(t)] = node;\\n    });\\n    tree.lookup = map;\\n    return tree;\\n  }\\n\\n  /**\\n    * Nest tuples into a tree structure, grouped by key values.\\n    * @constructor\\n    * @param {object} params - The parameters for this operator.\\n    * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\\n    * @param {boolean} [params.generate=false] - A boolean flag indicating if\\n    *   non-leaf nodes generated by this transform should be included in the\\n    *   output. The default (false) includes only the input data (leaf nodes)\\n    *   in the data stream.\\n    */\\n  function Nest(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Nest.Definition = {\\n    'type': 'Nest',\\n    'metadata': {'treesource': true, 'changes': true},\\n    'params': [\\n      { 'name': 'keys', 'type': 'field', 'array': true },\\n      { 'name': 'generate', 'type': 'boolean' }\\n    ]\\n  };\\n\\n  const children = n => n.values;\\n\\n  vegaUtil.inherits(Nest, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      if (!pulse.source) {\\n        vegaUtil.error('Nest transform requires an upstream data source.');\\n      }\\n\\n      var gen = _.generate,\\n          mod = _.modified(),\\n          out = pulse.clone(),\\n          tree = this.value;\\n\\n      if (!tree || mod || pulse.changed()) {\\n        // collect nodes to remove\\n        if (tree) {\\n          tree.each(node => {\\n            if (node.children && vegaDataflow.isTuple(node.data)) {\\n              out.rem.push(node.data);\\n            }\\n          });\\n        }\\n\\n        // generate new tree structure\\n        this.value = tree = d3Hierarchy.hierarchy({\\n          values: vegaUtil.array(_.keys)\\n            .reduce((n, k) => { n.key(k); return n; }, nest())\\n            .entries(out.source)\\n        }, children);\\n\\n        // collect nodes to add\\n        if (gen) {\\n          tree.each(node => {\\n            if (node.children) {\\n              node = vegaDataflow.ingest(node.data);\\n              out.add.push(node);\\n              out.source.push(node);\\n            }\\n          });\\n        }\\n\\n        // build lookup table\\n        lookup(tree, vegaDataflow.tupleid, vegaDataflow.tupleid);\\n      }\\n\\n      out.source.root = tree;\\n      return out;\\n    }\\n  });\\n\\n  function nest() {\\n    const keys = [],\\n          nest = {\\n            entries: array => entries(apply(array, 0), 0),\\n            key: d => (keys.push(d), nest)\\n          };\\n\\n    function apply(array, depth) {\\n      if (depth >= keys.length) {\\n        return array;\\n      }\\n\\n      const n = array.length,\\n            key = keys[depth++],\\n            valuesByKey = {},\\n            result = {};\\n\\n      let i = -1, keyValue, value, values;\\n\\n      while (++i < n) {\\n        keyValue = key(value = array[i]) + '';\\n        if (values = valuesByKey[keyValue]) {\\n          values.push(value);\\n        } else {\\n          valuesByKey[keyValue] = [value];\\n        }\\n      }\\n\\n      for (keyValue in valuesByKey) {\\n        result[keyValue] = apply(valuesByKey[keyValue], depth);\\n      }\\n\\n      return result;\\n    }\\n\\n    function entries(map, depth) {\\n      if (++depth > keys.length) return map;\\n      const array = [];\\n      for (const key in map) {\\n        array.push({\\n          key,\\n          values: entries(map[key], depth)\\n        });\\n      }\\n      return array;\\n    }\\n\\n    return nest;\\n  }\\n\\n  /**\\n   * Abstract class for tree layout.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   */\\n  function HierarchyLayout(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  const defaultSeparation = (a, b) => a.parent === b.parent ? 1 : 2;\\n\\n  vegaUtil.inherits(HierarchyLayout, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      if (!pulse.source || !pulse.source.root) {\\n        vegaUtil.error(this.constructor.name\\n          + ' transform requires a backing tree data source.');\\n      }\\n\\n      const layout = this.layout(_.method),\\n            fields = this.fields,\\n            root = pulse.source.root,\\n            as = _.as || fields;\\n\\n      if (_.field) root.sum(_.field); else root.count();\\n      if (_.sort) root.sort(vegaDataflow.stableCompare(_.sort, d => d.data));\\n\\n      setParams(layout, this.params, _);\\n      if (layout.separation) {\\n        layout.separation(_.separation !== false ? defaultSeparation : vegaUtil.one);\\n      }\\n\\n      try {\\n        this.value = layout(root);\\n      } catch (err) {\\n        vegaUtil.error(err);\\n      }\\n      root.each(node => setFields(node, fields, as));\\n\\n      return pulse.reflow(_.modified()).modifies(as).modifies('leaf');\\n    }\\n  });\\n\\n  function setParams(layout, params, _) {\\n    for (let p, i=0, n=params.length; i<n; ++i) {\\n      p = params[i];\\n      if (p in _) layout[p](_[p]);\\n    }\\n  }\\n\\n  function setFields(node, fields, as) {\\n    const t = node.data,\\n          n = fields.length - 1;\\n    for (let i=0; i<n; ++i) {\\n      t[as[i]] = node[fields[i]];\\n    }\\n    t[as[n]] = node.children ? node.children.length : 0;\\n  }\\n\\n  const Output = ['x', 'y', 'r', 'depth', 'children'];\\n\\n  /**\\n   * Packed circle tree layout.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - The value field to size nodes.\\n   */\\n  function Pack(params) {\\n    HierarchyLayout.call(this, params);\\n  }\\n\\n  Pack.Definition = {\\n    'type': 'Pack',\\n    'metadata': {'tree': true, 'modifies': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field' },\\n      { 'name': 'sort', 'type': 'compare' },\\n      { 'name': 'padding', 'type': 'number', 'default': 0 },\\n      { 'name': 'radius', 'type': 'field', 'default': null },\\n      { 'name': 'size', 'type': 'number', 'array': true, 'length': 2 },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': Output.length, 'default': Output }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Pack, HierarchyLayout, {\\n    layout: d3Hierarchy.pack,\\n    params: ['radius', 'size', 'padding'],\\n    fields: Output\\n  });\\n\\n  const Output$1 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\\n\\n  /**\\n   * Partition tree layout.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - The value field to size nodes.\\n   */\\n  function Partition(params) {\\n    HierarchyLayout.call(this, params);\\n  }\\n\\n  Partition.Definition = {\\n    'type': 'Partition',\\n    'metadata': {'tree': true, 'modifies': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field' },\\n      { 'name': 'sort', 'type': 'compare' },\\n      { 'name': 'padding', 'type': 'number', 'default': 0 },\\n      { 'name': 'round', 'type': 'boolean', 'default': false },\\n      { 'name': 'size', 'type': 'number', 'array': true, 'length': 2 },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': Output$1.length, 'default': Output$1 }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Partition, HierarchyLayout, {\\n    layout: d3Hierarchy.partition,\\n    params: ['size', 'round', 'padding'],\\n    fields: Output$1\\n  });\\n\\n  /**\\n    * Stratify a collection of tuples into a tree structure based on\\n    * id and parent id fields.\\n    * @constructor\\n    * @param {object} params - The parameters for this operator.\\n    * @param {function(object): *} params.key - Unique key field for each tuple.\\n    * @param {function(object): *} params.parentKey - Field with key for parent tuple.\\n    */\\n  function Stratify(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Stratify.Definition = {\\n    'type': 'Stratify',\\n    'metadata': {'treesource': true},\\n    'params': [\\n      { 'name': 'key', 'type': 'field', 'required': true },\\n      { 'name': 'parentKey', 'type': 'field', 'required': true  }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Stratify, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      if (!pulse.source) {\\n        vegaUtil.error('Stratify transform requires an upstream data source.');\\n      }\\n\\n      let tree = this.value;\\n\\n      const mod = _.modified(),\\n            out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),\\n            run = !tree\\n              || mod\\n              || pulse.changed(pulse.ADD_REM)\\n              || pulse.modified(_.key.fields)\\n              || pulse.modified(_.parentKey.fields);\\n\\n      // prevent upstream source pollution\\n      out.source = out.source.slice();\\n\\n      if (run) {\\n        tree = out.source.length\\n          ? lookup(\\n              d3Hierarchy.stratify().id(_.key).parentId(_.parentKey)(out.source),\\n              _.key,\\n              vegaUtil.truthy\\n            )\\n          : lookup(d3Hierarchy.stratify()([{}]), _.key, _.key);\\n      }\\n\\n      out.source.root = this.value = tree;\\n      return out;\\n    }\\n  });\\n\\n  var Layouts = {\\n    tidy: d3Hierarchy.tree,\\n    cluster: d3Hierarchy.cluster\\n  };\\n\\n  const Output$2 = ['x', 'y', 'depth', 'children'];\\n\\n  /**\\n   * Tree layout. Depending on the method parameter, performs either\\n   * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   */\\n  function Tree(params) {\\n    HierarchyLayout.call(this, params);\\n  }\\n\\n  Tree.Definition = {\\n    'type': 'Tree',\\n    'metadata': {'tree': true, 'modifies': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field' },\\n      { 'name': 'sort', 'type': 'compare' },\\n      { 'name': 'method', 'type': 'enum', 'default': 'tidy', 'values': ['tidy', 'cluster'] },\\n      { 'name': 'size', 'type': 'number', 'array': true, 'length': 2 },\\n      { 'name': 'nodeSize', 'type': 'number', 'array': true, 'length': 2 },\\n      { 'name': 'separation', 'type': 'boolean', 'default': true },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': Output$2.length, 'default': Output$2 }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Tree, HierarchyLayout, {\\n    /**\\n     * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.\\n     */\\n    layout(method) {\\n      var m = method || 'tidy';\\n      if (vegaUtil.hasOwnProperty(Layouts, m)) return Layouts[m]();\\n      else vegaUtil.error('Unrecognized Tree layout method: ' + m);\\n    },\\n    params: ['size', 'nodeSize'],\\n    fields: Output$2\\n  });\\n\\n  /**\\n    * Generate tuples representing links between tree nodes.\\n    * The resulting tuples will contain 'source' and 'target' fields,\\n    * which point to parent and child node tuples, respectively.\\n    * @constructor\\n    * @param {object} params - The parameters for this operator.\\n    */\\n  function TreeLinks(params) {\\n    vegaDataflow.Transform.call(this, [], params);\\n  }\\n\\n  TreeLinks.Definition = {\\n    'type': 'TreeLinks',\\n    'metadata': {'tree': true, 'generates': true, 'changes': true},\\n    'params': []\\n  };\\n\\n  vegaUtil.inherits(TreeLinks, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const links = this.value,\\n            tree = pulse.source && pulse.source.root,\\n            out = pulse.fork(pulse.NO_SOURCE),\\n            lut = {};\\n\\n      if (!tree) vegaUtil.error('TreeLinks transform requires a tree data source.');\\n\\n      if (pulse.changed(pulse.ADD_REM)) {\\n        // remove previous links\\n        out.rem = links;\\n\\n        // build lookup table of valid tuples\\n        pulse.visit(pulse.SOURCE, t => lut[vegaDataflow.tupleid(t)] = 1);\\n\\n        // generate links for all edges incident on valid tuples\\n        tree.each(node => {\\n          const t = node.data,\\n                p = node.parent && node.parent.data;\\n          if (p && lut[vegaDataflow.tupleid(t)] && lut[vegaDataflow.tupleid(p)]) {\\n            out.add.push(vegaDataflow.ingest({source: p, target: t}));\\n          }\\n        });\\n        this.value = out.add;\\n      }\\n\\n      else if (pulse.changed(pulse.MOD)) {\\n        // build lookup table of modified tuples\\n        pulse.visit(pulse.MOD, t => lut[vegaDataflow.tupleid(t)] = 1);\\n\\n        // gather links incident on modified tuples\\n        links.forEach(link => {\\n          if (lut[vegaDataflow.tupleid(link.source)] || lut[vegaDataflow.tupleid(link.target)]) {\\n            out.mod.push(link);\\n          }\\n        });\\n      }\\n\\n      return out;\\n    }\\n  });\\n\\n  const Tiles = {\\n    binary: d3Hierarchy.treemapBinary,\\n    dice: d3Hierarchy.treemapDice,\\n    slice: d3Hierarchy.treemapSlice,\\n    slicedice: d3Hierarchy.treemapSliceDice,\\n    squarify: d3Hierarchy.treemapSquarify,\\n    resquarify: d3Hierarchy.treemapResquarify\\n  };\\n\\n  const Output$3 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\\n\\n  /**\\n   * Treemap layout.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - The value field to size nodes.\\n   */\\n  function Treemap(params) {\\n    HierarchyLayout.call(this, params);\\n  }\\n\\n  Treemap.Definition = {\\n    'type': 'Treemap',\\n    'metadata': {'tree': true, 'modifies': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field' },\\n      { 'name': 'sort', 'type': 'compare' },\\n      { 'name': 'method', 'type': 'enum', 'default': 'squarify',\\n        'values': ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice'] },\\n      { 'name': 'padding', 'type': 'number', 'default': 0 },\\n      { 'name': 'paddingInner', 'type': 'number', 'default': 0 },\\n      { 'name': 'paddingOuter', 'type': 'number', 'default': 0 },\\n      { 'name': 'paddingTop', 'type': 'number', 'default': 0 },\\n      { 'name': 'paddingRight', 'type': 'number', 'default': 0 },\\n      { 'name': 'paddingBottom', 'type': 'number', 'default': 0 },\\n      { 'name': 'paddingLeft', 'type': 'number', 'default': 0 },\\n      { 'name': 'ratio', 'type': 'number', 'default': 1.618033988749895 },\\n      { 'name': 'round', 'type': 'boolean', 'default': false },\\n      { 'name': 'size', 'type': 'number', 'array': true, 'length': 2 },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': Output$3.length, 'default': Output$3 }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Treemap, HierarchyLayout, {\\n    /**\\n     * Treemap layout generator. Adds 'method' and 'ratio' parameters\\n     * to configure the underlying tile method.\\n     */\\n    layout() {\\n      const x = d3Hierarchy.treemap();\\n\\n      x.ratio = _ => {\\n        const t = x.tile();\\n        if (t.ratio) x.tile(t.ratio(_));\\n      };\\n\\n      x.method = _ => {\\n        if (vegaUtil.hasOwnProperty(Tiles, _)) x.tile(Tiles[_]);\\n        else vegaUtil.error('Unrecognized Treemap layout method: ' + _);\\n      };\\n\\n      return x;\\n    },\\n\\n    params: [\\n      'method', 'ratio', 'size', 'round',\\n      'padding', 'paddingInner', 'paddingOuter',\\n      'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'\\n    ],\\n\\n    fields: Output$3\\n  });\\n\\n  exports.nest = Nest;\\n  exports.pack = Pack;\\n  exports.partition = Partition;\\n  exports.stratify = Stratify;\\n  exports.tree = Tree;\\n  exports.treelinks = TreeLinks;\\n  exports.treemap = Treemap;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"transforms\",\"d3\",\"vegaDataflow\",\"vegaUtil\",\"d3Hierarchy\",\"lookup\",\"tree\",\"key\",\"filter\",\"map\",\"each\",\"node\",\"t\",\"data\",\"Nest\",\"params\",\"Transform\",\"call\",\"nest\",\"apply\",\"array\",\"depth\",\"keys\",\"length\",\"n\",\"valuesByKey\",\"result\",\"i\",\"keyValue\",\"value\",\"values\",\"push\",\"entries\",\"d\",\"HierarchyLayout\",\"setParams\",\"layout\",\"_\",\"p\",\"Pack\",\"Partition\",\"Stratify\",\"Tree\",\"TreeLinks\",\"Treemap\",\"Definition\",\"children\",\"inherits\",\"transform\",\"pulse\",\"source\",\"error\",\"gen\",\"generate\",\"mod\",\"modified\",\"out\",\"clone\",\"changed\",\"isTuple\",\"rem\",\"hierarchy\",\"reduce\",\"k\",\"ingest\",\"add\",\"tupleid\",\"root\",\"defaultSeparation\",\"a\",\"b\",\"parent\",\"constructor\",\"name\",\"method\",\"fields\",\"as\",\"field\",\"sum\",\"count\",\"sort\",\"stableCompare\",\"separation\",\"one\",\"err\",\"reflow\",\"modifies\",\"Output\",\"pack\",\"Output$1\",\"partition\",\"fork\",\"ALL\",\"materialize\",\"SOURCE\",\"run\",\"ADD_REM\",\"parentKey\",\"slice\",\"stratify\",\"id\",\"parentId\",\"truthy\",\"Layouts\",\"tidy\",\"cluster\",\"Output$2\",\"m\",\"hasOwnProperty\",\"links\",\"NO_SOURCE\",\"lut\",\"visit\",\"target\",\"MOD\",\"forEach\",\"link\",\"Tiles\",\"binary\",\"treemapBinary\",\"dice\",\"treemapDice\",\"treemapSlice\",\"slicedice\",\"treemapSliceDice\",\"squarify\",\"treemapSquarify\",\"resquarify\",\"treemapResquarify\",\"Output$3\",\"x\",\"treemap\",\"ratio\",\"x.ratio\",\"tile\",\"x.method\",\"treelinks\",\"Object\",\"defineProperty\"]\n}\n"]