["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-scenegraph/build/vega-scenegraph.js"],"~:js","shadow$provide.module$node_modules$vega_scenegraph$build$vega_scenegraph=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_util$build$vega_util\"),require(\"module$node_modules$d3_shape$dist$d3_shape\"),require(\"module$node_modules$d3_path$dist$d3_path\"),require(\"module$node_modules$vega_canvas$build$vega_canvas\"),require(\"module$node_modules$vega_loader$build$vega_loader\"),\nrequire(\"module$node_modules$vega_scale$build$vega_scale\")):\"function\"===typeof define&&define.amd?define(\"exports vega-util d3-shape d3-path vega-canvas vega-loader vega-scale\".split(\" \"),factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory(global.vega={},global.vega,global.d3,global.d3,global.vega,global.vega,global.vega))})(this,function(exports,vegaUtil,d3Shape,d3Path,vegaCanvas,vegaLoader,vegaScale){function gradientRef(g,defs,base){var type=g.gradient,id=g.id,prefix=\n\"radial\"===type?\"p_\":\"\";id||(id=g.id=\"gradient_\"+gradient_id++,\"radial\"===type?(g.x1=get(g.x1,.5),g.y1=get(g.y1,.5),g.r1=get(g.r1,0),g.x2=get(g.x2,.5),g.y2=get(g.y2,.5),g.r2=get(g.r2,.5),prefix=\"p_\"):(g.x1=get(g.x1,0),g.y1=get(g.y1,0),g.x2=get(g.x2,1),g.y2=get(g.y2,0)));defs[id]=g;return\"url(\"+(base||\"\")+\"#\"+prefix+id+\")\"}function get(val,def){return null!=val?val:def}function curves(type,orientation,tension){type=vegaUtil.hasOwnProperty(lookup,type)&&lookup[type];var curve=null;type&&(curve=type.curve||\ntype[orientation||\"vertical\"],type.tension&&null!=tension&&(curve=curve[type.tension](tension)));return curve}function pathParse(pathstr){var result=[],param,n,m,path=pathstr.slice().replace(regexp[0],\"###$1\").split(regexp[1]).slice(1);pathstr=0;for(n=path.length;pathstr<n;++pathstr){var curr=path[pathstr];var chunks=curr.slice(1).trim().replace(regexp[2],\"$1###$2\").replace(regexp[3],\"$1###$2\").split(regexp[4]);var cmd=curr.charAt(0);curr=[cmd];var j=0;for(m=chunks.length;j<m;++j)(param=+chunks[j])===\nparam&&curr.push(param);chunks=cmdlen[cmd.toLowerCase()];if(curr.length-1>chunks)for(m=curr.length,j=1,result.push([cmd].concat(curr.slice(j,j+=chunks))),cmd=\"M\"===cmd?\"L\":\"m\"===cmd?\"l\":cmd;j<m;j+=chunks)result.push([cmd].concat(curr.slice(j,j+chunks)));else result.push(curr)}return result}function segments(x,y,rx,ry,large,sweep,rotateX,ox,oy){var key=join.call(arguments);if(segmentCache[key])return segmentCache[key];var th=rotateX*DegToRad,sin_th=Math.sin(th);th=Math.cos(th);rx=Math.abs(rx);ry=Math.abs(ry);\nvar px=th*(ox-x)*.5+sin_th*(oy-y)*.5,py=th*(oy-y)*.5-sin_th*(ox-x)*.5;px=px*px/(rx*rx)+py*py/(ry*ry);1<px&&(px=Math.sqrt(px),rx*=px,ry*=px);var a00=th/rx,a01=sin_th/rx,a10=-sin_th/ry,a11=th/ry;px=a00*ox+a01*oy;py=a10*ox+a11*oy;a00=a00*x+a01*y;a01=a10*x+a11*y;a10=1/((a00-px)*(a00-px)+(a01-py)*(a01-py))-.25;0>a10&&(a10=0);a11=Math.sqrt(a10);sweep==large&&(a11=-a11);a10=.5*(px+a00)-a11*(a01-py);a11=.5*(py+a01)+a11*(a00-px);px=Math.atan2(py-a11,px-a10);py=Math.atan2(a01-a11,a00-a10)-px;0>py&&1===sweep?\npy+=Tau:0<py&&0===sweep&&(py-=Tau);a00=Math.ceil(Math.abs(py/(HalfPi+.001)));a01=[];for(var i=0;i<a00;++i)a01[i]=[a10,a11,px+i*py/a00,px+(i+1)*py/a00,rx,ry,sin_th,th];return segmentCache[key]=a01}function pathRender(context,path,l,t,sX,sY){var previous=null,x=0,y=0,controlX=0,controlY=0;null==l&&(l=0);null==t&&(t=0);null==sX&&(sX=1);null==sY&&(sY=sX);context.beginPath&&context.beginPath();for(var i=0,len=path.length;i<len;++i){var current=path[i];if(1!==sX||1!==sY){var tempX=sX;var tempY=sY;var c=\ntemp[0]=current[0];if(\"a\"===c||\"A\"===c)temp[1]=tempX*current[1],temp[2]=tempY*current[2],temp[3]=current[3],temp[4]=current[4],temp[5]=current[5],temp[6]=tempX*current[6],temp[7]=tempY*current[7];else if(\"h\"===c||\"H\"===c)temp[1]=tempX*current[1];else if(\"v\"===c||\"V\"===c)temp[1]=tempY*current[1];else{c=1;for(var n=current.length;c<n;++c)temp[c]=(1==c%2?tempX:tempY)*current[c]}current=temp}switch(current[0]){case \"l\":x+=current[1];y+=current[2];context.lineTo(x+l,y+t);break;case \"L\":x=current[1];y=\ncurrent[2];context.lineTo(x+l,y+t);break;case \"h\":x+=current[1];context.lineTo(x+l,y+t);break;case \"H\":x=current[1];context.lineTo(x+l,y+t);break;case \"v\":y+=current[1];context.lineTo(x+l,y+t);break;case \"V\":y=current[1];context.lineTo(x+l,y+t);break;case \"m\":x+=current[1];y+=current[2];context.moveTo(x+l,y+t);break;case \"M\":x=current[1];y=current[2];context.moveTo(x+l,y+t);break;case \"c\":tempX=x+current[5];tempY=y+current[6];controlX=x+current[3];controlY=y+current[4];context.bezierCurveTo(x+current[1]+\nl,y+current[2]+t,controlX+l,controlY+t,tempX+l,tempY+t);x=tempX;y=tempY;break;case \"C\":x=current[5];y=current[6];controlX=current[3];controlY=current[4];context.bezierCurveTo(current[1]+l,current[2]+t,controlX+l,controlY+t,x+l,y+t);break;case \"s\":tempX=x+current[3];tempY=y+current[4];controlX=2*x-controlX;controlY=2*y-controlY;context.bezierCurveTo(controlX+l,controlY+t,x+current[1]+l,y+current[2]+t,tempX+l,tempY+t);controlX=x+current[1];controlY=y+current[2];x=tempX;y=tempY;break;case \"S\":tempX=\ncurrent[3];tempY=current[4];controlX=2*x-controlX;controlY=2*y-controlY;context.bezierCurveTo(controlX+l,controlY+t,current[1]+l,current[2]+t,tempX+l,tempY+t);x=tempX;y=tempY;controlX=current[1];controlY=current[2];break;case \"q\":tempX=x+current[3];tempY=y+current[4];controlX=x+current[1];controlY=y+current[2];context.quadraticCurveTo(controlX+l,controlY+t,tempX+l,tempY+t);x=tempX;y=tempY;break;case \"Q\":tempX=current[3];tempY=current[4];context.quadraticCurveTo(current[1]+l,current[2]+t,tempX+l,tempY+\nt);x=tempX;y=tempY;controlX=current[1];controlY=current[2];break;case \"t\":tempX=x+current[1];tempY=y+current[2];null===previous[0].match(/[QqTt]/)?(controlX=x,controlY=y):\"t\"===previous[0]?(controlX=2*x-tempControlX,controlY=2*y-tempControlY):\"q\"===previous[0]&&(controlX=2*x-controlX,controlY=2*y-controlY);var tempControlX=controlX;var tempControlY=controlY;context.quadraticCurveTo(controlX+l,controlY+t,tempX+l,tempY+t);x=tempX;y=tempY;controlX=x+current[1];controlY=y+current[2];break;case \"T\":tempX=\ncurrent[1];tempY=current[2];controlX=2*x-controlX;controlY=2*y-controlY;context.quadraticCurveTo(controlX+l,controlY+t,tempX+l,tempY+t);x=tempX;y=tempY;break;case \"a\":drawArc(context,x+l,y+t,[current[1],current[2],current[3],current[4],current[5],current[6]+x+l,current[7]+y+t]);x+=current[6];y+=current[7];break;case \"A\":drawArc(context,x+l,y+t,[current[1],current[2],current[3],current[4],current[5],current[6]+l,current[7]+t]);x=current[6];y=current[7];break;case \"z\":case \"Z\":context.closePath()}previous=\ncurrent}}function drawArc(context,x,y,coords){x=segments(coords[5],coords[6],coords[0],coords[1],coords[3],coords[4],coords[2],x,y);for(y=0;y<x.length;++y){var params=x[y];coords=join.call(params);if(bezierCache[coords])coords=bezierCache[coords];else{var cx=params[0],cy=params[1],th0=params[2],th1=params[3],rx=params[4],ry=params[5],sin_th=params[6],cos_th=params[7];params=cos_th*rx;var a01=-sin_th*ry;rx*=sin_th;ry*=cos_th;var cos_th0=Math.cos(th0),sin_th0=Math.sin(th0);sin_th=Math.cos(th1);cos_th=\nMath.sin(th1);th0=.5*(th1-th0);th1=Math.sin(.5*th0);th1=8/3*th1*th1/Math.sin(th0);th0=cx+cos_th0-th1*sin_th0;cos_th0=cy+sin_th0+th1*cos_th0;cx+=sin_th;cy+=cos_th;cos_th=cx+th1*cos_th;sin_th=cy-th1*sin_th;coords=bezierCache[coords]=[params*th0+a01*cos_th0,rx*th0+ry*cos_th0,params*cos_th+a01*sin_th,rx*cos_th+ry*sin_th,params*cx+a01*cy,rx*cx+ry*cy]}context.bezierCurveTo(coords[0],coords[1],coords[2],coords[3],coords[4],coords[5])}}function symbols(_){return vegaUtil.hasOwnProperty(builtins,_)?builtins[_]:\ncustomSymbol(_)}function customSymbol(path){if(!vegaUtil.hasOwnProperty(custom,path)){var parsed=pathParse(path);custom[path]={draw:function(context,size){pathRender(context,parsed,0,0,Math.sqrt(size)/2)}}}return custom[path]}function rectangleX(d){return d.x}function rectangleY(d){return d.y}function rectangleWidth(d){return d.width}function rectangleHeight(d){return d.height}function number(_){return\"function\"===typeof _?_:function(){return+_}}function clamp(value,min,max){return Math.max(min,Math.min(value,\nmax))}function vg_rect(){function rectangle(_,x0,y0){var buffer;x0=null!=x0?x0:+x.call(this,_);y0=null!=y0?y0:+y.call(this,_);var w=+width.call(this,_),h=+height.call(this,_),s=Math.min(w,h)/2,tl=clamp(+crTL.call(this,_),0,s),tr=clamp(+crTR.call(this,_),0,s),bl=clamp(+crBL.call(this,_),0,s);_=clamp(+crBR.call(this,_),0,s);context||(context=buffer=d3Path.path());0>=tl&&0>=tr&&0>=bl&&0>=_?context.rect(x0,y0,w,h):(w=x0+w,h=y0+h,context.moveTo(x0+tl,y0),context.lineTo(w-tr,y0),context.bezierCurveTo(w-\n.448084975506*tr,y0,w,y0+.448084975506*tr,w,y0+tr),context.lineTo(w,h-_),context.bezierCurveTo(w,h-.448084975506*_,w-.448084975506*_,h,w-_,h),context.lineTo(x0+bl,h),context.bezierCurveTo(x0+.448084975506*bl,h,x0,h-.448084975506*bl,x0,h-bl),context.lineTo(x0,y0+tl),context.bezierCurveTo(x0,y0+.448084975506*tl,x0+.448084975506*tl,y0,x0+tl,y0),context.closePath());if(buffer)return context=null,buffer+\"\"||null}var x=rectangleX,y=rectangleY,width=rectangleWidth,height=rectangleHeight,crTL=number(0),crTR=\ncrTL,crBL=crTL,crBR=crTL,context=null;rectangle.x=function(_){return arguments.length?(x=number(_),rectangle):x};rectangle.y=function(_){return arguments.length?(y=number(_),rectangle):y};rectangle.width=function(_){return arguments.length?(width=number(_),rectangle):width};rectangle.height=function(_){return arguments.length?(height=number(_),rectangle):height};rectangle.cornerRadius=function(tl,tr,br,bl){return arguments.length?(crTL=number(tl),crTR=null!=tr?number(tr):crTL,crBR=null!=br?number(br):\ncrTL,crBL=null!=bl?number(bl):crTR,rectangle):crTL};rectangle.context=function(_){return arguments.length?(context=null==_?null:_,rectangle):context};return rectangle}function vg_trail(){function trail(data){var i,n=data.length,d,defined0=!1,buffer;null==context&&(context=buffer=d3Path.path());for(i=0;i<=n;++i)if(!(i<n&&defined(d=data[i],i,data))===defined0&&(defined0=!defined0)&&(ready=0),defined0){var x2=+x(d,i,data),y2=+y(d,i,data),r2=+size(d,i,data)/2;if(ready){var ux=y1-y2,uy=x2-x1;if(ux||uy){var ud=\nMath.sqrt(ux*ux+uy*uy),rx=(ux/=ud)*r1;ud=(uy/=ud)*r1;var t=Math.atan2(uy,ux);context.moveTo(x1-rx,y1-ud);context.lineTo(x2-ux*r2,y2-uy*r2);context.arc(x2,y2,r2,t-Math.PI,t);context.lineTo(x1+rx,y1+ud);context.arc(x1,y1,r1,t,t+Math.PI)}else context.arc(x2,y2,r2,0,Tau);context.closePath()}else ready=1;x1=x2;y1=y2;r1=r2}if(buffer)return context=null,buffer+\"\"||null}var x,y,size,defined,context=null,ready,x1,y1,r1;trail.x=function(_){return arguments.length?(x=_,trail):x};trail.y=function(_){return arguments.length?\n(y=_,trail):y};trail.size=function(_){return arguments.length?(size=_,trail):size};trail.defined=function(_){return arguments.length?(defined=_,trail):defined};trail.context=function(_){return arguments.length?(context=null==_?null:_,trail):context};return trail}function value$jscomp$0(a,b){return null!=a?a:b}function hasCornerRadius(item){return item.cornerRadius||item.cornerRadiusTopLeft||item.cornerRadiusTopRight||item.cornerRadiusBottomRight||item.cornerRadiusBottomLeft}function rectangle(context,\nitem,x,y){return rectShape.context(context)(item,x,y)}function clip(renderer,item,size){var clip=item.clip;renderer=renderer._defs;item=item.clip_id||(item.clip_id=\"clip\"+clip_id++);renderer=renderer.clipping[item]||(renderer.clipping[item]={id:item});vegaUtil.isFunction(clip)?renderer.path=clip(null):hasCornerRadius(size)?renderer.path=rectangle(null,size,0,0):(renderer.width=size.width||0,renderer.height=size.height||0);return\"url(#\"+item+\")\"}function Bounds(b){this.clear();b&&this.union(b)}function Item(mark){this.mark=\nmark;this.bounds=this.bounds||new Bounds}function GroupItem(mark){Item.call(this,mark);this.items=this.items||[]}function ResourceLoader(customLoader){this._pending=0;this._loader=customLoader||vegaLoader.loader()}function boundStroke(bounds,item,miter){if(item.stroke&&0!==item.opacity&&0!==item.strokeOpacity){var sw=null!=item.strokeWidth?+item.strokeWidth:1;bounds.expand(sw+(miter?item.strokeJoin&&\"miter\"!==item.strokeJoin?0:sw:0))}return bounds}function boundContext(_,deg){bounds=_;deg?(rot=deg*\nDegToRad,ma=md=Math.cos(rot),mb=Math.sin(rot),mc=-mb):(ma=md=1,rot=mb=mc=0);return context$jscomp$0}function quadExtrema(x0,x1,x2,cb){x2=(x0-x1)/(x0+x2-2*x1);0<x2&&1>x2&&cb(x0+(x1-x0)*x2)}function cubicExtrema(x0,x1,x2,x3,cb){var a=x3-x0+3*x1-3*x2,b=x0+x2-2*x1,c=x0-x1,t0=0,t1=0;1E-14<Math.abs(a)?(c=b*b+c*a,0<=c&&(c=Math.sqrt(c),t0=(-b+c)/a,t1=(-b-c)/a)):t0=.5*c/b;0<t0&&1>t0&&cb(cubic(t0,x0,x1,x2,x3));0<t1&&1>t1&&cb(cubic(t1,x0,x1,x2,x3))}function cubic(t,x0,x1,x2,x3){var s=1-t,s2=s*s,t2=t*t;return s2*\ns*x0+3*s2*t*x1+3*s*t2*x2+t2*t*x3}function intersectPath(draw){return function(item,brush){if(!context$1)return!0;draw(context$1,item);b$jscomp$0.clear().union(item.bounds).intersect(brush).round();var $jscomp$destructuring$var24=b$jscomp$0;item=$jscomp$destructuring$var24.x1;brush=$jscomp$destructuring$var24.x2;var y2=$jscomp$destructuring$var24.y2;for($jscomp$destructuring$var24=$jscomp$destructuring$var24.y1;$jscomp$destructuring$var24<=y2;++$jscomp$destructuring$var24)for(var x$332=item;x$332<=\nbrush;++x$332)if(context$1.isPointInPath(x$332,$jscomp$destructuring$var24))return!0;return!1}}function intersectPoint(item,box){return box.contains(item.x||0,item.y||0)}function intersectRect(item,box){var x=item.x||0,y=item.y||0;return box.intersects(b$jscomp$0.set(x,y,x+(item.width||0),y+(item.height||0)))}function intersectRule(item,box){var x=item.x||0,y=item.y||0;return intersectBoxLine(box,x,y,null!=item.x2?item.x2:x,null!=item.y2?item.y2:y)}function intersectBoxLine(box,x,y,u,v){var x1=box.x1,\ny1=box.y1,x2=box.x2;box=box.y2;u-=x;v-=y;var t0=0,t1=1,e;for(e=0;4>e;++e){if(0===e){var p=-u;var q=-(x1-x)}1===e&&(p=u,q=x2-x);2===e&&(p=-v,q=-(y1-y));3===e&&(p=v,q=box-y);if(1E-10>Math.abs(p)&&0>q)return!1;var r=q/p;if(0>p){if(r>t1)return!1;r>t0&&(t0=r)}else if(0<p){if(r<t0)return!1;r<t1&&(t1=r)}}return!0}function blend(context,item){context.globalCompositeOperation=item.blend||\"source-over\"}function value$1(value,dflt){return null==value?dflt:value}function addStops(gradient,stops){for(var n=stops.length,\ni=0;i<n;++i)gradient.addColorStop(stops[i].offset,stops[i].color);return gradient}function gradient(context,spec,bounds){var w=bounds.width(),h=bounds.height();if(\"radial\"===spec.gradient)context=context.createRadialGradient(bounds.x1+value$1(spec.x1,.5)*w,bounds.y1+value$1(spec.y1,.5)*h,Math.max(w,h)*value$1(spec.r1,0),bounds.x1+value$1(spec.x2,.5)*w,bounds.y1+value$1(spec.y2,.5)*h,Math.max(w,h)*value$1(spec.r2,.5));else{var x1=value$1(spec.x1,0),y1=value$1(spec.y1,0),x2=value$1(spec.x2,1),y2=value$1(spec.y2,\n0);if(x1===x2||y1===y2||w===h)context=context.createLinearGradient(bounds.x1+x1*w,bounds.y1+y1*h,bounds.x1+x2*w,bounds.y1+y2*h);else{bounds=vegaCanvas.canvas(Math.ceil(w),Math.ceil(h));var ictx=bounds.getContext(\"2d\");ictx.scale(w,h);ictx.fillStyle=addStops(ictx.createLinearGradient(x1,y1,x2,y2),spec.stops);ictx.fillRect(0,0,w,h);return context.createPattern(bounds,\"no-repeat\")}}return addStops(context,spec.stops)}function fill$jscomp$0(context,item,opacity){opacity*=null==item.fillOpacity?1:item.fillOpacity;\nreturn 0<opacity?(context.globalAlpha=opacity,item=(opacity=item.fill)&&opacity.gradient?gradient(context,opacity,item.bounds):opacity,context.fillStyle=item,!0):!1}function stroke(context,item,opacity){var lw=null!=(lw=item.strokeWidth)?lw:1;if(0>=lw)return!1;opacity*=null==item.strokeOpacity?1:item.strokeOpacity;return 0<opacity?(context.globalAlpha=opacity,opacity=(opacity=item.stroke)&&opacity.gradient?gradient(context,opacity,item.bounds):opacity,context.strokeStyle=opacity,context.lineWidth=\nlw,context.lineCap=item.strokeCap||\"butt\",context.lineJoin=item.strokeJoin||\"miter\",context.miterLimit=item.strokeMiterLimit||10,context.setLineDash&&(context.setLineDash(item.strokeDash||Empty),context.lineDashOffset=item.strokeDashOffset||0),!0):!1}function compare(a,b){return a.zindex-b.zindex||a.index-b.index}function zorder(scene){if(!scene.zdirty)return scene.zitems;var items=scene.items,output=[],n;var i=0;for(n=items.length;i<n;++i){var item=items[i];item.index=i;item.zindex&&output.push(item)}scene.zdirty=\n!1;return scene.zitems=output.sort(compare)}function visit(scene,visitor){var items=scene.items,n;if(items&&items.length){var zitems=zorder(scene);if(zitems&&zitems.length){scene=0;for(n=items.length;scene<n;++scene)items[scene].zindex||visitor(items[scene]);items=zitems}scene=0;for(n=items.length;scene<n;++scene)visitor(items[scene])}}function pickVisit(scene,visitor){var items=scene.items,hit,i;if(!items||!items.length)return null;var zitems=zorder(scene);zitems&&zitems.length&&(items=zitems);for(i=\nitems.length;0<=--i;)if(hit=visitor(items[i]))return hit;if(items===zitems)for(items=scene.items,i=items.length;0<=--i;)if(!items[i].zindex&&(hit=visitor(items[i])))return hit;return null}function drawAll(path){return function(context,scene,bounds){visit(scene,function(item){bounds&&!bounds.intersects(item.bounds)||drawPath(path,context,item,item)})}}function drawOne(path){return function(context,scene,bounds){!scene.items.length||bounds&&!bounds.intersects(scene.bounds)||drawPath(path,context,scene.items[0],\nscene.items)}}function drawPath(path,context,item,items){var opacity=null==item.opacity?1:item.opacity;0===opacity||path(context,items)||(blend(context,item),item.fill&&fill$jscomp$0(context,item,opacity)&&context.fill(),item.stroke&&stroke(context,item,opacity)&&context.stroke())}function pick(test){test=test||vegaUtil.truthy;return function(context,scene,x,y,gx,gy){x*=context.pixelRatio;y*=context.pixelRatio;return pickVisit(scene,function(item){var b=item.bounds;if((!b||b.contains(gx,gy))&&b&&\ntest(context,item,x,y,gx,gy))return item})}}function hitPath(path,filled){return function(context,o,x,y){var item=Array.isArray(o)?o[0]:o,fill=null==filled?item.fill:filled,stroke=item.stroke&&context.isPointInStroke;if(stroke){var lw=item.strokeWidth;item=item.strokeCap;context.lineWidth=null!=lw?lw:1;context.lineCap=null!=item?item:\"butt\"}return path(context,o)?!1:fill&&context.isPointInPath(x,y)||stroke&&context.isPointInStroke(x,y)}}function translate(x,y){return\"translate(\"+x+\",\"+y+\")\"}function markItemPath(type,\nshape,isect){function draw(context,item){var x=item.x||0,y=item.y||0,a=item.angle||0;context.translate(x,y);a&&context.rotate(a*=DegToRad);context.beginPath();shape(context,item);a&&context.rotate(-a);context.translate(-x,-y)}return{type:type,tag:\"path\",nested:!1,attr:function(emit,item){var JSCompiler_inline_result=translate(item.x||0,item.y||0)+(item.angle?\" rotate(\"+(item.angle+\")\"):\"\");emit(\"transform\",JSCompiler_inline_result);emit(\"d\",shape(null,item))},bound:function(bounds,item){shape(boundContext(bounds,\nitem.angle),item);return boundStroke(bounds,item).translate(item.x||0,item.y||0)},draw:drawAll(draw),pick:pick(hitPath(draw)),isect:isect||intersectPath(draw)}}function markMultiItemPath(type,shape,tip){function draw(context,items){context.beginPath();shape(context,items)}var hit=hitPath(draw);return{type:type,tag:\"path\",nested:!0,attr:function(emit,item){item=item.mark.items;item.length&&emit(\"d\",shape(null,item))},bound:function(bounds,mark){mark=mark.items;if(0===mark.length)return bounds;shape(boundContext(bounds),\nmark);return boundStroke(bounds,mark[0])},draw:drawOne(draw),pick:function(context,scene,x,y,gx,gy){var items=scene.items;scene=scene.bounds;if(!items||!items.length||scene&&!scene.contains(gx,gy))return null;x*=context.pixelRatio;y*=context.pixelRatio;return hit(context,items,x,y)?items[0]:null},isect:intersectPoint,tip:tip}}function clipGroup(context,group){context.beginPath();hasCornerRadius(group)?rectangle(context,group,0,0):context.rect(0,0,group.width||0,group.height||0);context.clip()}function offset$jscomp$0(item){var sw=\nvalue$1(item.strokeWidth,1);return null!=item.strokeOffset?item.strokeOffset:item.stroke&&.5<sw&&1.5>sw?.5-Math.abs(sw-1):0}function rectanglePath(context,group,x,y){var off=offset$jscomp$0(group);context.beginPath();rectangle(context,group,(x||0)+off,(y||0)+off)}function getImage(item,renderer){var image$jscomp$0=item.image;if(!image$jscomp$0||item.url&&item.url!==image$jscomp$0.url)image$jscomp$0={complete:!1,width:0,height:0},renderer.loadImage(item.url).then(function(image){item.image=image;item.image.url=\nitem.url});return image$jscomp$0}function imageWidth(item,image){return null!=item.width?item.width:image&&image.width?!1!==item.aspect&&item.height?item.height*image.width/image.height:image.width:0}function imageHeight(item,image){return null!=item.height?item.height:image&&image.height?!1!==item.aspect&&item.width?item.width*image.height/image.width:image.height:0}function imageXOffset(align,w){return\"center\"===align?w/2:\"right\"===align?w:0}function imageYOffset(baseline,h){return\"middle\"===baseline?\nh/2:\"bottom\"===baseline?h:0}function path$jscomp$0(context,item){var path=item.path;if(null==path)return!0;var x=item.x||0,y=item.y||0,sx=item.scaleX||1,sy=item.scaleY||1,a=(item.angle||0)*DegToRad,cache=item.pathCache;cache&&cache.path===path||((item.pathCache=cache=pathParse(path)).path=path);a&&context.rotate&&context.translate?(context.translate(x,y),context.rotate(a),pathRender(context,cache,0,0,sx,sy),context.rotate(-a),context.translate(-x,-y)):pathRender(context,cache,x,y,sx,sy)}function draw$2(context,\nitem){context.beginPath();rectangle(context,item)}function path$2(context,item,opacity){if(item.stroke&&stroke(context,item,opacity)){opacity=item.x||0;var y1=item.y||0;var x2=null!=item.x2?item.x2:opacity;item=null!=item.y2?item.y2:y1;context.beginPath();context.moveTo(opacity,y1);context.lineTo(x2,item);return!0}return!1}function useCanvas(use){textMetrics.width=use&&context$1?measureWidth:estimateWidth}function estimateWidth(item,text){text=textValue(item,text);item=fontSize(item);return~~(.8*\ntext.length*item)}function measureWidth(item,text){return 0>=fontSize(item)||!(text=textValue(item,text))?0:_measureWidth(text,font(item))}function _measureWidth(text,currentFont){var key=\"(\"+currentFont+\") \"+text,width=widthCache.get(key);void 0===width&&(context$1.font=currentFont,width=context$1.measureText(text).width,widthCache.set(key,width));return width}function fontSize(item){return null!=item.fontSize?+item.fontSize||0:11}function lineHeight(item){return null!=item.lineHeight?item.lineHeight:\nfontSize(item)+2}function textLines(item){item=item.lineBreak&&item.text&&!vegaUtil.isArray(item.text)?item.text.split(item.lineBreak):item.text;return vegaUtil.isArray(item)?1<item.length?item:item[0]:item}function textValue(item,line){line=null==line?\"\":(line+\"\").trim();if(0<item.limit&&line.length){var limit=+item.limit,width=widthGetter(item);if(!(width(line)<limit)){var ellipsis=item.ellipsis||\"…\",rtl=\"rtl\"===item.dir;item=0;var hi=line.length;limit-=width(ellipsis);if(rtl){for(;item<hi;)rtl=\nitem+hi>>>1,width(line.slice(rtl))>limit?item=rtl+1:hi=rtl;line=ellipsis+line.slice(item)}else{for(;item<hi;)rtl=1+(item+hi>>>1),width(line.slice(0,rtl))<limit?item=rtl:hi=rtl-1;line=line.slice(0,item)+ellipsis}}}return line}function widthGetter(item){if(textMetrics.width===measureWidth){var currentFont=font(item);return function(text){return _measureWidth(text,currentFont)}}var currentFontHeight=fontSize(item);return function(text){return~~(.8*text.length*currentFontHeight)}}function fontFamily(item,\nquote){item=item.font;return(quote&&item?String(item).replace(/\"/g,\"'\"):item)||\"sans-serif\"}function font(item,quote){return(item.fontStyle?item.fontStyle+\" \":\"\")+(item.fontVariant?item.fontVariant+\" \":\"\")+(item.fontWeight?item.fontWeight+\" \":\"\")+fontSize(item)+\"px \"+fontFamily(item,quote)}function offset$1(item){var baseline=item.baseline,h=fontSize(item);return Math.round(\"top\"===baseline?.79*h:\"middle\"===baseline?.3*h:\"bottom\"===baseline?-.21*h:\"line-top\"===baseline?.29*h+.5*lineHeight(item):\"line-bottom\"===\nbaseline?.29*h-.5*lineHeight(item):0)}function anchorPoint(item){var x=item.x||0,y=item.y||0,r=item.radius||0;r&&(item=(item.theta||0)-HalfPi,x+=r*Math.cos(item),y+=r*Math.sin(item));tempBounds.x1=x;tempBounds.y1=y;return tempBounds}function bound$5(bounds,item,mode){var h=textMetrics.height(item),a=item.align,p=anchorPoint(item),x=p.x1;p=p.y1;var dx=item.dx||0,dy=(item.dy||0)+offset$1(item)-Math.round(.8*h),tl=textLines(item);vegaUtil.isArray(tl)?(h+=lineHeight(item)*(tl.length-1),tl=tl.reduce(function(w,\nt){return Math.max(w,textMetrics.width(item,t))},0)):tl=textMetrics.width(item,tl);\"center\"===a?dx-=tl/2:\"right\"===a&&(dx-=tl);bounds.set(dx+=x,dy+=p,dx+tl,dy+h);if(item.angle&&!mode)bounds.rotate(item.angle*DegToRad,x,p);else if(2===mode)return bounds.rotatedPoints(item.angle*DegToRad,x,p);return bounds}function boundItem(item,func,opt){var type=Marks[item.mark.marktype];func=func||type.bound;type.nested&&(item=item.mark);return func(item.bounds||(item.bounds=new Bounds),item,opt)}function boundMark(mark,\nbounds,opt){var type=Marks[mark.marktype],bound=type.bound,items=mark.items,hasItems=items&&items.length;if(type.nested)return hasItems?mark=items[0]:(DUMMY.mark=mark,mark=DUMMY),opt=boundItem(mark,bound,opt),bounds=bounds&&bounds.union(opt)||opt;bounds=bounds||mark.bounds&&mark.bounds.clear()||new Bounds;if(hasItems)for(type=0,hasItems=items.length;type<hasItems;++type)bounds.union(boundItem(items[type],bound,opt));return mark.bounds=bounds}function sceneToJSON(scene,indent){return JSON.stringify(scene,\nkeys,indent)}function sceneFromJSON(json){json=\"string\"===typeof json?JSON.parse(json):json;return initialize(json)}function initialize(scene){var type=scene.marktype,items=scene.items,n;if(items){var i=0;for(n=items.length;i<n;++i){var parent=type?\"mark\":\"group\";items[i][parent]=scene;items[i].zindex&&(items[i][parent].zdirty=!0);\"group\"===(type||parent)&&initialize(items[i])}}type&&boundMark(scene);return scene}function Scenegraph(scene){arguments.length?this.root=sceneFromJSON(scene):(this.root=\ncreateMark({marktype:\"group\",name:\"root\",role:\"frame\"}),this.root.items=[new GroupItem(this.root)])}function createMark(def,group){group={bounds:new Bounds,clip:!!def.clip,group:group,interactive:!1===def.interactive?!1:!0,items:[],marktype:def.marktype,name:def.name||void 0,role:def.role||void 0,zindex:def.zindex||0};null!=def.aria&&(group.aria=def.aria);def.description&&(group.description=def.description);return group}function domCreate(doc,tag,ns){!doc&&\"undefined\"!==typeof document&&document.createElement&&\n(doc=document);return doc?ns?doc.createElementNS(ns,tag):doc.createElement(tag):null}function domFind(el,tag){tag=tag.toLowerCase();el=el.childNodes;for(var i=0,n=el.length;i<n;++i)if(el[i].tagName.toLowerCase()===tag)return el[i]}function domChild(el,index,tag,ns){index=el.childNodes[index];if(!index||index.tagName.toLowerCase()!==tag.toLowerCase()){var b=index||null;index=domCreate(el.ownerDocument,tag,ns);el.insertBefore(index,b)}return index}function domClear(el,index){for(var nodes=el.childNodes,\ncurr=nodes.length;curr>index;)el.removeChild(nodes[--curr]);return el}function cssClass(mark){return\"mark-\"+mark.marktype+(mark.role?\" role-\"+mark.role:\"\")+(mark.name?\" \"+mark.name:\"\")}function point(event,el){var rect=el.getBoundingClientRect();return[event.clientX-rect.left-(el.clientLeft||0),event.clientY-rect.top-(el.clientTop||0)]}function Handler(customLoader,customTooltip){this._active=null;this._handlers={};this._loader=customLoader||vegaLoader.loader();this._tooltip=customTooltip||defaultTooltip}\nfunction defaultTooltip(handler,event,item,value){handler.element().setAttribute(\"title\",value||\"\")}function Renderer(loader){this._bgcolor=this._el=null;this._loader=new ResourceLoader(loader)}function CanvasHandler(loader,tooltip){Handler.call(this,loader,tooltip);this._touch=this._down=null;this._first=!0;this._events={}}function eventListenerCheck(handler,type){(\"touchstart\"===type||\"touchmove\"===type||\"touchend\"===type?[\"touchstart\",\"touchmove\",\"touchend\"]:[type]).forEach(function(_){return addEventListener(handler,\n_)})}function addEventListener(handler,type){var canvas=handler.canvas();canvas&&!handler._events[type]&&(handler._events[type]=1,canvas.addEventListener(type,handler[type]?function(evt){return handler[type](evt)}:function(evt){return handler.fire(type,evt)}))}function move(moveEvent,overEvent,outEvent){return function(evt){var a=this._active,p=this.pickEvent(evt);p!==a&&(a&&a.exit||this.fire(outEvent,evt),this._active=p,this.fire(overEvent,evt));this.fire(moveEvent,evt)}}function inactive(type){return function(evt){this.fire(type,\nevt);this._active=null}}function CanvasRenderer(loader){Renderer.call(this,loader);this._options={};this._redraw=!1;this._dirty=new Bounds;this._tempb=new Bounds}function SVGHandler(loader,tooltip){Handler.call(this,loader,tooltip);var h=this;h._hrefHandler=listener(h,function(evt,item){item&&item.href&&h.handleHref(evt,item,item.href)});h._tooltipHandler=listener(h,function(evt,item){h.handleTooltip(evt,item,\"mouseout\"!==evt.type)})}function ariaItemAttributes(emit,item){var hide=!1===item.aria;\nemit(\"aria-hidden\",hide||void 0);if(hide||null==item.description)for(var prop in AriaEncode)emit(AriaEncode[prop],void 0);else hide=item.mark.marktype,emit(\"aria-label\",item.description),emit(\"role\",item.ariaRole||(\"group\"===hide?\"graphics-object\":\"graphics-symbol\")),emit(\"aria-roledescription\",item.ariaRoleDescription||hide+\" mark\")}function ariaMarkAttributes(mark){var $jscomp$compprop10={};return!1===mark.aria?($jscomp$compprop10[\"aria-hidden\"]=!0,$jscomp$compprop10):AriaIgnore[mark.role]?null:\nAriaGuides[mark.role]?ariaGuide(mark,AriaGuides[mark.role]):ariaMark(mark)}function ariaMark(mark){var type=mark.marktype,recurse=\"group\"===type||\"text\"===type||mark.items.some(function(_){return null!=_.description&&!1!==_.aria});return bundle(recurse?\"graphics-object\":\"graphics-symbol\",type+\" mark container\",mark.description)}function ariaGuide(mark,opt){try{var item=mark.items[0],caption=opt.caption||function(){return\"\"};return bundle(opt.role||\"graphics-symbol\",opt.desc,item.description||caption(item))}catch(err){return null}}\nfunction extractTitle(item){try{return vegaUtil.array(vegaUtil.peek(item.items).items[0].text).join(\" \")}catch(err){return null}}function channelCaption(props){props=props.map(function(p){return p+(\"fill\"===p||\"stroke\"===p?\" color\":\"\")});return 2>props.length?props[0]:props.slice(0,-1).join(\", \")+\" and \"+vegaUtil.peek(props)}function markup(){var buf=\"\",outer=\"\",inner=\"\",stack=[],attr=function(name,value){null!=value&&(outer+=\" \"+name+'\\x3d\"'+innerText(value).replace(/\"/g,\"\\x26quot;\").replace(/\\t/g,\n\"\\x26#x9;\").replace(/\\n/g,\"\\x26#xA;\").replace(/\\r/g,\"\\x26#xD;\")+'\"');return m},m={open:function(tag,attrs){for(var $jscomp$restParams=[],$jscomp$restIndex=1;$jscomp$restIndex<arguments.length;++$jscomp$restIndex)$jscomp$restParams[$jscomp$restIndex-1]=arguments[$jscomp$restIndex];outer&&(buf+=outer+\"\\x3e\"+inner,outer=inner=\"\");stack.push(tag);outer=\"\\x3c\"+tag;$jscomp$restParams=$jscomp.makeIterator($jscomp$restParams);for($jscomp$restIndex=$jscomp$restParams.next();!$jscomp$restIndex.done;$jscomp$restIndex=\n$jscomp$restParams.next()){$jscomp$restIndex=$jscomp$restIndex.value;for(var key in $jscomp$restIndex)attr(key,$jscomp$restIndex[key])}return m},close:function(){var tag=stack.pop();buf=outer?buf+(outer+(inner?\"\\x3e\"+inner+\"\\x3c/\"+tag+\"\\x3e\":\"/\\x3e\")):buf+(\"\\x3c/\"+tag+\"\\x3e\");outer=inner=\"\";return m},attr:attr,text:function(t){return inner+=innerText(t),m},toString:function(){return buf}};return m}function _serialize(m,node){m.open(node.tagName);if(node.hasAttributes())for(var attrs=node.attributes,\nn=attrs.length,i=0;i<n;++i)m.attr(attrs[i].name,attrs[i].value);if(node.hasChildNodes())for(node=node.childNodes,attrs=node.length,n=0;n<attrs;n++)i=node[n],3===i.nodeType?m.text(i.nodeValue):_serialize(m,i);return m.close()}function SVGRenderer(loader){Renderer.call(this,loader);this._dirtyID=0;this._dirty=[];this._defs=this._root=this._svg=null}function dirtyParents(item,id){for(;item&&item.dirty!==id;item=item.mark.group)if(item.dirty=id,item.mark&&item.mark.dirty!==id)item.mark.dirty=id;else break}\nfunction recurse$jscomp$0(renderer,el,group){el=el.lastChild.previousSibling;var prev,idx=0;visit(group,function(item){prev=renderer.mark(el,item,prev);++idx});domClear(el,1+idx)}function bind(item,el,sibling,tag,svg){var node=item._svg;if(!node){var doc=el.ownerDocument;node=domCreate(doc,tag,ns);item._svg=node;item.mark&&(node.__data__=item,node.__values__={fill:\"default\"},\"g\"===tag&&(tag=domCreate(doc,\"path\",ns),node.appendChild(tag),tag.__data__=item,tag=domCreate(doc,\"g\",ns),node.appendChild(tag),\ntag.__data__=item,doc=domCreate(doc,\"path\",ns),node.appendChild(doc),doc.__data__=item,doc.__values__={fill:\"default\"}))}(node.ownerSVGElement!==svg||node.parentNode&&1<node.parentNode.childNodes.length&&node.previousSibling!=sibling)&&el.insertBefore(node,sibling?sibling.nextSibling:el.firstChild);return node}function emit(name,value,ns){if(value!==values[name]){if(ns){var el=element;null!=value?el.setAttributeNS(ns,name,value):el.removeAttributeNS(ns,name)}else setAttribute(element,name,value);\nvalues[name]=value}}function setStyle(el,name,value){value!==values[name]&&(null==value?el.style.removeProperty(name):el.style.setProperty(name,value+\"\"),values[name]=value)}function setAttributes(el,attrs){for(var key in attrs)setAttribute(el,key,attrs[key])}function setAttribute(el,name,value){null!=value?el.setAttribute(name,value):el.removeAttribute(name)}function href(){var loc;return\"undefined\"===typeof window?\"\":(loc=window.location).hash?loc.href.slice(0,-loc.hash.length):loc.href}function SVGStringRenderer(loader){Renderer.call(this,\nloader);this._text=null;this._defs={gradient:{},clipping:{}}}function style(s,item,scene,tag,defs){if(null==item)return s;\"bgrect\"===tag&&!1===scene.interactive&&(s[\"pointer-events\"]=\"none\");if(\"bgfore\"===tag&&(!1===scene.interactive&&(s[\"pointer-events\"]=\"none\"),s.display=\"none\",null!==item.fill))return s;\"image\"===tag&&!1===item.smooth&&(s.style=\"image-rendering: optimizeSpeed; image-rendering: pixelated;\");\"text\"===tag&&(s[\"font-family\"]=fontFamily(item),s[\"font-size\"]=fontSize(item)+\"px\",s[\"font-style\"]=\nitem.fontStyle,s[\"font-variant\"]=item.fontVariant,s[\"font-weight\"]=item.fontWeight);for(var prop in styles)scene=item[prop],tag=styles[prop],(\"transparent\"!==scene||\"fill\"!==tag&&\"stroke\"!==tag)&&null!=scene&&(scene&&scene.gradient&&(scene=gradientRef(scene,defs.gradient,\"\")),s[tag]=scene);return s}function intersectMark(mark,box,filter,hits){if(mark.bounds&&box.intersects(mark.bounds)&&(\"group\"===mark.marktype||!1!==mark.interactive&&(!filter||filter(mark)))){var items=mark.items,type$350=mark.marktype;\nmark=items.length;var i=0;if(\"group\"===type$350)for(;i<mark;++i)intersectGroup(items[i],box,filter,hits);else for(filter=Marks[type$350].isect;i<mark;++i)type$350=items[i],intersectItem(type$350,box,filter)&&hits.push(type$350)}return hits}function intersectGroup(group,box,filter,hits){filter&&filter(group.mark)&&intersectItem(group,box,Marks.group.isect)&&hits.push(group);var marks=group.items,n=marks&&marks.length;if(n){var x$351=group.x||0;group=group.y||0;box.translate(-x$351,-group);for(var i=\n0;i<n;++i)intersectMark(marks[i],box,filter,hits);box.translate(x$351,group)}return hits}function intersectItem(item,box,test){var bounds=item.bounds;return box.encloses(bounds)||box.intersects(bounds)&&test(item,box)}function sceneEqual(a,b,key){return a===b?!0:\"path\"===key?pathEqual(a,b):a instanceof Date&&b instanceof Date?+a===+b:vegaUtil.isNumber(a)&&vegaUtil.isNumber(b)?1E-9>=Math.abs(a-b):a&&b&&(vegaUtil.isObject(a)||vegaUtil.isObject(b))?objectEqual(a,b):a==b}function pathEqual(a,b){return sceneEqual(pathParse(a),\npathParse(b))}function objectEqual(a,b){var ka=Object.keys(a),kb=Object.keys(b),i;if(ka.length!==kb.length)return!1;ka.sort();kb.sort();for(i=ka.length-1;0<=i;i--)if(ka[i]!=kb[i])return!1;for(i=ka.length-1;0<=i;i--)if(kb=ka[i],!sceneEqual(a[kb],b[kb],kb))return!1;return typeof a===typeof b}var gradient_id=0,lookup={basis:{curve:d3Shape.curveBasis},\"basis-closed\":{curve:d3Shape.curveBasisClosed},\"basis-open\":{curve:d3Shape.curveBasisOpen},bundle:{curve:d3Shape.curveBundle,tension:\"beta\",value:.85},\ncardinal:{curve:d3Shape.curveCardinal,tension:\"tension\",value:0},\"cardinal-open\":{curve:d3Shape.curveCardinalOpen,tension:\"tension\",value:0},\"cardinal-closed\":{curve:d3Shape.curveCardinalClosed,tension:\"tension\",value:0},\"catmull-rom\":{curve:d3Shape.curveCatmullRom,tension:\"alpha\",value:.5},\"catmull-rom-closed\":{curve:d3Shape.curveCatmullRomClosed,tension:\"alpha\",value:.5},\"catmull-rom-open\":{curve:d3Shape.curveCatmullRomOpen,tension:\"alpha\",value:.5},linear:{curve:d3Shape.curveLinear},\"linear-closed\":{curve:d3Shape.curveLinearClosed},\nmonotone:{horizontal:d3Shape.curveMonotoneY,vertical:d3Shape.curveMonotoneX},natural:{curve:d3Shape.curveNatural},step:{curve:d3Shape.curveStep},\"step-after\":{curve:d3Shape.curveStepAfter},\"step-before\":{curve:d3Shape.curveStepBefore}},cmdlen={m:2,l:2,h:1,v:1,c:6,s:4,q:4,t:2,a:7},regexp=[/([MLHVCSQTAZmlhvcsqtaz])/g,/###/,/(\\.\\d+)(\\.\\d)/g,/(\\d)([-+])/g,/\\s|,|###/],DegToRad=Math.PI/180,HalfPi=Math.PI/2,Tau=2*Math.PI,HalfSqrt3=Math.sqrt(3)/2,segmentCache={},bezierCache={},join=[].join,temp=[\"l\",0,0,\n0,0,0,0,0],builtins={circle:{draw:function(context,size){size=Math.sqrt(size)/2;context.moveTo(size,0);context.arc(0,0,size,0,Tau)}},cross:{draw:function(context,size){size=Math.sqrt(size)/2;var s=size/2.5;context.moveTo(-size,-s);context.lineTo(-size,s);context.lineTo(-s,s);context.lineTo(-s,size);context.lineTo(s,size);context.lineTo(s,s);context.lineTo(size,s);context.lineTo(size,-s);context.lineTo(s,-s);context.lineTo(s,-size);context.lineTo(-s,-size);context.lineTo(-s,-s);context.closePath()}},\ndiamond:{draw:function(context,size){size=Math.sqrt(size)/2;context.moveTo(-size,0);context.lineTo(0,-size);context.lineTo(size,0);context.lineTo(0,size);context.closePath()}},square:{draw:function(context,size){size=Math.sqrt(size);var x=-size/2;context.rect(x,x,size,size)}},arrow:{draw:function(context,size){size=Math.sqrt(size)/2;var s=size/7,t=size/2.5,v=size/8;context.moveTo(-s,size);context.lineTo(s,size);context.lineTo(s,-v);context.lineTo(t,-v);context.lineTo(0,-size);context.lineTo(-t,-v);\ncontext.lineTo(-s,-v);context.closePath()}},wedge:{draw:function(context,size){var r=Math.sqrt(size)/2;size=HalfSqrt3*r;var o=size-.5773502691896257*r;r/=4;context.moveTo(0,-size-o);context.lineTo(-r,size-o);context.lineTo(r,size-o);context.closePath()}},triangle:{draw:function(context,size){size=Math.sqrt(size)/2;var h=HalfSqrt3*size,o=h-.5773502691896257*size;context.moveTo(0,-h-o);context.lineTo(-size,h-o);context.lineTo(size,h-o);context.closePath()}},\"triangle-up\":{draw:function(context,size){size=\nMath.sqrt(size)/2;var h=HalfSqrt3*size;context.moveTo(0,-h);context.lineTo(-size,h);context.lineTo(size,h);context.closePath()}},\"triangle-down\":{draw:function(context,size){size=Math.sqrt(size)/2;var h=HalfSqrt3*size;context.moveTo(0,h);context.lineTo(-size,-h);context.lineTo(size,-h);context.closePath()}},\"triangle-right\":{draw:function(context,size){size=Math.sqrt(size)/2;var h=HalfSqrt3*size;context.moveTo(h,0);context.lineTo(-h,-size);context.lineTo(-h,size);context.closePath()}},\"triangle-left\":{draw:function(context,\nsize){size=Math.sqrt(size)/2;var h=HalfSqrt3*size;context.moveTo(-h,0);context.lineTo(h,-size);context.lineTo(h,size);context.closePath()}},stroke:{draw:function(context,size){size=Math.sqrt(size)/2;context.moveTo(-size,0);context.lineTo(size,0)}}},custom={},x$jscomp$0=function(item){return item.x||0},y$jscomp$0=function(item){return item.y||0},def$jscomp$0=function(item){return!1!==item.defined},arcShape=d3Shape.arc().startAngle(function(item){return item.startAngle||0}).endAngle(function(item){return item.endAngle||\n0}).padAngle(function(item){return item.padAngle||0}).innerRadius(function(item){return item.innerRadius||0}).outerRadius(function(item){return item.outerRadius||0}).cornerRadius(function(item){return item.cornerRadius||0}),areavShape=d3Shape.area().x(x$jscomp$0).y1(y$jscomp$0).y0(function(item){return(item.y||0)+(item.height||0)}).defined(def$jscomp$0),areahShape=d3Shape.area().y(y$jscomp$0).x1(x$jscomp$0).x0(function(item){return(item.x||0)+(item.width||0)}).defined(def$jscomp$0),lineShape=d3Shape.line().x(x$jscomp$0).y(y$jscomp$0).defined(def$jscomp$0),\nrectShape=vg_rect().x(x$jscomp$0).y(y$jscomp$0).width(function(item){return item.width||0}).height(function(item){return item.height||0}).cornerRadius(function(item){return value$jscomp$0(item.cornerRadiusTopLeft,item.cornerRadius)||0},function(item){return value$jscomp$0(item.cornerRadiusTopRight,item.cornerRadius)||0},function(item){return value$jscomp$0(item.cornerRadiusBottomRight,item.cornerRadius)||0},function(item){return value$jscomp$0(item.cornerRadiusBottomLeft,item.cornerRadius)||0}),symbolShape=\nd3Shape.symbol().type(function(item){return symbols(item.shape||\"circle\")}).size(function(item){return value$jscomp$0(item.size,64)}),trailShape=vg_trail().x(x$jscomp$0).y(y$jscomp$0).defined(def$jscomp$0).size(function(item){return item.size||1}),clip_id=1;Bounds.prototype={clone:function(){return new Bounds(this)},clear:function(){this.x1=+Number.MAX_VALUE;this.y1=+Number.MAX_VALUE;this.x2=-Number.MAX_VALUE;this.y2=-Number.MAX_VALUE;return this},empty:function(){return this.x1===+Number.MAX_VALUE&&\nthis.y1===+Number.MAX_VALUE&&this.x2===-Number.MAX_VALUE&&this.y2===-Number.MAX_VALUE},equals:function(b){return this.x1===b.x1&&this.y1===b.y1&&this.x2===b.x2&&this.y2===b.y2},set:function(x1,y1,x2,y2){x2<x1?(this.x2=x1,this.x1=x2):(this.x1=x1,this.x2=x2);y2<y1?(this.y2=y1,this.y1=y2):(this.y1=y1,this.y2=y2);return this},add:function(x,y){x<this.x1&&(this.x1=x);y<this.y1&&(this.y1=y);x>this.x2&&(this.x2=x);y>this.y2&&(this.y2=y);return this},expand:function(d){this.x1-=d;this.y1-=d;this.x2+=d;this.y2+=\nd;return this},round:function(){this.x1=Math.floor(this.x1);this.y1=Math.floor(this.y1);this.x2=Math.ceil(this.x2);this.y2=Math.ceil(this.y2);return this},scale:function(s){this.x1*=s;this.y1*=s;this.x2*=s;this.y2*=s;return this},translate:function(dx,dy){this.x1+=dx;this.x2+=dx;this.y1+=dy;this.y2+=dy;return this},rotate:function(angle,x,y){angle=this.rotatedPoints(angle,x,y);return this.clear().add(angle[0],angle[1]).add(angle[2],angle[3]).add(angle[4],angle[5]).add(angle[6],angle[7])},rotatedPoints:function(angle,\nx,y){var x1=this.x1,y1=this.y1,x2=this.x2,y2=this.y2,cos=Math.cos(angle);angle=Math.sin(angle);var cx=x-x*cos+y*angle;x=y-x*angle-y*cos;return[cos*x1-angle*y1+cx,angle*x1+cos*y1+x,cos*x1-angle*y2+cx,angle*x1+cos*y2+x,cos*x2-angle*y1+cx,angle*x2+cos*y1+x,cos*x2-angle*y2+cx,angle*x2+cos*y2+x]},union:function(b){b.x1<this.x1&&(this.x1=b.x1);b.y1<this.y1&&(this.y1=b.y1);b.x2>this.x2&&(this.x2=b.x2);b.y2>this.y2&&(this.y2=b.y2);return this},intersect:function(b){b.x1>this.x1&&(this.x1=b.x1);b.y1>this.y1&&\n(this.y1=b.y1);b.x2<this.x2&&(this.x2=b.x2);b.y2<this.y2&&(this.y2=b.y2);return this},encloses:function(b){return b&&this.x1<=b.x1&&this.x2>=b.x2&&this.y1<=b.y1&&this.y2>=b.y2},alignsWith:function(b){return b&&(this.x1==b.x1||this.x2==b.x2||this.y1==b.y1||this.y2==b.y2)},intersects:function(b){return b&&!(this.x2<b.x1||this.x1>b.x2||this.y2<b.y1||this.y1>b.y2)},contains:function(x,y){return!(x<this.x1||x>this.x2||y<this.y1||y>this.y2)},width:function(){return this.x2-this.x1},height:function(){return this.y2-\nthis.y1}};vegaUtil.inherits(GroupItem,Item);ResourceLoader.prototype={pending:function(){return this._pending},sanitizeURL:function(uri){var loader=this;loader._pending+=1;return loader._loader.sanitize(uri,{context:\"href\"}).then(function(opt){--loader._pending;return opt}).catch(function(){--loader._pending;return null})},loadImage:function(uri){var loader=this,Image=vegaCanvas.image();loader._pending+=1;return loader._loader.sanitize(uri,{context:\"image\"}).then(function(opt){var url=opt.href;if(!url||\n!Image)throw{url:url};var img=new Image;opt=vegaUtil.hasOwnProperty(opt,\"crossOrigin\")?opt.crossOrigin:\"anonymous\";null!=opt&&(img.crossOrigin=opt);img.onload=function(){--loader._pending};img.onerror=function(){--loader._pending};img.src=url;return img}).catch(function(e){--loader._pending;return{complete:!1,width:0,height:0,src:e&&e.url||\"\"}})},ready:function(){var loader=this;return new Promise(function(accept){function poll(value){loader.pending()?setTimeout(function(){poll(!0)},10):accept(value)}\npoll(!1)})}};var circleThreshold=Tau-1E-8,bounds,lx,ly,rot,ma,mb,mc,md,addL=function(x,y){x=lx=x;y=ly=y;return bounds.add(x,y)},addX=function(x){return bounds.add(x,bounds.y1)},addY=function(y){return bounds.add(bounds.x1,y)},addp=function(x,y){return bounds.add(ma*x+mc*y,mb*x+md*y)},addpL=function(x,y){return addL(ma*x+mc*y,mb*x+md*y)},context$jscomp$0={beginPath:function(){},closePath:function(){},moveTo:addpL,lineTo:addpL,rect:function(x,y,w,h){rot?(addp(x+w,y),addp(x+w,y+h),addp(x,y+h),addpL(x,\ny)):(bounds.add(x+w,y+h),addL(x,y))},quadraticCurveTo:function(x1,y1,x2,y2){var py1=mb*x1+md*y1,px2=ma*x2+mc*y2;x2=mb*x2+md*y2;quadExtrema(lx,ma*x1+mc*y1,px2,addX);quadExtrema(ly,py1,x2,addY);addL(px2,x2)},bezierCurveTo:function(x1,y1,x2,y2,x3,y3){var py1=mb*x1+md*y1,py2=mb*x2+md*y2,px3=ma*x3+mc*y3;x3=mb*x3+md*y3;cubicExtrema(lx,ma*x1+mc*y1,ma*x2+mc*y2,px3,addX);cubicExtrema(ly,py1,py2,x3,addY);addL(px3,x3)},arc:function(cx,cy,r,sa,ea,ccw){sa+=rot;ea+=rot;lx=r*Math.cos(ea)+cx;ly=r*Math.sin(ea)+cy;\nif(Math.abs(ea-sa)>circleThreshold)bounds.add(cx-r,cy-r),bounds.add(cx+r,cy+r);else{var update=function(a){return bounds.add(r*Math.cos(a)+cx,r*Math.sin(a)+cy)};update(sa);update(ea);if(ea!==sa){sa%=Tau;0>sa&&(sa+=Tau);ea%=Tau;0>ea&&(ea+=Tau);if(ea<sa){ccw=!ccw;var s=sa;sa=ea;ea=s}if(ccw)for(ea-=Tau,s=sa-sa%HalfPi,sa=0;4>sa&&s>ea;++sa,s-=HalfPi)update(s);else for(s=sa-sa%HalfPi+HalfPi,sa=0;4>sa&&s<ea;++sa,s+=HalfPi)update(s)}}}},context$1=(context$1=vegaCanvas.canvas(1,1))?context$1.getContext(\"2d\"):\nnull,b$jscomp$0=new Bounds,Empty=[],arc$1=markItemPath(\"arc\",function(context,item){return arcShape.context(context)(item)}),area$1=markMultiItemPath(\"area\",function(context,items){var item=items[0];return(\"horizontal\"===item.orient?areahShape:areavShape).curve(curves(item.interpolate||\"linear\",item.orient,item.tension)).context(context)(items)},function(a,p){p=\"horizontal\"===a[0].orient?p[1]:p[0];for(var z=\"horizontal\"===a[0].orient?\"y\":\"x\",i=a.length,min=Infinity,hit,d;0<=--i;)!1!==a[i].defined&&\n(d=Math.abs(a[i][z]-p),d<min&&(min=d,hit=a[i]));return hit}),hitBackground=hitPath(rectanglePath),hitForeground=hitPath(rectanglePath,!1),hitCorner=hitPath(rectanglePath,!0),group$jscomp$0={type:\"group\",tag:\"g\",nested:!1,attr:function(emit,item){emit(\"transform\",translate(item.x||0,item.y||0))},bound:function(bounds,group){if(!group.clip&&group.items)for(var items=group.items,m=items.length,j=0;j<m;++j)bounds.union(items[j].bounds);(group.clip||group.width||group.height)&&!group.noBound&&bounds.add(0,\n0).add(group.width||0,group.height||0);boundStroke(bounds,group);return bounds.translate(group.x||0,group.y||0)},draw:function(context,scene,bounds){var $jscomp$this=this;visit(scene,function(group){var gx=group.x||0,gy=group.y||0,fore=group.strokeForeground,opacity=null==group.opacity?1:group.opacity;(group.stroke||group.fill)&&opacity&&(rectanglePath(context,group,gx,gy),blend(context,group),group.fill&&fill$jscomp$0(context,group,opacity)&&context.fill(),group.stroke&&!fore&&stroke(context,group,\nopacity)&&context.stroke());context.save();context.translate(gx,gy);group.clip&&clipGroup(context,group);bounds&&bounds.translate(-gx,-gy);visit(group,function(item){$jscomp$this.draw(context,item,bounds)});bounds&&bounds.translate(gx,gy);context.restore();fore&&group.stroke&&opacity&&(rectanglePath(context,group,gx,gy),blend(context,group),stroke(context,group,opacity)&&context.stroke())})},pick:function(context,scene,x,y,gx,gy){var $jscomp$this=this;if(scene.bounds&&!scene.bounds.contains(gx,gy)||\n!scene.items)return null;var cx=x*context.pixelRatio,cy=y*context.pixelRatio;return pickVisit(scene,function(group){var hit=group.bounds;if(!hit||hit.contains(gx,gy)){var dx=group.x||0;var dy=group.y||0;hit=dx+(group.width||0);var dh=dy+(group.height||0),c=group.clip;if(!c||!(gx<dx||gx>hit||gy<dy||gy>dh)){context.save();context.translate(dx,dy);dx=gx-dx;dy=gy-dy;if(c&&hasCornerRadius(group)&&!hitCorner(context,group,cx,cy))return context.restore(),null;dh=group.strokeForeground;if((c=!1!==scene.interactive)&&\ndh&&group.stroke&&hitForeground(context,group,cx,cy))return context.restore(),group;hit=pickVisit(group,function(mark){return(!1!==mark.interactive||\"group\"===mark.marktype)&&mark.bounds&&mark.bounds.contains(dx,dy)?$jscomp$this.pick(mark,x,y,dx,dy):null});!hit&&c&&(group.fill||!dh&&group.stroke)&&hitBackground(context,group,cx,cy)&&(hit=group);context.restore();return hit||null}}})},isect:intersectRect,content:function(emit,item,renderer){item=item.clip?clip(renderer,item,item):null;emit(\"clip-path\",\nitem)},background:function(emit,item){emit(\"class\",\"background\");emit(\"aria-hidden\",!0);var off=offset$jscomp$0(item);emit(\"d\",rectangle(null,item,off,off))},foreground:function(emit,item){emit(\"class\",\"foreground\");emit(\"aria-hidden\",!0);if(item.strokeForeground){var off=offset$jscomp$0(item);emit(\"d\",rectangle(null,item,off,off))}else emit(\"d\",\"\")}},metadata={xmlns:\"http://www.w3.org/2000/svg\",\"xmlns:xlink\":\"http://www.w3.org/1999/xlink\",version:\"1.1\"},image$jscomp$1={type:\"image\",tag:\"image\",nested:!1,\nattr:function(emit,item,renderer){var img=getImage(item,renderer);renderer=imageWidth(item,img);var h=imageHeight(item,img),x=(item.x||0)-imageXOffset(item.align,renderer),y=(item.y||0)-imageYOffset(item.baseline,h);img=!img.src&&img.toDataURL?img.toDataURL():img.src||\"\";emit(\"href\",img,metadata[\"xmlns:xlink\"],\"xlink:href\");emit(\"transform\",translate(x,y));emit(\"width\",renderer);emit(\"height\",h);emit(\"preserveAspectRatio\",!1===item.aspect?\"none\":\"xMidYMid\")},bound:function(bounds,item){var img=item.image,\nw=imageWidth(item,img);img=imageHeight(item,img);var x=(item.x||0)-imageXOffset(item.align,w);item=(item.y||0)-imageYOffset(item.baseline,img);return bounds.set(x,item,x+w,item+img)},draw:function(context,scene,bounds){var $jscomp$this=this;visit(scene,function(item){if(!bounds||bounds.intersects(item.bounds)){var img=getImage(item,$jscomp$this),w=imageWidth(item,img),h=imageHeight(item,img),x=(item.x||0)-imageXOffset(item.align,w),y=(item.y||0)-imageYOffset(item.baseline,h),opacity;if(!1!==item.aspect){var ar0=\nimg.width/img.height;var ar1=item.width/item.height;ar0===ar0&&ar1===ar1&&ar0!==ar1&&(ar1<ar0?(ar0=w/ar0,y+=(h-ar0)/2,h=ar0):(ar0*=h,x+=(w-ar0)/2,w=ar0))}if(img.complete||img.toDataURL)blend(context,item),context.globalAlpha=null!=(opacity=item.opacity)?opacity:1,context.imageSmoothingEnabled=!1!==item.smooth,context.drawImage(img,x,y,w,h)}})},pick:pick(),isect:vegaUtil.truthy,get:getImage,xOffset:imageXOffset,yOffset:imageYOffset},line$1=markMultiItemPath(\"line\",function(context,items){var item=\nitems[0];return lineShape.curve(curves(item.interpolate||\"linear\",item.orient,item.tension)).context(context)(items)},function(a,p){for(var t=Math.pow(a[0].strokeWidth||1,2),i=a.length,dx,dy;0<=--i;)if(!1!==a[i].defined&&(dx=a[i].x-p[0],dy=a[i].y-p[1],dx=dx*dx+dy*dy,dx<t))return a[i];return null}),path$1={type:\"path\",tag:\"path\",nested:!1,attr:function(emit,item){var sy=item.scaleY||1;1===(item.scaleX||1)&&1===sy||emit(\"vector-effect\",\"non-scaling-stroke\");sy=translate(item.x||0,item.y||0)+(item.angle?\n\" rotate(\"+(item.angle+\")\"):\"\")+(item.scaleX||item.scaleY?\" scale(\"+((item.scaleX||1)+\",\"+(item.scaleY||1)+\")\"):\"\");emit(\"transform\",sy);emit(\"d\",item.path)},bound:function(bounds,item){return path$jscomp$0(boundContext(bounds,item.angle),item)?bounds.set(0,0,0,0):boundStroke(bounds,item,!0)},draw:drawAll(path$jscomp$0),pick:pick(hitPath(path$jscomp$0)),isect:intersectPath(path$jscomp$0)},rect={type:\"rect\",tag:\"path\",nested:!1,attr:function(emit,item){emit(\"d\",rectangle(null,item))},bound:function(bounds,\nitem){var x,y;return boundStroke(bounds.set(x=item.x||0,y=item.y||0,x+item.width||0,y+item.height||0),item)},draw:drawAll(draw$2),pick:pick(hitPath(draw$2)),isect:intersectRect},rule={type:\"rule\",tag:\"line\",nested:!1,attr:function(emit,item){emit(\"transform\",translate(item.x||0,item.y||0));emit(\"x2\",null!=item.x2?item.x2-(item.x||0):0);emit(\"y2\",null!=item.y2?item.y2-(item.y||0):0)},bound:function(bounds,item){var x1,y1;return boundStroke(bounds.set(x1=item.x||0,y1=item.y||0,null!=item.x2?item.x2:\nx1,null!=item.y2?item.y2:y1),item)},draw:function(context,scene,bounds){visit(scene,function(item){if(!bounds||bounds.intersects(item.bounds)){var opacity=null==item.opacity?1:item.opacity;opacity&&path$2(context,item,opacity)&&(blend(context,item),context.stroke())}})},pick:pick(function(context,item,x,y){return context.isPointInStroke?path$2(context,item,1)&&context.isPointInStroke(x,y):!1}),isect:intersectRule},shape$1=markItemPath(\"shape\",function(context,item){return(item.mark.shape||item.shape).context(context)(item)}),\nsymbol$1=markItemPath(\"symbol\",function(context,item){return symbolShape.context(context)(item)},intersectPoint),widthCache=vegaUtil.lruCache(),textMetrics={height:fontSize,measureWidth:measureWidth,estimateWidth:estimateWidth,width:estimateWidth,canvas:useCanvas};useCanvas(!0);var textAlign={left:\"start\",center:\"middle\",right:\"end\"},tempBounds=new Bounds,text$jscomp$0={type:\"text\",tag:\"text\",nested:!1,attr:function(emit,item){var dx=item.dx||0,dy=(item.dy||0)+offset$1(item),p=anchorPoint(item),x=\np.x1;p=p.y1;var a=item.angle||0;emit(\"text-anchor\",textAlign[item.align]||\"start\");if(a){if(item=translate(x,p)+\" rotate(\"+(a+\")\"),dx||dy)item+=\" \"+translate(dx,dy)}else item=translate(x+dx,p+dy);emit(\"transform\",item)},bound:bound$5,draw:function(context,scene,bounds){visit(scene,function(item){var opacity=null==item.opacity?1:item.opacity,i;if(!(bounds&&!bounds.intersects(item.bounds)||0===opacity||0>=item.fontSize||null==item.text||0===item.text.length)){context.font=font(item);context.textAlign=\nitem.align||\"left\";var p=anchorPoint(item);var x=p.x1;p=p.y1;item.angle&&(context.save(),context.translate(x,p),context.rotate(item.angle*DegToRad),x=p=0);x+=item.dx||0;p+=(item.dy||0)+offset$1(item);var tl=textLines(item);blend(context,item);if(vegaUtil.isArray(tl)){var lh=lineHeight(item);for(i=0;i<tl.length;++i){var str=textValue(item,tl[i]);item.fill&&fill$jscomp$0(context,item,opacity)&&context.fillText(str,x,p);item.stroke&&stroke(context,item,opacity)&&context.strokeText(str,x,p);p+=lh}}else str=\ntextValue(item,tl),item.fill&&fill$jscomp$0(context,item,opacity)&&context.fillText(str,x,p),item.stroke&&stroke(context,item,opacity)&&context.strokeText(str,x,p);item.angle&&context.restore()}})},pick:pick(function(context,item,x,y,gx,gy){if(0>=item.fontSize)return!1;if(!item.angle)return!0;x=anchorPoint(item);context=x.x1;x=x.y1;y=bound$5(tempBounds,item,1);var a=-item.angle*DegToRad;item=Math.cos(a);a=Math.sin(a);return y.contains(item*gx-a*gy+(context-item*context+a*x),a*gx+item*gy+(x-a*context-\nitem*x))}),isect:function(item,box){item=bound$5(tempBounds,item,2);return intersectBoxLine(box,item[0],item[1],item[2],item[3])||intersectBoxLine(box,item[0],item[1],item[4],item[5])||intersectBoxLine(box,item[4],item[5],item[6],item[7])||intersectBoxLine(box,item[2],item[3],item[6],item[7])}},trail$1=markMultiItemPath(\"trail\",function(context,items){return trailShape.context(context)(items)},function(a,p){for(var i=a.length,dx,dy;0<=--i;)if(!1!==a[i].defined&&(dx=a[i].x-p[0],dy=a[i].y-p[1],dy=dx*\ndx+dy*dy,dx=a[i].size||1,dy<dx*dx))return a[i];return null}),Marks={arc:arc$1,area:area$1,group:group$jscomp$0,image:image$jscomp$1,line:line$1,path:path$1,rect:rect,rule:rule,shape:shape$1,symbol:symbol$1,text:text$jscomp$0,trail:trail$1},DUMMY={mark:null},keys=\"marktype name role interactive clip items zindex x y width height align baseline fill fillOpacity opacity blend stroke strokeOpacity strokeWidth strokeCap strokeDash strokeDashOffset strokeForeground strokeOffset startAngle endAngle innerRadius outerRadius cornerRadius padAngle cornerRadiusTopLeft cornerRadiusTopRight cornerRadiusBottomLeft cornerRadiusBottomRight interpolate tension orient defined url aspect smooth path scaleX scaleY x2 y2 size shape text angle theta radius dir dx dy ellipsis limit lineBreak lineHeight font fontSize fontWeight fontStyle fontVariant description aria ariaRole ariaRoleDescription\".split(\" \");\nScenegraph.prototype={toJSON:function(indent){return sceneToJSON(this.root,indent||0)},mark:function(markdef,group,index){group=group||this.root.items[0];markdef=createMark(markdef,group);group.items[index]=markdef;markdef.zindex&&(markdef.group.zdirty=!0);return markdef}};Handler.prototype={initialize:function(el,origin,obj){this._el=el;this._obj=obj||null;return this.origin(origin)},element:function(){return this._el},canvas:function(){return this._el&&this._el.firstChild},origin:function(origin){return arguments.length?\n(this._origin=origin||[0,0],this):this._origin.slice()},scene:function(scene){if(!arguments.length)return this._scene;this._scene=scene;return this},on:function(){},off:function(){},_handlerIndex:function(h,type,handler){for(var i=h?h.length:0;0<=--i;)if(h[i].type===type&&(!handler||h[i].handler===handler))return i;return-1},handlers:function(type){var h=this._handlers,a=[];if(type)a.push.apply(a,h[this.eventName(type)]);else for(var k in h)a.push.apply(a,h[k]);return a},eventName:function(name){var i=\nname.indexOf(\".\");return 0>i?name:name.slice(0,i)},handleHref:function(event,item,href){this._loader.sanitize(href,{context:\"href\"}).then(function(opt){var e=new MouseEvent(event.type,event),a=domCreate(null,\"a\"),name;for(name in opt)a.setAttribute(name,opt[name]);a.dispatchEvent(e)}).catch(function(){})},handleTooltip:function(event,item,show){if(item&&null!=item.tooltip){var el=this.canvas(),origin=this._origin,mark=item&&item.mark,mdef;if(mark&&(mdef=Marks[mark.marktype]).tip){el=point(event,el);\nel[0]-=origin[0];for(el[1]-=origin[1];item=item.mark.group;)el[0]-=item.x||0,el[1]-=item.y||0;item=mdef.tip(mark.items,el)}this._tooltip.call(this._obj,this,event,item,show&&item&&item.tooltip||null)}},getItemBoundingClientRect:function(item){var el=this.canvas();if(el){var rect=el.getBoundingClientRect(),origin=this._origin,bounds=item.bounds;el=bounds.width();var height=bounds.height(),x=bounds.x1+origin[0]+rect.left;for(rect=bounds.y1+origin[1]+rect.top;item.mark&&(item=item.mark.group);)x+=item.x||\n0,rect+=item.y||0;return{x:x,y:rect,width:el,height:height,left:x,top:rect,right:x+el,bottom:rect+height}}}};Renderer.prototype={initialize:function(el,width,height,origin,scaleFactor){this._el=el;return this.resize(width,height,origin,scaleFactor)},element:function(){return this._el},canvas:function(){return this._el&&this._el.firstChild},background:function(bgcolor){if(0===arguments.length)return this._bgcolor;this._bgcolor=bgcolor;return this},resize:function(width,height,origin,scaleFactor){this._width=\nwidth;this._height=height;this._origin=origin||[0,0];this._scale=scaleFactor||1;return this},dirty:function(){},render:function(scene){var r=this;r._call=function(){r._render(scene)};r._call();r._call=null;return r},_render:function(){},renderAsync:function(scene){var r=this.render(scene);return this._ready?this._ready.then(function(){return r}):Promise.resolve(r)},_load:function(method,uri){var r=this;method=r._loader[method](uri);if(!r._ready){var call=r._call;r._ready=r._loader.ready().then(function(redraw){redraw&&\ncall();r._ready=null})}return method},sanitizeURL:function(uri){return this._load(\"sanitizeURL\",uri)},loadImage:function(uri){return this._load(\"loadImage\",uri)}};vegaUtil.inherits(CanvasHandler,Handler,{initialize:function(el,origin,obj){var $jscomp$this=this;this._canvas=el&&domFind(el,\"canvas\");[\"click\",\"mousedown\",\"mousemove\",\"mouseout\",\"dragleave\"].forEach(function(type){return eventListenerCheck($jscomp$this,type)});return Handler.prototype.initialize.call(this,el,origin,obj)},canvas:function(){return this._canvas},\ncontext:function(){return this._canvas.getContext(\"2d\")},events:\"keydown keypress keyup dragenter dragleave dragover mousedown mouseup mousemove mouseout mouseover click dblclick wheel mousewheel touchstart touchmove touchend\".split(\" \"),DOMMouseScroll:function(evt){this.fire(\"mousewheel\",evt)},mousemove:move(\"mousemove\",\"mouseover\",\"mouseout\"),dragover:move(\"dragover\",\"dragenter\",\"dragleave\"),mouseout:inactive(\"mouseout\"),dragleave:inactive(\"dragleave\"),mousedown:function(evt){this._down=this._active;\nthis.fire(\"mousedown\",evt)},click:function(evt){this._down===this._active&&(this.fire(\"click\",evt),this._down=null)},touchstart:function(evt){this._touch=this.pickEvent(evt.changedTouches[0]);this._first&&(this._active=this._touch,this._first=!1);this.fire(\"touchstart\",evt,!0)},touchmove:function(evt){this.fire(\"touchmove\",evt,!0)},touchend:function(evt){this.fire(\"touchend\",evt,!0);this._touch=null},fire:function(type,evt,touch){touch=touch?this._touch:this._active;var h=this._handlers[type];evt.vegaType=\ntype;\"click\"===type&&touch&&touch.href?this.handleHref(evt,touch,touch.href):(\"mousemove\"===type||\"mouseout\"===type)&&this.handleTooltip(evt,touch,\"mouseout\"!==type);if(h){type=0;for(var len=h.length;type<len;++type)h[type].handler.call(this._obj,evt,touch)}},on:function(type,handler){var name=this.eventName(type),h=this._handlers;0>this._handlerIndex(h[name],type,handler)&&(eventListenerCheck(this,type),(h[name]||(h[name]=[])).push({type:type,handler:handler}));return this},off:function(type,handler){var name=\nthis.eventName(type);name=this._handlers[name];type=this._handlerIndex(name,type,handler);0<=type&&name.splice(type,1);return this},pickEvent:function(evt){evt=point(evt,this._canvas);var o=this._origin;return this.pick(this._scene,evt[0],evt[1],evt[0]-o[0],evt[1]-o[1])},pick:function(scene,x,y,gx,gy){var g=this.context();return Marks[scene.marktype].pick.call(this,g,scene,x,y,gx,gy)}});var pixelRatio=\"undefined\"!==typeof window?window.devicePixelRatio||1:1,base$jscomp$0=Renderer.prototype;vegaUtil.inherits(CanvasRenderer,\nRenderer,{initialize:function(el,width,height,origin,scaleFactor,options){this._options=options||{};this._canvas=this._options.externalContext?null:vegaCanvas.canvas(1,1,this._options.type);el&&this._canvas&&(domClear(el,0).appendChild(this._canvas),this._canvas.setAttribute(\"class\",\"marks\"));return base$jscomp$0.initialize.call(this,el,width,height,origin,scaleFactor)},resize:function(width,height,origin,scaleFactor$jscomp$0){base$jscomp$0.resize.call(this,width,height,origin,scaleFactor$jscomp$0);\nif(this._canvas){width=this._canvas;height=this._width;origin=this._height;scaleFactor$jscomp$0=this._origin;var scaleFactor=this._scale,opt=this._options.context,inDOM=\"undefined\"!==typeof HTMLElement&&width instanceof HTMLElement&&null!=width.parentNode,context=width.getContext(\"2d\");scaleFactor=inDOM?pixelRatio:scaleFactor;width.width=height*scaleFactor;width.height=origin*scaleFactor;for(var key in opt)context[key]=opt[key];inDOM&&1!==scaleFactor&&(width.style.width=height+\"px\",width.style.height=\norigin+\"px\");context.pixelRatio=scaleFactor;context.setTransform(scaleFactor,0,0,scaleFactor,scaleFactor*scaleFactor$jscomp$0[0],scaleFactor*scaleFactor$jscomp$0[1])}else(key=this._options.externalContext)||vegaUtil.error(\"CanvasRenderer is missing a valid canvas or context\"),key.scale(this._scale,this._scale),key.translate(this._origin[0],this._origin[1]);this._redraw=!0;return this},canvas:function(){return this._canvas},context:function(){return this._options.externalContext||(this._canvas?this._canvas.getContext(\"2d\"):\nnull)},dirty:function(item){var b=this._tempb.clear().union(item.bounds);for(item=item.mark.group;item;)b.translate(item.x||0,item.y||0),item=item.mark.group;this._dirty.union(b)},_render:function(scene){var g=this.context(),o=this._origin,w=this._width,h=this._height,db=this._dirty,vb=(new Bounds).set(0,0,w,h).translate(-o[0],-o[1]);g.save();this._redraw||db.empty()?vb=(this._redraw=!1,vb.expand(1)):(vb=vb.intersect(db),vb.expand(1).round(),g.pixelRatio%1&&vb.scale(g.pixelRatio).round().scale(1/\ng.pixelRatio),vb.translate(-(o[0]%1),-(o[1]%1)),g.beginPath(),g.rect(vb.x1,vb.y1,vb.width(),vb.height()),g.clip());this.clear(-o[0],-o[1],w,h);this.draw(g,scene,vb);g.restore();db.clear();return this},draw:function(ctx,scene,bounds){var mark=Marks[scene.marktype];if(scene.clip){var clip=scene.clip;ctx.save();vegaUtil.isFunction(clip)?(ctx.beginPath(),clip(ctx),ctx.clip()):clipGroup(ctx,scene.group)}mark.draw.call(this,ctx,scene,bounds);scene.clip&&ctx.restore()},clear:function(x,y,w,h){var opt=this._options,\ng=this.context();\"pdf\"===opt.type||opt.externalContext||g.clearRect(x,y,w,h);null!=this._bgcolor&&(g.fillStyle=this._bgcolor,g.fillRect(x,y,w,h))}});var listener=function(context,handler){return function(evt){var item=evt.target.__data__;item=Array.isArray(item)?item[0]:item;evt.vegaType=evt.type;handler.call(context._obj,evt,item)}};vegaUtil.inherits(SVGHandler,Handler,{initialize:function(el,origin,obj){var svg=this._svg;svg&&(svg.removeEventListener(\"click\",this._hrefHandler),svg.removeEventListener(\"mousemove\",\nthis._tooltipHandler),svg.removeEventListener(\"mouseout\",this._tooltipHandler));if(this._svg=svg=el&&domFind(el,\"svg\"))svg.addEventListener(\"click\",this._hrefHandler),svg.addEventListener(\"mousemove\",this._tooltipHandler),svg.addEventListener(\"mouseout\",this._tooltipHandler);return Handler.prototype.initialize.call(this,el,origin,obj)},canvas:function(){return this._svg},on:function(type,handler){var name=this.eventName(type),h=this._handlers;0>this._handlerIndex(h[name],type,handler)&&(type={type:type,\nhandler:handler,listener:listener(this,handler)},(h[name]||(h[name]=[])).push(type),this._svg&&this._svg.addEventListener(name,type.listener));return this},off:function(type,handler){var name=this.eventName(type),h=this._handlers[name];type=this._handlerIndex(h,type,handler);0<=type&&(this._svg&&this._svg.removeEventListener(name,h[type].listener),h.splice(type,1));return this}});var bundle=function(role,roledesc,label){var $jscomp$compprop9={};return $jscomp$compprop9.role=role,$jscomp$compprop9[\"aria-roledescription\"]=\nroledesc,$jscomp$compprop9[\"aria-label\"]=label||void 0,$jscomp$compprop9},AriaIgnore=vegaUtil.toSet(\"axis-domain axis-grid axis-label axis-tick axis-title legend-band legend-entry legend-gradient legend-label legend-title legend-symbol title\".split(\" \")),AriaGuides={axis:{desc:\"axis\",caption:function(item){var datum=item.datum,orient=item.orient,title=datum.title?extractTitle(item):null,ctx=item.context;datum=ctx.scales[datum.scale].value;ctx=ctx.dataflow.locale();var type=datum.type;return(\"left\"===\norient||\"right\"===orient?\"Y\":\"X\")+\"-axis\"+(title?\" titled '\"+title+\"'\":\"\")+(\" for a \"+(vegaScale.isDiscrete(type)?\"discrete\":type)+\" scale with \")+vegaScale.domainCaption(ctx,datum,item)}},legend:{desc:\"legend\",caption:function(item){var datum=item.datum,title=datum.title?extractTitle(item):null,type=((datum.type||\"\")+\" legend\").trim(),scales=datum.scales;datum=Object.keys(scales);var ctx=item.context;scales=ctx.scales[scales[datum[0]]].value;ctx=ctx.dataflow.locale();return(type.length?type[0].toUpperCase()+\ntype.slice(1):type)+(title?\" titled '\"+title+\"'\":\"\")+(\" for \"+channelCaption(datum))+(\" with \"+vegaScale.domainCaption(ctx,scales,item))}},\"title-text\":{desc:\"title\",caption:function(item){return\"Title text '\"+vegaUtil.array(item.text).join(\" \")+\"'\"}},\"title-subtitle\":{desc:\"subtitle\",caption:function(item){return\"Subtitle text '\"+vegaUtil.array(item.text).join(\" \")+\"'\"}}},AriaEncode={ariaRole:\"role\",ariaRoleDescription:\"aria-roledescription\",description:\"aria-label\"},innerText=function(val){return(val+\n\"\").replace(/&/g,\"\\x26amp;\").replace(/</g,\"\\x26lt;\").replace(/>/g,\"\\x26gt;\")},serializeXML=function(node){return _serialize(markup(),node)+\"\"},styles={fill:\"fill\",fillOpacity:\"fill-opacity\",stroke:\"stroke\",strokeOpacity:\"stroke-opacity\",strokeWidth:\"stroke-width\",strokeCap:\"stroke-linecap\",strokeJoin:\"stroke-linejoin\",strokeDash:\"stroke-dasharray\",strokeDashOffset:\"stroke-dashoffset\",strokeMiterLimit:\"stroke-miterlimit\",opacity:\"opacity\",blend:\"mix-blend-mode\"},rootAttributes={fill:\"none\",\"stroke-miterlimit\":10},\nns=metadata.xmlns,base$1=Renderer.prototype;vegaUtil.inherits(SVGRenderer,Renderer,{initialize:function(el,width,height,origin,scaleFactor){this._defs={};this._clearDefs();el&&(this._svg=domChild(el,0,\"svg\",ns),setAttributes(this._svg,metadata),this._svg.setAttribute(\"class\",\"marks\"),domClear(el,1),this._root=domChild(this._svg,0,\"g\",ns),setAttributes(this._root,rootAttributes),domClear(this._svg,1));this.background(this._bgcolor);return base$1.initialize.call(this,el,width,height,origin,scaleFactor)},\nbackground:function(bgcolor){arguments.length&&this._svg&&this._svg.style.setProperty(\"background-color\",bgcolor);return base$1.background.apply(this,arguments)},resize:function(width,height,origin,scaleFactor){base$1.resize.call(this,width,height,origin,scaleFactor);this._svg&&(setAttributes(this._svg,{width:this._width*this._scale,height:this._height*this._scale,viewBox:\"0 0 \"+this._width+\" \"+this._height}),this._root.setAttribute(\"transform\",\"translate(\"+this._origin+\")\"));this._dirty=[];return this},\ncanvas:function(){return this._svg},svg:function(){var svg=this._svg,bg=this._bgcolor;if(!svg)return null;if(bg){svg.removeAttribute(\"style\");var node=domChild(svg,0,\"rect\",ns);setAttributes(node,{width:this._width,height:this._height,fill:bg})}var text=serializeXML(svg);bg&&(svg.removeChild(node),this._svg.style.setProperty(\"background-color\",bg));return text},_render:function(scene){this._dirtyCheck()&&(this._dirtyAll&&this._clearDefs(),this.mark(this._root,scene),domClear(this._root,1));this.defs();\nthis._dirty=[];++this._dirtyID;return this},dirty:function(item){item.dirty!==this._dirtyID&&(item.dirty=this._dirtyID,this._dirty.push(item))},isDirty:function(item){return this._dirtyAll||!item._svg||item.dirty===this._dirtyID},_dirtyCheck:function(){this._dirtyAll=!0;var items=this._dirty;if(!items.length||!this._dirtyID)return!0;var id=++this._dirtyID,n;var i$jscomp$0=0;for(n=items.length;i$jscomp$0<n;++i$jscomp$0){var item=items[i$jscomp$0];var mark=item.mark;if(mark.marktype!==type){var type=\nmark.marktype;var mdef=Marks[type]}mark.zdirty&&mark.dirty!==id&&(this._dirtyAll=!1,dirtyParents(item,id),mark.items.forEach(function(i){i.dirty=id}));mark.zdirty||(item.exit?(mdef.nested&&mark.items.length?(mark=mark.items[0],mark._svg&&this._update(mdef,mark._svg,mark)):item._svg&&(mark=item._svg.parentNode)&&mark.removeChild(item._svg),item._svg=null):(item=mdef.nested?mark.items[0]:item,item._update!==id&&(item._svg&&item._svg.ownerSVGElement?this._update(mdef,item._svg,item):(this._dirtyAll=\n!1,dirtyParents(item,id)),item._update=id)))}return!this._dirtyAll},mark:function(el,scene,prev){var $jscomp$this=this;if(!this.isDirty(scene))return scene._svg;var svg=this._svg,mdef=Marks[scene.marktype],events=!1===scene.interactive?\"none\":null,isGroup=\"g\"===mdef.tag,sibling=null,i=0,parent=bind(scene,el,prev,\"g\",svg);parent.setAttribute(\"class\",cssClass(scene));el=ariaMarkAttributes(scene);for(var key in el)setAttribute(parent,key,el[key]);isGroup||setAttribute(parent,\"pointer-events\",events);\nsetAttribute(parent,\"clip-path\",scene.clip?clip(this,scene,scene.group):null);events=function(item){var dirty=$jscomp$this.isDirty(item),node=bind(item,parent,sibling,mdef.tag,svg);dirty&&($jscomp$this._update(mdef,node,item),isGroup&&recurse$jscomp$0($jscomp$this,node,item));sibling=node;++i};mdef.nested?scene.items.length&&events(scene.items[0]):visit(scene,events);domClear(parent,i);return parent},_update:function(mdef,el,item){element=el;values=el.__values__;ariaItemAttributes(emit,item);mdef.attr(emit,\nitem,this);var extra=mark_extras[mdef.type];extra&&extra.call(this,mdef,el,item);element&&this.style(element,item)},style:function(el,item){if(null!=item)for(var prop in styles){var value$340=\"font\"===prop?fontFamily(item):item[prop];if(value$340!==values[prop]){var name=styles[prop];null==value$340?el.removeAttribute(name):(value$340&&value$340.gradient&&(value$340=gradientRef(value$340,this._defs.gradient,href())),el.setAttribute(name,value$340+\"\"));values[prop]=value$340}}},defs:function(){var svg=\nthis._svg,defs=this._defs,el=defs.el,index=0;for(id in defs.gradient){el||(defs.el=el=domChild(svg,1,\"defs\",ns));var n,el$jscomp$0=el,grad=defs.gradient[id];if(\"radial\"===grad.gradient){var stop=domChild(el$jscomp$0,index++,\"pattern\",ns);setAttributes(stop,{id:\"p_\"+grad.id,viewBox:\"0,0,1,1\",width:\"100%\",height:\"100%\",preserveAspectRatio:\"xMidYMid slice\"});stop=domChild(stop,0,\"rect\",ns);setAttributes(stop,{width:1,height:1,fill:\"url(\"+href()+\"#\"+grad.id+\")\"});el$jscomp$0=domChild(el$jscomp$0,index++,\n\"radialGradient\",ns);setAttributes(el$jscomp$0,{id:grad.id,fx:grad.x1,fy:grad.y1,fr:grad.r1,cx:grad.x2,cy:grad.y2,r:grad.r2})}else el$jscomp$0=domChild(el$jscomp$0,index++,\"linearGradient\",ns),setAttributes(el$jscomp$0,{id:grad.id,x1:grad.x1,x2:grad.x2,y1:grad.y1,y2:grad.y2});var i=0;for(n=grad.stops.length;i<n;++i)stop=domChild(el$jscomp$0,i,\"stop\",ns),stop.setAttribute(\"offset\",grad.stops[i].offset),stop.setAttribute(\"stop-color\",grad.stops[i].color);domClear(el$jscomp$0,i)}for(var id$341 in defs.clipping){el||\n(defs.el=el=domChild(svg,1,\"defs\",ns));var id=el;el$jscomp$0=defs.clipping[id$341];id=domChild(id,index,\"clipPath\",ns);id.setAttribute(\"id\",el$jscomp$0.id);el$jscomp$0.path?(grad=domChild(id,0,\"path\",ns),grad.setAttribute(\"d\",el$jscomp$0.path)):(grad=domChild(id,0,\"rect\",ns),setAttributes(grad,{x:0,y:0,width:el$jscomp$0.width,height:el$jscomp$0.height}));domClear(id,1);index+=1}el&&(0===index?(svg.removeChild(el),defs.el=null):domClear(el,index))},_clearDefs:function(){var def=this._defs;def.gradient=\n{};def.clipping={}}});var element=null,values=null,mark_extras={group:function(mdef,el,item){var fg=element=el.childNodes[2];values=fg.__values__;mdef.foreground(emit,item,this);values=el.__values__;element=el.childNodes[1];mdef.content(emit,item,this);el=element=el.childNodes[0];mdef.background(emit,item,this);mdef=!1===item.mark.interactive?\"none\":null;mdef!==values.events&&(setAttribute(fg,\"pointer-events\",mdef),setAttribute(el,\"pointer-events\",mdef),values.events=mdef);item.strokeForeground&&\nitem.stroke?(mdef=item.fill,setAttribute(fg,\"display\",null),this.style(el,item),setAttribute(el,\"stroke\",null),mdef&&(item.fill=null),values=fg.__values__,this.style(fg,item),mdef&&(item.fill=mdef),element=null):setAttribute(fg,\"display\",\"none\")},image:function(mdef,el,item){!1===item.smooth?(setStyle(el,\"image-rendering\",\"optimizeSpeed\"),setStyle(el,\"image-rendering\",\"pixelated\")):setStyle(el,\"image-rendering\",null)},text:function(mdef,el,item){mdef=textLines(item);if(vegaUtil.isArray(mdef)){var value=\nmdef.map(function(_){return textValue(item,_)});mdef=value.join(\"\\n\");if(mdef!==values.text){domClear(el,0);var doc=el.ownerDocument;var lh=lineHeight(item);value.forEach(function(t,i){var ts=domCreate(doc,\"tspan\",ns);ts.__data__=item;ts.textContent=t;i&&(ts.setAttribute(\"x\",0),ts.setAttribute(\"dy\",lh));el.appendChild(ts)});values.text=mdef}}else value=textValue(item,mdef),value!==values.text&&(el.textContent=value,values.text=value);setAttribute(el,\"font-family\",fontFamily(item));setAttribute(el,\n\"font-size\",fontSize(item)+\"px\");setAttribute(el,\"font-style\",item.fontStyle);setAttribute(el,\"font-variant\",item.fontVariant);setAttribute(el,\"font-weight\",item.fontWeight)}};vegaUtil.inherits(SVGStringRenderer,Renderer,{svg:function(){return this._text},_render:function(scene){var m=markup();m.open(\"svg\",vegaUtil.extend({},metadata,{class:\"marks\",width:this._width*this._scale,height:this._height*this._scale,viewBox:\"0 0 \"+this._width+\" \"+this._height}));var bg=this._bgcolor;bg&&\"transparent\"!==\nbg&&\"none\"!==bg&&m.open(\"rect\",{width:this._width,height:this._height,fill:bg}).close();m.open(\"g\",rootAttributes,{transform:\"translate(\"+this._origin+\")\"});this.mark(m,scene);m.close();this.defs(m);this._text=m.close()+\"\";return this},mark:function(m,scene$jscomp$0){var $jscomp$this=this,mdef=Marks[scene$jscomp$0.marktype],tag=mdef.tag,attrList=[ariaItemAttributes,mdef.attr];m.open(\"g\",{\"class\":cssClass(scene$jscomp$0),\"clip-path\":scene$jscomp$0.clip?clip(this,scene$jscomp$0,scene$jscomp$0.group):\nnull},ariaMarkAttributes(scene$jscomp$0),{\"pointer-events\":\"g\"!==tag&&!1===scene$jscomp$0.interactive?\"none\":null});var process=function(item){var href=$jscomp$this.href(item);href&&m.open(\"a\",href);m.open(tag,$jscomp$this.attr(scene$jscomp$0,item,attrList,\"g\"!==tag?tag:null));if(\"text\"===tag){var tl$343=textLines(item);if(vegaUtil.isArray(tl$343))for(var attrs={x:0,dy:lineHeight(item)},i=0;i<tl$343.length;++i)m.open(\"tspan\",i?attrs:null).text(textValue(item,tl$343[i])).close();else m.text(textValue(item,\ntl$343))}else\"g\"===tag&&(tl$343=item.strokeForeground,attrs=item.fill,i=item.stroke,tl$343&&i&&(item.stroke=null),m.open(\"path\",$jscomp$this.attr(scene$jscomp$0,item,mdef.background,\"bgrect\")).close(),m.open(\"g\",$jscomp$this.attr(scene$jscomp$0,item,mdef.content)),visit(item,function(scene){return $jscomp$this.mark(m,scene)}),m.close(),tl$343&&i?(attrs&&(item.fill=null),item.stroke=i,m.open(\"path\",$jscomp$this.attr(scene$jscomp$0,item,mdef.foreground,\"bgrect\")).close(),attrs&&(item.fill=attrs)):m.open(\"path\",\n$jscomp$this.attr(scene$jscomp$0,item,mdef.foreground,\"bgfore\")).close());m.close();href&&m.close()};mdef.nested?scene$jscomp$0.items&&scene$jscomp$0.items.length&&process(scene$jscomp$0.items[0]):visit(scene$jscomp$0,process);return m.close()},href:function(item){var $jscomp$this=this,href=item.href;if(href){if(item=this._hrefs&&this._hrefs[href])return item;this.sanitizeURL(href).then(function(attr){attr[\"xlink:href\"]=attr.href;attr.href=null;($jscomp$this._hrefs||($jscomp$this._hrefs={}))[href]=\nattr})}return null},attr:function(scene,item,attrs,tag){var $jscomp$this=this,object={},emit=function(name,value,ns,prefixed){object[prefixed||name]=value};Array.isArray(attrs)?attrs.forEach(function(fn){return fn(emit,item,$jscomp$this)}):attrs(emit,item,this);tag&&style(object,item,scene,tag,this._defs);return object},defs:function(m){var gradient=this._defs.gradient,clipping=this._defs.clipping;if(0!==Object.keys(gradient).length+Object.keys(clipping).length){m.open(\"defs\");for(var id in gradient){var def$346=\ngradient[id],stops=def$346.stops;\"radial\"===def$346.gradient?(m.open(\"pattern\",{id:\"p_\"+id,viewBox:\"0,0,1,1\",width:\"100%\",height:\"100%\",preserveAspectRatio:\"xMidYMid slice\"}),m.open(\"rect\",{width:\"1\",height:\"1\",fill:\"url(#\"+id+\")\"}).close(),m.close(),m.open(\"radialGradient\",{id:id,fx:def$346.x1,fy:def$346.y1,fr:def$346.r1,cx:def$346.x2,cy:def$346.y2,r:def$346.r2})):m.open(\"linearGradient\",{id:id,x1:def$346.x1,x2:def$346.x2,y1:def$346.y1,y2:def$346.y2});for(def$346=0;def$346<stops.length;++def$346)m.open(\"stop\",\n{offset:stops[def$346].offset,\"stop-color\":stops[def$346].color}).close();m.close()}for(var id$347 in clipping)gradient=clipping[id$347],m.open(\"clipPath\",{id:id$347}),gradient.path?m.open(\"path\",{d:gradient.path}).close():m.open(\"rect\",{x:0,y:0,width:gradient.width,height:gradient.height}).close(),m.close();m.close()}}});var modules={};modules.canvas=modules.png={renderer:CanvasRenderer,headless:CanvasRenderer,handler:CanvasHandler};modules.svg={renderer:SVGRenderer,headless:SVGStringRenderer,handler:SVGHandler};\nmodules.none={};var clipBounds=new Bounds;exports.Bounds=Bounds;exports.CanvasHandler=CanvasHandler;exports.CanvasRenderer=CanvasRenderer;exports.Gradient=function(p0,p1){var stops=[],gradient;return gradient={gradient:\"linear\",x1:p0?p0[0]:0,y1:p0?p0[1]:0,x2:p1?p1[0]:1,y2:p1?p1[1]:0,stops:stops,stop:function(offset,color){stops.push({offset:offset,color:color});return gradient}}};exports.GroupItem=GroupItem;exports.Handler=Handler;exports.Item=Item;exports.Marks=Marks;exports.RenderType={Canvas:\"canvas\",\nPNG:\"png\",SVG:\"svg\",None:\"none\"};exports.Renderer=Renderer;exports.ResourceLoader=ResourceLoader;exports.SVGHandler=SVGHandler;exports.SVGRenderer=SVGRenderer;exports.SVGStringRenderer=SVGStringRenderer;exports.Scenegraph=Scenegraph;exports.boundClip=function(mark){var clip=mark.clip;if(vegaUtil.isFunction(clip))clip(boundContext(clipBounds.clear()));else if(clip)clipBounds.set(0,0,mark.group.width,mark.group.height);else return;mark.bounds.intersect(clipBounds)};exports.boundContext=boundContext;\nexports.boundItem=boundItem;exports.boundMark=boundMark;exports.boundStroke=boundStroke;exports.domChild=domChild;exports.domClear=domClear;exports.domCreate=domCreate;exports.domFind=domFind;exports.font=font;exports.fontFamily=fontFamily;exports.fontSize=fontSize;exports.intersect=function(scene,bounds,filter){var hits=[];bounds=(new Bounds).union(bounds);var type=scene.marktype;return type?intersectMark(scene,bounds,filter,hits):\"group\"===type?intersectGroup(scene,bounds,filter,hits):vegaUtil.error(\"Intersect scene must be mark node or group item.\")};\nexports.intersectBoxLine=intersectBoxLine;exports.intersectPath=intersectPath;exports.intersectPoint=intersectPoint;exports.intersectRule=intersectRule;exports.lineHeight=lineHeight;exports.markup=markup;exports.multiLineOffset=function(item){var tl=textLines(item);return(vegaUtil.isArray(tl)?tl.length-1:0)*lineHeight(item)};exports.pathCurves=curves;exports.pathEqual=pathEqual;exports.pathParse=pathParse;exports.pathRectangle=vg_rect;exports.pathRender=pathRender;exports.pathSymbols=symbols;exports.pathTrail=\nvg_trail;exports.point=point;exports.renderModule=function(name,_){name=String(name||\"\").toLowerCase();return 1<arguments.length?(modules[name]=_,this):modules[name]};exports.resetSVGClipId=function(){clip_id=1};exports.resetSVGDefIds=function(){clip_id=1;gradient_id=0};exports.sceneEqual=sceneEqual;exports.sceneFromJSON=sceneFromJSON;exports.scenePickVisit=pickVisit;exports.sceneToJSON=sceneToJSON;exports.sceneVisit=visit;exports.sceneZOrder=zorder;exports.serializeXML=serializeXML;exports.textMetrics=\ntextMetrics;Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_scenegraph$build$vega_scenegraph\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('d3-shape'), require('d3-path'), require('vega-canvas'), require('vega-loader'), require('vega-scale')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'd3-shape', 'd3-path', 'vega-canvas', 'vega-loader', 'vega-scale'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.d3, global.d3, global.vega, global.vega, global.vega));\n}(this, (function (exports, vegaUtil, d3Shape, d3Path, vegaCanvas, vegaLoader, vegaScale) { 'use strict';\n\n  var gradient_id = 0;\n\n  function resetSVGGradientId() {\n    gradient_id = 0;\n  }\n\n  const patternPrefix = 'p_';\n\n  function isGradient(value) {\n    return value && value.gradient;\n  }\n\n  function gradientRef(g, defs, base) {\n    const type = g.gradient;\n\n    let id = g.id,\n        prefix = type === 'radial' ? patternPrefix : '';\n\n    // check id, assign default values as needed\n    if (!id) {\n      id = g.id = 'gradient_' + (gradient_id++);\n      if (type === 'radial') {\n        g.x1 = get(g.x1, 0.5);\n        g.y1 = get(g.y1, 0.5);\n        g.r1 = get(g.r1, 0);\n        g.x2 = get(g.x2, 0.5);\n        g.y2 = get(g.y2, 0.5);\n        g.r2 = get(g.r2, 0.5);\n        prefix = patternPrefix;\n      } else {\n        g.x1 = get(g.x1, 0);\n        g.y1 = get(g.y1, 0);\n        g.x2 = get(g.x2, 1);\n        g.y2 = get(g.y2, 0);\n      }\n    }\n\n    // register definition\n    defs[id] = g;\n\n    // return url reference\n    return 'url(' + (base || '') + '#' + prefix + id + ')';\n  }\n\n  function get(val, def) {\n    return val != null ? val : def;\n  }\n\n  function Gradient(p0, p1) {\n    var stops = [], gradient;\n    return gradient = {\n      gradient: 'linear',\n      x1: p0 ? p0[0] : 0,\n      y1: p0 ? p0[1] : 0,\n      x2: p1 ? p1[0] : 1,\n      y2: p1 ? p1[1] : 0,\n      stops: stops,\n      stop: function(offset, color) {\n        stops.push({offset: offset, color: color});\n        return gradient;\n      }\n    };\n  }\n\n  const lookup = {\n    'basis': {\n      curve: d3Shape.curveBasis\n    },\n    'basis-closed': {\n      curve: d3Shape.curveBasisClosed\n    },\n    'basis-open': {\n      curve: d3Shape.curveBasisOpen\n    },\n    'bundle': {\n      curve: d3Shape.curveBundle,\n      tension: 'beta',\n      value: 0.85\n    },\n    'cardinal': {\n      curve: d3Shape.curveCardinal,\n      tension: 'tension',\n      value: 0\n    },\n    'cardinal-open': {\n      curve: d3Shape.curveCardinalOpen,\n      tension: 'tension',\n      value: 0\n    },\n    'cardinal-closed': {\n      curve: d3Shape.curveCardinalClosed,\n      tension: 'tension',\n      value: 0\n    },\n    'catmull-rom': {\n      curve: d3Shape.curveCatmullRom,\n      tension: 'alpha',\n      value: 0.5\n    },\n    'catmull-rom-closed': {\n      curve: d3Shape.curveCatmullRomClosed,\n      tension: 'alpha',\n      value: 0.5\n    },\n    'catmull-rom-open': {\n      curve: d3Shape.curveCatmullRomOpen,\n      tension: 'alpha',\n      value: 0.5\n    },\n    'linear': {\n      curve: d3Shape.curveLinear\n    },\n    'linear-closed': {\n      curve: d3Shape.curveLinearClosed\n    },\n    'monotone': {\n      horizontal: d3Shape.curveMonotoneY,\n      vertical:   d3Shape.curveMonotoneX\n    },\n    'natural': {\n      curve: d3Shape.curveNatural\n    },\n    'step': {\n      curve: d3Shape.curveStep\n    },\n    'step-after': {\n      curve: d3Shape.curveStepAfter\n    },\n    'step-before': {\n      curve: d3Shape.curveStepBefore\n    }\n  };\n\n  function curves(type, orientation, tension) {\n    var entry = vegaUtil.hasOwnProperty(lookup, type) && lookup[type],\n        curve = null;\n\n    if (entry) {\n      curve = entry.curve || entry[orientation || 'vertical'];\n      if (entry.tension && tension != null) {\n        curve = curve[entry.tension](tension);\n      }\n    }\n\n    return curve;\n  }\n\n  // Path parsing and rendering code adapted from fabric.js -- Thanks!\n  const cmdlen = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n        regexp = [\n          /([MLHVCSQTAZmlhvcsqtaz])/g,\n          /###/,\n          /(\\.\\d+)(\\.\\d)/g,\n          /(\\d)([-+])/g,\n          /\\s|,|###/\n        ];\n\n  function pathParse(pathstr) {\n    const result = [];\n    let curr,\n        chunks,\n        parsed, param,\n        cmd, len, i, j, n, m;\n\n    // First, break path into command sequence\n    const path = pathstr\n      .slice()\n      .replace(regexp[0], '###$1')\n      .split(regexp[1])\n      .slice(1);\n\n    // Next, parse each command in turn\n    for (i = 0, n = path.length; i < n; ++i) {\n      curr = path[i];\n      chunks = curr\n        .slice(1)\n        .trim()\n        .replace(regexp[2], '$1###$2')\n        .replace(regexp[3], '$1###$2')\n        .split(regexp[4]);\n      cmd = curr.charAt(0);\n\n      parsed = [cmd];\n      for (j = 0, m = chunks.length; j < m; ++j) {\n        if ((param = +chunks[j]) === param) { // not NaN\n          parsed.push(param);\n        }\n      }\n\n      len = cmdlen[cmd.toLowerCase()];\n      if (parsed.length - 1 > len) {\n        const m = parsed.length;\n        j = 1;\n        result.push([cmd].concat(parsed.slice(j, j += len)));\n\n        // handle implicit lineTo (#2803)\n        cmd = cmd === 'M' ? 'L' : cmd === 'm' ? 'l' : cmd;\n\n        for (; j < m; j += len) {\n          result.push([cmd].concat(parsed.slice(j, j+len)));\n        }\n      }\n      else {\n        result.push(parsed);\n      }\n    }\n\n    return result;\n  }\n\n  const DegToRad = Math.PI / 180;\n  const Epsilon = 1e-14;\n  const HalfPi = Math.PI / 2;\n  const Tau = Math.PI * 2;\n  const HalfSqrt3 = Math.sqrt(3) / 2;\n\n  var segmentCache = {};\n  var bezierCache = {};\n\n  var join = [].join;\n\n  // Copied from Inkscape svgtopdf, thanks!\n  function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n    var key = join.call(arguments);\n    if (segmentCache[key]) {\n      return segmentCache[key];\n    }\n\n    var th = rotateX * DegToRad;\n    var sin_th = Math.sin(th);\n    var cos_th = Math.cos(th);\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n    var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n    var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n    var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n    if (pl > 1) {\n      pl = Math.sqrt(pl);\n      rx *= pl;\n      ry *= pl;\n    }\n\n    var a00 = cos_th / rx;\n    var a01 = sin_th / rx;\n    var a10 = (-sin_th) / ry;\n    var a11 = (cos_th) / ry;\n    var x0 = a00 * ox + a01 * oy;\n    var y0 = a10 * ox + a11 * oy;\n    var x1 = a00 * x + a01 * y;\n    var y1 = a10 * x + a11 * y;\n\n    var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n    var sfactor_sq = 1 / d - 0.25;\n    if (sfactor_sq < 0) sfactor_sq = 0;\n    var sfactor = Math.sqrt(sfactor_sq);\n    if (sweep == large) sfactor = -sfactor;\n    var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n    var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n    var th0 = Math.atan2(y0-yc, x0-xc);\n    var th1 = Math.atan2(y1-yc, x1-xc);\n\n    var th_arc = th1-th0;\n    if (th_arc < 0 && sweep === 1) {\n      th_arc += Tau;\n    } else if (th_arc > 0 && sweep === 0) {\n      th_arc -= Tau;\n    }\n\n    var segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));\n    var result = [];\n    for (var i=0; i<segs; ++i) {\n      var th2 = th0 + i * th_arc / segs;\n      var th3 = th0 + (i+1) * th_arc / segs;\n      result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n    }\n\n    return (segmentCache[key] = result);\n  }\n\n  function bezier(params) {\n    var key = join.call(params);\n    if (bezierCache[key]) {\n      return bezierCache[key];\n    }\n\n    var cx = params[0],\n        cy = params[1],\n        th0 = params[2],\n        th1 = params[3],\n        rx = params[4],\n        ry = params[5],\n        sin_th = params[6],\n        cos_th = params[7];\n\n    var a00 = cos_th * rx;\n    var a01 = -sin_th * ry;\n    var a10 = sin_th * rx;\n    var a11 = cos_th * ry;\n\n    var cos_th0 = Math.cos(th0);\n    var sin_th0 = Math.sin(th0);\n    var cos_th1 = Math.cos(th1);\n    var sin_th1 = Math.sin(th1);\n\n    var th_half = 0.5 * (th1 - th0);\n    var sin_th_h2 = Math.sin(th_half * 0.5);\n    var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n    var x1 = cx + cos_th0 - t * sin_th0;\n    var y1 = cy + sin_th0 + t * cos_th0;\n    var x3 = cx + cos_th1;\n    var y3 = cy + sin_th1;\n    var x2 = x3 + t * sin_th1;\n    var y2 = y3 - t * cos_th1;\n\n    return (bezierCache[key] = [\n      a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n      a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n      a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n    ]);\n  }\n\n  var temp = ['l', 0, 0, 0, 0, 0, 0, 0];\n\n  function scale(current, sX, sY) {\n    var c = (temp[0] = current[0]);\n    if (c === 'a' || c === 'A') {\n      temp[1] = sX * current[1];\n      temp[2] = sY * current[2];\n      temp[3] = current[3];\n      temp[4] = current[4];\n      temp[5] = current[5];\n      temp[6] = sX * current[6];\n      temp[7] = sY * current[7];\n    } else if (c === 'h' || c === 'H') {\n      temp[1] = sX * current[1];\n    } else if (c === 'v' || c === 'V') {\n      temp[1] = sY * current[1];\n    } else {\n      for (var i=1, n=current.length; i<n; ++i) {\n        temp[i] = (i % 2 == 1 ? sX : sY) * current[i];\n      }\n    }\n    return temp;\n  }\n\n  function pathRender(context, path, l, t, sX, sY) {\n    var current, // current instruction\n        previous = null,\n        x = 0, // current x\n        y = 0, // current y\n        controlX = 0, // current control point x\n        controlY = 0, // current control point y\n        tempX,\n        tempY,\n        tempControlX,\n        tempControlY;\n\n    if (l == null) l = 0;\n    if (t == null) t = 0;\n    if (sX == null) sX = 1;\n    if (sY == null) sY = sX;\n\n    if (context.beginPath) context.beginPath();\n\n    for (var i=0, len=path.length; i<len; ++i) {\n      current = path[i];\n      if (sX !== 1 || sY !== 1) {\n        current = scale(current, sX, sY);\n      }\n\n      switch (current[0]) { // first letter\n\n        case 'l': // lineto, relative\n          x += current[1];\n          y += current[2];\n          context.lineTo(x + l, y + t);\n          break;\n\n        case 'L': // lineto, absolute\n          x = current[1];\n          y = current[2];\n          context.lineTo(x + l, y + t);\n          break;\n\n        case 'h': // horizontal lineto, relative\n          x += current[1];\n          context.lineTo(x + l, y + t);\n          break;\n\n        case 'H': // horizontal lineto, absolute\n          x = current[1];\n          context.lineTo(x + l, y + t);\n          break;\n\n        case 'v': // vertical lineto, relative\n          y += current[1];\n          context.lineTo(x + l, y + t);\n          break;\n\n        case 'V': // verical lineto, absolute\n          y = current[1];\n          context.lineTo(x + l, y + t);\n          break;\n\n        case 'm': // moveTo, relative\n          x += current[1];\n          y += current[2];\n          context.moveTo(x + l, y + t);\n          break;\n\n        case 'M': // moveTo, absolute\n          x = current[1];\n          y = current[2];\n          context.moveTo(x + l, y + t);\n          break;\n\n        case 'c': // bezierCurveTo, relative\n          tempX = x + current[5];\n          tempY = y + current[6];\n          controlX = x + current[3];\n          controlY = y + current[4];\n          context.bezierCurveTo(\n            x + current[1] + l, // x1\n            y + current[2] + t, // y1\n            controlX + l, // x2\n            controlY + t, // y2\n            tempX + l,\n            tempY + t\n          );\n          x = tempX;\n          y = tempY;\n          break;\n\n        case 'C': // bezierCurveTo, absolute\n          x = current[5];\n          y = current[6];\n          controlX = current[3];\n          controlY = current[4];\n          context.bezierCurveTo(\n            current[1] + l,\n            current[2] + t,\n            controlX + l,\n            controlY + t,\n            x + l,\n            y + t\n          );\n          break;\n\n        case 's': // shorthand cubic bezierCurveTo, relative\n          // transform to absolute x,y\n          tempX = x + current[3];\n          tempY = y + current[4];\n          // calculate reflection of previous control points\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n          context.bezierCurveTo(\n            controlX + l,\n            controlY + t,\n            x + current[1] + l,\n            y + current[2] + t,\n            tempX + l,\n            tempY + t\n          );\n\n          // set control point to 2nd one of this command\n          // the first control point is assumed to be the reflection of\n          // the second control point on the previous command relative\n          // to the current point.\n          controlX = x + current[1];\n          controlY = y + current[2];\n\n          x = tempX;\n          y = tempY;\n          break;\n\n        case 'S': // shorthand cubic bezierCurveTo, absolute\n          tempX = current[3];\n          tempY = current[4];\n          // calculate reflection of previous control points\n          controlX = 2*x - controlX;\n          controlY = 2*y - controlY;\n          context.bezierCurveTo(\n            controlX + l,\n            controlY + t,\n            current[1] + l,\n            current[2] + t,\n            tempX + l,\n            tempY + t\n          );\n          x = tempX;\n          y = tempY;\n          // set control point to 2nd one of this command\n          // the first control point is assumed to be the reflection of\n          // the second control point on the previous command relative\n          // to the current point.\n          controlX = current[1];\n          controlY = current[2];\n\n          break;\n\n        case 'q': // quadraticCurveTo, relative\n          // transform to absolute x,y\n          tempX = x + current[3];\n          tempY = y + current[4];\n\n          controlX = x + current[1];\n          controlY = y + current[2];\n\n          context.quadraticCurveTo(\n            controlX + l,\n            controlY + t,\n            tempX + l,\n            tempY + t\n          );\n          x = tempX;\n          y = tempY;\n          break;\n\n        case 'Q': // quadraticCurveTo, absolute\n          tempX = current[3];\n          tempY = current[4];\n\n          context.quadraticCurveTo(\n            current[1] + l,\n            current[2] + t,\n            tempX + l,\n            tempY + t\n          );\n          x = tempX;\n          y = tempY;\n          controlX = current[1];\n          controlY = current[2];\n          break;\n\n        case 't': // shorthand quadraticCurveTo, relative\n\n          // transform to absolute x,y\n          tempX = x + current[1];\n          tempY = y + current[2];\n\n          if (previous[0].match(/[QqTt]/) === null) {\n            // If there is no previous command or if the previous command was not a Q, q, T or t,\n            // assume the control point is coincident with the current point\n            controlX = x;\n            controlY = y;\n          }\n          else if (previous[0] === 't') {\n            // calculate reflection of previous control points for t\n            controlX = 2 * x - tempControlX;\n            controlY = 2 * y - tempControlY;\n          }\n          else if (previous[0] === 'q') {\n            // calculate reflection of previous control points for q\n            controlX = 2 * x - controlX;\n            controlY = 2 * y - controlY;\n          }\n\n          tempControlX = controlX;\n          tempControlY = controlY;\n\n          context.quadraticCurveTo(\n            controlX + l,\n            controlY + t,\n            tempX + l,\n            tempY + t\n          );\n          x = tempX;\n          y = tempY;\n          controlX = x + current[1];\n          controlY = y + current[2];\n          break;\n\n        case 'T':\n          tempX = current[1];\n          tempY = current[2];\n\n          // calculate reflection of previous control points\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n          context.quadraticCurveTo(\n            controlX + l,\n            controlY + t,\n            tempX + l,\n            tempY + t\n          );\n          x = tempX;\n          y = tempY;\n          break;\n\n        case 'a':\n          drawArc(context, x + l, y + t, [\n            current[1],\n            current[2],\n            current[3],\n            current[4],\n            current[5],\n            current[6] + x + l,\n            current[7] + y + t\n          ]);\n          x += current[6];\n          y += current[7];\n          break;\n\n        case 'A':\n          drawArc(context, x + l, y + t, [\n            current[1],\n            current[2],\n            current[3],\n            current[4],\n            current[5],\n            current[6] + l,\n            current[7] + t\n          ]);\n          x = current[6];\n          y = current[7];\n          break;\n\n        case 'z':\n        case 'Z':\n          context.closePath();\n          break;\n      }\n      previous = current;\n    }\n  }\n\n  function drawArc(context, x, y, coords) {\n    var seg = segments(\n      coords[5], // end x\n      coords[6], // end y\n      coords[0], // radius x\n      coords[1], // radius y\n      coords[3], // large flag\n      coords[4], // sweep flag\n      coords[2], // rotation\n      x, y\n    );\n    for (var i=0; i<seg.length; ++i) {\n      var bez = bezier(seg[i]);\n      context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);\n    }\n  }\n\n  var Tan30 = 0.5773502691896257;\n\n  var builtins = {\n    'circle': {\n      draw: function(context, size) {\n        var r = Math.sqrt(size) / 2;\n        context.moveTo(r, 0);\n        context.arc(0, 0, r, 0, Tau);\n      }\n    },\n    'cross': {\n      draw: function(context, size) {\n        var r = Math.sqrt(size) / 2,\n            s = r / 2.5;\n        context.moveTo(-r, -s);\n        context.lineTo(-r, s);\n        context.lineTo(-s, s);\n        context.lineTo(-s, r);\n        context.lineTo(s, r);\n        context.lineTo(s, s);\n        context.lineTo(r, s);\n        context.lineTo(r, -s);\n        context.lineTo(s, -s);\n        context.lineTo(s, -r);\n        context.lineTo(-s, -r);\n        context.lineTo(-s, -s);\n        context.closePath();\n      }\n    },\n    'diamond': {\n      draw: function(context, size) {\n        var r = Math.sqrt(size) / 2;\n        context.moveTo(-r, 0);\n        context.lineTo(0, -r);\n        context.lineTo(r, 0);\n        context.lineTo(0, r);\n        context.closePath();\n      }\n    },\n    'square': {\n      draw: function(context, size) {\n        var w = Math.sqrt(size),\n            x = -w / 2;\n        context.rect(x, x, w, w);\n      }\n    },\n    'arrow': {\n      draw: function(context, size) {\n        var r = Math.sqrt(size) / 2,\n            s = r / 7,\n            t = r / 2.5,\n            v = r / 8;\n        context.moveTo(-s, r);\n        context.lineTo(s, r);\n        context.lineTo(s, -v);\n        context.lineTo(t, -v);\n        context.lineTo(0, -r);\n        context.lineTo(-t, -v);\n        context.lineTo(-s, -v);\n        context.closePath();\n      }\n    },\n    'wedge': {\n      draw: function(context, size) {\n        var r = Math.sqrt(size) / 2,\n            h = HalfSqrt3 * r,\n            o = (h - r * Tan30),\n            b = r / 4;\n        context.moveTo(0, -h - o);\n        context.lineTo(-b, h - o);\n        context.lineTo(b, h - o);\n        context.closePath();\n      }\n    },\n    'triangle': {\n      draw: function(context, size) {\n        var r = Math.sqrt(size) / 2,\n            h = HalfSqrt3 * r,\n            o = (h - r * Tan30);\n        context.moveTo(0, -h - o);\n        context.lineTo(-r, h - o);\n        context.lineTo(r, h - o);\n        context.closePath();\n      }\n    },\n    'triangle-up': {\n      draw: function(context, size) {\n        var r = Math.sqrt(size) / 2,\n            h = HalfSqrt3 * r;\n        context.moveTo(0, -h);\n        context.lineTo(-r, h);\n        context.lineTo(r, h);\n        context.closePath();\n      }\n    },\n    'triangle-down': {\n      draw: function(context, size) {\n        var r = Math.sqrt(size) / 2,\n            h = HalfSqrt3 * r;\n        context.moveTo(0, h);\n        context.lineTo(-r, -h);\n        context.lineTo(r, -h);\n        context.closePath();\n      }\n    },\n    'triangle-right': {\n      draw: function(context, size) {\n        var r = Math.sqrt(size) / 2,\n            h = HalfSqrt3 * r;\n        context.moveTo(h, 0);\n        context.lineTo(-h, -r);\n        context.lineTo(-h, r);\n        context.closePath();\n      }\n    },\n    'triangle-left': {\n      draw: function(context, size) {\n        var r = Math.sqrt(size) / 2,\n            h = HalfSqrt3 * r;\n        context.moveTo(-h, 0);\n        context.lineTo(h, -r);\n        context.lineTo(h, r);\n        context.closePath();\n      }\n    },\n    'stroke': {\n      draw: function(context, size) {\n        var r = Math.sqrt(size) / 2;\n        context.moveTo(-r, 0);\n        context.lineTo(r, 0);\n      }\n    }\n  };\n\n  function symbols(_) {\n    return vegaUtil.hasOwnProperty(builtins, _) ? builtins[_] : customSymbol(_);\n  }\n\n  var custom = {};\n\n  function customSymbol(path) {\n    if (!vegaUtil.hasOwnProperty(custom, path)) {\n      var parsed = pathParse(path);\n      custom[path] = {\n        draw: function(context, size) {\n          pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);\n        }\n      };\n    }\n    return custom[path];\n  }\n\n  // See http://spencermortensen.com/articles/bezier-circle/\n  const C = 0.448084975506; // C = 1 - c\n\n  function rectangleX(d) {\n    return d.x;\n  }\n\n  function rectangleY(d) {\n    return d.y;\n  }\n\n  function rectangleWidth(d) {\n    return d.width;\n  }\n\n  function rectangleHeight(d) {\n    return d.height;\n  }\n\n  function number(_) {\n    return typeof _ === 'function' ? _ : () => +_;\n  }\n\n  function clamp(value, min, max) {\n    return Math.max(min, Math.min(value, max));\n  }\n\n  function vg_rect() {\n    var x = rectangleX,\n        y = rectangleY,\n        width = rectangleWidth,\n        height = rectangleHeight,\n        crTL = number(0),\n        crTR = crTL,\n        crBL = crTL,\n        crBR = crTL,\n        context = null;\n\n    function rectangle(_, x0, y0) {\n      var buffer,\n          x1 = x0 != null ? x0 : +x.call(this, _),\n          y1 = y0 != null ? y0 : +y.call(this, _),\n          w  = +width.call(this, _),\n          h  = +height.call(this, _),\n          s  = Math.min(w, h) / 2,\n          tl = clamp(+crTL.call(this, _), 0, s),\n          tr = clamp(+crTR.call(this, _), 0, s),\n          bl = clamp(+crBL.call(this, _), 0, s),\n          br = clamp(+crBR.call(this, _), 0, s);\n\n      if (!context) context = buffer = d3Path.path();\n\n      if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {\n        context.rect(x1, y1, w, h);\n      } else {\n        var x2 = x1 + w,\n            y2 = y1 + h;\n        context.moveTo(x1 + tl, y1);\n        context.lineTo(x2 - tr, y1);\n        context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);\n        context.lineTo(x2, y2 - br);\n        context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);\n        context.lineTo(x1 + bl, y2);\n        context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);\n        context.lineTo(x1, y1 + tl);\n        context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);\n        context.closePath();\n      }\n\n      if (buffer) {\n        context = null;\n        return buffer + '' || null;\n      }\n    }\n\n    rectangle.x = function(_) {\n      if (arguments.length) {\n        x = number(_);\n        return rectangle;\n      } else {\n        return x;\n      }\n    };\n\n    rectangle.y = function(_) {\n      if (arguments.length) {\n        y = number(_);\n        return rectangle;\n      } else {\n        return y;\n      }\n    };\n\n    rectangle.width = function(_) {\n      if (arguments.length) {\n        width = number(_);\n        return rectangle;\n      } else {\n        return width;\n      }\n    };\n\n    rectangle.height = function(_) {\n      if (arguments.length) {\n        height = number(_);\n        return rectangle;\n      } else {\n        return height;\n      }\n    };\n\n    rectangle.cornerRadius = function(tl, tr, br, bl) {\n      if (arguments.length) {\n        crTL = number(tl);\n        crTR = tr != null ? number(tr) : crTL;\n        crBR = br != null ? number(br) : crTL;\n        crBL = bl != null ? number(bl) : crTR;\n        return rectangle;\n      } else {\n        return crTL;\n      }\n    };\n\n    rectangle.context = function(_) {\n      if (arguments.length) {\n        context = _ == null ? null : _;\n        return rectangle;\n      } else {\n        return context;\n      }\n    };\n\n    return rectangle;\n  }\n\n  function vg_trail() {\n    var x,\n        y,\n        size,\n        defined,\n        context = null,\n        ready, x1, y1, r1;\n\n    function point(x2, y2, w2) {\n      var r2 = w2 / 2;\n\n      if (ready) {\n        var ux = y1 - y2,\n            uy = x2 - x1;\n\n        if (ux || uy) {\n          // get normal vector\n          var ud = Math.sqrt(ux * ux + uy * uy),\n              rx = (ux /= ud) * r1,\n              ry = (uy /= ud) * r1,\n              t = Math.atan2(uy, ux);\n\n          // draw segment\n          context.moveTo(x1 - rx, y1 - ry);\n          context.lineTo(x2 - ux * r2, y2 - uy * r2);\n          context.arc(x2, y2, r2, t - Math.PI, t);\n          context.lineTo(x1 + rx, y1 + ry);\n          context.arc(x1, y1, r1, t, t + Math.PI);\n        } else {\n          context.arc(x2, y2, r2, 0, Tau);\n        }\n        context.closePath();\n      } else {\n        ready = 1;\n      }\n      x1 = x2;\n      y1 = y2;\n      r1 = r2;\n    }\n\n    function trail(data) {\n      var i,\n          n = data.length,\n          d,\n          defined0 = false,\n          buffer;\n\n      if (context == null) context = buffer = d3Path.path();\n\n      for (i = 0; i <= n; ++i) {\n        if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n          if (defined0 = !defined0) ready = 0;\n        }\n        if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));\n      }\n\n      if (buffer) {\n        context = null;\n        return buffer + '' || null;\n      }\n    }\n\n    trail.x = function(_) {\n      if (arguments.length) {\n        x = _;\n        return trail;\n      } else {\n        return x;\n      }\n    };\n\n    trail.y = function(_) {\n      if (arguments.length) {\n        y = _;\n        return trail;\n      } else {\n        return y;\n      }\n    };\n\n    trail.size = function(_) {\n      if (arguments.length) {\n        size = _;\n        return trail;\n      } else {\n        return size;\n      }\n    };\n\n    trail.defined = function(_) {\n      if (arguments.length) {\n        defined = _;\n        return trail;\n      } else {\n        return defined;\n      }\n    };\n\n    trail.context = function(_) {\n      if (arguments.length) {\n        if (_ == null) {\n          context = null;\n        } else {\n          context = _;\n        }\n        return trail;\n      } else {\n        return context;\n      }\n    };\n\n    return trail;\n  }\n\n  function value(a, b) {\n    return a != null ? a : b;\n  }\n\n  const x =  item => item.x || 0,\n        y =  item => item.y || 0,\n        w =  item => item.width || 0,\n        h =  item => item.height || 0,\n        xw = item => (item.x || 0) + (item.width || 0),\n        yh = item => (item.y || 0) + (item.height || 0),\n        sa = item => item.startAngle || 0,\n        ea = item => item.endAngle || 0,\n        pa = item => item.padAngle || 0,\n        ir = item => item.innerRadius || 0,\n        or = item => item.outerRadius || 0,\n        cr = item => item.cornerRadius || 0,\n        tl = item => value(item.cornerRadiusTopLeft, item.cornerRadius) || 0,\n        tr = item => value(item.cornerRadiusTopRight, item.cornerRadius) || 0,\n        br = item => value(item.cornerRadiusBottomRight, item.cornerRadius) || 0,\n        bl = item => value(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,\n        sz = item => value(item.size, 64),\n        ts = item => item.size || 1,\n        def = item => !(item.defined === false),\n        type = item => symbols(item.shape || 'circle');\n\n  const arcShape    = d3Shape.arc().startAngle(sa).endAngle(ea).padAngle(pa)\n                        .innerRadius(ir).outerRadius(or).cornerRadius(cr),\n        areavShape  = d3Shape.area().x(x).y1(y).y0(yh).defined(def),\n        areahShape  = d3Shape.area().y(y).x1(x).x0(xw).defined(def),\n        lineShape   = d3Shape.line().x(x).y(y).defined(def),\n        rectShape   = vg_rect().x(x).y(y).width(w).height(h)\n                        .cornerRadius(tl, tr, br, bl),\n        symbolShape = d3Shape.symbol().type(type).size(sz),\n        trailShape  = vg_trail().x(x).y(y).defined(def).size(ts);\n\n  function hasCornerRadius(item) {\n    return item.cornerRadius\n      || item.cornerRadiusTopLeft\n      || item.cornerRadiusTopRight\n      || item.cornerRadiusBottomRight\n      || item.cornerRadiusBottomLeft;\n  }\n\n  function arc(context, item) {\n    return arcShape.context(context)(item);\n  }\n\n  function area(context, items) {\n    const item = items[0],\n          interp = item.interpolate || 'linear';\n    return (item.orient === 'horizontal' ? areahShape : areavShape)\n      .curve(curves(interp, item.orient, item.tension))\n      .context(context)(items);\n  }\n\n  function line(context, items) {\n    const item = items[0],\n          interp = item.interpolate || 'linear';\n    return lineShape.curve(curves(interp, item.orient, item.tension))\n      .context(context)(items);\n  }\n\n  function rectangle(context, item, x, y) {\n    return rectShape.context(context)(item, x, y);\n  }\n\n  function shape(context, item) {\n    return (item.mark.shape || item.shape)\n      .context(context)(item);\n  }\n\n  function symbol(context, item) {\n    return symbolShape.context(context)(item);\n  }\n\n  function trail(context, items) {\n    return trailShape.context(context)(items);\n  }\n\n  var clip_id = 1;\n\n  function resetSVGClipId() {\n    clip_id = 1;\n  }\n\n  function clip(renderer, item, size) {\n    var clip = item.clip,\n        defs = renderer._defs,\n        id = item.clip_id || (item.clip_id = 'clip' + clip_id++),\n        c = defs.clipping[id] || (defs.clipping[id] = {id: id});\n\n    if (vegaUtil.isFunction(clip)) {\n      c.path = clip(null);\n    } else if (hasCornerRadius(size)) {\n      c.path = rectangle(null, size, 0, 0);\n    } else {\n      c.width = size.width || 0;\n      c.height = size.height || 0;\n    }\n\n    return 'url(#' + id + ')';\n  }\n\n  function Bounds(b) {\n    this.clear();\n    if (b) this.union(b);\n  }\n\n  Bounds.prototype = {\n    clone() {\n      return new Bounds(this);\n    },\n\n    clear() {\n      this.x1 = +Number.MAX_VALUE;\n      this.y1 = +Number.MAX_VALUE;\n      this.x2 = -Number.MAX_VALUE;\n      this.y2 = -Number.MAX_VALUE;\n      return this;\n    },\n\n    empty() {\n      return (\n        this.x1 === +Number.MAX_VALUE &&\n        this.y1 === +Number.MAX_VALUE &&\n        this.x2 === -Number.MAX_VALUE &&\n        this.y2 === -Number.MAX_VALUE\n      );\n    },\n\n    equals(b) {\n      return (\n        this.x1 === b.x1 &&\n        this.y1 === b.y1 &&\n        this.x2 === b.x2 &&\n        this.y2 === b.y2\n      );\n    },\n\n    set(x1, y1, x2, y2) {\n      if (x2 < x1) {\n        this.x2 = x1;\n        this.x1 = x2;\n      } else {\n        this.x1 = x1;\n        this.x2 = x2;\n      }\n      if (y2 < y1) {\n        this.y2 = y1;\n        this.y1 = y2;\n      } else {\n        this.y1 = y1;\n        this.y2 = y2;\n      }\n      return this;\n    },\n\n    add(x, y) {\n      if (x < this.x1) this.x1 = x;\n      if (y < this.y1) this.y1 = y;\n      if (x > this.x2) this.x2 = x;\n      if (y > this.y2) this.y2 = y;\n      return this;\n    },\n\n    expand(d) {\n      this.x1 -= d;\n      this.y1 -= d;\n      this.x2 += d;\n      this.y2 += d;\n      return this;\n    },\n\n    round() {\n      this.x1 = Math.floor(this.x1);\n      this.y1 = Math.floor(this.y1);\n      this.x2 = Math.ceil(this.x2);\n      this.y2 = Math.ceil(this.y2);\n      return this;\n    },\n\n    scale(s) {\n      this.x1 *= s;\n      this.y1 *= s;\n      this.x2 *= s;\n      this.y2 *= s;\n      return this;\n    },\n\n    translate(dx, dy) {\n      this.x1 += dx;\n      this.x2 += dx;\n      this.y1 += dy;\n      this.y2 += dy;\n      return this;\n    },\n\n    rotate(angle, x, y) {\n      const p = this.rotatedPoints(angle, x, y);\n      return this.clear()\n        .add(p[0], p[1])\n        .add(p[2], p[3])\n        .add(p[4], p[5])\n        .add(p[6], p[7]);\n    },\n\n    rotatedPoints(angle, x, y) {\n      var {x1, y1, x2, y2} = this,\n          cos = Math.cos(angle),\n          sin = Math.sin(angle),\n          cx = x - x * cos + y * sin,\n          cy = y - x * sin - y * cos;\n\n      return [\n        cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy,\n        cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy,\n        cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy,\n        cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy\n      ];\n    },\n\n    union(b) {\n      if (b.x1 < this.x1) this.x1 = b.x1;\n      if (b.y1 < this.y1) this.y1 = b.y1;\n      if (b.x2 > this.x2) this.x2 = b.x2;\n      if (b.y2 > this.y2) this.y2 = b.y2;\n      return this;\n    },\n\n    intersect(b) {\n      if (b.x1 > this.x1) this.x1 = b.x1;\n      if (b.y1 > this.y1) this.y1 = b.y1;\n      if (b.x2 < this.x2) this.x2 = b.x2;\n      if (b.y2 < this.y2) this.y2 = b.y2;\n      return this;\n    },\n\n    encloses(b) {\n      return b && (\n        this.x1 <= b.x1 &&\n        this.x2 >= b.x2 &&\n        this.y1 <= b.y1 &&\n        this.y2 >= b.y2\n      );\n    },\n\n    alignsWith(b) {\n      return b && (\n        this.x1 == b.x1 ||\n        this.x2 == b.x2 ||\n        this.y1 == b.y1 ||\n        this.y2 == b.y2\n      );\n    },\n\n    intersects(b) {\n      return b && !(\n        this.x2 < b.x1 ||\n        this.x1 > b.x2 ||\n        this.y2 < b.y1 ||\n        this.y1 > b.y2\n      );\n    },\n\n    contains(x, y) {\n      return !(\n        x < this.x1 ||\n        x > this.x2 ||\n        y < this.y1 ||\n        y > this.y2\n      );\n    },\n\n    width() {\n      return this.x2 - this.x1;\n    },\n\n    height() {\n      return this.y2 - this.y1;\n    }\n  };\n\n  function Item(mark) {\n    this.mark = mark;\n    this.bounds = (this.bounds || new Bounds());\n  }\n\n  function GroupItem(mark) {\n    Item.call(this, mark);\n    this.items = (this.items || []);\n  }\n\n  vegaUtil.inherits(GroupItem, Item);\n\n  function ResourceLoader(customLoader) {\n    this._pending = 0;\n    this._loader = customLoader || vegaLoader.loader();\n  }\n\n  function increment(loader) {\n    loader._pending += 1;\n  }\n\n  function decrement(loader) {\n    loader._pending -= 1;\n  }\n\n  ResourceLoader.prototype = {\n    pending() {\n      return this._pending;\n    },\n\n    sanitizeURL(uri) {\n      var loader = this;\n      increment(loader);\n\n      return loader._loader.sanitize(uri, {context:'href'})\n        .then(opt => {\n          decrement(loader);\n          return opt;\n        })\n        .catch(() => {\n          decrement(loader);\n          return null;\n        });\n    },\n\n    loadImage(uri) {\n      const loader = this,\n            Image = vegaCanvas.image();\n      increment(loader);\n\n      return loader._loader\n        .sanitize(uri, {context: 'image'})\n        .then(opt => {\n          const url = opt.href;\n          if (!url || !Image) throw {url: url};\n\n          const img = new Image();\n\n          // set crossOrigin only if cors is defined; empty string sets anonymous mode\n          // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin\n          const cors = vegaUtil.hasOwnProperty(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';\n          if (cors != null) img.crossOrigin = cors;\n\n          // attempt to load image resource\n          img.onload = () => decrement(loader);\n          img.onerror = () => decrement(loader);\n          img.src = url;\n\n          return img;\n        })\n        .catch(e => {\n          decrement(loader);\n          return {complete: false, width: 0, height: 0, src: e && e.url || ''};\n        });\n    },\n\n    ready() {\n      var loader = this;\n      return new Promise(accept => {\n        function poll(value) {\n          if (!loader.pending()) accept(value);\n          else setTimeout(() => { poll(true); }, 10);\n        }\n        poll(false);\n      });\n    }\n  };\n\n  function boundStroke(bounds, item, miter) {\n    if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {\n      const sw = item.strokeWidth != null ? +item.strokeWidth : 1;\n      bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));\n    }\n    return bounds;\n  }\n\n  function miterAdjustment(item, strokeWidth) {\n    // TODO: more sophisticated adjustment? Or miter support in boundContext?\n    return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;\n  }\n\n  const circleThreshold = Tau - 1e-8;\n  let bounds, lx, ly, rot, ma, mb, mc, md;\n\n  const add = (x, y) => bounds.add(x, y);\n  const addL = (x, y) => add(lx = x, ly = y);\n  const addX = x => add(x, bounds.y1);\n  const addY = y => add(bounds.x1, y);\n\n  const px = (x, y) => ma * x + mc * y;\n  const py = (x, y) => mb * x + md * y;\n  const addp = (x, y) => add(px(x, y), py(x, y));\n  const addpL = (x, y) => addL(px(x, y), py(x, y));\n\n  function boundContext(_, deg) {\n    bounds = _;\n    if (deg) {\n      rot = deg * DegToRad;\n      ma = md = Math.cos(rot);\n      mb = Math.sin(rot);\n      mc = -mb;\n    } else {\n      ma = md = 1;\n      rot = mb = mc = 0;\n    }\n    return context;\n  }\n\n  const context = {\n    beginPath() {},\n    closePath() {},\n\n    moveTo: addpL,\n    lineTo: addpL,\n\n    rect(x, y, w, h) {\n      if (rot) {\n        addp(x + w, y);\n        addp(x + w, y + h);\n        addp(x, y + h);\n        addpL(x, y);\n      } else {\n        add(x + w, y + h);\n        addL(x, y);\n      }\n    },\n\n    quadraticCurveTo(x1, y1, x2, y2) {\n      const px1 = px(x1, y1),\n            py1 = py(x1, y1),\n            px2 = px(x2, y2),\n            py2 = py(x2, y2);\n      quadExtrema(lx, px1, px2, addX);\n      quadExtrema(ly, py1, py2, addY);\n      addL(px2, py2);\n    },\n\n    bezierCurveTo(x1, y1, x2, y2, x3, y3) {\n      const px1 = px(x1, y1),\n            py1 = py(x1, y1),\n            px2 = px(x2, y2),\n            py2 = py(x2, y2),\n            px3 = px(x3, y3),\n            py3 = py(x3, y3);\n      cubicExtrema(lx, px1, px2, px3, addX);\n      cubicExtrema(ly, py1, py2, py3, addY);\n      addL(px3, py3);\n    },\n\n    arc(cx, cy, r, sa, ea, ccw) {\n      sa += rot;\n      ea += rot;\n\n      // store last point on path\n      lx = r * Math.cos(ea) + cx;\n      ly = r * Math.sin(ea) + cy;\n\n      if (Math.abs(ea - sa) > circleThreshold) {\n        // treat as full circle\n        add(cx - r, cy - r);\n        add(cx + r, cy + r);\n      } else {\n        const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);\n        let s, i;\n\n        // sample end points\n        update(sa);\n        update(ea);\n\n        // sample interior points aligned with 90 degrees\n        if (ea !== sa) {\n          sa = sa % Tau; if (sa < 0) sa += Tau;\n          ea = ea % Tau; if (ea < 0) ea += Tau;\n\n          if (ea < sa) {\n            ccw = !ccw; // flip direction\n            s = sa; sa = ea; ea = s; // swap end-points\n          }\n\n          if (ccw) {\n            ea -= Tau;\n            s = sa - (sa % HalfPi);\n            for (i=0; i<4 && s>ea; ++i, s-=HalfPi) update(s);\n          } else {\n            s = sa - (sa % HalfPi) + HalfPi;\n            for (i=0; i<4 && s<ea; ++i, s=s+HalfPi) update(s);\n          }\n        }\n      }\n    }\n  };\n\n  function quadExtrema(x0, x1, x2, cb) {\n    const t = (x0 - x1) / (x0 + x2 - 2 * x1);\n    if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);\n  }\n\n  function cubicExtrema(x0, x1, x2, x3, cb) {\n    const a = x3 - x0 + 3 * x1 - 3 * x2,\n          b = x0 + x2 - 2 * x1,\n          c = x0 - x1;\n\n    let t0 = 0, t1 = 0, r;\n\n    // solve for parameter t\n    if (Math.abs(a) > Epsilon) {\n      // quadratic equation\n      r = b * b + c * a;\n      if (r >= 0) {\n        r = Math.sqrt(r);\n        t0 = (-b + r) / a;\n        t1 = (-b - r) / a;\n      }\n    } else {\n      // linear equation\n      t0 = 0.5 * c / b;\n    }\n\n    // calculate position\n    if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));\n    if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));\n  }\n\n  function cubic(t, x0, x1, x2, x3) {\n    const s = 1 - t, s2 = s * s, t2 = t * t;\n    return (s2 * s * x0) + (3 * s2 * t * x1) + (3 * s * t2 * x2) + (t2 * t * x3);\n  }\n\n  var context$1 = (context$1 = vegaCanvas.canvas(1,1))\n    ? context$1.getContext('2d')\n    : null;\n\n  const b = new Bounds();\n\n  function intersectPath(draw) {\n    return function(item, brush) {\n      // rely on (inaccurate) bounds intersection if no context\n      if (!context$1) return true;\n\n      // add path to offscreen graphics context\n      draw(context$1, item);\n\n      // get bounds intersection region\n      b.clear().union(item.bounds).intersect(brush).round();\n      const {x1, y1, x2, y2} = b;\n\n      // iterate over intersection region\n      // perform fine grained inclusion test\n      for (let y = y1; y <= y2; ++y) {\n        for (let x = x1; x <= x2; ++x) {\n          if (context$1.isPointInPath(x, y)) {\n            return true;\n          }\n        }\n      }\n\n      // false if no hits in intersection region\n      return false;\n    };\n  }\n\n  function intersectPoint(item, box) {\n    return box.contains(item.x || 0, item.y || 0);\n  }\n\n  function intersectRect(item, box) {\n    const x = item.x || 0,\n          y = item.y || 0,\n          w = item.width || 0,\n          h = item.height || 0;\n    return box.intersects(b.set(x, y, x + w, y + h));\n  }\n\n  function intersectRule(item, box) {\n    const x = item.x || 0,\n          y = item.y || 0,\n          x2 = item.x2 != null ? item.x2 : x,\n          y2 = item.y2 != null ? item.y2 : y;\n    return intersectBoxLine(box, x, y, x2, y2);\n  }\n\n  function intersectBoxLine(box, x, y, u, v) {\n    const {x1, y1, x2, y2} = box,\n          dx = u - x,\n          dy = v - y;\n\n    let t0 = 0, t1 = 1, p, q, r, e;\n\n    for (e=0; e<4; ++e) {\n      if (e === 0) { p = -dx; q = -(x1 - x); }\n      if (e === 1) { p =  dx; q =  (x2 - x); }\n      if (e === 2) { p = -dy; q = -(y1 - y); }\n      if (e === 3) { p =  dy; q =  (y2 - y); }\n\n      if (Math.abs(p) < 1e-10 && q < 0) return false;\n\n      r = q / p;\n\n      if (p < 0) {\n        if (r > t1) return false;\n        else if (r > t0) t0 = r;\n      } else if (p > 0) {\n        if (r < t0) return false;\n        else if (r < t1) t1 = r;\n      }\n    }\n\n    return true;\n  }\n\n  function blend(context, item) {\n    context.globalCompositeOperation = item.blend || 'source-over';\n  }\n\n  function value$1(value, dflt) {\n    return value == null ? dflt : value;\n  }\n\n  function addStops(gradient, stops) {\n    const n = stops.length;\n    for (let i=0; i<n; ++i) {\n      gradient.addColorStop(stops[i].offset, stops[i].color);\n    }\n    return gradient;\n  }\n\n  function gradient(context, spec, bounds) {\n    const w = bounds.width(),\n          h = bounds.height();\n    let gradient;\n\n\n    if (spec.gradient === 'radial') {\n      gradient = context.createRadialGradient(\n        bounds.x1 + value$1(spec.x1, 0.5) * w,\n        bounds.y1 + value$1(spec.y1, 0.5) * h,\n        Math.max(w, h) * value$1(spec.r1, 0),\n        bounds.x1 + value$1(spec.x2, 0.5) * w,\n        bounds.y1 + value$1(spec.y2, 0.5) * h,\n        Math.max(w, h) * value$1(spec.r2, 0.5)\n      );\n    } else { // linear gradient\n      const x1 = value$1(spec.x1, 0),\n            y1 = value$1(spec.y1, 0),\n            x2 = value$1(spec.x2, 1),\n            y2 = value$1(spec.y2, 0);\n\n      if (x1 === x2 || y1 === y2 || w === h) {\n        // axis aligned: use normal gradient\n        gradient = context.createLinearGradient(\n          bounds.x1 + x1 * w,\n          bounds.y1 + y1 * h,\n          bounds.x1 + x2 * w,\n          bounds.y1 + y2 * h\n        );\n      } else {\n        // not axis aligned: render gradient into a pattern (#2365)\n        // this allows us to use normalized bounding box coordinates\n        const image = vegaCanvas.canvas(Math.ceil(w), Math.ceil(h)),\n              ictx = image.getContext('2d');\n\n        ictx.scale(w, h);\n        ictx.fillStyle = addStops(\n          ictx.createLinearGradient(x1, y1, x2, y2),\n          spec.stops\n        );\n        ictx.fillRect(0, 0, w, h);\n\n        return context.createPattern(image, 'no-repeat');\n      }\n    }\n\n    return addStops(gradient, spec.stops);\n  }\n\n  function color(context, item, value) {\n    return isGradient(value)\n      ? gradient(context, value, item.bounds)\n      : value;\n  }\n\n  function fill(context, item, opacity) {\n    opacity *= (item.fillOpacity==null ? 1 : item.fillOpacity);\n    if (opacity > 0) {\n      context.globalAlpha = opacity;\n      context.fillStyle = color(context, item, item.fill);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  var Empty = [];\n\n  function stroke(context, item, opacity) {\n    var lw = (lw = item.strokeWidth) != null ? lw : 1;\n\n    if (lw <= 0) return false;\n\n    opacity *= (item.strokeOpacity==null ? 1 : item.strokeOpacity);\n    if (opacity > 0) {\n      context.globalAlpha = opacity;\n      context.strokeStyle = color(context, item, item.stroke);\n\n      context.lineWidth = lw;\n      context.lineCap = item.strokeCap || 'butt';\n      context.lineJoin = item.strokeJoin || 'miter';\n      context.miterLimit = item.strokeMiterLimit || 10;\n\n      if (context.setLineDash) {\n        context.setLineDash(item.strokeDash || Empty);\n        context.lineDashOffset = item.strokeDashOffset || 0;\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function compare(a, b) {\n    return a.zindex - b.zindex || a.index - b.index;\n  }\n\n  function zorder(scene) {\n    if (!scene.zdirty) return scene.zitems;\n\n    var items = scene.items,\n        output = [], item, i, n;\n\n    for (i=0, n=items.length; i<n; ++i) {\n      item = items[i];\n      item.index = i;\n      if (item.zindex) output.push(item);\n    }\n\n    scene.zdirty = false;\n    return scene.zitems = output.sort(compare);\n  }\n\n  function visit(scene, visitor) {\n    var items = scene.items, i, n;\n    if (!items || !items.length) return;\n\n    var zitems = zorder(scene);\n\n    if (zitems && zitems.length) {\n      for (i=0, n=items.length; i<n; ++i) {\n        if (!items[i].zindex) visitor(items[i]);\n      }\n      items = zitems;\n    }\n\n    for (i=0, n=items.length; i<n; ++i) {\n      visitor(items[i]);\n    }\n  }\n\n  function pickVisit(scene, visitor) {\n    var items = scene.items, hit, i;\n    if (!items || !items.length) return null;\n\n    var zitems = zorder(scene);\n    if (zitems && zitems.length) items = zitems;\n\n    for (i=items.length; --i >= 0;) {\n      if (hit = visitor(items[i])) return hit;\n    }\n\n    if (items === zitems) {\n      for (items=scene.items, i=items.length; --i >= 0;) {\n        if (!items[i].zindex) {\n          if (hit = visitor(items[i])) return hit;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  function drawAll(path) {\n    return function(context, scene, bounds) {\n      visit(scene, item => {\n        if (!bounds || bounds.intersects(item.bounds)) {\n          drawPath(path, context, item, item);\n        }\n      });\n    };\n  }\n\n  function drawOne(path) {\n    return function(context, scene, bounds) {\n      if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {\n        drawPath(path, context, scene.items[0], scene.items);\n      }\n    };\n  }\n\n  function drawPath(path, context, item, items) {\n    var opacity = item.opacity == null ? 1 : item.opacity;\n    if (opacity === 0) return;\n\n    if (path(context, items)) return;\n\n    blend(context, item);\n\n    if (item.fill && fill(context, item, opacity)) {\n      context.fill();\n    }\n\n    if (item.stroke && stroke(context, item, opacity)) {\n      context.stroke();\n    }\n  }\n\n  function pick(test) {\n    test = test || vegaUtil.truthy;\n\n    return function(context, scene, x, y, gx, gy) {\n      x *= context.pixelRatio;\n      y *= context.pixelRatio;\n\n      return pickVisit(scene, item => {\n        var b = item.bounds;\n        // first hit test against bounding box\n        if ((b && !b.contains(gx, gy)) || !b) return;\n        // if in bounding box, perform more careful test\n        if (test(context, item, x, y, gx, gy)) return item;\n      });\n    };\n  }\n\n  function hitPath(path, filled) {\n    return function(context, o, x, y) {\n      var item = Array.isArray(o) ? o[0] : o,\n          fill = (filled == null) ? item.fill : filled,\n          stroke = item.stroke && context.isPointInStroke, lw, lc;\n\n      if (stroke) {\n        lw = item.strokeWidth;\n        lc = item.strokeCap;\n        context.lineWidth = lw != null ? lw : 1;\n        context.lineCap   = lc != null ? lc : 'butt';\n      }\n\n      return path(context, o) ? false :\n        (fill && context.isPointInPath(x, y)) ||\n        (stroke && context.isPointInStroke(x, y));\n    };\n  }\n\n  function pickPath(path) {\n    return pick(hitPath(path));\n  }\n\n  function translate(x, y) {\n    return 'translate(' + x + ',' + y + ')';\n  }\n\n  function rotate(a) {\n    return 'rotate(' + a + ')';\n  }\n\n  function scale$1(scaleX, scaleY){\n    return 'scale('+ scaleX + ',' + scaleY+')';\n  }\n\n  function translateItem(item) {\n    return translate(item.x || 0, item.y || 0);\n  }\n\n  function rotateItem(item) {\n    return translate(item.x || 0, item.y || 0)\n      + (item.angle ? ' ' + rotate(item.angle) : '');\n  }\n\n  function transformItem(item) {\n    return translate(item.x || 0, item.y || 0)\n      + (item.angle ? ' ' + rotate(item.angle) : '')\n      + (item.scaleX || item.scaleY ? ' ' + scale$1(item.scaleX || 1, item.scaleY || 1) : '');\n  }\n\n  function markItemPath(type, shape, isect) {\n\n    function attr(emit, item) {\n      emit('transform', rotateItem(item));\n      emit('d', shape(null, item));\n    }\n\n    function bound(bounds, item) {\n      shape(boundContext(bounds, item.angle), item);\n      return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);\n    }\n\n    function draw(context, item) {\n      var x = item.x || 0,\n          y = item.y || 0,\n          a = item.angle || 0;\n\n      context.translate(x, y);\n      if (a) context.rotate(a *= DegToRad);\n      context.beginPath();\n      shape(context, item);\n      if (a) context.rotate(-a);\n      context.translate(-x, -y);\n    }\n\n    return {\n      type:   type,\n      tag:    'path',\n      nested: false,\n      attr:   attr,\n      bound:  bound,\n      draw:   drawAll(draw),\n      pick:   pickPath(draw),\n      isect:  isect || intersectPath(draw)\n    };\n\n  }\n\n  var arc$1 = markItemPath('arc', arc);\n\n  function pickArea(a, p) {\n    var v = a[0].orient === 'horizontal' ? p[1] : p[0],\n        z = a[0].orient === 'horizontal' ? 'y' : 'x',\n        i = a.length,\n        min = +Infinity, hit, d;\n\n    while (--i >= 0) {\n      if (a[i].defined === false) continue;\n      d = Math.abs(a[i][z] - v);\n      if (d < min) {\n        min = d;\n        hit = a[i];\n      }\n    }\n\n    return hit;\n  }\n\n  function pickLine(a, p) {\n    var t = Math.pow(a[0].strokeWidth || 1, 2),\n        i = a.length, dx, dy, dd;\n\n    while (--i >= 0) {\n      if (a[i].defined === false) continue;\n      dx = a[i].x - p[0];\n      dy = a[i].y - p[1];\n      dd = dx * dx + dy * dy;\n      if (dd < t) return a[i];\n    }\n\n    return null;\n  }\n\n  function pickTrail(a, p) {\n    var i = a.length, dx, dy, dd;\n\n    while (--i >= 0) {\n      if (a[i].defined === false) continue;\n      dx = a[i].x - p[0];\n      dy = a[i].y - p[1];\n      dd = dx * dx + dy * dy;\n      dx = a[i].size || 1;\n      if (dd < dx*dx) return a[i];\n    }\n\n    return null;\n  }\n\n  function markMultiItemPath(type, shape, tip) {\n\n    function attr(emit, item) {\n      var items = item.mark.items;\n      if (items.length) emit('d', shape(null, items));\n    }\n\n    function bound(bounds, mark) {\n      var items = mark.items;\n      if (items.length === 0) {\n        return bounds;\n      } else {\n        shape(boundContext(bounds), items);\n        return boundStroke(bounds, items[0]);\n      }\n    }\n\n    function draw(context, items) {\n      context.beginPath();\n      shape(context, items);\n    }\n\n    var hit = hitPath(draw);\n\n    function pick(context, scene, x, y, gx, gy) {\n      var items = scene.items,\n          b = scene.bounds;\n\n      if (!items || !items.length || b && !b.contains(gx, gy)) {\n        return null;\n      }\n\n      x *= context.pixelRatio;\n      y *= context.pixelRatio;\n      return hit(context, items, x, y) ? items[0] : null;\n    }\n\n    return {\n      type:   type,\n      tag:    'path',\n      nested: true,\n      attr:   attr,\n      bound:  bound,\n      draw:   drawOne(draw),\n      pick:   pick,\n      isect:  intersectPoint,\n      tip:    tip\n    };\n\n  }\n\n  var area$1 = markMultiItemPath('area', area, pickArea);\n\n  function clip$1(context, scene) {\n    var clip = scene.clip;\n\n    context.save();\n\n    if (vegaUtil.isFunction(clip)) {\n      context.beginPath();\n      clip(context);\n      context.clip();\n    } else {\n      clipGroup(context, scene.group);\n    }\n  }\n\n  function clipGroup(context, group) {\n    context.beginPath();\n    hasCornerRadius(group)\n      ? rectangle(context, group, 0, 0)\n      : context.rect(0, 0, group.width || 0, group.height || 0);\n    context.clip();\n  }\n\n  function offset(item) {\n    const sw = value$1(item.strokeWidth, 1);\n    return item.strokeOffset != null ? item.strokeOffset\n      : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1)\n      : 0;\n  }\n\n  function attr(emit, item) {\n    emit('transform', translateItem(item));\n  }\n\n  function emitRectangle(emit, item) {\n    const off = offset(item);\n    emit('d', rectangle(null, item, off, off));\n  }\n\n  function background(emit, item) {\n    emit('class', 'background');\n    emit('aria-hidden', true);\n    emitRectangle(emit, item);\n  }\n\n  function foreground(emit, item) {\n    emit('class', 'foreground');\n    emit('aria-hidden', true);\n    if (item.strokeForeground) {\n      emitRectangle(emit, item);\n    } else {\n      emit('d', '');\n    }\n  }\n\n  function content(emit, item, renderer) {\n    const url = item.clip ? clip(renderer, item, item) : null;\n    emit('clip-path', url);\n  }\n\n  function bound(bounds, group) {\n    if (!group.clip && group.items) {\n      const items = group.items, m = items.length;\n      for (let j=0; j<m; ++j) {\n        bounds.union(items[j].bounds);\n      }\n    }\n\n    if ((group.clip || group.width || group.height) && !group.noBound) {\n      bounds.add(0, 0).add(group.width || 0, group.height || 0);\n    }\n\n    boundStroke(bounds, group);\n\n    return bounds.translate(group.x || 0, group.y || 0);\n  }\n\n  function rectanglePath(context, group, x, y) {\n    const off = offset(group);\n    context.beginPath();\n    rectangle(context, group, (x || 0) + off, (y || 0) + off);\n  }\n\n  const hitBackground = hitPath(rectanglePath);\n  const hitForeground = hitPath(rectanglePath, false);\n  const hitCorner = hitPath(rectanglePath, true);\n\n  function draw(context, scene, bounds) {\n    visit(scene, group => {\n      const gx = group.x || 0,\n            gy = group.y || 0,\n            fore = group.strokeForeground,\n            opacity = group.opacity == null ? 1 : group.opacity;\n\n      // draw group background\n      if ((group.stroke || group.fill) && opacity) {\n        rectanglePath(context, group, gx, gy);\n        blend(context, group);\n        if (group.fill && fill(context, group, opacity)) {\n          context.fill();\n        }\n        if (group.stroke && !fore && stroke(context, group, opacity)) {\n          context.stroke();\n        }\n      }\n\n      // setup graphics context, set clip and bounds\n      context.save();\n      context.translate(gx, gy);\n      if (group.clip) clipGroup(context, group);\n      if (bounds) bounds.translate(-gx, -gy);\n\n      // draw group contents\n      visit(group, item => {\n        this.draw(context, item, bounds);\n      });\n\n      // restore graphics context\n      if (bounds) bounds.translate(gx, gy);\n      context.restore();\n\n      // draw group foreground\n      if (fore && group.stroke && opacity) {\n        rectanglePath(context, group, gx, gy);\n        blend(context, group);\n        if (stroke(context, group, opacity)) {\n          context.stroke();\n        }\n      }\n    });\n  }\n\n  function pick$1(context, scene, x, y, gx, gy) {\n    if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {\n      return null;\n    }\n\n    const cx = x * context.pixelRatio,\n          cy = y * context.pixelRatio;\n\n    return pickVisit(scene, group => {\n      let hit, dx, dy;\n\n      // first hit test bounding box\n      const b = group.bounds;\n      if (b && !b.contains(gx, gy)) return;\n\n      // passed bounds check, test rectangular clip\n      dx = group.x || 0;\n      dy = group.y || 0;\n      const dw = dx + (group.width || 0),\n            dh = dy + (group.height || 0),\n            c = group.clip;\n      if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return;\n\n      // adjust coordinate system\n      context.save();\n      context.translate(dx, dy);\n      dx = gx - dx;\n      dy = gy - dy;\n\n      // test background for rounded corner clip\n      if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {\n        context.restore();\n        return null;\n      }\n\n      const fore = group.strokeForeground,\n            ix = scene.interactive !== false;\n\n      // hit test against group foreground\n      if (ix && fore && group.stroke\n          && hitForeground(context, group, cx, cy)) {\n        context.restore();\n        return group;\n      }\n\n      // hit test against contained marks\n      hit = pickVisit(group, mark => pickMark(mark, dx, dy)\n        ? this.pick(mark, x, y, dx, dy)\n        : null\n      );\n\n      // hit test against group background\n      if (!hit && ix && (group.fill || (!fore && group.stroke))\n          && hitBackground(context, group, cx, cy)) {\n        hit = group;\n      }\n\n      // restore state and return\n      context.restore();\n      return hit || null;\n    });\n  }\n\n  function pickMark(mark, x, y) {\n    return (mark.interactive !== false || mark.marktype === 'group')\n      && mark.bounds && mark.bounds.contains(x, y);\n  }\n\n  var group = {\n    type:       'group',\n    tag:        'g',\n    nested:     false,\n    attr:       attr,\n    bound:      bound,\n    draw:       draw,\n    pick:       pick$1,\n    isect:      intersectRect,\n    content:    content,\n    background: background,\n    foreground: foreground\n  };\n\n  var metadata = {\n    'xmlns': 'http://www.w3.org/2000/svg',\n    'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n    'version': '1.1'\n  };\n\n  function getImage(item, renderer) {\n    var image = item.image;\n    if (!image || item.url && item.url !== image.url) {\n      image = {complete: false, width: 0, height: 0};\n      renderer.loadImage(item.url).then(image => {\n        item.image = image;\n        item.image.url = item.url;\n      });\n    }\n    return image;\n  }\n\n  function imageWidth(item, image) {\n    return item.width != null ? item.width\n      : !image || !image.width ? 0\n      : item.aspect !== false && item.height ? item.height * image.width / image.height\n      : image.width;\n  }\n\n  function imageHeight(item, image) {\n    return item.height != null ? item.height\n      : !image || !image.height ? 0\n      : item.aspect !== false && item.width ? item.width * image.height / image.width\n      : image.height;\n  }\n\n  function imageXOffset(align, w) {\n    return align === 'center' ? w / 2 : align === 'right' ? w : 0;\n  }\n\n  function imageYOffset(baseline, h) {\n    return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;\n  }\n\n  function attr$1(emit, item, renderer) {\n    const img = getImage(item, renderer),\n          w = imageWidth(item, img),\n          h = imageHeight(item, img),\n          x = (item.x || 0) - imageXOffset(item.align, w),\n          y = (item.y || 0) - imageYOffset(item.baseline, h),\n          i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';\n\n    emit('href', i, metadata['xmlns:xlink'], 'xlink:href');\n    emit('transform', translate(x, y));\n    emit('width', w);\n    emit('height', h);\n    emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');\n  }\n\n  function bound$1(bounds, item) {\n    const img = item.image,\n          w = imageWidth(item, img),\n          h = imageHeight(item, img),\n          x = (item.x || 0) - imageXOffset(item.align, w),\n          y = (item.y || 0) - imageYOffset(item.baseline, h);\n\n    return bounds.set(x, y, x + w, y + h);\n  }\n\n  function draw$1(context, scene, bounds) {\n    visit(scene, item => {\n      if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n      const img = getImage(item, this);\n      let w = imageWidth(item, img),\n          h = imageHeight(item, img),\n          x = (item.x || 0) - imageXOffset(item.align, w),\n          y = (item.y || 0) - imageYOffset(item.baseline, h),\n          opacity, ar0, ar1, t;\n\n      if (item.aspect !== false) {\n        ar0 = img.width / img.height;\n        ar1 = item.width / item.height;\n        if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {\n          if (ar1 < ar0) {\n            t = w / ar0;\n            y += (h - t) / 2;\n            h = t;\n          } else {\n            t = h * ar0;\n            x += (w - t) / 2;\n            w = t;\n          }\n        }\n      }\n\n      if (img.complete || img.toDataURL) {\n        blend(context, item);\n        context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;\n        context.imageSmoothingEnabled = item.smooth !== false;\n        context.drawImage(img, x, y, w, h);\n      }\n    });\n  }\n\n  var image = {\n    type:     'image',\n    tag:      'image',\n    nested:   false,\n    attr:     attr$1,\n    bound:    bound$1,\n    draw:     draw$1,\n    pick:     pick(),\n    isect:    vegaUtil.truthy, // bounds check is sufficient\n    get:      getImage,\n    xOffset:  imageXOffset,\n    yOffset:  imageYOffset\n  };\n\n  var line$1 = markMultiItemPath('line', line, pickLine);\n\n  function attr$2(emit, item) {\n    var sx = item.scaleX || 1,\n        sy = item.scaleY || 1;\n    if (sx !== 1 || sy !== 1) {\n      emit('vector-effect', 'non-scaling-stroke');\n    }\n    emit('transform', transformItem(item));\n    emit('d', item.path);\n  }\n\n  function path(context, item) {\n    var path = item.path;\n    if (path == null) return true;\n\n    var x = item.x || 0,\n        y = item.y || 0,\n        sx = item.scaleX || 1,\n        sy = item.scaleY || 1,\n        a = (item.angle || 0) * DegToRad,\n        cache = item.pathCache;\n\n    if (!cache || cache.path !== path) {\n      (item.pathCache = cache = pathParse(path)).path = path;\n    }\n\n    if (a && context.rotate && context.translate) {\n      context.translate(x, y);\n      context.rotate(a);\n      pathRender(context, cache, 0, 0, sx, sy);\n      context.rotate(-a);\n      context.translate(-x, -y);\n    } else {\n      pathRender(context, cache, x, y, sx, sy);\n    }\n  }\n\n  function bound$2(bounds, item) {\n    return path(boundContext(bounds, item.angle), item)\n      ? bounds.set(0, 0, 0, 0)\n      : boundStroke(bounds, item, true);\n  }\n\n  var path$1 = {\n    type:   'path',\n    tag:    'path',\n    nested: false,\n    attr:   attr$2,\n    bound:  bound$2,\n    draw:   drawAll(path),\n    pick:   pickPath(path),\n    isect:  intersectPath(path)\n  };\n\n  function attr$3(emit, item) {\n    emit('d', rectangle(null, item));\n  }\n\n  function bound$3(bounds, item) {\n    var x, y;\n    return boundStroke(bounds.set(\n      x = item.x || 0,\n      y = item.y || 0,\n      (x + item.width) || 0,\n      (y + item.height) || 0\n    ), item);\n  }\n\n  function draw$2(context, item) {\n    context.beginPath();\n    rectangle(context, item);\n  }\n\n  var rect = {\n    type:   'rect',\n    tag:    'path',\n    nested: false,\n    attr:   attr$3,\n    bound:  bound$3,\n    draw:   drawAll(draw$2),\n    pick:   pickPath(draw$2),\n    isect:  intersectRect\n  };\n\n  function attr$4(emit, item) {\n    emit('transform', translateItem(item));\n    emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);\n    emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);\n  }\n\n  function bound$4(bounds, item) {\n    var x1, y1;\n    return boundStroke(bounds.set(\n      x1 = item.x || 0,\n      y1 = item.y || 0,\n      item.x2 != null ? item.x2 : x1,\n      item.y2 != null ? item.y2 : y1\n    ), item);\n  }\n\n  function path$2(context, item, opacity) {\n    var x1, y1, x2, y2;\n\n    if (item.stroke && stroke(context, item, opacity)) {\n      x1 = item.x || 0;\n      y1 = item.y || 0;\n      x2 = item.x2 != null ? item.x2 : x1;\n      y2 = item.y2 != null ? item.y2 : y1;\n      context.beginPath();\n      context.moveTo(x1, y1);\n      context.lineTo(x2, y2);\n      return true;\n    }\n    return false;\n  }\n\n  function draw$3(context, scene, bounds) {\n    visit(scene, item => {\n      if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n      var opacity = item.opacity == null ? 1 : item.opacity;\n      if (opacity && path$2(context, item, opacity)) {\n        blend(context, item);\n        context.stroke();\n      }\n    });\n  }\n\n  function hit(context, item, x, y) {\n    if (!context.isPointInStroke) return false;\n    return path$2(context, item, 1) && context.isPointInStroke(x, y);\n  }\n\n  var rule = {\n    type:   'rule',\n    tag:    'line',\n    nested: false,\n    attr:   attr$4,\n    bound:  bound$4,\n    draw:   draw$3,\n    pick:   pick(hit),\n    isect:  intersectRule\n  };\n\n  var shape$1 = markItemPath('shape', shape);\n\n  var symbol$1 = markItemPath('symbol', symbol, intersectPoint);\n\n  // memoize text width measurement\n  const widthCache = vegaUtil.lruCache();\n\n  var textMetrics = {\n    height: fontSize,\n    measureWidth: measureWidth,\n    estimateWidth: estimateWidth,\n    width: estimateWidth,\n    canvas: useCanvas\n  };\n\n  useCanvas(true);\n\n  function useCanvas(use) {\n    textMetrics.width = (use && context$1) ? measureWidth : estimateWidth;\n  }\n\n  // make dumb, simple estimate if no canvas is available\n  function estimateWidth(item, text) {\n    return _estimateWidth(textValue(item, text), fontSize(item));\n  }\n\n  function _estimateWidth(text, currentFontHeight) {\n    return ~~(0.8 * text.length * currentFontHeight);\n  }\n\n  // measure text width if canvas is available\n  function measureWidth(item, text) {\n    return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0\n      : _measureWidth(text, font(item));\n  }\n\n  function _measureWidth(text, currentFont) {\n    const key = `(${currentFont}) ${text}`;\n    let width = widthCache.get(key);\n    if (width === undefined) {\n      context$1.font = currentFont;\n      width = context$1.measureText(text).width;\n      widthCache.set(key, width);\n    }\n    return width;\n  }\n\n  function fontSize(item) {\n    return item.fontSize != null ? (+item.fontSize || 0) : 11;\n  }\n\n  function lineHeight(item) {\n    return item.lineHeight != null ? item.lineHeight : (fontSize(item) + 2);\n  }\n\n  function lineArray(_) {\n    return vegaUtil.isArray(_) ? _.length > 1 ? _ : _[0] : _;\n  }\n\n  function textLines(item) {\n    return lineArray(\n      item.lineBreak && item.text && !vegaUtil.isArray(item.text)\n        ? item.text.split(item.lineBreak)\n        : item.text\n    );\n  }\n\n  function multiLineOffset(item) {\n    const tl = textLines(item);\n    return (vegaUtil.isArray(tl) ? (tl.length - 1) : 0) * lineHeight(item);\n  }\n\n  function textValue(item, line) {\n    const text = line == null ? '' : (line + '').trim();\n    return item.limit > 0 && text.length ? truncate(item, text) : text;\n  }\n\n  function widthGetter(item) {\n    if (textMetrics.width === measureWidth) {\n      // we are using canvas\n      const currentFont = font(item);\n      return text => _measureWidth(text, currentFont);\n    } else {\n      // we are relying on estimates\n      const currentFontHeight = fontSize(item);\n      return text => _estimateWidth(text, currentFontHeight);\n    }\n  }\n\n  function truncate(item, text) {\n    var limit = +item.limit,\n        width = widthGetter(item);\n\n    if (width(text) < limit) return text;\n\n    var ellipsis = item.ellipsis || '\\u2026',\n        rtl = item.dir === 'rtl',\n        lo = 0,\n        hi = text.length, mid;\n\n    limit -= width(ellipsis);\n\n    if (rtl) {\n      while (lo < hi) {\n        mid = (lo + hi >>> 1);\n        if (width(text.slice(mid)) > limit) lo = mid + 1;\n        else hi = mid;\n      }\n      return ellipsis + text.slice(lo);\n    } else {\n      while (lo < hi) {\n        mid = 1 + (lo + hi >>> 1);\n        if (width(text.slice(0, mid)) < limit) lo = mid;\n        else hi = mid - 1;\n      }\n      return text.slice(0, lo) + ellipsis;\n    }\n  }\n\n  function fontFamily(item, quote) {\n    var font = item.font;\n    return (quote && font\n      ? String(font).replace(/\"/g, '\\'')\n      : font) || 'sans-serif';\n  }\n\n  function font(item, quote) {\n    return '' +\n      (item.fontStyle ? item.fontStyle + ' ' : '') +\n      (item.fontVariant ? item.fontVariant + ' ' : '') +\n      (item.fontWeight ? item.fontWeight + ' ' : '') +\n      fontSize(item) + 'px ' +\n      fontFamily(item, quote);\n  }\n\n  function offset$1(item) {\n    // perform our own font baseline calculation\n    // why? not all browsers support SVG 1.1 'alignment-baseline' :(\n    // this also ensures consistent layout across renderers\n    var baseline = item.baseline,\n        h = fontSize(item);\n\n    return Math.round(\n      baseline === 'top'         ?  0.79 * h :\n      baseline === 'middle'      ?  0.30 * h :\n      baseline === 'bottom'      ? -0.21 * h :\n      baseline === 'line-top'    ?  0.29 * h + 0.5 * lineHeight(item) :\n      baseline === 'line-bottom' ?  0.29 * h - 0.5 * lineHeight(item) : 0\n    );\n  }\n\n  var textAlign = {\n    'left':   'start',\n    'center': 'middle',\n    'right':  'end'\n  };\n\n  var tempBounds = new Bounds();\n\n  function anchorPoint(item) {\n    var x = item.x || 0,\n        y = item.y || 0,\n        r = item.radius || 0, t;\n\n    if (r) {\n      t = (item.theta || 0) - HalfPi;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    tempBounds.x1 = x;\n    tempBounds.y1 = y;\n    return tempBounds;\n  }\n\n  function attr$5(emit, item) {\n    var dx = item.dx || 0,\n        dy = (item.dy || 0) + offset$1(item),\n        p = anchorPoint(item),\n        x = p.x1,\n        y = p.y1,\n        a = item.angle || 0, t;\n\n    emit('text-anchor', textAlign[item.align] || 'start');\n\n    if (a) {\n      t = translate(x, y) + ' ' + rotate(a);\n      if (dx || dy) t += ' ' + translate(dx, dy);\n    } else {\n      t = translate(x + dx, y + dy);\n    }\n    emit('transform', t);\n  }\n\n  function bound$5(bounds, item, mode) {\n    var h = textMetrics.height(item),\n        a = item.align,\n        p = anchorPoint(item),\n        x = p.x1,\n        y = p.y1,\n        dx = item.dx || 0,\n        dy = (item.dy || 0) + offset$1(item) - Math.round(0.8*h), // use 4/5 offset\n        tl = textLines(item),\n        w;\n\n    // get dimensions\n    if (vegaUtil.isArray(tl)) {\n      // multi-line text\n      h += lineHeight(item) * (tl.length - 1);\n      w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);\n    } else {\n      // single-line text\n      w = textMetrics.width(item, tl);\n    }\n\n    // horizontal alignment\n    if (a === 'center') {\n      dx -= (w / 2);\n    } else if (a === 'right') {\n      dx -= w;\n    } else ;\n\n    bounds.set(dx+=x, dy+=y, dx+w, dy+h);\n\n    if (item.angle && !mode) {\n      bounds.rotate(item.angle * DegToRad, x, y);\n    } else if (mode === 2) {\n      return bounds.rotatedPoints(item.angle * DegToRad, x, y);\n    }\n    return bounds;\n  }\n\n  function draw$4(context, scene, bounds) {\n    visit(scene, item => {\n      var opacity = item.opacity == null ? 1 : item.opacity,\n          p, x, y, i, lh, tl, str;\n\n      if (bounds && !bounds.intersects(item.bounds) || // bounds check\n          opacity === 0 || item.fontSize <= 0 ||\n          item.text == null || item.text.length === 0) return;\n\n      context.font = font(item);\n      context.textAlign = item.align || 'left';\n\n      p = anchorPoint(item);\n      x = p.x1,\n      y = p.y1;\n\n      if (item.angle) {\n        context.save();\n        context.translate(x, y);\n        context.rotate(item.angle * DegToRad);\n        x = y = 0; // reset x, y\n      }\n      x += (item.dx || 0);\n      y += (item.dy || 0) + offset$1(item);\n\n      tl = textLines(item);\n      blend(context, item);\n      if (vegaUtil.isArray(tl)) {\n        lh = lineHeight(item);\n        for (i=0; i<tl.length; ++i) {\n          str = textValue(item, tl[i]);\n          if (item.fill && fill(context, item, opacity)) {\n            context.fillText(str, x, y);\n          }\n          if (item.stroke && stroke(context, item, opacity)) {\n            context.strokeText(str, x, y);\n          }\n          y += lh;\n        }\n      } else {\n        str = textValue(item, tl);\n        if (item.fill && fill(context, item, opacity)) {\n          context.fillText(str, x, y);\n        }\n        if (item.stroke && stroke(context, item, opacity)) {\n          context.strokeText(str, x, y);\n        }\n      }\n\n      if (item.angle) context.restore();\n    });\n  }\n\n  function hit$1(context, item, x, y, gx, gy) {\n    if (item.fontSize <= 0) return false;\n    if (!item.angle) return true; // bounds sufficient if no rotation\n\n    // project point into space of unrotated bounds\n    var p = anchorPoint(item),\n        ax = p.x1,\n        ay = p.y1,\n        b = bound$5(tempBounds, item, 1),\n        a = -item.angle * DegToRad,\n        cos = Math.cos(a),\n        sin = Math.sin(a),\n        px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),\n        py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);\n\n    return b.contains(px, py);\n  }\n\n  function intersectText(item, box) {\n    var p = bound$5(tempBounds, item, 2);\n    return intersectBoxLine(box, p[0], p[1], p[2], p[3])\n        || intersectBoxLine(box, p[0], p[1], p[4], p[5])\n        || intersectBoxLine(box, p[4], p[5], p[6], p[7])\n        || intersectBoxLine(box, p[2], p[3], p[6], p[7]);\n  }\n\n  var text = {\n    type:   'text',\n    tag:    'text',\n    nested: false,\n    attr:   attr$5,\n    bound:  bound$5,\n    draw:   draw$4,\n    pick:   pick(hit$1),\n    isect:  intersectText\n  };\n\n  var trail$1 = markMultiItemPath('trail', trail, pickTrail);\n\n  var Marks = {\n    arc:     arc$1,\n    area:    area$1,\n    group:   group,\n    image:   image,\n    line:    line$1,\n    path:    path$1,\n    rect:    rect,\n    rule:    rule,\n    shape:   shape$1,\n    symbol:  symbol$1,\n    text:    text,\n    trail:   trail$1\n  };\n\n  function boundItem(item, func, opt) {\n    var type = Marks[item.mark.marktype],\n        bound = func || type.bound;\n    if (type.nested) item = item.mark;\n\n    return bound(item.bounds || (item.bounds = new Bounds()), item, opt);\n  }\n\n  var DUMMY = {mark: null};\n\n  function boundMark(mark, bounds, opt) {\n    var type  = Marks[mark.marktype],\n        bound = type.bound,\n        items = mark.items,\n        hasItems = items && items.length,\n        i, n, item, b;\n\n    if (type.nested) {\n      if (hasItems) {\n        item = items[0];\n      } else {\n        // no items, fake it\n        DUMMY.mark = mark;\n        item = DUMMY;\n      }\n      b = boundItem(item, bound, opt);\n      bounds = bounds && bounds.union(b) || b;\n      return bounds;\n    }\n\n    bounds = bounds\n      || mark.bounds && mark.bounds.clear()\n      || new Bounds();\n\n    if (hasItems) {\n      for (i=0, n=items.length; i<n; ++i) {\n        bounds.union(boundItem(items[i], bound, opt));\n      }\n    }\n\n    return mark.bounds = bounds;\n  }\n\n  var keys = [\n    'marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex',\n    'x', 'y', 'width', 'height', 'align', 'baseline',             // layout\n    'fill', 'fillOpacity', 'opacity', 'blend',                    // fill\n    'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',        // stroke\n    'strokeDash', 'strokeDashOffset',                             // stroke dash\n    'strokeForeground', 'strokeOffset',                           // group\n    'startAngle', 'endAngle', 'innerRadius', 'outerRadius',       // arc\n    'cornerRadius', 'padAngle',                                   // arc, rect\n    'cornerRadiusTopLeft', 'cornerRadiusTopRight',                // rect, group\n    'cornerRadiusBottomLeft', 'cornerRadiusBottomRight',\n    'interpolate', 'tension', 'orient', 'defined',                // area, line\n    'url', 'aspect', 'smooth',                                    // image\n    'path', 'scaleX', 'scaleY',                                   // path\n    'x2', 'y2',                                                   // rule\n    'size', 'shape',                                              // symbol\n    'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy',        // text\n    'ellipsis', 'limit', 'lineBreak', 'lineHeight',\n    'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant', // font\n    'description', 'aria', 'ariaRole', 'ariaRoleDescription'      // aria\n  ];\n\n  function sceneToJSON(scene, indent) {\n    return JSON.stringify(scene, keys, indent);\n  }\n\n  function sceneFromJSON(json) {\n    var scene = (typeof json === 'string' ? JSON.parse(json) : json);\n    return initialize(scene);\n  }\n\n  function initialize(scene) {\n    var type = scene.marktype,\n        items = scene.items,\n        parent, i, n;\n\n    if (items) {\n      for (i=0, n=items.length; i<n; ++i) {\n        parent = type ? 'mark' : 'group';\n        items[i][parent] = scene;\n        if (items[i].zindex) items[i][parent].zdirty = true;\n        if ('group' === (type || parent)) initialize(items[i]);\n      }\n    }\n\n    if (type) boundMark(scene);\n    return scene;\n  }\n\n  function Scenegraph(scene) {\n    if (arguments.length) {\n      this.root = sceneFromJSON(scene);\n    } else {\n      this.root = createMark({\n        marktype: 'group',\n        name: 'root',\n        role: 'frame'\n      });\n      this.root.items = [new GroupItem(this.root)];\n    }\n  }\n\n  Scenegraph.prototype = {\n    toJSON(indent) {\n      return sceneToJSON(this.root, indent || 0);\n    },\n\n    mark(markdef, group, index) {\n      group = group || this.root.items[0];\n      var mark = createMark(markdef, group);\n      group.items[index] = mark;\n      if (mark.zindex) mark.group.zdirty = true;\n      return mark;\n    }\n  };\n\n  function createMark(def, group) {\n    const mark = {\n      bounds:      new Bounds(),\n      clip:        !!def.clip,\n      group:       group,\n      interactive: def.interactive === false ? false : true,\n      items:       [],\n      marktype:    def.marktype,\n      name:        def.name || undefined,\n      role:        def.role || undefined,\n      zindex:      def.zindex || 0\n    };\n\n    // add accessibility properties if defined\n    if (def.aria != null) {\n      mark.aria = def.aria;\n    }\n    if (def.description) {\n      mark.description = def.description;\n    }\n\n    return mark;\n  }\n\n  // create a new DOM element\n  function domCreate(doc, tag, ns) {\n    if (!doc && typeof document !== 'undefined' && document.createElement) {\n      doc = document;\n    }\n    return doc\n      ? (ns ? doc.createElementNS(ns, tag) : doc.createElement(tag))\n      : null;\n  }\n\n  // find first child element with matching tag\n  function domFind(el, tag) {\n    tag = tag.toLowerCase();\n    var nodes = el.childNodes, i = 0, n = nodes.length;\n    for (; i<n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {\n      return nodes[i];\n    }\n  }\n\n  // retrieve child element at given index\n  // create & insert if doesn't exist or if tags do not match\n  function domChild(el, index, tag, ns) {\n    var a = el.childNodes[index], b;\n    if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {\n      b = a || null;\n      a = domCreate(el.ownerDocument, tag, ns);\n      el.insertBefore(a, b);\n    }\n    return a;\n  }\n\n  // remove all child elements at or above the given index\n  function domClear(el, index) {\n    var nodes = el.childNodes,\n        curr = nodes.length;\n    while (curr > index) el.removeChild(nodes[--curr]);\n    return el;\n  }\n\n  // generate css class name for mark\n  function cssClass(mark) {\n    return 'mark-' + mark.marktype\n      + (mark.role ? ' role-' + mark.role : '')\n      + (mark.name ? ' ' + mark.name : '');\n  }\n\n  function point(event, el) {\n    var rect = el.getBoundingClientRect();\n    return [\n      event.clientX - rect.left - (el.clientLeft || 0),\n      event.clientY - rect.top - (el.clientTop || 0)\n    ];\n  }\n\n  function resolveItem(item, event, el, origin) {\n    var mark = item && item.mark,\n        mdef, p;\n\n    if (mark && (mdef = Marks[mark.marktype]).tip) {\n      p = point(event, el);\n      p[0] -= origin[0];\n      p[1] -= origin[1];\n      while (item = item.mark.group) {\n        p[0] -= item.x || 0;\n        p[1] -= item.y || 0;\n      }\n      item = mdef.tip(mark.items, p);\n    }\n\n    return item;\n  }\n\n  /**\n   * Create a new Handler instance.\n   * @param {object} [customLoader] - Optional loader instance for\n   *   href URL sanitization. If not specified, a standard loader\n   *   instance will be generated.\n   * @param {function} [customTooltip] - Optional tooltip handler\n   *   function for custom tooltip display.\n   * @constructor\n   */\n  function Handler(customLoader, customTooltip) {\n    this._active = null;\n    this._handlers = {};\n    this._loader = customLoader || vegaLoader.loader();\n    this._tooltip = customTooltip || defaultTooltip;\n  }\n\n  // The default tooltip display handler.\n  // Sets the HTML title attribute on the visualization container.\n  function defaultTooltip(handler, event, item, value) {\n    handler.element().setAttribute('title', value || '');\n  }\n\n  Handler.prototype = {\n    /**\n     * Initialize a new Handler instance.\n     * @param {DOMElement} el - The containing DOM element for the display.\n     * @param {Array<number>} origin - The origin of the display, in pixels.\n     *   The coordinate system will be translated to this point.\n     * @param {object} [obj] - Optional context object that should serve as\n     *   the \"this\" context for event callbacks.\n     * @return {Handler} - This handler instance.\n     */\n    initialize(el, origin, obj) {\n      this._el = el;\n      this._obj = obj || null;\n      return this.origin(origin);\n    },\n\n    /**\n     * Returns the parent container element for a visualization.\n     * @return {DOMElement} - The containing DOM element.\n     */\n    element() {\n      return this._el;\n    },\n\n    /**\n     * Returns the scene element (e.g., canvas or SVG) of the visualization\n     * Subclasses must override if the first child is not the scene element.\n     * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n     */\n    canvas() {\n      return this._el && this._el.firstChild;\n    },\n\n    /**\n     * Get / set the origin coordinates of the visualization.\n     */\n    origin(origin) {\n      if (arguments.length) {\n        this._origin = origin || [0, 0];\n        return this;\n      } else {\n        return this._origin.slice();\n      }\n    },\n\n    /**\n     * Get / set the scenegraph root.\n     */\n    scene(scene) {\n      if (!arguments.length) return this._scene;\n      this._scene = scene;\n      return this;\n    },\n\n    /**\n     * Add an event handler. Subclasses should override this method.\n     */\n    on(/*type, handler*/) {},\n\n    /**\n     * Remove an event handler. Subclasses should override this method.\n     */\n    off(/*type, handler*/) {},\n\n    /**\n     * Utility method for finding the array index of an event handler.\n     * @param {Array} h - An array of registered event handlers.\n     * @param {string} type - The event type.\n     * @param {function} handler - The event handler instance to find.\n     * @return {number} - The handler's array index or -1 if not registered.\n     */\n    _handlerIndex(h, type, handler) {\n      for (let i = h ? h.length : 0; --i>=0;) {\n        if (h[i].type === type && (!handler || h[i].handler === handler)) {\n          return i;\n        }\n      }\n      return -1;\n    },\n\n    /**\n     * Returns an array with registered event handlers.\n     * @param {string} [type] - The event type to query. Any annotations\n     *   are ignored; for example, for the argument \"click.foo\", \".foo\" will\n     *   be ignored and the method returns all \"click\" handlers. If type is\n     *   null or unspecified, this method returns handlers for all types.\n     * @return {Array} - A new array containing all registered event handlers.\n     */\n    handlers(type) {\n      const h = this._handlers, a = [];\n      if (type) {\n        a.push.apply(a, h[this.eventName(type)]);\n      } else {\n        for (const k in h) { a.push.apply(a, h[k]); }\n      }\n      return a;\n    },\n\n    /**\n     * Parses an event name string to return the specific event type.\n     * For example, given \"click.foo\" returns \"click\"\n     * @param {string} name - The input event type string.\n     * @return {string} - A string with the event type only.\n     */\n    eventName(name) {\n      const i = name.indexOf('.');\n      return i < 0 ? name : name.slice(0, i);\n    },\n\n    /**\n     * Handle hyperlink navigation in response to an item.href value.\n     * @param {Event} event - The event triggering hyperlink navigation.\n     * @param {Item} item - The scenegraph item.\n     * @param {string} href - The URL to navigate to.\n     */\n    handleHref(event, item, href) {\n      this._loader\n        .sanitize(href, {context:'href'})\n        .then(opt => {\n          const e = new MouseEvent(event.type, event),\n                a = domCreate(null, 'a');\n          for (const name in opt) a.setAttribute(name, opt[name]);\n          a.dispatchEvent(e);\n        })\n        .catch(() => { /* do nothing */ });\n    },\n\n    /**\n     * Handle tooltip display in response to an item.tooltip value.\n     * @param {Event} event - The event triggering tooltip display.\n     * @param {Item} item - The scenegraph item.\n     * @param {boolean} show - A boolean flag indicating whether\n     *   to show or hide a tooltip for the given item.\n     */\n    handleTooltip(event, item, show) {\n      if (item && item.tooltip != null) {\n        item = resolveItem(item, event, this.canvas(), this._origin);\n        const value = (show && item && item.tooltip) || null;\n        this._tooltip.call(this._obj, this, event, item, value);\n      }\n    },\n\n    /**\n     * Returns the size of a scenegraph item and its position relative\n     * to the viewport.\n     * @param {Item} item - The scenegraph item.\n     * @return {object} - A bounding box object (compatible with the\n     *   DOMRect type) consisting of x, y, width, heigh, top, left,\n     *   right, and bottom properties.\n     */\n    getItemBoundingClientRect(item) {\n      const el = this.canvas();\n      if (!el) return;\n\n      const rect = el.getBoundingClientRect(),\n            origin = this._origin,\n            bounds = item.bounds,\n            width = bounds.width(),\n            height = bounds.height();\n\n      let x = bounds.x1 + origin[0] + rect.left,\n          y = bounds.y1 + origin[1] + rect.top;\n\n      // translate coordinate for each parent group\n      while (item.mark && (item = item.mark.group)) {\n        x += item.x || 0;\n        y += item.y || 0;\n      }\n\n      // return DOMRect-compatible bounding box\n      return {\n        x, y, width, height,\n        left: x, top: y, right: x + width, bottom: y + height\n      };\n    }\n  };\n\n  /**\n   * Create a new Renderer instance.\n   * @param {object} [loader] - Optional loader instance for\n   *   image and href URL sanitization. If not specified, a\n   *   standard loader instance will be generated.\n   * @constructor\n   */\n  function Renderer(loader) {\n    this._el = null;\n    this._bgcolor = null;\n    this._loader = new ResourceLoader(loader);\n  }\n\n  Renderer.prototype = {\n    /**\n     * Initialize a new Renderer instance.\n     * @param {DOMElement} el - The containing DOM element for the display.\n     * @param {number} width - The coordinate width of the display, in pixels.\n     * @param {number} height - The coordinate height of the display, in pixels.\n     * @param {Array<number>} origin - The origin of the display, in pixels.\n     *   The coordinate system will be translated to this point.\n     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n     *   the width and height to determine the final pixel size.\n     * @return {Renderer} - This renderer instance.\n     */\n    initialize(el, width, height, origin, scaleFactor) {\n      this._el = el;\n      return this.resize(width, height, origin, scaleFactor);\n    },\n\n    /**\n     * Returns the parent container element for a visualization.\n     * @return {DOMElement} - The containing DOM element.\n     */\n    element() {\n      return this._el;\n    },\n\n    /**\n     * Returns the scene element (e.g., canvas or SVG) of the visualization\n     * Subclasses must override if the first child is not the scene element.\n     * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n     */\n    canvas() {\n      return this._el && this._el.firstChild;\n    },\n\n    /**\n     * Get / set the background color.\n     */\n    background(bgcolor) {\n      if (arguments.length === 0) return this._bgcolor;\n      this._bgcolor = bgcolor;\n      return this;\n    },\n\n    /**\n     * Resize the display.\n     * @param {number} width - The new coordinate width of the display, in pixels.\n     * @param {number} height - The new coordinate height of the display, in pixels.\n     * @param {Array<number>} origin - The new origin of the display, in pixels.\n     *   The coordinate system will be translated to this point.\n     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n     *   the width and height to determine the final pixel size.\n     * @return {Renderer} - This renderer instance;\n     */\n    resize(width, height, origin, scaleFactor) {\n      this._width = width;\n      this._height = height;\n      this._origin = origin || [0, 0];\n      this._scale = scaleFactor || 1;\n      return this;\n    },\n\n    /**\n     * Report a dirty item whose bounds should be redrawn.\n     * This base class method does nothing. Subclasses that perform\n     * incremental should implement this method.\n     * @param {Item} item - The dirty item whose bounds should be redrawn.\n     */\n    dirty(/*item*/) {},\n\n    /**\n     * Render an input scenegraph, potentially with a set of dirty items.\n     * This method will perform an immediate rendering with available resources.\n     * The renderer may also need to perform image loading to perform a complete\n     * render. This process can lead to asynchronous re-rendering of the scene\n     * after this method returns. To receive notification when rendering is\n     * complete, use the renderAsync method instead.\n     * @param {object} scene - The root mark of a scenegraph to render.\n     * @return {Renderer} - This renderer instance.\n     */\n    render(scene) {\n      var r = this;\n\n      // bind arguments into a render call, and cache it\n      // this function may be subsequently called for async redraw\n      r._call = function() { r._render(scene); };\n\n      // invoke the renderer\n      r._call();\n\n      // clear the cached call for garbage collection\n      // async redraws will stash their own copy\n      r._call = null;\n\n      return r;\n    },\n\n    /**\n     * Internal rendering method. Renderer subclasses should override this\n     * method to actually perform rendering.\n     * @param {object} scene - The root mark of a scenegraph to render.\n     */\n    _render(/*scene*/) {\n      // subclasses to override\n    },\n\n    /**\n     * Asynchronous rendering method. Similar to render, but returns a Promise\n     * that resolves when all rendering is completed. Sometimes a renderer must\n     * perform image loading to get a complete rendering. The returned\n     * Promise will not resolve until this process completes.\n     * @param {object} scene - The root mark of a scenegraph to render.\n     * @return {Promise} - A Promise that resolves when rendering is complete.\n     */\n    renderAsync(scene) {\n      var r = this.render(scene);\n      return this._ready\n        ? this._ready.then(() => r)\n        : Promise.resolve(r);\n    },\n\n    /**\n     * Internal method for asynchronous resource loading.\n     * Proxies method calls to the ImageLoader, and tracks loading\n     * progress to invoke a re-render once complete.\n     * @param {string} method - The method name to invoke on the ImageLoader.\n     * @param {string} uri - The URI for the requested resource.\n     * @return {Promise} - A Promise that resolves to the requested resource.\n     */\n    _load(method, uri) {\n      var r = this,\n          p = r._loader[method](uri);\n\n      if (!r._ready) {\n        // re-render the scene when loading completes\n        var call = r._call;\n        r._ready = r._loader.ready()\n          .then(redraw => {\n            if (redraw) call();\n            r._ready = null;\n          });\n      }\n\n      return p;\n    },\n\n    /**\n     * Sanitize a URL to include as a hyperlink in the rendered scene.\n     * This method proxies a call to ImageLoader.sanitizeURL, but also tracks\n     * image loading progress and invokes a re-render once complete.\n     * @param {string} uri - The URI string to sanitize.\n     * @return {Promise} - A Promise that resolves to the sanitized URL.\n     */\n    sanitizeURL(uri) {\n      return this._load('sanitizeURL', uri);\n    },\n\n    /**\n     * Requests an image to include in the rendered scene.\n     * This method proxies a call to ImageLoader.loadImage, but also tracks\n     * image loading progress and invokes a re-render once complete.\n     * @param {string} uri - The URI string of the image.\n     * @return {Promise} - A Promise that resolves to the loaded Image.\n     */\n    loadImage(uri) {\n      return this._load('loadImage', uri);\n    }\n  };\n\n  const KeyDownEvent = 'keydown';\n  const KeyPressEvent = 'keypress';\n  const KeyUpEvent = 'keyup';\n  const DragEnterEvent = 'dragenter';\n  const DragLeaveEvent = 'dragleave';\n  const DragOverEvent = 'dragover';\n  const MouseDownEvent = 'mousedown';\n  const MouseUpEvent = 'mouseup';\n  const MouseMoveEvent = 'mousemove';\n  const MouseOutEvent = 'mouseout';\n  const MouseOverEvent = 'mouseover';\n  const ClickEvent = 'click';\n  const DoubleClickEvent = 'dblclick';\n  const WheelEvent = 'wheel';\n  const MouseWheelEvent = 'mousewheel';\n  const TouchStartEvent = 'touchstart';\n  const TouchMoveEvent = 'touchmove';\n  const TouchEndEvent = 'touchend';\n\n  const Events = [\n    KeyDownEvent,\n    KeyPressEvent,\n    KeyUpEvent,\n    DragEnterEvent,\n    DragLeaveEvent,\n    DragOverEvent,\n    MouseDownEvent,\n    MouseUpEvent,\n    MouseMoveEvent,\n    MouseOutEvent,\n    MouseOverEvent,\n    ClickEvent,\n    DoubleClickEvent,\n    WheelEvent,\n    MouseWheelEvent,\n    TouchStartEvent,\n    TouchMoveEvent,\n    TouchEndEvent\n  ];\n\n  const TooltipShowEvent = MouseMoveEvent;\n\n  const TooltipHideEvent = MouseOutEvent;\n\n  const HrefEvent = ClickEvent;\n\n  function CanvasHandler(loader, tooltip) {\n    Handler.call(this, loader, tooltip);\n    this._down = null;\n    this._touch = null;\n    this._first = true;\n    this._events = {};\n  }\n\n  const eventBundle = type => (\n    type === TouchStartEvent ||\n    type === TouchMoveEvent ||\n    type === TouchEndEvent\n  )\n  ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent]\n  : [type];\n\n  // lazily add listeners to the canvas as needed\n  function eventListenerCheck(handler, type) {\n    eventBundle(type).forEach(_ => addEventListener(handler, _));\n  }\n\n  function addEventListener(handler, type) {\n    const canvas = handler.canvas();\n    if (canvas && !handler._events[type]) {\n      handler._events[type] = 1;\n      canvas.addEventListener(type, handler[type]\n        ? evt => handler[type](evt)\n        : evt => handler.fire(type, evt)\n      );\n    }\n  }\n\n  function move(moveEvent, overEvent, outEvent) {\n    return function(evt) {\n      const a = this._active,\n            p = this.pickEvent(evt);\n\n      if (p === a) {\n        // active item and picked item are the same\n        this.fire(moveEvent, evt); // fire move\n      } else {\n        // active item and picked item are different\n        if (!a || !a.exit) {\n          // fire out for prior active item\n          // suppress if active item was removed from scene\n          this.fire(outEvent, evt);\n        }\n        this._active = p;          // set new active item\n        this.fire(overEvent, evt); // fire over for new active item\n        this.fire(moveEvent, evt); // fire move for new active item\n      }\n    };\n  }\n\n  function inactive(type) {\n    return function(evt) {\n      this.fire(type, evt);\n      this._active = null;\n    };\n  }\n\n  vegaUtil.inherits(CanvasHandler, Handler, {\n    initialize(el, origin, obj) {\n      this._canvas = el && domFind(el, 'canvas');\n\n      // add minimal events required for proper state management\n      [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent]\n        .forEach(type => eventListenerCheck(this, type));\n\n      return Handler.prototype.initialize.call(this, el, origin, obj);\n    },\n\n    // return the backing canvas instance\n    canvas() {\n      return this._canvas;\n    },\n\n    // retrieve the current canvas context\n    context() {\n      return this._canvas.getContext('2d');\n    },\n\n    // supported events\n    events: Events,\n\n    // to keep old versions of firefox happy\n    DOMMouseScroll(evt) {\n      this.fire(MouseWheelEvent, evt);\n    },\n\n    mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),\n    dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),\n\n    mouseout: inactive(MouseOutEvent),\n    dragleave: inactive(DragLeaveEvent),\n\n    mousedown(evt) {\n      this._down = this._active;\n      this.fire(MouseDownEvent, evt);\n    },\n\n    click(evt) {\n      if (this._down === this._active) {\n        this.fire(ClickEvent, evt);\n        this._down = null;\n      }\n    },\n\n    touchstart(evt) {\n      this._touch = this.pickEvent(evt.changedTouches[0]);\n\n      if (this._first) {\n        this._active = this._touch;\n        this._first = false;\n      }\n\n      this.fire(TouchStartEvent, evt, true);\n    },\n\n    touchmove(evt) {\n      this.fire(TouchMoveEvent, evt, true);\n    },\n\n    touchend(evt) {\n      this.fire(TouchEndEvent, evt, true);\n      this._touch = null;\n    },\n\n    // fire an event\n    fire(type, evt, touch) {\n      const a = touch ? this._touch : this._active,\n            h = this._handlers[type];\n\n      // set event type relative to scenegraph items\n      evt.vegaType = type;\n\n      // handle hyperlinks and tooltips first\n      if (type === HrefEvent && a && a.href) {\n        this.handleHref(evt, a, a.href);\n      } else if (type === TooltipShowEvent || type === TooltipHideEvent) {\n        this.handleTooltip(evt, a, type !== TooltipHideEvent);\n      }\n\n      // invoke all registered handlers\n      if (h) {\n        for (let i=0, len=h.length; i<len; ++i) {\n          h[i].handler.call(this._obj, evt, a);\n        }\n      }\n    },\n\n    // add an event handler\n    on(type, handler) {\n      const name = this.eventName(type),\n            h = this._handlers,\n            i = this._handlerIndex(h[name], type, handler);\n\n      if (i < 0) {\n        eventListenerCheck(this, type);\n        (h[name] || (h[name] = [])).push({\n          type:    type,\n          handler: handler\n        });\n      }\n\n      return this;\n    },\n\n    // remove an event handler\n    off(type, handler) {\n      const name = this.eventName(type),\n            h = this._handlers[name],\n            i = this._handlerIndex(h, type, handler);\n\n      if (i >= 0) {\n        h.splice(i, 1);\n      }\n\n      return this;\n    },\n\n    pickEvent(evt) {\n      const p = point(evt, this._canvas),\n            o = this._origin;\n      return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);\n    },\n\n    // find the scenegraph item at the current mouse position\n    // x, y -- the absolute x, y mouse coordinates on the canvas element\n    // gx, gy -- the relative coordinates within the current group\n    pick(scene, x, y, gx, gy) {\n      const g = this.context(),\n            mark = Marks[scene.marktype];\n      return mark.pick.call(this, g, scene, x, y, gx, gy);\n    }\n  });\n\n  function devicePixelRatio() {\n    return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;\n  }\n\n  var pixelRatio = devicePixelRatio();\n\n  function resize(canvas, width, height, origin, scaleFactor, opt) {\n    const inDOM = typeof HTMLElement !== 'undefined'\n                && canvas instanceof HTMLElement\n                && canvas.parentNode != null,\n          context = canvas.getContext('2d'),\n          ratio = inDOM ? pixelRatio : scaleFactor;\n\n    canvas.width = width * ratio;\n    canvas.height = height * ratio;\n\n    for (const key in opt) {\n      context[key] = opt[key];\n    }\n\n    if (inDOM && ratio !== 1) {\n      canvas.style.width = width + 'px';\n      canvas.style.height = height + 'px';\n    }\n\n    context.pixelRatio = ratio;\n    context.setTransform(\n      ratio, 0, 0, ratio,\n      ratio * origin[0],\n      ratio * origin[1]\n    );\n\n    return canvas;\n  }\n\n  function CanvasRenderer(loader) {\n    Renderer.call(this, loader);\n    this._options = {};\n    this._redraw = false;\n    this._dirty = new Bounds();\n    this._tempb = new Bounds();\n  }\n\n  const base = Renderer.prototype;\n\n  const viewBounds = (origin, width, height) => new Bounds()\n    .set(0, 0, width, height)\n    .translate(-origin[0], -origin[1]);\n\n  function clipToBounds(g, b, origin) {\n    // expand bounds by 1 pixel, then round to pixel boundaries\n    b.expand(1).round();\n\n    // align to base pixel grid in case of non-integer scaling (#2425)\n    if (g.pixelRatio % 1) {\n      b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);\n    }\n\n    // to avoid artifacts translate if origin has fractional pixels\n    b.translate(-(origin[0] % 1), -(origin[1] % 1));\n\n    // set clip path\n    g.beginPath();\n    g.rect(b.x1, b.y1, b.width(), b.height());\n    g.clip();\n\n    return b;\n  }\n\n  vegaUtil.inherits(CanvasRenderer, Renderer, {\n    initialize(el, width, height, origin, scaleFactor, options) {\n      this._options = options || {};\n\n      this._canvas = this._options.externalContext\n        ? null\n        : vegaCanvas.canvas(1, 1, this._options.type); // instantiate a small canvas\n\n      if (el && this._canvas) {\n        domClear(el, 0).appendChild(this._canvas);\n        this._canvas.setAttribute('class', 'marks');\n      }\n\n      // this method will invoke resize to size the canvas appropriately\n      return base.initialize.call(this, el, width, height, origin, scaleFactor);\n    },\n\n    resize(width, height, origin, scaleFactor) {\n      base.resize.call(this, width, height, origin, scaleFactor);\n\n      if (this._canvas) {\n        // configure canvas size and transform\n        resize(this._canvas, this._width, this._height,\n          this._origin, this._scale, this._options.context);\n      } else {\n        // external context needs to be scaled and positioned to origin\n        const ctx = this._options.externalContext;\n        if (!ctx) vegaUtil.error('CanvasRenderer is missing a valid canvas or context');\n        ctx.scale(this._scale, this._scale);\n        ctx.translate(this._origin[0], this._origin[1]);\n      }\n\n      this._redraw = true;\n      return this;\n    },\n\n    canvas() {\n      return this._canvas;\n    },\n\n    context() {\n      return this._options.externalContext\n        || (this._canvas ? this._canvas.getContext('2d') : null);\n    },\n\n    dirty(item) {\n      const b = this._tempb.clear().union(item.bounds);\n      let g = item.mark.group;\n\n      while (g) {\n        b.translate(g.x || 0, g.y || 0);\n        g = g.mark.group;\n      }\n\n      this._dirty.union(b);\n    },\n\n    _render(scene) {\n      const g = this.context(),\n            o = this._origin,\n            w = this._width,\n            h = this._height,\n            db = this._dirty,\n            vb = viewBounds(o, w, h);\n\n      // setup\n      g.save();\n      const b = this._redraw || db.empty()\n        ? (this._redraw = false, vb.expand(1))\n        : clipToBounds(g, vb.intersect(db), o);\n\n      this.clear(-o[0], -o[1], w, h);\n\n      // render\n      this.draw(g, scene, b);\n\n      // takedown\n      g.restore();\n      db.clear();\n\n      return this;\n    },\n\n    draw(ctx, scene, bounds) {\n      const mark = Marks[scene.marktype];\n      if (scene.clip) clip$1(ctx, scene);\n      mark.draw.call(this, ctx, scene, bounds);\n      if (scene.clip) ctx.restore();\n    },\n\n    clear(x, y, w, h) {\n      const opt = this._options,\n            g = this.context();\n\n      if (opt.type !== 'pdf' && !opt.externalContext) {\n        // calling clear rect voids vector output in pdf mode\n        // and could remove external context content (#2615)\n        g.clearRect(x, y, w, h);\n      }\n\n      if (this._bgcolor != null) {\n        g.fillStyle = this._bgcolor;\n        g.fillRect(x, y, w, h);\n      }\n    }\n  });\n\n  function SVGHandler(loader, tooltip) {\n    Handler.call(this, loader, tooltip);\n    const h = this;\n    h._hrefHandler = listener(h, (evt, item) => {\n      if (item && item.href) h.handleHref(evt, item, item.href);\n    });\n    h._tooltipHandler = listener(h, (evt, item) => {\n      h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);\n    });\n  }\n\n  // wrap an event listener for the SVG DOM\n  const listener = (context, handler) => evt => {\n    let item = evt.target.__data__;\n    item = Array.isArray(item) ? item[0] : item;\n    evt.vegaType = evt.type;\n    handler.call(context._obj, evt, item);\n  };\n\n  vegaUtil.inherits(SVGHandler, Handler, {\n    initialize(el, origin, obj) {\n      let svg = this._svg;\n      if (svg) {\n        svg.removeEventListener(HrefEvent, this._hrefHandler);\n        svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);\n        svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);\n      }\n      this._svg = svg = el && domFind(el, 'svg');\n      if (svg) {\n        svg.addEventListener(HrefEvent, this._hrefHandler);\n        svg.addEventListener(TooltipShowEvent, this._tooltipHandler);\n        svg.addEventListener(TooltipHideEvent, this._tooltipHandler);\n      }\n      return Handler.prototype.initialize.call(this, el, origin, obj);\n    },\n\n    canvas() {\n      return this._svg;\n    },\n\n    // add an event handler\n    on(type, handler) {\n      const name = this.eventName(type),\n            h = this._handlers,\n            i = this._handlerIndex(h[name], type, handler);\n\n      if (i < 0) {\n        const x = {\n          type,\n          handler,\n          listener: listener(this, handler)\n        };\n\n        (h[name] || (h[name] = [])).push(x);\n        if (this._svg) {\n          this._svg.addEventListener(name, x.listener);\n        }\n      }\n\n      return this;\n    },\n\n    // remove an event handler\n    off(type, handler) {\n      const name = this.eventName(type),\n            h = this._handlers[name],\n            i = this._handlerIndex(h, type, handler);\n\n      if (i >= 0) {\n        if (this._svg) {\n          this._svg.removeEventListener(name, h[i].listener);\n        }\n        h.splice(i, 1);\n      }\n\n      return this;\n    }\n  });\n\n  const ARIA_HIDDEN = 'aria-hidden';\n  const ARIA_LABEL = 'aria-label';\n  const ARIA_ROLE = 'role';\n  const ARIA_ROLEDESCRIPTION = 'aria-roledescription';\n  const GRAPHICS_OBJECT = 'graphics-object';\n  const GRAPHICS_SYMBOL = 'graphics-symbol';\n\n  const bundle = (role, roledesc, label) => ({\n    [ARIA_ROLE]: role,\n    [ARIA_ROLEDESCRIPTION]: roledesc,\n    [ARIA_LABEL]: label || undefined\n  });\n\n  // these roles are covered by related roles\n  // we can ignore them, no need to generate attributes\n  const AriaIgnore = vegaUtil.toSet([\n    'axis-domain',\n    'axis-grid',\n    'axis-label',\n    'axis-tick',\n    'axis-title',\n    'legend-band',\n    'legend-entry',\n    'legend-gradient',\n    'legend-label',\n    'legend-title',\n    'legend-symbol',\n    'title'\n  ]);\n\n  // aria attribute generators for guide roles\n  const AriaGuides = {\n    'axis': {desc: 'axis', caption: axisCaption},\n    'legend': {desc: 'legend', caption: legendCaption},\n    'title-text': {\n      desc: 'title',\n      caption: item => `Title text '${titleCaption(item)}'`\n    },\n    'title-subtitle': {\n      desc: 'subtitle',\n      caption: item => `Subtitle text '${titleCaption(item)}'`\n    }\n  };\n\n  // aria properties generated for mark item encoding channels\n  const AriaEncode = {\n    ariaRole: ARIA_ROLE,\n    ariaRoleDescription: ARIA_ROLEDESCRIPTION,\n    description: ARIA_LABEL\n  };\n\n  function ariaItemAttributes(emit, item) {\n    const hide = item.aria === false;\n    emit(ARIA_HIDDEN, hide || undefined);\n\n    if (hide || item.description == null) {\n      for (const prop in AriaEncode) {\n        emit(AriaEncode[prop], undefined);\n      }\n    } else {\n      const type = item.mark.marktype;\n      emit(\n        ARIA_LABEL,\n        item.description\n      );\n      emit(\n        ARIA_ROLE,\n        item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL)\n      );\n      emit(\n        ARIA_ROLEDESCRIPTION,\n        item.ariaRoleDescription || `${type} mark`\n      );\n    }\n  }\n\n  function ariaMarkAttributes(mark) {\n    return mark.aria === false ? { [ARIA_HIDDEN]: true }\n      : AriaIgnore[mark.role] ? null\n      : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role])\n      : ariaMark(mark);\n  }\n\n  function ariaMark(mark) {\n    const type = mark.marktype;\n    const recurse = (\n      type === 'group' ||\n      type === 'text' ||\n      mark.items.some(_ => _.description != null && _.aria !== false)\n    );\n    return bundle(\n      recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL,\n      `${type} mark container`,\n      mark.description\n    );\n  }\n\n  function ariaGuide(mark, opt) {\n    try {\n      const item = mark.items[0],\n            caption = opt.caption || (() => '');\n      return bundle(\n        opt.role || GRAPHICS_SYMBOL,\n        opt.desc,\n        item.description || caption(item)\n      );\n    } catch (err) {\n      return null;\n    }\n  }\n\n  function titleCaption(item) {\n    return vegaUtil.array(item.text).join(' ');\n  }\n\n  function axisCaption(item) {\n    const datum = item.datum,\n          orient = item.orient,\n          title = datum.title ? extractTitle(item) : null,\n          ctx = item.context,\n          scale = ctx.scales[datum.scale].value,\n          locale = ctx.dataflow.locale(),\n          type = scale.type,\n          xy = (orient === 'left' || orient === 'right') ? 'Y' : 'X';\n\n    return `${xy}-axis`\n      + (title ? ` titled '${title}'` : '')\n      + ` for a ${vegaScale.isDiscrete(type) ? 'discrete' : type} scale`\n      + ` with ${vegaScale.domainCaption(locale, scale, item)}`;\n  }\n\n  function legendCaption(item) {\n    const datum = item.datum,\n          title = datum.title ? extractTitle(item) : null,\n          type = `${datum.type || ''} legend`.trim(),\n          scales = datum.scales,\n          props = Object.keys(scales),\n          ctx = item.context,\n          scale = ctx.scales[scales[props[0]]].value,\n          locale = ctx.dataflow.locale();\n\n    return capitalize(type)\n      + (title ? ` titled '${title}'` : '')\n      + ` for ${channelCaption(props)}`\n      + ` with ${vegaScale.domainCaption(locale, scale, item)}`;\n  }\n\n  function extractTitle(item) {\n    try {\n      return vegaUtil.array(vegaUtil.peek(item.items).items[0].text).join(' ');\n    } catch (err) {\n      return null;\n    }\n  }\n\n  function channelCaption(props) {\n    props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));\n    return props.length < 2 ? props[0]\n      : props.slice(0, -1).join(', ') + ' and ' + vegaUtil.peek(props);\n  }\n\n  function capitalize(s) {\n    return s.length ? s[0].toUpperCase() + s.slice(1) : s;\n  }\n\n  const innerText = val => (val + '')\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n\n  const attrText = val => innerText(val)\n    .replace(/\"/g, '&quot;')\n    .replace(/\\t/g, '&#x9;')\n    .replace(/\\n/g, '&#xA;')\n    .replace(/\\r/g, '&#xD;');\n\n  function markup() {\n    let buf = '',\n        outer = '',\n        inner = '';\n\n    const stack = [],\n          clear = () => outer = inner = '',\n          push = tag => {\n            if (outer) { buf += `${outer}>${inner}`; clear(); }\n            stack.push(tag);\n          },\n          attr = (name, value) => {\n            if (value != null) outer += ` ${name}=\"${attrText(value)}\"`;\n            return m;\n          },\n\n          m = {\n            open(tag, ...attrs) {\n              push(tag);\n              outer = '<' + tag;\n              for (const set of attrs) {\n                for (const key in set) attr(key, set[key]);\n              }\n              return m;\n            },\n            close() {\n              const tag = stack.pop();\n              if (outer) {\n                buf += outer + (inner\n                  ? `>${inner}</${tag}>`\n                  : '/>');\n              } else {\n                buf += `</${tag}>`;\n              }\n              clear();\n              return m;\n            },\n            attr,\n            text: t => (inner += innerText(t), m),\n            toString: () => buf\n          };\n\n    return m;\n  }\n\n  const serializeXML = node =>\n    _serialize(markup(), node) + '';\n\n  function _serialize(m, node) {\n    m.open(node.tagName);\n\n    if (node.hasAttributes()) {\n      const attrs = node.attributes,\n            n = attrs.length;\n      for (let i=0; i<n; ++i) {\n        m.attr(attrs[i].name, attrs[i].value);\n      }\n    }\n\n    if (node.hasChildNodes()) {\n      const children = node.childNodes,\n            n = children.length;\n\n      for (let i=0; i<n; i++) {\n        const child = children[i];\n        child.nodeType === 3 // text node\n          ? m.text(child.nodeValue)\n          : _serialize(m, child);\n      }\n    }\n\n    return m.close();\n  }\n\n  const styles = {\n    fill:             'fill',\n    fillOpacity:      'fill-opacity',\n    stroke:           'stroke',\n    strokeOpacity:    'stroke-opacity',\n    strokeWidth:      'stroke-width',\n    strokeCap:        'stroke-linecap',\n    strokeJoin:       'stroke-linejoin',\n    strokeDash:       'stroke-dasharray',\n    strokeDashOffset: 'stroke-dashoffset',\n    strokeMiterLimit: 'stroke-miterlimit',\n    opacity:          'opacity',\n    blend:            'mix-blend-mode'\n  };\n\n  // ensure miter limit default is consistent with canvas (#2498)\n  const rootAttributes = {\n    'fill': 'none',\n    'stroke-miterlimit': 10\n  };\n\n  const RootIndex = 0,\n        ns = metadata.xmlns;\n\n  function SVGRenderer(loader) {\n    Renderer.call(this, loader);\n    this._dirtyID = 0;\n    this._dirty = [];\n    this._svg = null;\n    this._root = null;\n    this._defs = null;\n  }\n\n  const base$1 = Renderer.prototype;\n\n  vegaUtil.inherits(SVGRenderer, Renderer, {\n    /**\n     * Initialize a new SVGRenderer instance.\n     * @param {DOMElement} el - The containing DOM element for the display.\n     * @param {number} width - The coordinate width of the display, in pixels.\n     * @param {number} height - The coordinate height of the display, in pixels.\n     * @param {Array<number>} origin - The origin of the display, in pixels.\n     *   The coordinate system will be translated to this point.\n     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n     *   the width and height to determine the final pixel size.\n     * @return {SVGRenderer} - This renderer instance.\n     */\n    initialize(el, width, height, origin, scaleFactor) {\n      // create the svg definitions cache\n      this._defs = {};\n      this._clearDefs();\n\n      if (el) {\n        this._svg = domChild(el, 0, 'svg', ns);\n        setAttributes(this._svg, metadata);\n        this._svg.setAttribute('class', 'marks');\n        domClear(el, 1);\n\n        // set the svg root group\n        this._root = domChild(this._svg, RootIndex, 'g', ns);\n        setAttributes(this._root, rootAttributes);\n\n        // ensure no additional child elements\n        domClear(this._svg, RootIndex + 1);\n      }\n\n      // set background color if defined\n      this.background(this._bgcolor);\n\n      return base$1.initialize.call(this, el, width, height, origin, scaleFactor);\n    },\n\n    /**\n     * Get / set the background color.\n     */\n    background(bgcolor) {\n      if (arguments.length && this._svg) {\n        this._svg.style.setProperty('background-color', bgcolor);\n      }\n      return base$1.background.apply(this, arguments);\n    },\n\n    /**\n     * Resize the display.\n     * @param {number} width - The new coordinate width of the display, in pixels.\n     * @param {number} height - The new coordinate height of the display, in pixels.\n     * @param {Array<number>} origin - The new origin of the display, in pixels.\n     *   The coordinate system will be translated to this point.\n     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n     *   the width and height to determine the final pixel size.\n     * @return {SVGRenderer} - This renderer instance;\n     */\n    resize(width, height, origin, scaleFactor) {\n      base$1.resize.call(this, width, height, origin, scaleFactor);\n\n      if (this._svg) {\n        setAttributes(this._svg, {\n          width: this._width * this._scale,\n          height: this._height * this._scale,\n          viewBox: `0 0 ${this._width} ${this._height}`\n        });\n        this._root.setAttribute('transform', `translate(${this._origin})`);\n      }\n\n      this._dirty = [];\n\n      return this;\n    },\n\n    /**\n     * Returns the SVG element of the visualization.\n     * @return {DOMElement} - The SVG element.\n     */\n    canvas() {\n      return this._svg;\n    },\n\n    /**\n     * Returns an SVG text string for the rendered content,\n     * or null if this renderer is currently headless.\n     */\n    svg() {\n      const svg = this._svg,\n            bg = this._bgcolor;\n\n      if (!svg) return null;\n\n      let node;\n      if (bg) {\n        svg.removeAttribute('style');\n        node = domChild(svg, RootIndex, 'rect', ns);\n        setAttributes(node, {width: this._width, height: this._height, fill: bg});\n      }\n\n      const text = serializeXML(svg);\n\n      if (bg) {\n        svg.removeChild(node);\n        this._svg.style.setProperty('background-color', bg);\n      }\n\n      return text;\n    },\n\n    /**\n     * Internal rendering method.\n     * @param {object} scene - The root mark of a scenegraph to render.\n     */\n    _render(scene) {\n      // perform spot updates and re-render markup\n      if (this._dirtyCheck()) {\n        if (this._dirtyAll) this._clearDefs();\n        this.mark(this._root, scene);\n        domClear(this._root, 1);\n      }\n\n      this.defs();\n\n      this._dirty = [];\n      ++this._dirtyID;\n\n      return this;\n    },\n\n    // -- Manage rendering of items marked as dirty --\n\n    /**\n     * Flag a mark item as dirty.\n     * @param {Item} item - The mark item.\n     */\n    dirty(item) {\n      if (item.dirty !== this._dirtyID) {\n        item.dirty = this._dirtyID;\n        this._dirty.push(item);\n      }\n    },\n\n    /**\n     * Check if a mark item is considered dirty.\n     * @param {Item} item - The mark item.\n     */\n    isDirty(item) {\n      return this._dirtyAll\n        || !item._svg\n        || item.dirty === this._dirtyID;\n    },\n\n    /**\n     * Internal method to check dirty status and, if possible,\n     * make targetted updates without a full rendering pass.\n     */\n    _dirtyCheck() {\n      this._dirtyAll = true;\n      const items = this._dirty;\n      if (!items.length || !this._dirtyID) return true;\n\n      const id = ++this._dirtyID;\n      let item, mark, type, mdef, i, n, o;\n\n      for (i=0, n=items.length; i<n; ++i) {\n        item = items[i];\n        mark = item.mark;\n\n        if (mark.marktype !== type) {\n          // memoize mark instance lookup\n          type = mark.marktype;\n          mdef = Marks[type];\n        }\n\n        if (mark.zdirty && mark.dirty !== id) {\n          this._dirtyAll = false;\n          dirtyParents(item, id);\n          mark.items.forEach(i => { i.dirty = id; });\n        }\n        if (mark.zdirty) continue; // handle in standard drawing pass\n\n        if (item.exit) { // EXIT\n          if (mdef.nested && mark.items.length) {\n            // if nested mark with remaining points, update instead\n            o = mark.items[0];\n            if (o._svg) this._update(mdef, o._svg, o);\n          } else if (item._svg) {\n            // otherwise remove from DOM\n            o = item._svg.parentNode;\n            if (o) o.removeChild(item._svg);\n          }\n          item._svg = null;\n          continue;\n        }\n\n        item = (mdef.nested ? mark.items[0] : item);\n        if (item._update === id) continue; // already visited\n\n        if (!item._svg || !item._svg.ownerSVGElement) {\n          // ENTER\n          this._dirtyAll = false;\n          dirtyParents(item, id);\n        } else {\n          // IN-PLACE UPDATE\n          this._update(mdef, item._svg, item);\n        }\n        item._update = id;\n      }\n      return !this._dirtyAll;\n    },\n\n    // -- Construct & maintain scenegraph to SVG mapping ---\n\n    /**\n     * Render a set of mark items.\n     * @param {SVGElement} el - The parent element in the SVG tree.\n     * @param {object} scene - The mark parent to render.\n     * @param {SVGElement} prev - The previous sibling in the SVG tree.\n     */\n    mark(el, scene, prev) {\n      if (!this.isDirty(scene)) return scene._svg;\n\n      const svg = this._svg,\n            mdef = Marks[scene.marktype],\n            events = scene.interactive === false ? 'none' : null,\n            isGroup = mdef.tag === 'g';\n\n      let sibling = null,\n          i = 0;\n\n      const parent = bind(scene, el, prev, 'g', svg);\n      parent.setAttribute('class', cssClass(scene));\n\n      // apply aria attributes to parent container element\n      const aria = ariaMarkAttributes(scene);\n      for (const key in aria) setAttribute(parent, key, aria[key]);\n\n      if (!isGroup) {\n        setAttribute(parent, 'pointer-events', events);\n      }\n      setAttribute(parent, 'clip-path',\n        scene.clip ? clip(this, scene, scene.group) : null);\n\n      const process = item => {\n        const dirty = this.isDirty(item),\n              node = bind(item, parent, sibling, mdef.tag, svg);\n\n        if (dirty) {\n          this._update(mdef, node, item);\n          if (isGroup) recurse(this, node, item);\n        }\n\n        sibling = node;\n        ++i;\n      };\n\n      if (mdef.nested) {\n        if (scene.items.length) process(scene.items[0]);\n      } else {\n        visit(scene, process);\n      }\n\n      domClear(parent, i);\n      return parent;\n    },\n\n    /**\n     * Update the attributes of an SVG element for a mark item.\n     * @param {object} mdef - The mark definition object\n     * @param {SVGElement} el - The SVG element.\n     * @param {Item} item - The mark item.\n     */\n    _update(mdef, el, item) {\n      // set dom element and values cache\n      // provides access to emit method\n      element = el;\n      values = el.__values__;\n\n      // apply aria-specific properties\n      ariaItemAttributes(emit, item);\n\n      // apply svg attributes\n      mdef.attr(emit, item, this);\n\n      // some marks need special treatment\n      const extra = mark_extras[mdef.type];\n      if (extra) extra.call(this, mdef, el, item);\n\n      // apply svg style attributes\n      // note: element state may have been modified by 'extra' method\n      if (element) this.style(element, item);\n    },\n\n    /**\n     * Update the presentation attributes of an SVG element for a mark item.\n     * @param {SVGElement} el - The SVG element.\n     * @param {Item} item - The mark item.\n     */\n    style(el, item) {\n      if (item == null) return;\n\n      for (const prop in styles) {\n        let value = prop === 'font' ? fontFamily(item) : item[prop];\n        if (value === values[prop]) continue;\n\n        const name = styles[prop];\n        if (value == null) {\n          el.removeAttribute(name);\n        } else {\n          if (isGradient(value)) {\n            value = gradientRef(value, this._defs.gradient, href());\n          }\n          el.setAttribute(name, value + '');\n        }\n\n        values[prop] = value;\n      }\n    },\n\n    /**\n     * Render SVG defs, as needed.\n     * Must be called *after* marks have been processed to ensure the\n     * collected state is current and accurate.\n     */\n    defs() {\n      const svg = this._svg,\n            defs = this._defs;\n\n      let el = defs.el,\n          index = 0;\n\n      for (const id in defs.gradient) {\n        if (!el) defs.el = (el = domChild(svg, RootIndex + 1, 'defs', ns));\n        index = updateGradient(el, defs.gradient[id], index);\n      }\n\n      for (const id in defs.clipping) {\n        if (!el) defs.el = (el = domChild(svg, RootIndex + 1, 'defs', ns));\n        index = updateClipping(el, defs.clipping[id], index);\n      }\n\n      // clean-up\n      if (el) {\n        index === 0\n          ? (svg.removeChild(el), defs.el = null)\n          : domClear(el, index);\n      }\n    },\n\n    /**\n     * Clear defs caches.\n     */\n    _clearDefs() {\n      const def = this._defs;\n      def.gradient = {};\n      def.clipping = {};\n    }\n  });\n\n  // mark ancestor chain with a dirty id\n  function dirtyParents(item, id) {\n    for (; item && item.dirty !== id; item=item.mark.group) {\n      item.dirty = id;\n      if (item.mark && item.mark.dirty !== id) {\n        item.mark.dirty = id;\n      } else return;\n    }\n  }\n\n  // update gradient definitions\n  function updateGradient(el, grad, index) {\n    let i, n, stop;\n\n    if (grad.gradient === 'radial') {\n      // SVG radial gradients automatically transform to normalized bbox\n      // coordinates, in a way that is cumbersome to replicate in canvas.\n      // We wrap the radial gradient in a pattern element, allowing us to\n      // maintain a circular gradient that matches what canvas provides.\n      let pt = domChild(el, index++, 'pattern', ns);\n      setAttributes(pt, {\n        id: patternPrefix + grad.id,\n        viewBox: '0,0,1,1',\n        width: '100%',\n        height: '100%',\n        preserveAspectRatio: 'xMidYMid slice'\n      });\n\n      pt = domChild(pt, 0, 'rect', ns);\n      setAttributes(pt, {\n        width: 1,\n        height: 1,\n        fill: `url(${href()}#${grad.id})`\n      });\n\n      el = domChild(el, index++, 'radialGradient', ns);\n      setAttributes(el, {\n        id: grad.id,\n        fx: grad.x1,\n        fy: grad.y1,\n        fr: grad.r1,\n        cx: grad.x2,\n        cy: grad.y2,\n        r: grad.r2\n      });\n    } else {\n      el = domChild(el, index++, 'linearGradient', ns);\n      setAttributes(el, {\n        id: grad.id,\n        x1: grad.x1,\n        x2: grad.x2,\n        y1: grad.y1,\n        y2: grad.y2\n      });\n    }\n\n    for (i=0, n=grad.stops.length; i<n; ++i) {\n      stop = domChild(el, i, 'stop', ns);\n      stop.setAttribute('offset', grad.stops[i].offset);\n      stop.setAttribute('stop-color', grad.stops[i].color);\n    }\n    domClear(el, i);\n\n    return index;\n  }\n\n  // update clipping path definitions\n  function updateClipping(el, clip, index) {\n    let mask;\n\n    el = domChild(el, index, 'clipPath', ns);\n    el.setAttribute('id', clip.id);\n\n    if (clip.path) {\n      mask = domChild(el, 0, 'path', ns);\n      mask.setAttribute('d', clip.path);\n    } else {\n      mask = domChild(el, 0, 'rect', ns);\n      setAttributes(mask, {x: 0, y: 0, width: clip.width, height: clip.height});\n    }\n    domClear(el, 1);\n\n    return index + 1;\n  }\n\n  // Recursively process group contents.\n  function recurse(renderer, el, group) {\n    el = el.lastChild.previousSibling;\n    let prev, idx = 0;\n\n    visit(group, item => {\n      prev = renderer.mark(el, item, prev);\n      ++idx;\n    });\n\n    // remove any extraneous DOM elements\n    domClear(el, 1 + idx);\n  }\n\n  // Bind a scenegraph item to an SVG DOM element.\n  // Create new SVG elements as needed.\n  function bind(item, el, sibling, tag, svg) {\n    let node = item._svg, doc;\n\n    // create a new dom node if needed\n    if (!node) {\n      doc = el.ownerDocument;\n      node = domCreate(doc, tag, ns);\n      item._svg = node;\n\n      if (item.mark) {\n        node.__data__ = item;\n        node.__values__ = {fill: 'default'};\n\n        // if group, create background, content, and foreground elements\n        if (tag === 'g') {\n          const bg = domCreate(doc, 'path', ns);\n          node.appendChild(bg);\n          bg.__data__ = item;\n\n          const cg = domCreate(doc, 'g', ns);\n          node.appendChild(cg);\n          cg.__data__ = item;\n\n          const fg = domCreate(doc, 'path', ns);\n          node.appendChild(fg);\n          fg.__data__ = item;\n          fg.__values__ = {fill: 'default'};\n        }\n      }\n    }\n\n    // (re-)insert if (a) not contained in SVG or (b) sibling order has changed\n    if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {\n      el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);\n    }\n\n    return node;\n  }\n\n  // check if two nodes are ordered siblings\n  function siblingCheck(node, sibling) {\n    return node.parentNode\n      && node.parentNode.childNodes.length > 1\n      && node.previousSibling != sibling; // treat null/undefined the same\n  }\n\n  // -- Set attributes & styles on SVG elements ---\n\n  let element = null, // temp var for current SVG element\n      values = null;  // temp var for current values hash\n\n  // Extra configuration for certain mark types\n  const mark_extras = {\n    group(mdef, el, item) {\n      const fg = element = el.childNodes[2];\n      values = fg.__values__;\n      mdef.foreground(emit, item, this);\n\n      values = el.__values__; // use parent's values hash\n      element = el.childNodes[1];\n      mdef.content(emit, item, this);\n\n      const bg = element = el.childNodes[0];\n      mdef.background(emit, item, this);\n\n      const value = item.mark.interactive === false ? 'none' : null;\n      if (value !== values.events) {\n        setAttribute(fg, 'pointer-events', value);\n        setAttribute(bg, 'pointer-events', value);\n        values.events = value;\n      }\n\n      if (item.strokeForeground && item.stroke) {\n        const fill = item.fill;\n        setAttribute(fg, 'display', null);\n\n        // set style of background\n        this.style(bg, item);\n        setAttribute(bg, 'stroke', null);\n\n        // set style of foreground\n        if (fill) item.fill = null;\n        values = fg.__values__;\n        this.style(fg, item);\n        if (fill) item.fill = fill;\n\n        // leave element null to prevent downstream styling\n        element = null;\n      } else {\n        // ensure foreground is ignored\n        setAttribute(fg, 'display', 'none');\n      }\n    },\n    image(mdef, el, item) {\n      if (item.smooth === false) {\n        setStyle(el, 'image-rendering', 'optimizeSpeed');\n        setStyle(el, 'image-rendering', 'pixelated');\n      } else {\n        setStyle(el, 'image-rendering', null);\n      }\n    },\n    text(mdef, el, item) {\n      const tl = textLines(item);\n      let key, value, doc, lh;\n\n      if (vegaUtil.isArray(tl)) {\n        // multi-line text\n        value = tl.map(_ => textValue(item, _));\n        key = value.join('\\n'); // content cache key\n\n        if (key !== values.text) {\n          domClear(el, 0);\n          doc = el.ownerDocument;\n          lh = lineHeight(item);\n          value.forEach((t, i) => {\n            const ts = domCreate(doc, 'tspan', ns);\n            ts.__data__ = item; // data binding\n            ts.textContent = t;\n            if (i) {\n              ts.setAttribute('x', 0);\n              ts.setAttribute('dy', lh);\n            }\n            el.appendChild(ts);\n          });\n          values.text = key;\n        }\n      } else {\n        // single-line text\n        value = textValue(item, tl);\n        if (value !== values.text) {\n          el.textContent = value;\n          values.text = value;\n        }\n      }\n\n      setAttribute(el, 'font-family', fontFamily(item));\n      setAttribute(el, 'font-size', fontSize(item) + 'px');\n      setAttribute(el, 'font-style', item.fontStyle);\n      setAttribute(el, 'font-variant', item.fontVariant);\n      setAttribute(el, 'font-weight', item.fontWeight);\n    }\n  };\n\n  function emit(name, value, ns) {\n    // early exit if value is unchanged\n    if (value === values[name]) return;\n\n    // use appropriate method given namespace (ns)\n    if (ns) {\n      setAttributeNS(element, name, value, ns);\n    } else {\n      setAttribute(element, name, value);\n    }\n\n    // note current value for future comparison\n    values[name] = value;\n  }\n\n  function setStyle(el, name, value) {\n    if (value !== values[name]) {\n      if (value == null) {\n        el.style.removeProperty(name);\n      } else {\n        el.style.setProperty(name, value + '');\n      }\n      values[name] = value;\n    }\n  }\n\n  function setAttributes(el, attrs) {\n    for (const key in attrs) {\n      setAttribute(el, key, attrs[key]);\n    }\n  }\n\n  function setAttribute(el, name, value) {\n    if (value != null) {\n      // if value is provided, update DOM attribute\n      el.setAttribute(name, value);\n    } else {\n      // else remove DOM attribute\n      el.removeAttribute(name);\n    }\n  }\n\n  function setAttributeNS(el, name, value, ns) {\n    if (value != null) {\n      // if value is provided, update DOM attribute\n      el.setAttributeNS(ns, name, value);\n    } else {\n      // else remove DOM attribute\n      el.removeAttributeNS(ns, name);\n    }\n  }\n\n  function href() {\n    let loc;\n    return typeof window === 'undefined' ? ''\n      : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length)\n      : loc.href;\n  }\n\n  function SVGStringRenderer(loader) {\n    Renderer.call(this, loader);\n    this._text = null;\n    this._defs = {\n      gradient: {},\n      clipping: {}\n    };\n  }\n\n  vegaUtil.inherits(SVGStringRenderer, Renderer, {\n    /**\n     * Returns the rendered SVG text string,\n     * or null if rendering has not yet occurred.\n     */\n    svg() {\n      return this._text;\n    },\n\n    /**\n     * Internal rendering method.\n     * @param {object} scene - The root mark of a scenegraph to render.\n     */\n    _render(scene) {\n      const m = markup();\n\n      // svg tag\n      m.open('svg', vegaUtil.extend({}, metadata, {\n        class:   'marks',\n        width:   this._width * this._scale,\n        height:  this._height * this._scale,\n        viewBox: `0 0 ${this._width} ${this._height}`\n      }));\n\n      // background, if defined\n      const bg = this._bgcolor;\n      if (bg && bg !== 'transparent' && bg !== 'none') {\n        m.open('rect', {\n          width:  this._width,\n          height: this._height,\n          fill:   bg\n        }).close();\n      }\n\n      // root content group\n      m.open('g', rootAttributes, {\n        transform: 'translate(' + this._origin + ')'\n      });\n      this.mark(m, scene);\n      m.close(); // </g>\n\n      // defs\n      this.defs(m);\n\n      // get SVG text string\n      this._text = m.close() + '';\n\n      return this;\n    },\n\n    /**\n     * Render a set of mark items.\n     * @param {object} m - The markup context.\n     * @param {object} scene - The mark parent to render.\n     */\n    mark(m, scene) {\n      const mdef = Marks[scene.marktype],\n            tag  = mdef.tag,\n            attrList = [ariaItemAttributes, mdef.attr];\n\n      // render opening group tag\n      m.open('g',\n        {\n          'class': cssClass(scene),\n          'clip-path': scene.clip ? clip(this, scene, scene.group) : null\n        },\n        ariaMarkAttributes(scene),\n        {\n          'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null\n        }\n      );\n\n      // render contained elements\n      const process = item => {\n        const href = this.href(item);\n        if (href) m.open('a', href);\n\n        m.open(\n          tag,\n          this.attr(scene, item, attrList, tag !== 'g' ? tag : null)\n        );\n\n        if (tag === 'text') {\n          const tl = textLines(item);\n          if (vegaUtil.isArray(tl)) {\n            // multi-line text\n            const attrs = {x: 0, dy: lineHeight(item)};\n            for (let i=0; i<tl.length; ++i) {\n              m.open('tspan', i ? attrs: null)\n                .text(textValue(item, tl[i]))\n                .close();\n            }\n          } else {\n            // single-line text\n            m.text(textValue(item, tl));\n          }\n        } else if (tag === 'g') {\n          const fore = item.strokeForeground,\n                fill = item.fill,\n                stroke = item.stroke;\n\n          if (fore && stroke) {\n            item.stroke = null;\n          }\n\n          m.open(\n            'path',\n            this.attr(scene, item, mdef.background, 'bgrect')\n          ).close();\n\n          // recurse for group content\n          m.open('g', this.attr(scene, item, mdef.content));\n          visit(item, scene => this.mark(m, scene));\n          m.close();\n\n          if (fore && stroke) {\n            if (fill) item.fill = null;\n            item.stroke = stroke;\n\n            m.open(\n              'path',\n              this.attr(scene, item, mdef.foreground, 'bgrect')\n            ).close();\n\n            if (fill) item.fill = fill;\n          } else {\n            m.open(\n              'path',\n              this.attr(scene, item, mdef.foreground, 'bgfore')\n            ).close();\n          }\n        }\n\n        m.close(); // </tag>\n        if (href) m.close(); // </a>\n      };\n\n      if (mdef.nested) {\n        if (scene.items && scene.items.length) process(scene.items[0]);\n      } else {\n        visit(scene, process);\n      }\n\n      // render closing group tag\n      return m.close(); // </g>\n    },\n\n    /**\n     * Get href attributes for a hyperlinked mark item.\n     * @param {Item} item - The mark item.\n     */\n    href(item) {\n      const href = item.href;\n      let attr;\n\n      if (href) {\n        if (attr = this._hrefs && this._hrefs[href]) {\n          return attr;\n        } else {\n          this.sanitizeURL(href).then(attr => {\n            // rewrite to use xlink namespace\n            attr['xlink:href'] = attr.href;\n            attr.href = null;\n            (this._hrefs || (this._hrefs = {}))[href] = attr;\n          });\n        }\n      }\n      return null;\n    },\n\n    /**\n     * Get an object of SVG attributes for a mark item.\n     * @param {object} scene - The mark parent.\n     * @param {Item} item - The mark item.\n     * @param {array|function} attrs - One or more attribute emitters.\n     * @param {string} tag - The tag being rendered.\n     */\n    attr(scene, item, attrs, tag) {\n      const object = {},\n            emit = (name, value, ns, prefixed) => {\n              object[prefixed || name] = value;\n            };\n\n      // apply mark specific attributes\n      if (Array.isArray(attrs)) {\n        attrs.forEach(fn => fn(emit, item, this));\n      } else {\n        attrs(emit, item, this);\n      }\n\n      // apply style attributes\n      if (tag) {\n        style(object, item, scene, tag, this._defs);\n      }\n\n      return object;\n    },\n\n    /**\n     * Render SVG defs, as needed.\n     * Must be called *after* marks have been processed to ensure the\n     * collected state is current and accurate.\n     * @param {object} m - The markup context.\n     */\n    defs(m) {\n      const gradient = this._defs.gradient,\n            clipping = this._defs.clipping,\n            count = Object.keys(gradient).length + Object.keys(clipping).length;\n\n      if (count === 0) return; // nothing to do\n\n      m.open('defs');\n\n      for (const id in gradient) {\n        const def = gradient[id],\n              stops = def.stops;\n\n        if (def.gradient === 'radial') {\n          // SVG radial gradients automatically transform to normalized bbox\n          // coordinates, in a way that is cumbersome to replicate in canvas.\n          // We wrap the radial gradient in a pattern element, allowing us to\n          // maintain a circular gradient that matches what canvas provides.\n\n          m.open('pattern', {\n            id: patternPrefix + id,\n            viewBox: '0,0,1,1',\n            width: '100%',\n            height: '100%',\n            preserveAspectRatio: 'xMidYMid slice'\n          });\n\n          m.open('rect', {\n            width:  '1',\n            height: '1',\n            fill:   'url(#' + id + ')'\n          }).close();\n\n          m.close(); // </pattern>\n\n          m.open('radialGradient', {\n            id: id,\n            fx: def.x1,\n            fy: def.y1,\n            fr: def.r1,\n            cx: def.x2,\n            cy: def.y2,\n            r: def.r2\n          });\n        } else {\n          m.open('linearGradient', {\n            id: id,\n            x1: def.x1,\n            x2: def.x2,\n            y1: def.y1,\n            y2: def.y2\n          });\n        }\n\n        for (let i = 0; i < stops.length; ++i) {\n          m.open('stop', {\n            offset: stops[i].offset,\n            'stop-color': stops[i].color\n          }).close();\n        }\n\n        m.close();\n      }\n\n      for (const id in clipping) {\n        const def = clipping[id];\n\n        m.open('clipPath', {id: id});\n        if (def.path) {\n          m.open('path', {\n            d: def.path\n          }).close();\n        } else {\n          m.open('rect', {\n            x: 0,\n            y: 0,\n            width: def.width,\n            height: def.height\n          }).close();\n        }\n        m.close();\n      }\n\n      m.close();\n    }\n  });\n\n  // Helper function for attr for style presentation attributes\n  function style(s, item, scene, tag, defs) {\n    if (item == null) return s;\n\n    if (tag === 'bgrect' && scene.interactive === false) {\n      s['pointer-events'] = 'none';\n    }\n\n    if (tag === 'bgfore') {\n      if (scene.interactive === false) {\n        s['pointer-events'] = 'none';\n      }\n      s.display = 'none';\n      if (item.fill !== null) return s;\n    }\n\n    if (tag === 'image' && item.smooth === false) {\n      s.style = 'image-rendering: optimizeSpeed; image-rendering: pixelated;';\n    }\n\n    if (tag === 'text') {\n      s['font-family'] = fontFamily(item);\n      s['font-size'] = fontSize(item) + 'px';\n      s['font-style'] = item.fontStyle;\n      s['font-variant'] = item.fontVariant;\n      s['font-weight'] = item.fontWeight;\n    }\n\n    for (const prop in styles) {\n      let value = item[prop];\n      const name = styles[prop];\n\n      if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ; else if (value != null) {\n        if (isGradient(value)) {\n          value = gradientRef(value, defs.gradient, '');\n        }\n        s[name] = value;\n      }\n    }\n\n    return s;\n  }\n\n  var Canvas = 'canvas';\n  var PNG = 'png';\n  var SVG = 'svg';\n  var None = 'none';\n\n  var RenderType = {\n    Canvas: Canvas,\n    PNG:    PNG,\n    SVG:    SVG,\n    None:   None\n  };\n\n  var modules = {};\n\n  modules[Canvas] = modules[PNG] = {\n    renderer: CanvasRenderer,\n    headless: CanvasRenderer,\n    handler:  CanvasHandler\n  };\n\n  modules[SVG] = {\n    renderer: SVGRenderer,\n    headless: SVGStringRenderer,\n    handler:  SVGHandler\n  };\n\n  modules[None] = {};\n\n  function renderModule(name, _) {\n    name = String(name || '').toLowerCase();\n    if (arguments.length > 1) {\n      modules[name] = _;\n      return this;\n    } else {\n      return modules[name];\n    }\n  }\n\n  function intersect(scene, bounds, filter) {\n    const hits = [], // intersection results\n          box = new Bounds().union(bounds), // defensive copy\n          type = scene.marktype;\n\n    return type ? intersectMark(scene, box, filter, hits)\n      : type === 'group' ? intersectGroup(scene, box, filter, hits)\n      : vegaUtil.error('Intersect scene must be mark node or group item.');\n  }\n\n  function intersectMark(mark, box, filter, hits) {\n    if (visitMark(mark, box, filter)) {\n      const items = mark.items,\n            type = mark.marktype,\n            n = items.length;\n\n      let i = 0;\n\n      if (type === 'group') {\n        for (; i<n; ++i) {\n          intersectGroup(items[i], box, filter, hits);\n        }\n      } else {\n        for (const test = Marks[type].isect; i<n; ++i) {\n          const item = items[i];\n          if (intersectItem(item, box, test)) hits.push(item);\n        }\n      }\n    }\n    return hits;\n  }\n\n  function visitMark(mark, box, filter) {\n    // process if bounds intersect and if\n    // (1) mark is a group mark (so we must recurse), or\n    // (2) mark is interactive and passes filter\n    return mark.bounds && box.intersects(mark.bounds) && (\n      mark.marktype === 'group' ||\n      mark.interactive !== false && (!filter || filter(mark))\n    );\n  }\n\n  function intersectGroup(group, box, filter, hits) {\n    // test intersect against group\n    // skip groups by default unless filter says otherwise\n    if ((filter && filter(group.mark)) &&\n        intersectItem(group, box, Marks.group.isect)) {\n      hits.push(group);\n    }\n\n    // recursively test children marks\n    // translate box to group coordinate space\n    const marks = group.items,\n          n = marks && marks.length;\n\n    if (n) {\n      const x = group.x || 0,\n            y = group.y || 0;\n      box.translate(-x, -y);\n      for (let i=0; i<n; ++i) {\n        intersectMark(marks[i], box, filter, hits);\n      }\n      box.translate(x, y);\n    }\n\n    return hits;\n  }\n\n  function intersectItem(item, box, test) {\n    // test bounds enclosure, bounds intersection, then detailed test\n    const bounds = item.bounds;\n    return box.encloses(bounds) || (box.intersects(bounds) && test(item, box));\n  }\n\n  const clipBounds = new Bounds();\n\n  function boundClip(mark) {\n    const clip = mark.clip;\n\n    if (vegaUtil.isFunction(clip)) {\n      clip(boundContext(clipBounds.clear()));\n    } else if (clip) {\n      clipBounds.set(0, 0, mark.group.width, mark.group.height);\n    } else return;\n\n    mark.bounds.intersect(clipBounds);\n  }\n\n  var TOLERANCE = 1e-9;\n\n  function sceneEqual(a, b, key) {\n    return (a === b) ? true\n      : (key === 'path') ? pathEqual(a, b)\n      : (a instanceof Date && b instanceof Date) ? +a === +b\n      : (vegaUtil.isNumber(a) && vegaUtil.isNumber(b)) ? Math.abs(a - b) <= TOLERANCE\n      : (!a || !b || !vegaUtil.isObject(a) && !vegaUtil.isObject(b)) ? a == b\n      : objectEqual(a, b);\n  }\n\n  function pathEqual(a, b) {\n    return sceneEqual(pathParse(a), pathParse(b));\n  }\n\n  function objectEqual(a, b) {\n    var ka = Object.keys(a),\n        kb = Object.keys(b),\n        key, i;\n\n    if (ka.length !== kb.length) return false;\n\n    ka.sort();\n    kb.sort();\n\n    for (i = ka.length - 1; i >= 0; i--) {\n      if (ka[i] != kb[i]) return false;\n    }\n\n    for (i = ka.length - 1; i >= 0; i--) {\n      key = ka[i];\n      if (!sceneEqual(a[key], b[key], key)) return false;\n    }\n\n    return typeof a === typeof b;\n  }\n\n  function resetSVGDefIds() {\n    resetSVGClipId();\n    resetSVGGradientId();\n  }\n\n  exports.Bounds = Bounds;\n  exports.CanvasHandler = CanvasHandler;\n  exports.CanvasRenderer = CanvasRenderer;\n  exports.Gradient = Gradient;\n  exports.GroupItem = GroupItem;\n  exports.Handler = Handler;\n  exports.Item = Item;\n  exports.Marks = Marks;\n  exports.RenderType = RenderType;\n  exports.Renderer = Renderer;\n  exports.ResourceLoader = ResourceLoader;\n  exports.SVGHandler = SVGHandler;\n  exports.SVGRenderer = SVGRenderer;\n  exports.SVGStringRenderer = SVGStringRenderer;\n  exports.Scenegraph = Scenegraph;\n  exports.boundClip = boundClip;\n  exports.boundContext = boundContext;\n  exports.boundItem = boundItem;\n  exports.boundMark = boundMark;\n  exports.boundStroke = boundStroke;\n  exports.domChild = domChild;\n  exports.domClear = domClear;\n  exports.domCreate = domCreate;\n  exports.domFind = domFind;\n  exports.font = font;\n  exports.fontFamily = fontFamily;\n  exports.fontSize = fontSize;\n  exports.intersect = intersect;\n  exports.intersectBoxLine = intersectBoxLine;\n  exports.intersectPath = intersectPath;\n  exports.intersectPoint = intersectPoint;\n  exports.intersectRule = intersectRule;\n  exports.lineHeight = lineHeight;\n  exports.markup = markup;\n  exports.multiLineOffset = multiLineOffset;\n  exports.pathCurves = curves;\n  exports.pathEqual = pathEqual;\n  exports.pathParse = pathParse;\n  exports.pathRectangle = vg_rect;\n  exports.pathRender = pathRender;\n  exports.pathSymbols = symbols;\n  exports.pathTrail = vg_trail;\n  exports.point = point;\n  exports.renderModule = renderModule;\n  exports.resetSVGClipId = resetSVGClipId;\n  exports.resetSVGDefIds = resetSVGDefIds;\n  exports.sceneEqual = sceneEqual;\n  exports.sceneFromJSON = sceneFromJSON;\n  exports.scenePickVisit = pickVisit;\n  exports.sceneToJSON = sceneToJSON;\n  exports.sceneVisit = visit;\n  exports.sceneZOrder = zorder;\n  exports.serializeXML = serializeXML;\n  exports.textMetrics = textMetrics;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$d3_path$dist$d3_path","~$module$node_modules$vega_scale$build$vega_scale","~$module$node_modules$d3_shape$dist$d3_shape","~$shadow.js","~$module$node_modules$vega_loader$build$vega_loader","~$module$node_modules$vega_util$build$vega_util","~$module$node_modules$vega_canvas$build$vega_canvas"]],"~:properties",["^5",["_dirty","Renderer","_scale","trail","stop","mousedown","interactive","pathSymbols","pickEvent","boundStroke","d","_defs","y1","role","ready","stops","bezierCurveTo","sceneZOrder","getItemBoundingClientRect","isDirty","yOffset","canvas","domCreate","handler","Gradient","s","width","rule","renderer","origin","url","right","pathCache","dragleave","top","blend","handleHref","onerror","_events","Canvas","curve","fx","cy","gradient","lineWidth","lineTo","index","xOffset","beginPath","off","SVGHandler","aria","offset","translate","strokeDashOffset","_hrefs","x1","strokeCap","prototype","height","encloses","shape","scale","area","intersectPoint","tip","q","SVGRenderer","DOMMouseScroll","handlers","expand","intersect","group","_touch","clip","class","image","zdirty","Handler","resetSVGClipId","fontFamily","el","r1","_handlerIndex","ariaRole","_svg","mouseout","_render","contains","cornerRadius","lineHeight","sceneFromJSON","markup","pick","Marks","vegaType","textContent","CanvasRenderer","x","__esModule","complete","union","imageSmoothingEnabled","defined","path","svg","strokeDash","rotatedPoints","_obj","dirty","boundItem","PNG","vertical","v","_canvas","attr","strokeJoin","id","renderModule","transform","toString","lineCap","_origin","viewBox","root","foreground","vega","_pending","click","intersectPath","src","None","listener","Scenegraph","_width","boundClip","intersectBoxLine","pathRectangle","multiLineOffset","element","domClear","lineJoin","href","loadImage","name","mousemove","fr","eventName","pixelRatio","preserveAspectRatio","stroke","strokeMiterLimit","style","tag","_handlers","value","pathParse","items","_down","_call","sceneEqual","context","boundMark","_text","touchmove","globalCompositeOperation","pathRender","text","_clearDefs","fill","r2","fontSize","a","textMetrics","strokeWidth","touchend","_el","on","desc","fy","strokeOpacity","content","_height","resetSVGDefIds","symbol","empty","_tooltip","clipping","CanvasHandler","font","_root","onload","_dirtyAll","intersectRule","arc","globalAlpha","events","Bounds","_tooltipHandler","tension","domChild","t","pathEqual","line","_dirtyCheck","close","RenderType","sceneVisit","moveTo","type","render","initialize","r","y","horizontal","draw","_scene","quadraticCurveTo","x2","touchstart","headless","_dirtyID","_active","ResourceLoader","marktype","serializeXML","dy","clone","_tempb","l","bound","display","y2","__values__","lineDashOffset","add","bounds","fillOpacity","bottom","set","SVGStringRenderer","handleTooltip","rect","domFind","_bgcolor","strokeStyle","resize","size","isect","_options","defs","clear","h","estimateWidth","sanitizeURL","cx","open","pending","mark","_first","caption","closePath","round","pathCurves","alignsWith","m","_update","SVG","GroupItem","nested","_load","sceneToJSON","background","get","rotate","__data__","miterLimit","Item","color","pathTrail","equals","intersects","_redraw","renderAsync","opacity","crossOrigin","clip_id","ariaRoleDescription","point","c","zindex","textAlign","left","description","_ready","scenePickVisit","measureWidth","_hrefHandler","fire","zitems","scene","_loader","toJSON","boundContext","fillStyle","dragover"]],"~:compiled-at",1600144479905,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_scenegraph$build$vega_scenegraph.js\",\n\"lineCount\":161,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-scenegraph/build/vega-scenegraph.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_scenegraph$build$vega_scenegraph\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('d3-shape'), require('d3-path'), require('vega-canvas'), require('vega-loader'), require('vega-scale')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'd3-shape', 'd3-path', 'vega-canvas', 'vega-loader', 'vega-scale'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.d3, global.d3, global.vega, global.vega, global.vega));\\n}(this, (function (exports, vegaUtil, d3Shape, d3Path, vegaCanvas, vegaLoader, vegaScale) { 'use strict';\\n\\n  var gradient_id = 0;\\n\\n  function resetSVGGradientId() {\\n    gradient_id = 0;\\n  }\\n\\n  const patternPrefix = 'p_';\\n\\n  function isGradient(value) {\\n    return value && value.gradient;\\n  }\\n\\n  function gradientRef(g, defs, base) {\\n    const type = g.gradient;\\n\\n    let id = g.id,\\n        prefix = type === 'radial' ? patternPrefix : '';\\n\\n    // check id, assign default values as needed\\n    if (!id) {\\n      id = g.id = 'gradient_' + (gradient_id++);\\n      if (type === 'radial') {\\n        g.x1 = get(g.x1, 0.5);\\n        g.y1 = get(g.y1, 0.5);\\n        g.r1 = get(g.r1, 0);\\n        g.x2 = get(g.x2, 0.5);\\n        g.y2 = get(g.y2, 0.5);\\n        g.r2 = get(g.r2, 0.5);\\n        prefix = patternPrefix;\\n      } else {\\n        g.x1 = get(g.x1, 0);\\n        g.y1 = get(g.y1, 0);\\n        g.x2 = get(g.x2, 1);\\n        g.y2 = get(g.y2, 0);\\n      }\\n    }\\n\\n    // register definition\\n    defs[id] = g;\\n\\n    // return url reference\\n    return 'url(' + (base || '') + '#' + prefix + id + ')';\\n  }\\n\\n  function get(val, def) {\\n    return val != null ? val : def;\\n  }\\n\\n  function Gradient(p0, p1) {\\n    var stops = [], gradient;\\n    return gradient = {\\n      gradient: 'linear',\\n      x1: p0 ? p0[0] : 0,\\n      y1: p0 ? p0[1] : 0,\\n      x2: p1 ? p1[0] : 1,\\n      y2: p1 ? p1[1] : 0,\\n      stops: stops,\\n      stop: function(offset, color) {\\n        stops.push({offset: offset, color: color});\\n        return gradient;\\n      }\\n    };\\n  }\\n\\n  const lookup = {\\n    'basis': {\\n      curve: d3Shape.curveBasis\\n    },\\n    'basis-closed': {\\n      curve: d3Shape.curveBasisClosed\\n    },\\n    'basis-open': {\\n      curve: d3Shape.curveBasisOpen\\n    },\\n    'bundle': {\\n      curve: d3Shape.curveBundle,\\n      tension: 'beta',\\n      value: 0.85\\n    },\\n    'cardinal': {\\n      curve: d3Shape.curveCardinal,\\n      tension: 'tension',\\n      value: 0\\n    },\\n    'cardinal-open': {\\n      curve: d3Shape.curveCardinalOpen,\\n      tension: 'tension',\\n      value: 0\\n    },\\n    'cardinal-closed': {\\n      curve: d3Shape.curveCardinalClosed,\\n      tension: 'tension',\\n      value: 0\\n    },\\n    'catmull-rom': {\\n      curve: d3Shape.curveCatmullRom,\\n      tension: 'alpha',\\n      value: 0.5\\n    },\\n    'catmull-rom-closed': {\\n      curve: d3Shape.curveCatmullRomClosed,\\n      tension: 'alpha',\\n      value: 0.5\\n    },\\n    'catmull-rom-open': {\\n      curve: d3Shape.curveCatmullRomOpen,\\n      tension: 'alpha',\\n      value: 0.5\\n    },\\n    'linear': {\\n      curve: d3Shape.curveLinear\\n    },\\n    'linear-closed': {\\n      curve: d3Shape.curveLinearClosed\\n    },\\n    'monotone': {\\n      horizontal: d3Shape.curveMonotoneY,\\n      vertical:   d3Shape.curveMonotoneX\\n    },\\n    'natural': {\\n      curve: d3Shape.curveNatural\\n    },\\n    'step': {\\n      curve: d3Shape.curveStep\\n    },\\n    'step-after': {\\n      curve: d3Shape.curveStepAfter\\n    },\\n    'step-before': {\\n      curve: d3Shape.curveStepBefore\\n    }\\n  };\\n\\n  function curves(type, orientation, tension) {\\n    var entry = vegaUtil.hasOwnProperty(lookup, type) && lookup[type],\\n        curve = null;\\n\\n    if (entry) {\\n      curve = entry.curve || entry[orientation || 'vertical'];\\n      if (entry.tension && tension != null) {\\n        curve = curve[entry.tension](tension);\\n      }\\n    }\\n\\n    return curve;\\n  }\\n\\n  // Path parsing and rendering code adapted from fabric.js -- Thanks!\\n  const cmdlen = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\\n        regexp = [\\n          /([MLHVCSQTAZmlhvcsqtaz])/g,\\n          /###/,\\n          /(\\\\.\\\\d+)(\\\\.\\\\d)/g,\\n          /(\\\\d)([-+])/g,\\n          /\\\\s|,|###/\\n        ];\\n\\n  function pathParse(pathstr) {\\n    const result = [];\\n    let curr,\\n        chunks,\\n        parsed, param,\\n        cmd, len, i, j, n, m;\\n\\n    // First, break path into command sequence\\n    const path = pathstr\\n      .slice()\\n      .replace(regexp[0], '###$1')\\n      .split(regexp[1])\\n      .slice(1);\\n\\n    // Next, parse each command in turn\\n    for (i = 0, n = path.length; i < n; ++i) {\\n      curr = path[i];\\n      chunks = curr\\n        .slice(1)\\n        .trim()\\n        .replace(regexp[2], '$1###$2')\\n        .replace(regexp[3], '$1###$2')\\n        .split(regexp[4]);\\n      cmd = curr.charAt(0);\\n\\n      parsed = [cmd];\\n      for (j = 0, m = chunks.length; j < m; ++j) {\\n        if ((param = +chunks[j]) === param) { // not NaN\\n          parsed.push(param);\\n        }\\n      }\\n\\n      len = cmdlen[cmd.toLowerCase()];\\n      if (parsed.length - 1 > len) {\\n        const m = parsed.length;\\n        j = 1;\\n        result.push([cmd].concat(parsed.slice(j, j += len)));\\n\\n        // handle implicit lineTo (#2803)\\n        cmd = cmd === 'M' ? 'L' : cmd === 'm' ? 'l' : cmd;\\n\\n        for (; j < m; j += len) {\\n          result.push([cmd].concat(parsed.slice(j, j+len)));\\n        }\\n      }\\n      else {\\n        result.push(parsed);\\n      }\\n    }\\n\\n    return result;\\n  }\\n\\n  const DegToRad = Math.PI / 180;\\n  const Epsilon = 1e-14;\\n  const HalfPi = Math.PI / 2;\\n  const Tau = Math.PI * 2;\\n  const HalfSqrt3 = Math.sqrt(3) / 2;\\n\\n  var segmentCache = {};\\n  var bezierCache = {};\\n\\n  var join = [].join;\\n\\n  // Copied from Inkscape svgtopdf, thanks!\\n  function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\\n    var key = join.call(arguments);\\n    if (segmentCache[key]) {\\n      return segmentCache[key];\\n    }\\n\\n    var th = rotateX * DegToRad;\\n    var sin_th = Math.sin(th);\\n    var cos_th = Math.cos(th);\\n    rx = Math.abs(rx);\\n    ry = Math.abs(ry);\\n    var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\\n    var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\\n    var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\\n    if (pl > 1) {\\n      pl = Math.sqrt(pl);\\n      rx *= pl;\\n      ry *= pl;\\n    }\\n\\n    var a00 = cos_th / rx;\\n    var a01 = sin_th / rx;\\n    var a10 = (-sin_th) / ry;\\n    var a11 = (cos_th) / ry;\\n    var x0 = a00 * ox + a01 * oy;\\n    var y0 = a10 * ox + a11 * oy;\\n    var x1 = a00 * x + a01 * y;\\n    var y1 = a10 * x + a11 * y;\\n\\n    var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\\n    var sfactor_sq = 1 / d - 0.25;\\n    if (sfactor_sq < 0) sfactor_sq = 0;\\n    var sfactor = Math.sqrt(sfactor_sq);\\n    if (sweep == large) sfactor = -sfactor;\\n    var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\\n    var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\\n\\n    var th0 = Math.atan2(y0-yc, x0-xc);\\n    var th1 = Math.atan2(y1-yc, x1-xc);\\n\\n    var th_arc = th1-th0;\\n    if (th_arc < 0 && sweep === 1) {\\n      th_arc += Tau;\\n    } else if (th_arc > 0 && sweep === 0) {\\n      th_arc -= Tau;\\n    }\\n\\n    var segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));\\n    var result = [];\\n    for (var i=0; i<segs; ++i) {\\n      var th2 = th0 + i * th_arc / segs;\\n      var th3 = th0 + (i+1) * th_arc / segs;\\n      result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\\n    }\\n\\n    return (segmentCache[key] = result);\\n  }\\n\\n  function bezier(params) {\\n    var key = join.call(params);\\n    if (bezierCache[key]) {\\n      return bezierCache[key];\\n    }\\n\\n    var cx = params[0],\\n        cy = params[1],\\n        th0 = params[2],\\n        th1 = params[3],\\n        rx = params[4],\\n        ry = params[5],\\n        sin_th = params[6],\\n        cos_th = params[7];\\n\\n    var a00 = cos_th * rx;\\n    var a01 = -sin_th * ry;\\n    var a10 = sin_th * rx;\\n    var a11 = cos_th * ry;\\n\\n    var cos_th0 = Math.cos(th0);\\n    var sin_th0 = Math.sin(th0);\\n    var cos_th1 = Math.cos(th1);\\n    var sin_th1 = Math.sin(th1);\\n\\n    var th_half = 0.5 * (th1 - th0);\\n    var sin_th_h2 = Math.sin(th_half * 0.5);\\n    var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\\n    var x1 = cx + cos_th0 - t * sin_th0;\\n    var y1 = cy + sin_th0 + t * cos_th0;\\n    var x3 = cx + cos_th1;\\n    var y3 = cy + sin_th1;\\n    var x2 = x3 + t * sin_th1;\\n    var y2 = y3 - t * cos_th1;\\n\\n    return (bezierCache[key] = [\\n      a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\\n      a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\\n      a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\\n    ]);\\n  }\\n\\n  var temp = ['l', 0, 0, 0, 0, 0, 0, 0];\\n\\n  function scale(current, sX, sY) {\\n    var c = (temp[0] = current[0]);\\n    if (c === 'a' || c === 'A') {\\n      temp[1] = sX * current[1];\\n      temp[2] = sY * current[2];\\n      temp[3] = current[3];\\n      temp[4] = current[4];\\n      temp[5] = current[5];\\n      temp[6] = sX * current[6];\\n      temp[7] = sY * current[7];\\n    } else if (c === 'h' || c === 'H') {\\n      temp[1] = sX * current[1];\\n    } else if (c === 'v' || c === 'V') {\\n      temp[1] = sY * current[1];\\n    } else {\\n      for (var i=1, n=current.length; i<n; ++i) {\\n        temp[i] = (i % 2 == 1 ? sX : sY) * current[i];\\n      }\\n    }\\n    return temp;\\n  }\\n\\n  function pathRender(context, path, l, t, sX, sY) {\\n    var current, // current instruction\\n        previous = null,\\n        x = 0, // current x\\n        y = 0, // current y\\n        controlX = 0, // current control point x\\n        controlY = 0, // current control point y\\n        tempX,\\n        tempY,\\n        tempControlX,\\n        tempControlY;\\n\\n    if (l == null) l = 0;\\n    if (t == null) t = 0;\\n    if (sX == null) sX = 1;\\n    if (sY == null) sY = sX;\\n\\n    if (context.beginPath) context.beginPath();\\n\\n    for (var i=0, len=path.length; i<len; ++i) {\\n      current = path[i];\\n      if (sX !== 1 || sY !== 1) {\\n        current = scale(current, sX, sY);\\n      }\\n\\n      switch (current[0]) { // first letter\\n\\n        case 'l': // lineto, relative\\n          x += current[1];\\n          y += current[2];\\n          context.lineTo(x + l, y + t);\\n          break;\\n\\n        case 'L': // lineto, absolute\\n          x = current[1];\\n          y = current[2];\\n          context.lineTo(x + l, y + t);\\n          break;\\n\\n        case 'h': // horizontal lineto, relative\\n          x += current[1];\\n          context.lineTo(x + l, y + t);\\n          break;\\n\\n        case 'H': // horizontal lineto, absolute\\n          x = current[1];\\n          context.lineTo(x + l, y + t);\\n          break;\\n\\n        case 'v': // vertical lineto, relative\\n          y += current[1];\\n          context.lineTo(x + l, y + t);\\n          break;\\n\\n        case 'V': // verical lineto, absolute\\n          y = current[1];\\n          context.lineTo(x + l, y + t);\\n          break;\\n\\n        case 'm': // moveTo, relative\\n          x += current[1];\\n          y += current[2];\\n          context.moveTo(x + l, y + t);\\n          break;\\n\\n        case 'M': // moveTo, absolute\\n          x = current[1];\\n          y = current[2];\\n          context.moveTo(x + l, y + t);\\n          break;\\n\\n        case 'c': // bezierCurveTo, relative\\n          tempX = x + current[5];\\n          tempY = y + current[6];\\n          controlX = x + current[3];\\n          controlY = y + current[4];\\n          context.bezierCurveTo(\\n            x + current[1] + l, // x1\\n            y + current[2] + t, // y1\\n            controlX + l, // x2\\n            controlY + t, // y2\\n            tempX + l,\\n            tempY + t\\n          );\\n          x = tempX;\\n          y = tempY;\\n          break;\\n\\n        case 'C': // bezierCurveTo, absolute\\n          x = current[5];\\n          y = current[6];\\n          controlX = current[3];\\n          controlY = current[4];\\n          context.bezierCurveTo(\\n            current[1] + l,\\n            current[2] + t,\\n            controlX + l,\\n            controlY + t,\\n            x + l,\\n            y + t\\n          );\\n          break;\\n\\n        case 's': // shorthand cubic bezierCurveTo, relative\\n          // transform to absolute x,y\\n          tempX = x + current[3];\\n          tempY = y + current[4];\\n          // calculate reflection of previous control points\\n          controlX = 2 * x - controlX;\\n          controlY = 2 * y - controlY;\\n          context.bezierCurveTo(\\n            controlX + l,\\n            controlY + t,\\n            x + current[1] + l,\\n            y + current[2] + t,\\n            tempX + l,\\n            tempY + t\\n          );\\n\\n          // set control point to 2nd one of this command\\n          // the first control point is assumed to be the reflection of\\n          // the second control point on the previous command relative\\n          // to the current point.\\n          controlX = x + current[1];\\n          controlY = y + current[2];\\n\\n          x = tempX;\\n          y = tempY;\\n          break;\\n\\n        case 'S': // shorthand cubic bezierCurveTo, absolute\\n          tempX = current[3];\\n          tempY = current[4];\\n          // calculate reflection of previous control points\\n          controlX = 2*x - controlX;\\n          controlY = 2*y - controlY;\\n          context.bezierCurveTo(\\n            controlX + l,\\n            controlY + t,\\n            current[1] + l,\\n            current[2] + t,\\n            tempX + l,\\n            tempY + t\\n          );\\n          x = tempX;\\n          y = tempY;\\n          // set control point to 2nd one of this command\\n          // the first control point is assumed to be the reflection of\\n          // the second control point on the previous command relative\\n          // to the current point.\\n          controlX = current[1];\\n          controlY = current[2];\\n\\n          break;\\n\\n        case 'q': // quadraticCurveTo, relative\\n          // transform to absolute x,y\\n          tempX = x + current[3];\\n          tempY = y + current[4];\\n\\n          controlX = x + current[1];\\n          controlY = y + current[2];\\n\\n          context.quadraticCurveTo(\\n            controlX + l,\\n            controlY + t,\\n            tempX + l,\\n            tempY + t\\n          );\\n          x = tempX;\\n          y = tempY;\\n          break;\\n\\n        case 'Q': // quadraticCurveTo, absolute\\n          tempX = current[3];\\n          tempY = current[4];\\n\\n          context.quadraticCurveTo(\\n            current[1] + l,\\n            current[2] + t,\\n            tempX + l,\\n            tempY + t\\n          );\\n          x = tempX;\\n          y = tempY;\\n          controlX = current[1];\\n          controlY = current[2];\\n          break;\\n\\n        case 't': // shorthand quadraticCurveTo, relative\\n\\n          // transform to absolute x,y\\n          tempX = x + current[1];\\n          tempY = y + current[2];\\n\\n          if (previous[0].match(/[QqTt]/) === null) {\\n            // If there is no previous command or if the previous command was not a Q, q, T or t,\\n            // assume the control point is coincident with the current point\\n            controlX = x;\\n            controlY = y;\\n          }\\n          else if (previous[0] === 't') {\\n            // calculate reflection of previous control points for t\\n            controlX = 2 * x - tempControlX;\\n            controlY = 2 * y - tempControlY;\\n          }\\n          else if (previous[0] === 'q') {\\n            // calculate reflection of previous control points for q\\n            controlX = 2 * x - controlX;\\n            controlY = 2 * y - controlY;\\n          }\\n\\n          tempControlX = controlX;\\n          tempControlY = controlY;\\n\\n          context.quadraticCurveTo(\\n            controlX + l,\\n            controlY + t,\\n            tempX + l,\\n            tempY + t\\n          );\\n          x = tempX;\\n          y = tempY;\\n          controlX = x + current[1];\\n          controlY = y + current[2];\\n          break;\\n\\n        case 'T':\\n          tempX = current[1];\\n          tempY = current[2];\\n\\n          // calculate reflection of previous control points\\n          controlX = 2 * x - controlX;\\n          controlY = 2 * y - controlY;\\n          context.quadraticCurveTo(\\n            controlX + l,\\n            controlY + t,\\n            tempX + l,\\n            tempY + t\\n          );\\n          x = tempX;\\n          y = tempY;\\n          break;\\n\\n        case 'a':\\n          drawArc(context, x + l, y + t, [\\n            current[1],\\n            current[2],\\n            current[3],\\n            current[4],\\n            current[5],\\n            current[6] + x + l,\\n            current[7] + y + t\\n          ]);\\n          x += current[6];\\n          y += current[7];\\n          break;\\n\\n        case 'A':\\n          drawArc(context, x + l, y + t, [\\n            current[1],\\n            current[2],\\n            current[3],\\n            current[4],\\n            current[5],\\n            current[6] + l,\\n            current[7] + t\\n          ]);\\n          x = current[6];\\n          y = current[7];\\n          break;\\n\\n        case 'z':\\n        case 'Z':\\n          context.closePath();\\n          break;\\n      }\\n      previous = current;\\n    }\\n  }\\n\\n  function drawArc(context, x, y, coords) {\\n    var seg = segments(\\n      coords[5], // end x\\n      coords[6], // end y\\n      coords[0], // radius x\\n      coords[1], // radius y\\n      coords[3], // large flag\\n      coords[4], // sweep flag\\n      coords[2], // rotation\\n      x, y\\n    );\\n    for (var i=0; i<seg.length; ++i) {\\n      var bez = bezier(seg[i]);\\n      context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);\\n    }\\n  }\\n\\n  var Tan30 = 0.5773502691896257;\\n\\n  var builtins = {\\n    'circle': {\\n      draw: function(context, size) {\\n        var r = Math.sqrt(size) / 2;\\n        context.moveTo(r, 0);\\n        context.arc(0, 0, r, 0, Tau);\\n      }\\n    },\\n    'cross': {\\n      draw: function(context, size) {\\n        var r = Math.sqrt(size) / 2,\\n            s = r / 2.5;\\n        context.moveTo(-r, -s);\\n        context.lineTo(-r, s);\\n        context.lineTo(-s, s);\\n        context.lineTo(-s, r);\\n        context.lineTo(s, r);\\n        context.lineTo(s, s);\\n        context.lineTo(r, s);\\n        context.lineTo(r, -s);\\n        context.lineTo(s, -s);\\n        context.lineTo(s, -r);\\n        context.lineTo(-s, -r);\\n        context.lineTo(-s, -s);\\n        context.closePath();\\n      }\\n    },\\n    'diamond': {\\n      draw: function(context, size) {\\n        var r = Math.sqrt(size) / 2;\\n        context.moveTo(-r, 0);\\n        context.lineTo(0, -r);\\n        context.lineTo(r, 0);\\n        context.lineTo(0, r);\\n        context.closePath();\\n      }\\n    },\\n    'square': {\\n      draw: function(context, size) {\\n        var w = Math.sqrt(size),\\n            x = -w / 2;\\n        context.rect(x, x, w, w);\\n      }\\n    },\\n    'arrow': {\\n      draw: function(context, size) {\\n        var r = Math.sqrt(size) / 2,\\n            s = r / 7,\\n            t = r / 2.5,\\n            v = r / 8;\\n        context.moveTo(-s, r);\\n        context.lineTo(s, r);\\n        context.lineTo(s, -v);\\n        context.lineTo(t, -v);\\n        context.lineTo(0, -r);\\n        context.lineTo(-t, -v);\\n        context.lineTo(-s, -v);\\n        context.closePath();\\n      }\\n    },\\n    'wedge': {\\n      draw: function(context, size) {\\n        var r = Math.sqrt(size) / 2,\\n            h = HalfSqrt3 * r,\\n            o = (h - r * Tan30),\\n            b = r / 4;\\n        context.moveTo(0, -h - o);\\n        context.lineTo(-b, h - o);\\n        context.lineTo(b, h - o);\\n        context.closePath();\\n      }\\n    },\\n    'triangle': {\\n      draw: function(context, size) {\\n        var r = Math.sqrt(size) / 2,\\n            h = HalfSqrt3 * r,\\n            o = (h - r * Tan30);\\n        context.moveTo(0, -h - o);\\n        context.lineTo(-r, h - o);\\n        context.lineTo(r, h - o);\\n        context.closePath();\\n      }\\n    },\\n    'triangle-up': {\\n      draw: function(context, size) {\\n        var r = Math.sqrt(size) / 2,\\n            h = HalfSqrt3 * r;\\n        context.moveTo(0, -h);\\n        context.lineTo(-r, h);\\n        context.lineTo(r, h);\\n        context.closePath();\\n      }\\n    },\\n    'triangle-down': {\\n      draw: function(context, size) {\\n        var r = Math.sqrt(size) / 2,\\n            h = HalfSqrt3 * r;\\n        context.moveTo(0, h);\\n        context.lineTo(-r, -h);\\n        context.lineTo(r, -h);\\n        context.closePath();\\n      }\\n    },\\n    'triangle-right': {\\n      draw: function(context, size) {\\n        var r = Math.sqrt(size) / 2,\\n            h = HalfSqrt3 * r;\\n        context.moveTo(h, 0);\\n        context.lineTo(-h, -r);\\n        context.lineTo(-h, r);\\n        context.closePath();\\n      }\\n    },\\n    'triangle-left': {\\n      draw: function(context, size) {\\n        var r = Math.sqrt(size) / 2,\\n            h = HalfSqrt3 * r;\\n        context.moveTo(-h, 0);\\n        context.lineTo(h, -r);\\n        context.lineTo(h, r);\\n        context.closePath();\\n      }\\n    },\\n    'stroke': {\\n      draw: function(context, size) {\\n        var r = Math.sqrt(size) / 2;\\n        context.moveTo(-r, 0);\\n        context.lineTo(r, 0);\\n      }\\n    }\\n  };\\n\\n  function symbols(_) {\\n    return vegaUtil.hasOwnProperty(builtins, _) ? builtins[_] : customSymbol(_);\\n  }\\n\\n  var custom = {};\\n\\n  function customSymbol(path) {\\n    if (!vegaUtil.hasOwnProperty(custom, path)) {\\n      var parsed = pathParse(path);\\n      custom[path] = {\\n        draw: function(context, size) {\\n          pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);\\n        }\\n      };\\n    }\\n    return custom[path];\\n  }\\n\\n  // See http://spencermortensen.com/articles/bezier-circle/\\n  const C = 0.448084975506; // C = 1 - c\\n\\n  function rectangleX(d) {\\n    return d.x;\\n  }\\n\\n  function rectangleY(d) {\\n    return d.y;\\n  }\\n\\n  function rectangleWidth(d) {\\n    return d.width;\\n  }\\n\\n  function rectangleHeight(d) {\\n    return d.height;\\n  }\\n\\n  function number(_) {\\n    return typeof _ === 'function' ? _ : () => +_;\\n  }\\n\\n  function clamp(value, min, max) {\\n    return Math.max(min, Math.min(value, max));\\n  }\\n\\n  function vg_rect() {\\n    var x = rectangleX,\\n        y = rectangleY,\\n        width = rectangleWidth,\\n        height = rectangleHeight,\\n        crTL = number(0),\\n        crTR = crTL,\\n        crBL = crTL,\\n        crBR = crTL,\\n        context = null;\\n\\n    function rectangle(_, x0, y0) {\\n      var buffer,\\n          x1 = x0 != null ? x0 : +x.call(this, _),\\n          y1 = y0 != null ? y0 : +y.call(this, _),\\n          w  = +width.call(this, _),\\n          h  = +height.call(this, _),\\n          s  = Math.min(w, h) / 2,\\n          tl = clamp(+crTL.call(this, _), 0, s),\\n          tr = clamp(+crTR.call(this, _), 0, s),\\n          bl = clamp(+crBL.call(this, _), 0, s),\\n          br = clamp(+crBR.call(this, _), 0, s);\\n\\n      if (!context) context = buffer = d3Path.path();\\n\\n      if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {\\n        context.rect(x1, y1, w, h);\\n      } else {\\n        var x2 = x1 + w,\\n            y2 = y1 + h;\\n        context.moveTo(x1 + tl, y1);\\n        context.lineTo(x2 - tr, y1);\\n        context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);\\n        context.lineTo(x2, y2 - br);\\n        context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);\\n        context.lineTo(x1 + bl, y2);\\n        context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);\\n        context.lineTo(x1, y1 + tl);\\n        context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);\\n        context.closePath();\\n      }\\n\\n      if (buffer) {\\n        context = null;\\n        return buffer + '' || null;\\n      }\\n    }\\n\\n    rectangle.x = function(_) {\\n      if (arguments.length) {\\n        x = number(_);\\n        return rectangle;\\n      } else {\\n        return x;\\n      }\\n    };\\n\\n    rectangle.y = function(_) {\\n      if (arguments.length) {\\n        y = number(_);\\n        return rectangle;\\n      } else {\\n        return y;\\n      }\\n    };\\n\\n    rectangle.width = function(_) {\\n      if (arguments.length) {\\n        width = number(_);\\n        return rectangle;\\n      } else {\\n        return width;\\n      }\\n    };\\n\\n    rectangle.height = function(_) {\\n      if (arguments.length) {\\n        height = number(_);\\n        return rectangle;\\n      } else {\\n        return height;\\n      }\\n    };\\n\\n    rectangle.cornerRadius = function(tl, tr, br, bl) {\\n      if (arguments.length) {\\n        crTL = number(tl);\\n        crTR = tr != null ? number(tr) : crTL;\\n        crBR = br != null ? number(br) : crTL;\\n        crBL = bl != null ? number(bl) : crTR;\\n        return rectangle;\\n      } else {\\n        return crTL;\\n      }\\n    };\\n\\n    rectangle.context = function(_) {\\n      if (arguments.length) {\\n        context = _ == null ? null : _;\\n        return rectangle;\\n      } else {\\n        return context;\\n      }\\n    };\\n\\n    return rectangle;\\n  }\\n\\n  function vg_trail() {\\n    var x,\\n        y,\\n        size,\\n        defined,\\n        context = null,\\n        ready, x1, y1, r1;\\n\\n    function point(x2, y2, w2) {\\n      var r2 = w2 / 2;\\n\\n      if (ready) {\\n        var ux = y1 - y2,\\n            uy = x2 - x1;\\n\\n        if (ux || uy) {\\n          // get normal vector\\n          var ud = Math.sqrt(ux * ux + uy * uy),\\n              rx = (ux /= ud) * r1,\\n              ry = (uy /= ud) * r1,\\n              t = Math.atan2(uy, ux);\\n\\n          // draw segment\\n          context.moveTo(x1 - rx, y1 - ry);\\n          context.lineTo(x2 - ux * r2, y2 - uy * r2);\\n          context.arc(x2, y2, r2, t - Math.PI, t);\\n          context.lineTo(x1 + rx, y1 + ry);\\n          context.arc(x1, y1, r1, t, t + Math.PI);\\n        } else {\\n          context.arc(x2, y2, r2, 0, Tau);\\n        }\\n        context.closePath();\\n      } else {\\n        ready = 1;\\n      }\\n      x1 = x2;\\n      y1 = y2;\\n      r1 = r2;\\n    }\\n\\n    function trail(data) {\\n      var i,\\n          n = data.length,\\n          d,\\n          defined0 = false,\\n          buffer;\\n\\n      if (context == null) context = buffer = d3Path.path();\\n\\n      for (i = 0; i <= n; ++i) {\\n        if (!(i < n && defined(d = data[i], i, data)) === defined0) {\\n          if (defined0 = !defined0) ready = 0;\\n        }\\n        if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));\\n      }\\n\\n      if (buffer) {\\n        context = null;\\n        return buffer + '' || null;\\n      }\\n    }\\n\\n    trail.x = function(_) {\\n      if (arguments.length) {\\n        x = _;\\n        return trail;\\n      } else {\\n        return x;\\n      }\\n    };\\n\\n    trail.y = function(_) {\\n      if (arguments.length) {\\n        y = _;\\n        return trail;\\n      } else {\\n        return y;\\n      }\\n    };\\n\\n    trail.size = function(_) {\\n      if (arguments.length) {\\n        size = _;\\n        return trail;\\n      } else {\\n        return size;\\n      }\\n    };\\n\\n    trail.defined = function(_) {\\n      if (arguments.length) {\\n        defined = _;\\n        return trail;\\n      } else {\\n        return defined;\\n      }\\n    };\\n\\n    trail.context = function(_) {\\n      if (arguments.length) {\\n        if (_ == null) {\\n          context = null;\\n        } else {\\n          context = _;\\n        }\\n        return trail;\\n      } else {\\n        return context;\\n      }\\n    };\\n\\n    return trail;\\n  }\\n\\n  function value(a, b) {\\n    return a != null ? a : b;\\n  }\\n\\n  const x =  item => item.x || 0,\\n        y =  item => item.y || 0,\\n        w =  item => item.width || 0,\\n        h =  item => item.height || 0,\\n        xw = item => (item.x || 0) + (item.width || 0),\\n        yh = item => (item.y || 0) + (item.height || 0),\\n        sa = item => item.startAngle || 0,\\n        ea = item => item.endAngle || 0,\\n        pa = item => item.padAngle || 0,\\n        ir = item => item.innerRadius || 0,\\n        or = item => item.outerRadius || 0,\\n        cr = item => item.cornerRadius || 0,\\n        tl = item => value(item.cornerRadiusTopLeft, item.cornerRadius) || 0,\\n        tr = item => value(item.cornerRadiusTopRight, item.cornerRadius) || 0,\\n        br = item => value(item.cornerRadiusBottomRight, item.cornerRadius) || 0,\\n        bl = item => value(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,\\n        sz = item => value(item.size, 64),\\n        ts = item => item.size || 1,\\n        def = item => !(item.defined === false),\\n        type = item => symbols(item.shape || 'circle');\\n\\n  const arcShape    = d3Shape.arc().startAngle(sa).endAngle(ea).padAngle(pa)\\n                        .innerRadius(ir).outerRadius(or).cornerRadius(cr),\\n        areavShape  = d3Shape.area().x(x).y1(y).y0(yh).defined(def),\\n        areahShape  = d3Shape.area().y(y).x1(x).x0(xw).defined(def),\\n        lineShape   = d3Shape.line().x(x).y(y).defined(def),\\n        rectShape   = vg_rect().x(x).y(y).width(w).height(h)\\n                        .cornerRadius(tl, tr, br, bl),\\n        symbolShape = d3Shape.symbol().type(type).size(sz),\\n        trailShape  = vg_trail().x(x).y(y).defined(def).size(ts);\\n\\n  function hasCornerRadius(item) {\\n    return item.cornerRadius\\n      || item.cornerRadiusTopLeft\\n      || item.cornerRadiusTopRight\\n      || item.cornerRadiusBottomRight\\n      || item.cornerRadiusBottomLeft;\\n  }\\n\\n  function arc(context, item) {\\n    return arcShape.context(context)(item);\\n  }\\n\\n  function area(context, items) {\\n    const item = items[0],\\n          interp = item.interpolate || 'linear';\\n    return (item.orient === 'horizontal' ? areahShape : areavShape)\\n      .curve(curves(interp, item.orient, item.tension))\\n      .context(context)(items);\\n  }\\n\\n  function line(context, items) {\\n    const item = items[0],\\n          interp = item.interpolate || 'linear';\\n    return lineShape.curve(curves(interp, item.orient, item.tension))\\n      .context(context)(items);\\n  }\\n\\n  function rectangle(context, item, x, y) {\\n    return rectShape.context(context)(item, x, y);\\n  }\\n\\n  function shape(context, item) {\\n    return (item.mark.shape || item.shape)\\n      .context(context)(item);\\n  }\\n\\n  function symbol(context, item) {\\n    return symbolShape.context(context)(item);\\n  }\\n\\n  function trail(context, items) {\\n    return trailShape.context(context)(items);\\n  }\\n\\n  var clip_id = 1;\\n\\n  function resetSVGClipId() {\\n    clip_id = 1;\\n  }\\n\\n  function clip(renderer, item, size) {\\n    var clip = item.clip,\\n        defs = renderer._defs,\\n        id = item.clip_id || (item.clip_id = 'clip' + clip_id++),\\n        c = defs.clipping[id] || (defs.clipping[id] = {id: id});\\n\\n    if (vegaUtil.isFunction(clip)) {\\n      c.path = clip(null);\\n    } else if (hasCornerRadius(size)) {\\n      c.path = rectangle(null, size, 0, 0);\\n    } else {\\n      c.width = size.width || 0;\\n      c.height = size.height || 0;\\n    }\\n\\n    return 'url(#' + id + ')';\\n  }\\n\\n  function Bounds(b) {\\n    this.clear();\\n    if (b) this.union(b);\\n  }\\n\\n  Bounds.prototype = {\\n    clone() {\\n      return new Bounds(this);\\n    },\\n\\n    clear() {\\n      this.x1 = +Number.MAX_VALUE;\\n      this.y1 = +Number.MAX_VALUE;\\n      this.x2 = -Number.MAX_VALUE;\\n      this.y2 = -Number.MAX_VALUE;\\n      return this;\\n    },\\n\\n    empty() {\\n      return (\\n        this.x1 === +Number.MAX_VALUE &&\\n        this.y1 === +Number.MAX_VALUE &&\\n        this.x2 === -Number.MAX_VALUE &&\\n        this.y2 === -Number.MAX_VALUE\\n      );\\n    },\\n\\n    equals(b) {\\n      return (\\n        this.x1 === b.x1 &&\\n        this.y1 === b.y1 &&\\n        this.x2 === b.x2 &&\\n        this.y2 === b.y2\\n      );\\n    },\\n\\n    set(x1, y1, x2, y2) {\\n      if (x2 < x1) {\\n        this.x2 = x1;\\n        this.x1 = x2;\\n      } else {\\n        this.x1 = x1;\\n        this.x2 = x2;\\n      }\\n      if (y2 < y1) {\\n        this.y2 = y1;\\n        this.y1 = y2;\\n      } else {\\n        this.y1 = y1;\\n        this.y2 = y2;\\n      }\\n      return this;\\n    },\\n\\n    add(x, y) {\\n      if (x < this.x1) this.x1 = x;\\n      if (y < this.y1) this.y1 = y;\\n      if (x > this.x2) this.x2 = x;\\n      if (y > this.y2) this.y2 = y;\\n      return this;\\n    },\\n\\n    expand(d) {\\n      this.x1 -= d;\\n      this.y1 -= d;\\n      this.x2 += d;\\n      this.y2 += d;\\n      return this;\\n    },\\n\\n    round() {\\n      this.x1 = Math.floor(this.x1);\\n      this.y1 = Math.floor(this.y1);\\n      this.x2 = Math.ceil(this.x2);\\n      this.y2 = Math.ceil(this.y2);\\n      return this;\\n    },\\n\\n    scale(s) {\\n      this.x1 *= s;\\n      this.y1 *= s;\\n      this.x2 *= s;\\n      this.y2 *= s;\\n      return this;\\n    },\\n\\n    translate(dx, dy) {\\n      this.x1 += dx;\\n      this.x2 += dx;\\n      this.y1 += dy;\\n      this.y2 += dy;\\n      return this;\\n    },\\n\\n    rotate(angle, x, y) {\\n      const p = this.rotatedPoints(angle, x, y);\\n      return this.clear()\\n        .add(p[0], p[1])\\n        .add(p[2], p[3])\\n        .add(p[4], p[5])\\n        .add(p[6], p[7]);\\n    },\\n\\n    rotatedPoints(angle, x, y) {\\n      var {x1, y1, x2, y2} = this,\\n          cos = Math.cos(angle),\\n          sin = Math.sin(angle),\\n          cx = x - x * cos + y * sin,\\n          cy = y - x * sin - y * cos;\\n\\n      return [\\n        cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy,\\n        cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy,\\n        cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy,\\n        cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy\\n      ];\\n    },\\n\\n    union(b) {\\n      if (b.x1 < this.x1) this.x1 = b.x1;\\n      if (b.y1 < this.y1) this.y1 = b.y1;\\n      if (b.x2 > this.x2) this.x2 = b.x2;\\n      if (b.y2 > this.y2) this.y2 = b.y2;\\n      return this;\\n    },\\n\\n    intersect(b) {\\n      if (b.x1 > this.x1) this.x1 = b.x1;\\n      if (b.y1 > this.y1) this.y1 = b.y1;\\n      if (b.x2 < this.x2) this.x2 = b.x2;\\n      if (b.y2 < this.y2) this.y2 = b.y2;\\n      return this;\\n    },\\n\\n    encloses(b) {\\n      return b && (\\n        this.x1 <= b.x1 &&\\n        this.x2 >= b.x2 &&\\n        this.y1 <= b.y1 &&\\n        this.y2 >= b.y2\\n      );\\n    },\\n\\n    alignsWith(b) {\\n      return b && (\\n        this.x1 == b.x1 ||\\n        this.x2 == b.x2 ||\\n        this.y1 == b.y1 ||\\n        this.y2 == b.y2\\n      );\\n    },\\n\\n    intersects(b) {\\n      return b && !(\\n        this.x2 < b.x1 ||\\n        this.x1 > b.x2 ||\\n        this.y2 < b.y1 ||\\n        this.y1 > b.y2\\n      );\\n    },\\n\\n    contains(x, y) {\\n      return !(\\n        x < this.x1 ||\\n        x > this.x2 ||\\n        y < this.y1 ||\\n        y > this.y2\\n      );\\n    },\\n\\n    width() {\\n      return this.x2 - this.x1;\\n    },\\n\\n    height() {\\n      return this.y2 - this.y1;\\n    }\\n  };\\n\\n  function Item(mark) {\\n    this.mark = mark;\\n    this.bounds = (this.bounds || new Bounds());\\n  }\\n\\n  function GroupItem(mark) {\\n    Item.call(this, mark);\\n    this.items = (this.items || []);\\n  }\\n\\n  vegaUtil.inherits(GroupItem, Item);\\n\\n  function ResourceLoader(customLoader) {\\n    this._pending = 0;\\n    this._loader = customLoader || vegaLoader.loader();\\n  }\\n\\n  function increment(loader) {\\n    loader._pending += 1;\\n  }\\n\\n  function decrement(loader) {\\n    loader._pending -= 1;\\n  }\\n\\n  ResourceLoader.prototype = {\\n    pending() {\\n      return this._pending;\\n    },\\n\\n    sanitizeURL(uri) {\\n      var loader = this;\\n      increment(loader);\\n\\n      return loader._loader.sanitize(uri, {context:'href'})\\n        .then(opt => {\\n          decrement(loader);\\n          return opt;\\n        })\\n        .catch(() => {\\n          decrement(loader);\\n          return null;\\n        });\\n    },\\n\\n    loadImage(uri) {\\n      const loader = this,\\n            Image = vegaCanvas.image();\\n      increment(loader);\\n\\n      return loader._loader\\n        .sanitize(uri, {context: 'image'})\\n        .then(opt => {\\n          const url = opt.href;\\n          if (!url || !Image) throw {url: url};\\n\\n          const img = new Image();\\n\\n          // set crossOrigin only if cors is defined; empty string sets anonymous mode\\n          // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin\\n          const cors = vegaUtil.hasOwnProperty(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';\\n          if (cors != null) img.crossOrigin = cors;\\n\\n          // attempt to load image resource\\n          img.onload = () => decrement(loader);\\n          img.onerror = () => decrement(loader);\\n          img.src = url;\\n\\n          return img;\\n        })\\n        .catch(e => {\\n          decrement(loader);\\n          return {complete: false, width: 0, height: 0, src: e && e.url || ''};\\n        });\\n    },\\n\\n    ready() {\\n      var loader = this;\\n      return new Promise(accept => {\\n        function poll(value) {\\n          if (!loader.pending()) accept(value);\\n          else setTimeout(() => { poll(true); }, 10);\\n        }\\n        poll(false);\\n      });\\n    }\\n  };\\n\\n  function boundStroke(bounds, item, miter) {\\n    if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {\\n      const sw = item.strokeWidth != null ? +item.strokeWidth : 1;\\n      bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));\\n    }\\n    return bounds;\\n  }\\n\\n  function miterAdjustment(item, strokeWidth) {\\n    // TODO: more sophisticated adjustment? Or miter support in boundContext?\\n    return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;\\n  }\\n\\n  const circleThreshold = Tau - 1e-8;\\n  let bounds, lx, ly, rot, ma, mb, mc, md;\\n\\n  const add = (x, y) => bounds.add(x, y);\\n  const addL = (x, y) => add(lx = x, ly = y);\\n  const addX = x => add(x, bounds.y1);\\n  const addY = y => add(bounds.x1, y);\\n\\n  const px = (x, y) => ma * x + mc * y;\\n  const py = (x, y) => mb * x + md * y;\\n  const addp = (x, y) => add(px(x, y), py(x, y));\\n  const addpL = (x, y) => addL(px(x, y), py(x, y));\\n\\n  function boundContext(_, deg) {\\n    bounds = _;\\n    if (deg) {\\n      rot = deg * DegToRad;\\n      ma = md = Math.cos(rot);\\n      mb = Math.sin(rot);\\n      mc = -mb;\\n    } else {\\n      ma = md = 1;\\n      rot = mb = mc = 0;\\n    }\\n    return context;\\n  }\\n\\n  const context = {\\n    beginPath() {},\\n    closePath() {},\\n\\n    moveTo: addpL,\\n    lineTo: addpL,\\n\\n    rect(x, y, w, h) {\\n      if (rot) {\\n        addp(x + w, y);\\n        addp(x + w, y + h);\\n        addp(x, y + h);\\n        addpL(x, y);\\n      } else {\\n        add(x + w, y + h);\\n        addL(x, y);\\n      }\\n    },\\n\\n    quadraticCurveTo(x1, y1, x2, y2) {\\n      const px1 = px(x1, y1),\\n            py1 = py(x1, y1),\\n            px2 = px(x2, y2),\\n            py2 = py(x2, y2);\\n      quadExtrema(lx, px1, px2, addX);\\n      quadExtrema(ly, py1, py2, addY);\\n      addL(px2, py2);\\n    },\\n\\n    bezierCurveTo(x1, y1, x2, y2, x3, y3) {\\n      const px1 = px(x1, y1),\\n            py1 = py(x1, y1),\\n            px2 = px(x2, y2),\\n            py2 = py(x2, y2),\\n            px3 = px(x3, y3),\\n            py3 = py(x3, y3);\\n      cubicExtrema(lx, px1, px2, px3, addX);\\n      cubicExtrema(ly, py1, py2, py3, addY);\\n      addL(px3, py3);\\n    },\\n\\n    arc(cx, cy, r, sa, ea, ccw) {\\n      sa += rot;\\n      ea += rot;\\n\\n      // store last point on path\\n      lx = r * Math.cos(ea) + cx;\\n      ly = r * Math.sin(ea) + cy;\\n\\n      if (Math.abs(ea - sa) > circleThreshold) {\\n        // treat as full circle\\n        add(cx - r, cy - r);\\n        add(cx + r, cy + r);\\n      } else {\\n        const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);\\n        let s, i;\\n\\n        // sample end points\\n        update(sa);\\n        update(ea);\\n\\n        // sample interior points aligned with 90 degrees\\n        if (ea !== sa) {\\n          sa = sa % Tau; if (sa < 0) sa += Tau;\\n          ea = ea % Tau; if (ea < 0) ea += Tau;\\n\\n          if (ea < sa) {\\n            ccw = !ccw; // flip direction\\n            s = sa; sa = ea; ea = s; // swap end-points\\n          }\\n\\n          if (ccw) {\\n            ea -= Tau;\\n            s = sa - (sa % HalfPi);\\n            for (i=0; i<4 && s>ea; ++i, s-=HalfPi) update(s);\\n          } else {\\n            s = sa - (sa % HalfPi) + HalfPi;\\n            for (i=0; i<4 && s<ea; ++i, s=s+HalfPi) update(s);\\n          }\\n        }\\n      }\\n    }\\n  };\\n\\n  function quadExtrema(x0, x1, x2, cb) {\\n    const t = (x0 - x1) / (x0 + x2 - 2 * x1);\\n    if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);\\n  }\\n\\n  function cubicExtrema(x0, x1, x2, x3, cb) {\\n    const a = x3 - x0 + 3 * x1 - 3 * x2,\\n          b = x0 + x2 - 2 * x1,\\n          c = x0 - x1;\\n\\n    let t0 = 0, t1 = 0, r;\\n\\n    // solve for parameter t\\n    if (Math.abs(a) > Epsilon) {\\n      // quadratic equation\\n      r = b * b + c * a;\\n      if (r >= 0) {\\n        r = Math.sqrt(r);\\n        t0 = (-b + r) / a;\\n        t1 = (-b - r) / a;\\n      }\\n    } else {\\n      // linear equation\\n      t0 = 0.5 * c / b;\\n    }\\n\\n    // calculate position\\n    if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));\\n    if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));\\n  }\\n\\n  function cubic(t, x0, x1, x2, x3) {\\n    const s = 1 - t, s2 = s * s, t2 = t * t;\\n    return (s2 * s * x0) + (3 * s2 * t * x1) + (3 * s * t2 * x2) + (t2 * t * x3);\\n  }\\n\\n  var context$1 = (context$1 = vegaCanvas.canvas(1,1))\\n    ? context$1.getContext('2d')\\n    : null;\\n\\n  const b = new Bounds();\\n\\n  function intersectPath(draw) {\\n    return function(item, brush) {\\n      // rely on (inaccurate) bounds intersection if no context\\n      if (!context$1) return true;\\n\\n      // add path to offscreen graphics context\\n      draw(context$1, item);\\n\\n      // get bounds intersection region\\n      b.clear().union(item.bounds).intersect(brush).round();\\n      const {x1, y1, x2, y2} = b;\\n\\n      // iterate over intersection region\\n      // perform fine grained inclusion test\\n      for (let y = y1; y <= y2; ++y) {\\n        for (let x = x1; x <= x2; ++x) {\\n          if (context$1.isPointInPath(x, y)) {\\n            return true;\\n          }\\n        }\\n      }\\n\\n      // false if no hits in intersection region\\n      return false;\\n    };\\n  }\\n\\n  function intersectPoint(item, box) {\\n    return box.contains(item.x || 0, item.y || 0);\\n  }\\n\\n  function intersectRect(item, box) {\\n    const x = item.x || 0,\\n          y = item.y || 0,\\n          w = item.width || 0,\\n          h = item.height || 0;\\n    return box.intersects(b.set(x, y, x + w, y + h));\\n  }\\n\\n  function intersectRule(item, box) {\\n    const x = item.x || 0,\\n          y = item.y || 0,\\n          x2 = item.x2 != null ? item.x2 : x,\\n          y2 = item.y2 != null ? item.y2 : y;\\n    return intersectBoxLine(box, x, y, x2, y2);\\n  }\\n\\n  function intersectBoxLine(box, x, y, u, v) {\\n    const {x1, y1, x2, y2} = box,\\n          dx = u - x,\\n          dy = v - y;\\n\\n    let t0 = 0, t1 = 1, p, q, r, e;\\n\\n    for (e=0; e<4; ++e) {\\n      if (e === 0) { p = -dx; q = -(x1 - x); }\\n      if (e === 1) { p =  dx; q =  (x2 - x); }\\n      if (e === 2) { p = -dy; q = -(y1 - y); }\\n      if (e === 3) { p =  dy; q =  (y2 - y); }\\n\\n      if (Math.abs(p) < 1e-10 && q < 0) return false;\\n\\n      r = q / p;\\n\\n      if (p < 0) {\\n        if (r > t1) return false;\\n        else if (r > t0) t0 = r;\\n      } else if (p > 0) {\\n        if (r < t0) return false;\\n        else if (r < t1) t1 = r;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  function blend(context, item) {\\n    context.globalCompositeOperation = item.blend || 'source-over';\\n  }\\n\\n  function value$1(value, dflt) {\\n    return value == null ? dflt : value;\\n  }\\n\\n  function addStops(gradient, stops) {\\n    const n = stops.length;\\n    for (let i=0; i<n; ++i) {\\n      gradient.addColorStop(stops[i].offset, stops[i].color);\\n    }\\n    return gradient;\\n  }\\n\\n  function gradient(context, spec, bounds) {\\n    const w = bounds.width(),\\n          h = bounds.height();\\n    let gradient;\\n\\n\\n    if (spec.gradient === 'radial') {\\n      gradient = context.createRadialGradient(\\n        bounds.x1 + value$1(spec.x1, 0.5) * w,\\n        bounds.y1 + value$1(spec.y1, 0.5) * h,\\n        Math.max(w, h) * value$1(spec.r1, 0),\\n        bounds.x1 + value$1(spec.x2, 0.5) * w,\\n        bounds.y1 + value$1(spec.y2, 0.5) * h,\\n        Math.max(w, h) * value$1(spec.r2, 0.5)\\n      );\\n    } else { // linear gradient\\n      const x1 = value$1(spec.x1, 0),\\n            y1 = value$1(spec.y1, 0),\\n            x2 = value$1(spec.x2, 1),\\n            y2 = value$1(spec.y2, 0);\\n\\n      if (x1 === x2 || y1 === y2 || w === h) {\\n        // axis aligned: use normal gradient\\n        gradient = context.createLinearGradient(\\n          bounds.x1 + x1 * w,\\n          bounds.y1 + y1 * h,\\n          bounds.x1 + x2 * w,\\n          bounds.y1 + y2 * h\\n        );\\n      } else {\\n        // not axis aligned: render gradient into a pattern (#2365)\\n        // this allows us to use normalized bounding box coordinates\\n        const image = vegaCanvas.canvas(Math.ceil(w), Math.ceil(h)),\\n              ictx = image.getContext('2d');\\n\\n        ictx.scale(w, h);\\n        ictx.fillStyle = addStops(\\n          ictx.createLinearGradient(x1, y1, x2, y2),\\n          spec.stops\\n        );\\n        ictx.fillRect(0, 0, w, h);\\n\\n        return context.createPattern(image, 'no-repeat');\\n      }\\n    }\\n\\n    return addStops(gradient, spec.stops);\\n  }\\n\\n  function color(context, item, value) {\\n    return isGradient(value)\\n      ? gradient(context, value, item.bounds)\\n      : value;\\n  }\\n\\n  function fill(context, item, opacity) {\\n    opacity *= (item.fillOpacity==null ? 1 : item.fillOpacity);\\n    if (opacity > 0) {\\n      context.globalAlpha = opacity;\\n      context.fillStyle = color(context, item, item.fill);\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  var Empty = [];\\n\\n  function stroke(context, item, opacity) {\\n    var lw = (lw = item.strokeWidth) != null ? lw : 1;\\n\\n    if (lw <= 0) return false;\\n\\n    opacity *= (item.strokeOpacity==null ? 1 : item.strokeOpacity);\\n    if (opacity > 0) {\\n      context.globalAlpha = opacity;\\n      context.strokeStyle = color(context, item, item.stroke);\\n\\n      context.lineWidth = lw;\\n      context.lineCap = item.strokeCap || 'butt';\\n      context.lineJoin = item.strokeJoin || 'miter';\\n      context.miterLimit = item.strokeMiterLimit || 10;\\n\\n      if (context.setLineDash) {\\n        context.setLineDash(item.strokeDash || Empty);\\n        context.lineDashOffset = item.strokeDashOffset || 0;\\n      }\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function compare(a, b) {\\n    return a.zindex - b.zindex || a.index - b.index;\\n  }\\n\\n  function zorder(scene) {\\n    if (!scene.zdirty) return scene.zitems;\\n\\n    var items = scene.items,\\n        output = [], item, i, n;\\n\\n    for (i=0, n=items.length; i<n; ++i) {\\n      item = items[i];\\n      item.index = i;\\n      if (item.zindex) output.push(item);\\n    }\\n\\n    scene.zdirty = false;\\n    return scene.zitems = output.sort(compare);\\n  }\\n\\n  function visit(scene, visitor) {\\n    var items = scene.items, i, n;\\n    if (!items || !items.length) return;\\n\\n    var zitems = zorder(scene);\\n\\n    if (zitems && zitems.length) {\\n      for (i=0, n=items.length; i<n; ++i) {\\n        if (!items[i].zindex) visitor(items[i]);\\n      }\\n      items = zitems;\\n    }\\n\\n    for (i=0, n=items.length; i<n; ++i) {\\n      visitor(items[i]);\\n    }\\n  }\\n\\n  function pickVisit(scene, visitor) {\\n    var items = scene.items, hit, i;\\n    if (!items || !items.length) return null;\\n\\n    var zitems = zorder(scene);\\n    if (zitems && zitems.length) items = zitems;\\n\\n    for (i=items.length; --i >= 0;) {\\n      if (hit = visitor(items[i])) return hit;\\n    }\\n\\n    if (items === zitems) {\\n      for (items=scene.items, i=items.length; --i >= 0;) {\\n        if (!items[i].zindex) {\\n          if (hit = visitor(items[i])) return hit;\\n        }\\n      }\\n    }\\n\\n    return null;\\n  }\\n\\n  function drawAll(path) {\\n    return function(context, scene, bounds) {\\n      visit(scene, item => {\\n        if (!bounds || bounds.intersects(item.bounds)) {\\n          drawPath(path, context, item, item);\\n        }\\n      });\\n    };\\n  }\\n\\n  function drawOne(path) {\\n    return function(context, scene, bounds) {\\n      if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {\\n        drawPath(path, context, scene.items[0], scene.items);\\n      }\\n    };\\n  }\\n\\n  function drawPath(path, context, item, items) {\\n    var opacity = item.opacity == null ? 1 : item.opacity;\\n    if (opacity === 0) return;\\n\\n    if (path(context, items)) return;\\n\\n    blend(context, item);\\n\\n    if (item.fill && fill(context, item, opacity)) {\\n      context.fill();\\n    }\\n\\n    if (item.stroke && stroke(context, item, opacity)) {\\n      context.stroke();\\n    }\\n  }\\n\\n  function pick(test) {\\n    test = test || vegaUtil.truthy;\\n\\n    return function(context, scene, x, y, gx, gy) {\\n      x *= context.pixelRatio;\\n      y *= context.pixelRatio;\\n\\n      return pickVisit(scene, item => {\\n        var b = item.bounds;\\n        // first hit test against bounding box\\n        if ((b && !b.contains(gx, gy)) || !b) return;\\n        // if in bounding box, perform more careful test\\n        if (test(context, item, x, y, gx, gy)) return item;\\n      });\\n    };\\n  }\\n\\n  function hitPath(path, filled) {\\n    return function(context, o, x, y) {\\n      var item = Array.isArray(o) ? o[0] : o,\\n          fill = (filled == null) ? item.fill : filled,\\n          stroke = item.stroke && context.isPointInStroke, lw, lc;\\n\\n      if (stroke) {\\n        lw = item.strokeWidth;\\n        lc = item.strokeCap;\\n        context.lineWidth = lw != null ? lw : 1;\\n        context.lineCap   = lc != null ? lc : 'butt';\\n      }\\n\\n      return path(context, o) ? false :\\n        (fill && context.isPointInPath(x, y)) ||\\n        (stroke && context.isPointInStroke(x, y));\\n    };\\n  }\\n\\n  function pickPath(path) {\\n    return pick(hitPath(path));\\n  }\\n\\n  function translate(x, y) {\\n    return 'translate(' + x + ',' + y + ')';\\n  }\\n\\n  function rotate(a) {\\n    return 'rotate(' + a + ')';\\n  }\\n\\n  function scale$1(scaleX, scaleY){\\n    return 'scale('+ scaleX + ',' + scaleY+')';\\n  }\\n\\n  function translateItem(item) {\\n    return translate(item.x || 0, item.y || 0);\\n  }\\n\\n  function rotateItem(item) {\\n    return translate(item.x || 0, item.y || 0)\\n      + (item.angle ? ' ' + rotate(item.angle) : '');\\n  }\\n\\n  function transformItem(item) {\\n    return translate(item.x || 0, item.y || 0)\\n      + (item.angle ? ' ' + rotate(item.angle) : '')\\n      + (item.scaleX || item.scaleY ? ' ' + scale$1(item.scaleX || 1, item.scaleY || 1) : '');\\n  }\\n\\n  function markItemPath(type, shape, isect) {\\n\\n    function attr(emit, item) {\\n      emit('transform', rotateItem(item));\\n      emit('d', shape(null, item));\\n    }\\n\\n    function bound(bounds, item) {\\n      shape(boundContext(bounds, item.angle), item);\\n      return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);\\n    }\\n\\n    function draw(context, item) {\\n      var x = item.x || 0,\\n          y = item.y || 0,\\n          a = item.angle || 0;\\n\\n      context.translate(x, y);\\n      if (a) context.rotate(a *= DegToRad);\\n      context.beginPath();\\n      shape(context, item);\\n      if (a) context.rotate(-a);\\n      context.translate(-x, -y);\\n    }\\n\\n    return {\\n      type:   type,\\n      tag:    'path',\\n      nested: false,\\n      attr:   attr,\\n      bound:  bound,\\n      draw:   drawAll(draw),\\n      pick:   pickPath(draw),\\n      isect:  isect || intersectPath(draw)\\n    };\\n\\n  }\\n\\n  var arc$1 = markItemPath('arc', arc);\\n\\n  function pickArea(a, p) {\\n    var v = a[0].orient === 'horizontal' ? p[1] : p[0],\\n        z = a[0].orient === 'horizontal' ? 'y' : 'x',\\n        i = a.length,\\n        min = +Infinity, hit, d;\\n\\n    while (--i >= 0) {\\n      if (a[i].defined === false) continue;\\n      d = Math.abs(a[i][z] - v);\\n      if (d < min) {\\n        min = d;\\n        hit = a[i];\\n      }\\n    }\\n\\n    return hit;\\n  }\\n\\n  function pickLine(a, p) {\\n    var t = Math.pow(a[0].strokeWidth || 1, 2),\\n        i = a.length, dx, dy, dd;\\n\\n    while (--i >= 0) {\\n      if (a[i].defined === false) continue;\\n      dx = a[i].x - p[0];\\n      dy = a[i].y - p[1];\\n      dd = dx * dx + dy * dy;\\n      if (dd < t) return a[i];\\n    }\\n\\n    return null;\\n  }\\n\\n  function pickTrail(a, p) {\\n    var i = a.length, dx, dy, dd;\\n\\n    while (--i >= 0) {\\n      if (a[i].defined === false) continue;\\n      dx = a[i].x - p[0];\\n      dy = a[i].y - p[1];\\n      dd = dx * dx + dy * dy;\\n      dx = a[i].size || 1;\\n      if (dd < dx*dx) return a[i];\\n    }\\n\\n    return null;\\n  }\\n\\n  function markMultiItemPath(type, shape, tip) {\\n\\n    function attr(emit, item) {\\n      var items = item.mark.items;\\n      if (items.length) emit('d', shape(null, items));\\n    }\\n\\n    function bound(bounds, mark) {\\n      var items = mark.items;\\n      if (items.length === 0) {\\n        return bounds;\\n      } else {\\n        shape(boundContext(bounds), items);\\n        return boundStroke(bounds, items[0]);\\n      }\\n    }\\n\\n    function draw(context, items) {\\n      context.beginPath();\\n      shape(context, items);\\n    }\\n\\n    var hit = hitPath(draw);\\n\\n    function pick(context, scene, x, y, gx, gy) {\\n      var items = scene.items,\\n          b = scene.bounds;\\n\\n      if (!items || !items.length || b && !b.contains(gx, gy)) {\\n        return null;\\n      }\\n\\n      x *= context.pixelRatio;\\n      y *= context.pixelRatio;\\n      return hit(context, items, x, y) ? items[0] : null;\\n    }\\n\\n    return {\\n      type:   type,\\n      tag:    'path',\\n      nested: true,\\n      attr:   attr,\\n      bound:  bound,\\n      draw:   drawOne(draw),\\n      pick:   pick,\\n      isect:  intersectPoint,\\n      tip:    tip\\n    };\\n\\n  }\\n\\n  var area$1 = markMultiItemPath('area', area, pickArea);\\n\\n  function clip$1(context, scene) {\\n    var clip = scene.clip;\\n\\n    context.save();\\n\\n    if (vegaUtil.isFunction(clip)) {\\n      context.beginPath();\\n      clip(context);\\n      context.clip();\\n    } else {\\n      clipGroup(context, scene.group);\\n    }\\n  }\\n\\n  function clipGroup(context, group) {\\n    context.beginPath();\\n    hasCornerRadius(group)\\n      ? rectangle(context, group, 0, 0)\\n      : context.rect(0, 0, group.width || 0, group.height || 0);\\n    context.clip();\\n  }\\n\\n  function offset(item) {\\n    const sw = value$1(item.strokeWidth, 1);\\n    return item.strokeOffset != null ? item.strokeOffset\\n      : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1)\\n      : 0;\\n  }\\n\\n  function attr(emit, item) {\\n    emit('transform', translateItem(item));\\n  }\\n\\n  function emitRectangle(emit, item) {\\n    const off = offset(item);\\n    emit('d', rectangle(null, item, off, off));\\n  }\\n\\n  function background(emit, item) {\\n    emit('class', 'background');\\n    emit('aria-hidden', true);\\n    emitRectangle(emit, item);\\n  }\\n\\n  function foreground(emit, item) {\\n    emit('class', 'foreground');\\n    emit('aria-hidden', true);\\n    if (item.strokeForeground) {\\n      emitRectangle(emit, item);\\n    } else {\\n      emit('d', '');\\n    }\\n  }\\n\\n  function content(emit, item, renderer) {\\n    const url = item.clip ? clip(renderer, item, item) : null;\\n    emit('clip-path', url);\\n  }\\n\\n  function bound(bounds, group) {\\n    if (!group.clip && group.items) {\\n      const items = group.items, m = items.length;\\n      for (let j=0; j<m; ++j) {\\n        bounds.union(items[j].bounds);\\n      }\\n    }\\n\\n    if ((group.clip || group.width || group.height) && !group.noBound) {\\n      bounds.add(0, 0).add(group.width || 0, group.height || 0);\\n    }\\n\\n    boundStroke(bounds, group);\\n\\n    return bounds.translate(group.x || 0, group.y || 0);\\n  }\\n\\n  function rectanglePath(context, group, x, y) {\\n    const off = offset(group);\\n    context.beginPath();\\n    rectangle(context, group, (x || 0) + off, (y || 0) + off);\\n  }\\n\\n  const hitBackground = hitPath(rectanglePath);\\n  const hitForeground = hitPath(rectanglePath, false);\\n  const hitCorner = hitPath(rectanglePath, true);\\n\\n  function draw(context, scene, bounds) {\\n    visit(scene, group => {\\n      const gx = group.x || 0,\\n            gy = group.y || 0,\\n            fore = group.strokeForeground,\\n            opacity = group.opacity == null ? 1 : group.opacity;\\n\\n      // draw group background\\n      if ((group.stroke || group.fill) && opacity) {\\n        rectanglePath(context, group, gx, gy);\\n        blend(context, group);\\n        if (group.fill && fill(context, group, opacity)) {\\n          context.fill();\\n        }\\n        if (group.stroke && !fore && stroke(context, group, opacity)) {\\n          context.stroke();\\n        }\\n      }\\n\\n      // setup graphics context, set clip and bounds\\n      context.save();\\n      context.translate(gx, gy);\\n      if (group.clip) clipGroup(context, group);\\n      if (bounds) bounds.translate(-gx, -gy);\\n\\n      // draw group contents\\n      visit(group, item => {\\n        this.draw(context, item, bounds);\\n      });\\n\\n      // restore graphics context\\n      if (bounds) bounds.translate(gx, gy);\\n      context.restore();\\n\\n      // draw group foreground\\n      if (fore && group.stroke && opacity) {\\n        rectanglePath(context, group, gx, gy);\\n        blend(context, group);\\n        if (stroke(context, group, opacity)) {\\n          context.stroke();\\n        }\\n      }\\n    });\\n  }\\n\\n  function pick$1(context, scene, x, y, gx, gy) {\\n    if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {\\n      return null;\\n    }\\n\\n    const cx = x * context.pixelRatio,\\n          cy = y * context.pixelRatio;\\n\\n    return pickVisit(scene, group => {\\n      let hit, dx, dy;\\n\\n      // first hit test bounding box\\n      const b = group.bounds;\\n      if (b && !b.contains(gx, gy)) return;\\n\\n      // passed bounds check, test rectangular clip\\n      dx = group.x || 0;\\n      dy = group.y || 0;\\n      const dw = dx + (group.width || 0),\\n            dh = dy + (group.height || 0),\\n            c = group.clip;\\n      if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return;\\n\\n      // adjust coordinate system\\n      context.save();\\n      context.translate(dx, dy);\\n      dx = gx - dx;\\n      dy = gy - dy;\\n\\n      // test background for rounded corner clip\\n      if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {\\n        context.restore();\\n        return null;\\n      }\\n\\n      const fore = group.strokeForeground,\\n            ix = scene.interactive !== false;\\n\\n      // hit test against group foreground\\n      if (ix && fore && group.stroke\\n          && hitForeground(context, group, cx, cy)) {\\n        context.restore();\\n        return group;\\n      }\\n\\n      // hit test against contained marks\\n      hit = pickVisit(group, mark => pickMark(mark, dx, dy)\\n        ? this.pick(mark, x, y, dx, dy)\\n        : null\\n      );\\n\\n      // hit test against group background\\n      if (!hit && ix && (group.fill || (!fore && group.stroke))\\n          && hitBackground(context, group, cx, cy)) {\\n        hit = group;\\n      }\\n\\n      // restore state and return\\n      context.restore();\\n      return hit || null;\\n    });\\n  }\\n\\n  function pickMark(mark, x, y) {\\n    return (mark.interactive !== false || mark.marktype === 'group')\\n      && mark.bounds && mark.bounds.contains(x, y);\\n  }\\n\\n  var group = {\\n    type:       'group',\\n    tag:        'g',\\n    nested:     false,\\n    attr:       attr,\\n    bound:      bound,\\n    draw:       draw,\\n    pick:       pick$1,\\n    isect:      intersectRect,\\n    content:    content,\\n    background: background,\\n    foreground: foreground\\n  };\\n\\n  var metadata = {\\n    'xmlns': 'http://www.w3.org/2000/svg',\\n    'xmlns:xlink': 'http://www.w3.org/1999/xlink',\\n    'version': '1.1'\\n  };\\n\\n  function getImage(item, renderer) {\\n    var image = item.image;\\n    if (!image || item.url && item.url !== image.url) {\\n      image = {complete: false, width: 0, height: 0};\\n      renderer.loadImage(item.url).then(image => {\\n        item.image = image;\\n        item.image.url = item.url;\\n      });\\n    }\\n    return image;\\n  }\\n\\n  function imageWidth(item, image) {\\n    return item.width != null ? item.width\\n      : !image || !image.width ? 0\\n      : item.aspect !== false && item.height ? item.height * image.width / image.height\\n      : image.width;\\n  }\\n\\n  function imageHeight(item, image) {\\n    return item.height != null ? item.height\\n      : !image || !image.height ? 0\\n      : item.aspect !== false && item.width ? item.width * image.height / image.width\\n      : image.height;\\n  }\\n\\n  function imageXOffset(align, w) {\\n    return align === 'center' ? w / 2 : align === 'right' ? w : 0;\\n  }\\n\\n  function imageYOffset(baseline, h) {\\n    return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;\\n  }\\n\\n  function attr$1(emit, item, renderer) {\\n    const img = getImage(item, renderer),\\n          w = imageWidth(item, img),\\n          h = imageHeight(item, img),\\n          x = (item.x || 0) - imageXOffset(item.align, w),\\n          y = (item.y || 0) - imageYOffset(item.baseline, h),\\n          i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';\\n\\n    emit('href', i, metadata['xmlns:xlink'], 'xlink:href');\\n    emit('transform', translate(x, y));\\n    emit('width', w);\\n    emit('height', h);\\n    emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');\\n  }\\n\\n  function bound$1(bounds, item) {\\n    const img = item.image,\\n          w = imageWidth(item, img),\\n          h = imageHeight(item, img),\\n          x = (item.x || 0) - imageXOffset(item.align, w),\\n          y = (item.y || 0) - imageYOffset(item.baseline, h);\\n\\n    return bounds.set(x, y, x + w, y + h);\\n  }\\n\\n  function draw$1(context, scene, bounds) {\\n    visit(scene, item => {\\n      if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\\n\\n      const img = getImage(item, this);\\n      let w = imageWidth(item, img),\\n          h = imageHeight(item, img),\\n          x = (item.x || 0) - imageXOffset(item.align, w),\\n          y = (item.y || 0) - imageYOffset(item.baseline, h),\\n          opacity, ar0, ar1, t;\\n\\n      if (item.aspect !== false) {\\n        ar0 = img.width / img.height;\\n        ar1 = item.width / item.height;\\n        if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {\\n          if (ar1 < ar0) {\\n            t = w / ar0;\\n            y += (h - t) / 2;\\n            h = t;\\n          } else {\\n            t = h * ar0;\\n            x += (w - t) / 2;\\n            w = t;\\n          }\\n        }\\n      }\\n\\n      if (img.complete || img.toDataURL) {\\n        blend(context, item);\\n        context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;\\n        context.imageSmoothingEnabled = item.smooth !== false;\\n        context.drawImage(img, x, y, w, h);\\n      }\\n    });\\n  }\\n\\n  var image = {\\n    type:     'image',\\n    tag:      'image',\\n    nested:   false,\\n    attr:     attr$1,\\n    bound:    bound$1,\\n    draw:     draw$1,\\n    pick:     pick(),\\n    isect:    vegaUtil.truthy, // bounds check is sufficient\\n    get:      getImage,\\n    xOffset:  imageXOffset,\\n    yOffset:  imageYOffset\\n  };\\n\\n  var line$1 = markMultiItemPath('line', line, pickLine);\\n\\n  function attr$2(emit, item) {\\n    var sx = item.scaleX || 1,\\n        sy = item.scaleY || 1;\\n    if (sx !== 1 || sy !== 1) {\\n      emit('vector-effect', 'non-scaling-stroke');\\n    }\\n    emit('transform', transformItem(item));\\n    emit('d', item.path);\\n  }\\n\\n  function path(context, item) {\\n    var path = item.path;\\n    if (path == null) return true;\\n\\n    var x = item.x || 0,\\n        y = item.y || 0,\\n        sx = item.scaleX || 1,\\n        sy = item.scaleY || 1,\\n        a = (item.angle || 0) * DegToRad,\\n        cache = item.pathCache;\\n\\n    if (!cache || cache.path !== path) {\\n      (item.pathCache = cache = pathParse(path)).path = path;\\n    }\\n\\n    if (a && context.rotate && context.translate) {\\n      context.translate(x, y);\\n      context.rotate(a);\\n      pathRender(context, cache, 0, 0, sx, sy);\\n      context.rotate(-a);\\n      context.translate(-x, -y);\\n    } else {\\n      pathRender(context, cache, x, y, sx, sy);\\n    }\\n  }\\n\\n  function bound$2(bounds, item) {\\n    return path(boundContext(bounds, item.angle), item)\\n      ? bounds.set(0, 0, 0, 0)\\n      : boundStroke(bounds, item, true);\\n  }\\n\\n  var path$1 = {\\n    type:   'path',\\n    tag:    'path',\\n    nested: false,\\n    attr:   attr$2,\\n    bound:  bound$2,\\n    draw:   drawAll(path),\\n    pick:   pickPath(path),\\n    isect:  intersectPath(path)\\n  };\\n\\n  function attr$3(emit, item) {\\n    emit('d', rectangle(null, item));\\n  }\\n\\n  function bound$3(bounds, item) {\\n    var x, y;\\n    return boundStroke(bounds.set(\\n      x = item.x || 0,\\n      y = item.y || 0,\\n      (x + item.width) || 0,\\n      (y + item.height) || 0\\n    ), item);\\n  }\\n\\n  function draw$2(context, item) {\\n    context.beginPath();\\n    rectangle(context, item);\\n  }\\n\\n  var rect = {\\n    type:   'rect',\\n    tag:    'path',\\n    nested: false,\\n    attr:   attr$3,\\n    bound:  bound$3,\\n    draw:   drawAll(draw$2),\\n    pick:   pickPath(draw$2),\\n    isect:  intersectRect\\n  };\\n\\n  function attr$4(emit, item) {\\n    emit('transform', translateItem(item));\\n    emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);\\n    emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);\\n  }\\n\\n  function bound$4(bounds, item) {\\n    var x1, y1;\\n    return boundStroke(bounds.set(\\n      x1 = item.x || 0,\\n      y1 = item.y || 0,\\n      item.x2 != null ? item.x2 : x1,\\n      item.y2 != null ? item.y2 : y1\\n    ), item);\\n  }\\n\\n  function path$2(context, item, opacity) {\\n    var x1, y1, x2, y2;\\n\\n    if (item.stroke && stroke(context, item, opacity)) {\\n      x1 = item.x || 0;\\n      y1 = item.y || 0;\\n      x2 = item.x2 != null ? item.x2 : x1;\\n      y2 = item.y2 != null ? item.y2 : y1;\\n      context.beginPath();\\n      context.moveTo(x1, y1);\\n      context.lineTo(x2, y2);\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  function draw$3(context, scene, bounds) {\\n    visit(scene, item => {\\n      if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\\n      var opacity = item.opacity == null ? 1 : item.opacity;\\n      if (opacity && path$2(context, item, opacity)) {\\n        blend(context, item);\\n        context.stroke();\\n      }\\n    });\\n  }\\n\\n  function hit(context, item, x, y) {\\n    if (!context.isPointInStroke) return false;\\n    return path$2(context, item, 1) && context.isPointInStroke(x, y);\\n  }\\n\\n  var rule = {\\n    type:   'rule',\\n    tag:    'line',\\n    nested: false,\\n    attr:   attr$4,\\n    bound:  bound$4,\\n    draw:   draw$3,\\n    pick:   pick(hit),\\n    isect:  intersectRule\\n  };\\n\\n  var shape$1 = markItemPath('shape', shape);\\n\\n  var symbol$1 = markItemPath('symbol', symbol, intersectPoint);\\n\\n  // memoize text width measurement\\n  const widthCache = vegaUtil.lruCache();\\n\\n  var textMetrics = {\\n    height: fontSize,\\n    measureWidth: measureWidth,\\n    estimateWidth: estimateWidth,\\n    width: estimateWidth,\\n    canvas: useCanvas\\n  };\\n\\n  useCanvas(true);\\n\\n  function useCanvas(use) {\\n    textMetrics.width = (use && context$1) ? measureWidth : estimateWidth;\\n  }\\n\\n  // make dumb, simple estimate if no canvas is available\\n  function estimateWidth(item, text) {\\n    return _estimateWidth(textValue(item, text), fontSize(item));\\n  }\\n\\n  function _estimateWidth(text, currentFontHeight) {\\n    return ~~(0.8 * text.length * currentFontHeight);\\n  }\\n\\n  // measure text width if canvas is available\\n  function measureWidth(item, text) {\\n    return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0\\n      : _measureWidth(text, font(item));\\n  }\\n\\n  function _measureWidth(text, currentFont) {\\n    const key = `(${currentFont}) ${text}`;\\n    let width = widthCache.get(key);\\n    if (width === undefined) {\\n      context$1.font = currentFont;\\n      width = context$1.measureText(text).width;\\n      widthCache.set(key, width);\\n    }\\n    return width;\\n  }\\n\\n  function fontSize(item) {\\n    return item.fontSize != null ? (+item.fontSize || 0) : 11;\\n  }\\n\\n  function lineHeight(item) {\\n    return item.lineHeight != null ? item.lineHeight : (fontSize(item) + 2);\\n  }\\n\\n  function lineArray(_) {\\n    return vegaUtil.isArray(_) ? _.length > 1 ? _ : _[0] : _;\\n  }\\n\\n  function textLines(item) {\\n    return lineArray(\\n      item.lineBreak && item.text && !vegaUtil.isArray(item.text)\\n        ? item.text.split(item.lineBreak)\\n        : item.text\\n    );\\n  }\\n\\n  function multiLineOffset(item) {\\n    const tl = textLines(item);\\n    return (vegaUtil.isArray(tl) ? (tl.length - 1) : 0) * lineHeight(item);\\n  }\\n\\n  function textValue(item, line) {\\n    const text = line == null ? '' : (line + '').trim();\\n    return item.limit > 0 && text.length ? truncate(item, text) : text;\\n  }\\n\\n  function widthGetter(item) {\\n    if (textMetrics.width === measureWidth) {\\n      // we are using canvas\\n      const currentFont = font(item);\\n      return text => _measureWidth(text, currentFont);\\n    } else {\\n      // we are relying on estimates\\n      const currentFontHeight = fontSize(item);\\n      return text => _estimateWidth(text, currentFontHeight);\\n    }\\n  }\\n\\n  function truncate(item, text) {\\n    var limit = +item.limit,\\n        width = widthGetter(item);\\n\\n    if (width(text) < limit) return text;\\n\\n    var ellipsis = item.ellipsis || '\\\\u2026',\\n        rtl = item.dir === 'rtl',\\n        lo = 0,\\n        hi = text.length, mid;\\n\\n    limit -= width(ellipsis);\\n\\n    if (rtl) {\\n      while (lo < hi) {\\n        mid = (lo + hi >>> 1);\\n        if (width(text.slice(mid)) > limit) lo = mid + 1;\\n        else hi = mid;\\n      }\\n      return ellipsis + text.slice(lo);\\n    } else {\\n      while (lo < hi) {\\n        mid = 1 + (lo + hi >>> 1);\\n        if (width(text.slice(0, mid)) < limit) lo = mid;\\n        else hi = mid - 1;\\n      }\\n      return text.slice(0, lo) + ellipsis;\\n    }\\n  }\\n\\n  function fontFamily(item, quote) {\\n    var font = item.font;\\n    return (quote && font\\n      ? String(font).replace(/\\\"/g, '\\\\'')\\n      : font) || 'sans-serif';\\n  }\\n\\n  function font(item, quote) {\\n    return '' +\\n      (item.fontStyle ? item.fontStyle + ' ' : '') +\\n      (item.fontVariant ? item.fontVariant + ' ' : '') +\\n      (item.fontWeight ? item.fontWeight + ' ' : '') +\\n      fontSize(item) + 'px ' +\\n      fontFamily(item, quote);\\n  }\\n\\n  function offset$1(item) {\\n    // perform our own font baseline calculation\\n    // why? not all browsers support SVG 1.1 'alignment-baseline' :(\\n    // this also ensures consistent layout across renderers\\n    var baseline = item.baseline,\\n        h = fontSize(item);\\n\\n    return Math.round(\\n      baseline === 'top'         ?  0.79 * h :\\n      baseline === 'middle'      ?  0.30 * h :\\n      baseline === 'bottom'      ? -0.21 * h :\\n      baseline === 'line-top'    ?  0.29 * h + 0.5 * lineHeight(item) :\\n      baseline === 'line-bottom' ?  0.29 * h - 0.5 * lineHeight(item) : 0\\n    );\\n  }\\n\\n  var textAlign = {\\n    'left':   'start',\\n    'center': 'middle',\\n    'right':  'end'\\n  };\\n\\n  var tempBounds = new Bounds();\\n\\n  function anchorPoint(item) {\\n    var x = item.x || 0,\\n        y = item.y || 0,\\n        r = item.radius || 0, t;\\n\\n    if (r) {\\n      t = (item.theta || 0) - HalfPi;\\n      x += r * Math.cos(t);\\n      y += r * Math.sin(t);\\n    }\\n\\n    tempBounds.x1 = x;\\n    tempBounds.y1 = y;\\n    return tempBounds;\\n  }\\n\\n  function attr$5(emit, item) {\\n    var dx = item.dx || 0,\\n        dy = (item.dy || 0) + offset$1(item),\\n        p = anchorPoint(item),\\n        x = p.x1,\\n        y = p.y1,\\n        a = item.angle || 0, t;\\n\\n    emit('text-anchor', textAlign[item.align] || 'start');\\n\\n    if (a) {\\n      t = translate(x, y) + ' ' + rotate(a);\\n      if (dx || dy) t += ' ' + translate(dx, dy);\\n    } else {\\n      t = translate(x + dx, y + dy);\\n    }\\n    emit('transform', t);\\n  }\\n\\n  function bound$5(bounds, item, mode) {\\n    var h = textMetrics.height(item),\\n        a = item.align,\\n        p = anchorPoint(item),\\n        x = p.x1,\\n        y = p.y1,\\n        dx = item.dx || 0,\\n        dy = (item.dy || 0) + offset$1(item) - Math.round(0.8*h), // use 4/5 offset\\n        tl = textLines(item),\\n        w;\\n\\n    // get dimensions\\n    if (vegaUtil.isArray(tl)) {\\n      // multi-line text\\n      h += lineHeight(item) * (tl.length - 1);\\n      w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);\\n    } else {\\n      // single-line text\\n      w = textMetrics.width(item, tl);\\n    }\\n\\n    // horizontal alignment\\n    if (a === 'center') {\\n      dx -= (w / 2);\\n    } else if (a === 'right') {\\n      dx -= w;\\n    } else ;\\n\\n    bounds.set(dx+=x, dy+=y, dx+w, dy+h);\\n\\n    if (item.angle && !mode) {\\n      bounds.rotate(item.angle * DegToRad, x, y);\\n    } else if (mode === 2) {\\n      return bounds.rotatedPoints(item.angle * DegToRad, x, y);\\n    }\\n    return bounds;\\n  }\\n\\n  function draw$4(context, scene, bounds) {\\n    visit(scene, item => {\\n      var opacity = item.opacity == null ? 1 : item.opacity,\\n          p, x, y, i, lh, tl, str;\\n\\n      if (bounds && !bounds.intersects(item.bounds) || // bounds check\\n          opacity === 0 || item.fontSize <= 0 ||\\n          item.text == null || item.text.length === 0) return;\\n\\n      context.font = font(item);\\n      context.textAlign = item.align || 'left';\\n\\n      p = anchorPoint(item);\\n      x = p.x1,\\n      y = p.y1;\\n\\n      if (item.angle) {\\n        context.save();\\n        context.translate(x, y);\\n        context.rotate(item.angle * DegToRad);\\n        x = y = 0; // reset x, y\\n      }\\n      x += (item.dx || 0);\\n      y += (item.dy || 0) + offset$1(item);\\n\\n      tl = textLines(item);\\n      blend(context, item);\\n      if (vegaUtil.isArray(tl)) {\\n        lh = lineHeight(item);\\n        for (i=0; i<tl.length; ++i) {\\n          str = textValue(item, tl[i]);\\n          if (item.fill && fill(context, item, opacity)) {\\n            context.fillText(str, x, y);\\n          }\\n          if (item.stroke && stroke(context, item, opacity)) {\\n            context.strokeText(str, x, y);\\n          }\\n          y += lh;\\n        }\\n      } else {\\n        str = textValue(item, tl);\\n        if (item.fill && fill(context, item, opacity)) {\\n          context.fillText(str, x, y);\\n        }\\n        if (item.stroke && stroke(context, item, opacity)) {\\n          context.strokeText(str, x, y);\\n        }\\n      }\\n\\n      if (item.angle) context.restore();\\n    });\\n  }\\n\\n  function hit$1(context, item, x, y, gx, gy) {\\n    if (item.fontSize <= 0) return false;\\n    if (!item.angle) return true; // bounds sufficient if no rotation\\n\\n    // project point into space of unrotated bounds\\n    var p = anchorPoint(item),\\n        ax = p.x1,\\n        ay = p.y1,\\n        b = bound$5(tempBounds, item, 1),\\n        a = -item.angle * DegToRad,\\n        cos = Math.cos(a),\\n        sin = Math.sin(a),\\n        px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),\\n        py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);\\n\\n    return b.contains(px, py);\\n  }\\n\\n  function intersectText(item, box) {\\n    var p = bound$5(tempBounds, item, 2);\\n    return intersectBoxLine(box, p[0], p[1], p[2], p[3])\\n        || intersectBoxLine(box, p[0], p[1], p[4], p[5])\\n        || intersectBoxLine(box, p[4], p[5], p[6], p[7])\\n        || intersectBoxLine(box, p[2], p[3], p[6], p[7]);\\n  }\\n\\n  var text = {\\n    type:   'text',\\n    tag:    'text',\\n    nested: false,\\n    attr:   attr$5,\\n    bound:  bound$5,\\n    draw:   draw$4,\\n    pick:   pick(hit$1),\\n    isect:  intersectText\\n  };\\n\\n  var trail$1 = markMultiItemPath('trail', trail, pickTrail);\\n\\n  var Marks = {\\n    arc:     arc$1,\\n    area:    area$1,\\n    group:   group,\\n    image:   image,\\n    line:    line$1,\\n    path:    path$1,\\n    rect:    rect,\\n    rule:    rule,\\n    shape:   shape$1,\\n    symbol:  symbol$1,\\n    text:    text,\\n    trail:   trail$1\\n  };\\n\\n  function boundItem(item, func, opt) {\\n    var type = Marks[item.mark.marktype],\\n        bound = func || type.bound;\\n    if (type.nested) item = item.mark;\\n\\n    return bound(item.bounds || (item.bounds = new Bounds()), item, opt);\\n  }\\n\\n  var DUMMY = {mark: null};\\n\\n  function boundMark(mark, bounds, opt) {\\n    var type  = Marks[mark.marktype],\\n        bound = type.bound,\\n        items = mark.items,\\n        hasItems = items && items.length,\\n        i, n, item, b;\\n\\n    if (type.nested) {\\n      if (hasItems) {\\n        item = items[0];\\n      } else {\\n        // no items, fake it\\n        DUMMY.mark = mark;\\n        item = DUMMY;\\n      }\\n      b = boundItem(item, bound, opt);\\n      bounds = bounds && bounds.union(b) || b;\\n      return bounds;\\n    }\\n\\n    bounds = bounds\\n      || mark.bounds && mark.bounds.clear()\\n      || new Bounds();\\n\\n    if (hasItems) {\\n      for (i=0, n=items.length; i<n; ++i) {\\n        bounds.union(boundItem(items[i], bound, opt));\\n      }\\n    }\\n\\n    return mark.bounds = bounds;\\n  }\\n\\n  var keys = [\\n    'marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex',\\n    'x', 'y', 'width', 'height', 'align', 'baseline',             // layout\\n    'fill', 'fillOpacity', 'opacity', 'blend',                    // fill\\n    'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',        // stroke\\n    'strokeDash', 'strokeDashOffset',                             // stroke dash\\n    'strokeForeground', 'strokeOffset',                           // group\\n    'startAngle', 'endAngle', 'innerRadius', 'outerRadius',       // arc\\n    'cornerRadius', 'padAngle',                                   // arc, rect\\n    'cornerRadiusTopLeft', 'cornerRadiusTopRight',                // rect, group\\n    'cornerRadiusBottomLeft', 'cornerRadiusBottomRight',\\n    'interpolate', 'tension', 'orient', 'defined',                // area, line\\n    'url', 'aspect', 'smooth',                                    // image\\n    'path', 'scaleX', 'scaleY',                                   // path\\n    'x2', 'y2',                                                   // rule\\n    'size', 'shape',                                              // symbol\\n    'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy',        // text\\n    'ellipsis', 'limit', 'lineBreak', 'lineHeight',\\n    'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant', // font\\n    'description', 'aria', 'ariaRole', 'ariaRoleDescription'      // aria\\n  ];\\n\\n  function sceneToJSON(scene, indent) {\\n    return JSON.stringify(scene, keys, indent);\\n  }\\n\\n  function sceneFromJSON(json) {\\n    var scene = (typeof json === 'string' ? JSON.parse(json) : json);\\n    return initialize(scene);\\n  }\\n\\n  function initialize(scene) {\\n    var type = scene.marktype,\\n        items = scene.items,\\n        parent, i, n;\\n\\n    if (items) {\\n      for (i=0, n=items.length; i<n; ++i) {\\n        parent = type ? 'mark' : 'group';\\n        items[i][parent] = scene;\\n        if (items[i].zindex) items[i][parent].zdirty = true;\\n        if ('group' === (type || parent)) initialize(items[i]);\\n      }\\n    }\\n\\n    if (type) boundMark(scene);\\n    return scene;\\n  }\\n\\n  function Scenegraph(scene) {\\n    if (arguments.length) {\\n      this.root = sceneFromJSON(scene);\\n    } else {\\n      this.root = createMark({\\n        marktype: 'group',\\n        name: 'root',\\n        role: 'frame'\\n      });\\n      this.root.items = [new GroupItem(this.root)];\\n    }\\n  }\\n\\n  Scenegraph.prototype = {\\n    toJSON(indent) {\\n      return sceneToJSON(this.root, indent || 0);\\n    },\\n\\n    mark(markdef, group, index) {\\n      group = group || this.root.items[0];\\n      var mark = createMark(markdef, group);\\n      group.items[index] = mark;\\n      if (mark.zindex) mark.group.zdirty = true;\\n      return mark;\\n    }\\n  };\\n\\n  function createMark(def, group) {\\n    const mark = {\\n      bounds:      new Bounds(),\\n      clip:        !!def.clip,\\n      group:       group,\\n      interactive: def.interactive === false ? false : true,\\n      items:       [],\\n      marktype:    def.marktype,\\n      name:        def.name || undefined,\\n      role:        def.role || undefined,\\n      zindex:      def.zindex || 0\\n    };\\n\\n    // add accessibility properties if defined\\n    if (def.aria != null) {\\n      mark.aria = def.aria;\\n    }\\n    if (def.description) {\\n      mark.description = def.description;\\n    }\\n\\n    return mark;\\n  }\\n\\n  // create a new DOM element\\n  function domCreate(doc, tag, ns) {\\n    if (!doc && typeof document !== 'undefined' && document.createElement) {\\n      doc = document;\\n    }\\n    return doc\\n      ? (ns ? doc.createElementNS(ns, tag) : doc.createElement(tag))\\n      : null;\\n  }\\n\\n  // find first child element with matching tag\\n  function domFind(el, tag) {\\n    tag = tag.toLowerCase();\\n    var nodes = el.childNodes, i = 0, n = nodes.length;\\n    for (; i<n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {\\n      return nodes[i];\\n    }\\n  }\\n\\n  // retrieve child element at given index\\n  // create & insert if doesn't exist or if tags do not match\\n  function domChild(el, index, tag, ns) {\\n    var a = el.childNodes[index], b;\\n    if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {\\n      b = a || null;\\n      a = domCreate(el.ownerDocument, tag, ns);\\n      el.insertBefore(a, b);\\n    }\\n    return a;\\n  }\\n\\n  // remove all child elements at or above the given index\\n  function domClear(el, index) {\\n    var nodes = el.childNodes,\\n        curr = nodes.length;\\n    while (curr > index) el.removeChild(nodes[--curr]);\\n    return el;\\n  }\\n\\n  // generate css class name for mark\\n  function cssClass(mark) {\\n    return 'mark-' + mark.marktype\\n      + (mark.role ? ' role-' + mark.role : '')\\n      + (mark.name ? ' ' + mark.name : '');\\n  }\\n\\n  function point(event, el) {\\n    var rect = el.getBoundingClientRect();\\n    return [\\n      event.clientX - rect.left - (el.clientLeft || 0),\\n      event.clientY - rect.top - (el.clientTop || 0)\\n    ];\\n  }\\n\\n  function resolveItem(item, event, el, origin) {\\n    var mark = item && item.mark,\\n        mdef, p;\\n\\n    if (mark && (mdef = Marks[mark.marktype]).tip) {\\n      p = point(event, el);\\n      p[0] -= origin[0];\\n      p[1] -= origin[1];\\n      while (item = item.mark.group) {\\n        p[0] -= item.x || 0;\\n        p[1] -= item.y || 0;\\n      }\\n      item = mdef.tip(mark.items, p);\\n    }\\n\\n    return item;\\n  }\\n\\n  /**\\n   * Create a new Handler instance.\\n   * @param {object} [customLoader] - Optional loader instance for\\n   *   href URL sanitization. If not specified, a standard loader\\n   *   instance will be generated.\\n   * @param {function} [customTooltip] - Optional tooltip handler\\n   *   function for custom tooltip display.\\n   * @constructor\\n   */\\n  function Handler(customLoader, customTooltip) {\\n    this._active = null;\\n    this._handlers = {};\\n    this._loader = customLoader || vegaLoader.loader();\\n    this._tooltip = customTooltip || defaultTooltip;\\n  }\\n\\n  // The default tooltip display handler.\\n  // Sets the HTML title attribute on the visualization container.\\n  function defaultTooltip(handler, event, item, value) {\\n    handler.element().setAttribute('title', value || '');\\n  }\\n\\n  Handler.prototype = {\\n    /**\\n     * Initialize a new Handler instance.\\n     * @param {DOMElement} el - The containing DOM element for the display.\\n     * @param {Array<number>} origin - The origin of the display, in pixels.\\n     *   The coordinate system will be translated to this point.\\n     * @param {object} [obj] - Optional context object that should serve as\\n     *   the \\\"this\\\" context for event callbacks.\\n     * @return {Handler} - This handler instance.\\n     */\\n    initialize(el, origin, obj) {\\n      this._el = el;\\n      this._obj = obj || null;\\n      return this.origin(origin);\\n    },\\n\\n    /**\\n     * Returns the parent container element for a visualization.\\n     * @return {DOMElement} - The containing DOM element.\\n     */\\n    element() {\\n      return this._el;\\n    },\\n\\n    /**\\n     * Returns the scene element (e.g., canvas or SVG) of the visualization\\n     * Subclasses must override if the first child is not the scene element.\\n     * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\\n     */\\n    canvas() {\\n      return this._el && this._el.firstChild;\\n    },\\n\\n    /**\\n     * Get / set the origin coordinates of the visualization.\\n     */\\n    origin(origin) {\\n      if (arguments.length) {\\n        this._origin = origin || [0, 0];\\n        return this;\\n      } else {\\n        return this._origin.slice();\\n      }\\n    },\\n\\n    /**\\n     * Get / set the scenegraph root.\\n     */\\n    scene(scene) {\\n      if (!arguments.length) return this._scene;\\n      this._scene = scene;\\n      return this;\\n    },\\n\\n    /**\\n     * Add an event handler. Subclasses should override this method.\\n     */\\n    on(/*type, handler*/) {},\\n\\n    /**\\n     * Remove an event handler. Subclasses should override this method.\\n     */\\n    off(/*type, handler*/) {},\\n\\n    /**\\n     * Utility method for finding the array index of an event handler.\\n     * @param {Array} h - An array of registered event handlers.\\n     * @param {string} type - The event type.\\n     * @param {function} handler - The event handler instance to find.\\n     * @return {number} - The handler's array index or -1 if not registered.\\n     */\\n    _handlerIndex(h, type, handler) {\\n      for (let i = h ? h.length : 0; --i>=0;) {\\n        if (h[i].type === type && (!handler || h[i].handler === handler)) {\\n          return i;\\n        }\\n      }\\n      return -1;\\n    },\\n\\n    /**\\n     * Returns an array with registered event handlers.\\n     * @param {string} [type] - The event type to query. Any annotations\\n     *   are ignored; for example, for the argument \\\"click.foo\\\", \\\".foo\\\" will\\n     *   be ignored and the method returns all \\\"click\\\" handlers. If type is\\n     *   null or unspecified, this method returns handlers for all types.\\n     * @return {Array} - A new array containing all registered event handlers.\\n     */\\n    handlers(type) {\\n      const h = this._handlers, a = [];\\n      if (type) {\\n        a.push.apply(a, h[this.eventName(type)]);\\n      } else {\\n        for (const k in h) { a.push.apply(a, h[k]); }\\n      }\\n      return a;\\n    },\\n\\n    /**\\n     * Parses an event name string to return the specific event type.\\n     * For example, given \\\"click.foo\\\" returns \\\"click\\\"\\n     * @param {string} name - The input event type string.\\n     * @return {string} - A string with the event type only.\\n     */\\n    eventName(name) {\\n      const i = name.indexOf('.');\\n      return i < 0 ? name : name.slice(0, i);\\n    },\\n\\n    /**\\n     * Handle hyperlink navigation in response to an item.href value.\\n     * @param {Event} event - The event triggering hyperlink navigation.\\n     * @param {Item} item - The scenegraph item.\\n     * @param {string} href - The URL to navigate to.\\n     */\\n    handleHref(event, item, href) {\\n      this._loader\\n        .sanitize(href, {context:'href'})\\n        .then(opt => {\\n          const e = new MouseEvent(event.type, event),\\n                a = domCreate(null, 'a');\\n          for (const name in opt) a.setAttribute(name, opt[name]);\\n          a.dispatchEvent(e);\\n        })\\n        .catch(() => { /* do nothing */ });\\n    },\\n\\n    /**\\n     * Handle tooltip display in response to an item.tooltip value.\\n     * @param {Event} event - The event triggering tooltip display.\\n     * @param {Item} item - The scenegraph item.\\n     * @param {boolean} show - A boolean flag indicating whether\\n     *   to show or hide a tooltip for the given item.\\n     */\\n    handleTooltip(event, item, show) {\\n      if (item && item.tooltip != null) {\\n        item = resolveItem(item, event, this.canvas(), this._origin);\\n        const value = (show && item && item.tooltip) || null;\\n        this._tooltip.call(this._obj, this, event, item, value);\\n      }\\n    },\\n\\n    /**\\n     * Returns the size of a scenegraph item and its position relative\\n     * to the viewport.\\n     * @param {Item} item - The scenegraph item.\\n     * @return {object} - A bounding box object (compatible with the\\n     *   DOMRect type) consisting of x, y, width, heigh, top, left,\\n     *   right, and bottom properties.\\n     */\\n    getItemBoundingClientRect(item) {\\n      const el = this.canvas();\\n      if (!el) return;\\n\\n      const rect = el.getBoundingClientRect(),\\n            origin = this._origin,\\n            bounds = item.bounds,\\n            width = bounds.width(),\\n            height = bounds.height();\\n\\n      let x = bounds.x1 + origin[0] + rect.left,\\n          y = bounds.y1 + origin[1] + rect.top;\\n\\n      // translate coordinate for each parent group\\n      while (item.mark && (item = item.mark.group)) {\\n        x += item.x || 0;\\n        y += item.y || 0;\\n      }\\n\\n      // return DOMRect-compatible bounding box\\n      return {\\n        x, y, width, height,\\n        left: x, top: y, right: x + width, bottom: y + height\\n      };\\n    }\\n  };\\n\\n  /**\\n   * Create a new Renderer instance.\\n   * @param {object} [loader] - Optional loader instance for\\n   *   image and href URL sanitization. If not specified, a\\n   *   standard loader instance will be generated.\\n   * @constructor\\n   */\\n  function Renderer(loader) {\\n    this._el = null;\\n    this._bgcolor = null;\\n    this._loader = new ResourceLoader(loader);\\n  }\\n\\n  Renderer.prototype = {\\n    /**\\n     * Initialize a new Renderer instance.\\n     * @param {DOMElement} el - The containing DOM element for the display.\\n     * @param {number} width - The coordinate width of the display, in pixels.\\n     * @param {number} height - The coordinate height of the display, in pixels.\\n     * @param {Array<number>} origin - The origin of the display, in pixels.\\n     *   The coordinate system will be translated to this point.\\n     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\\n     *   the width and height to determine the final pixel size.\\n     * @return {Renderer} - This renderer instance.\\n     */\\n    initialize(el, width, height, origin, scaleFactor) {\\n      this._el = el;\\n      return this.resize(width, height, origin, scaleFactor);\\n    },\\n\\n    /**\\n     * Returns the parent container element for a visualization.\\n     * @return {DOMElement} - The containing DOM element.\\n     */\\n    element() {\\n      return this._el;\\n    },\\n\\n    /**\\n     * Returns the scene element (e.g., canvas or SVG) of the visualization\\n     * Subclasses must override if the first child is not the scene element.\\n     * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\\n     */\\n    canvas() {\\n      return this._el && this._el.firstChild;\\n    },\\n\\n    /**\\n     * Get / set the background color.\\n     */\\n    background(bgcolor) {\\n      if (arguments.length === 0) return this._bgcolor;\\n      this._bgcolor = bgcolor;\\n      return this;\\n    },\\n\\n    /**\\n     * Resize the display.\\n     * @param {number} width - The new coordinate width of the display, in pixels.\\n     * @param {number} height - The new coordinate height of the display, in pixels.\\n     * @param {Array<number>} origin - The new origin of the display, in pixels.\\n     *   The coordinate system will be translated to this point.\\n     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\\n     *   the width and height to determine the final pixel size.\\n     * @return {Renderer} - This renderer instance;\\n     */\\n    resize(width, height, origin, scaleFactor) {\\n      this._width = width;\\n      this._height = height;\\n      this._origin = origin || [0, 0];\\n      this._scale = scaleFactor || 1;\\n      return this;\\n    },\\n\\n    /**\\n     * Report a dirty item whose bounds should be redrawn.\\n     * This base class method does nothing. Subclasses that perform\\n     * incremental should implement this method.\\n     * @param {Item} item - The dirty item whose bounds should be redrawn.\\n     */\\n    dirty(/*item*/) {},\\n\\n    /**\\n     * Render an input scenegraph, potentially with a set of dirty items.\\n     * This method will perform an immediate rendering with available resources.\\n     * The renderer may also need to perform image loading to perform a complete\\n     * render. This process can lead to asynchronous re-rendering of the scene\\n     * after this method returns. To receive notification when rendering is\\n     * complete, use the renderAsync method instead.\\n     * @param {object} scene - The root mark of a scenegraph to render.\\n     * @return {Renderer} - This renderer instance.\\n     */\\n    render(scene) {\\n      var r = this;\\n\\n      // bind arguments into a render call, and cache it\\n      // this function may be subsequently called for async redraw\\n      r._call = function() { r._render(scene); };\\n\\n      // invoke the renderer\\n      r._call();\\n\\n      // clear the cached call for garbage collection\\n      // async redraws will stash their own copy\\n      r._call = null;\\n\\n      return r;\\n    },\\n\\n    /**\\n     * Internal rendering method. Renderer subclasses should override this\\n     * method to actually perform rendering.\\n     * @param {object} scene - The root mark of a scenegraph to render.\\n     */\\n    _render(/*scene*/) {\\n      // subclasses to override\\n    },\\n\\n    /**\\n     * Asynchronous rendering method. Similar to render, but returns a Promise\\n     * that resolves when all rendering is completed. Sometimes a renderer must\\n     * perform image loading to get a complete rendering. The returned\\n     * Promise will not resolve until this process completes.\\n     * @param {object} scene - The root mark of a scenegraph to render.\\n     * @return {Promise} - A Promise that resolves when rendering is complete.\\n     */\\n    renderAsync(scene) {\\n      var r = this.render(scene);\\n      return this._ready\\n        ? this._ready.then(() => r)\\n        : Promise.resolve(r);\\n    },\\n\\n    /**\\n     * Internal method for asynchronous resource loading.\\n     * Proxies method calls to the ImageLoader, and tracks loading\\n     * progress to invoke a re-render once complete.\\n     * @param {string} method - The method name to invoke on the ImageLoader.\\n     * @param {string} uri - The URI for the requested resource.\\n     * @return {Promise} - A Promise that resolves to the requested resource.\\n     */\\n    _load(method, uri) {\\n      var r = this,\\n          p = r._loader[method](uri);\\n\\n      if (!r._ready) {\\n        // re-render the scene when loading completes\\n        var call = r._call;\\n        r._ready = r._loader.ready()\\n          .then(redraw => {\\n            if (redraw) call();\\n            r._ready = null;\\n          });\\n      }\\n\\n      return p;\\n    },\\n\\n    /**\\n     * Sanitize a URL to include as a hyperlink in the rendered scene.\\n     * This method proxies a call to ImageLoader.sanitizeURL, but also tracks\\n     * image loading progress and invokes a re-render once complete.\\n     * @param {string} uri - The URI string to sanitize.\\n     * @return {Promise} - A Promise that resolves to the sanitized URL.\\n     */\\n    sanitizeURL(uri) {\\n      return this._load('sanitizeURL', uri);\\n    },\\n\\n    /**\\n     * Requests an image to include in the rendered scene.\\n     * This method proxies a call to ImageLoader.loadImage, but also tracks\\n     * image loading progress and invokes a re-render once complete.\\n     * @param {string} uri - The URI string of the image.\\n     * @return {Promise} - A Promise that resolves to the loaded Image.\\n     */\\n    loadImage(uri) {\\n      return this._load('loadImage', uri);\\n    }\\n  };\\n\\n  const KeyDownEvent = 'keydown';\\n  const KeyPressEvent = 'keypress';\\n  const KeyUpEvent = 'keyup';\\n  const DragEnterEvent = 'dragenter';\\n  const DragLeaveEvent = 'dragleave';\\n  const DragOverEvent = 'dragover';\\n  const MouseDownEvent = 'mousedown';\\n  const MouseUpEvent = 'mouseup';\\n  const MouseMoveEvent = 'mousemove';\\n  const MouseOutEvent = 'mouseout';\\n  const MouseOverEvent = 'mouseover';\\n  const ClickEvent = 'click';\\n  const DoubleClickEvent = 'dblclick';\\n  const WheelEvent = 'wheel';\\n  const MouseWheelEvent = 'mousewheel';\\n  const TouchStartEvent = 'touchstart';\\n  const TouchMoveEvent = 'touchmove';\\n  const TouchEndEvent = 'touchend';\\n\\n  const Events = [\\n    KeyDownEvent,\\n    KeyPressEvent,\\n    KeyUpEvent,\\n    DragEnterEvent,\\n    DragLeaveEvent,\\n    DragOverEvent,\\n    MouseDownEvent,\\n    MouseUpEvent,\\n    MouseMoveEvent,\\n    MouseOutEvent,\\n    MouseOverEvent,\\n    ClickEvent,\\n    DoubleClickEvent,\\n    WheelEvent,\\n    MouseWheelEvent,\\n    TouchStartEvent,\\n    TouchMoveEvent,\\n    TouchEndEvent\\n  ];\\n\\n  const TooltipShowEvent = MouseMoveEvent;\\n\\n  const TooltipHideEvent = MouseOutEvent;\\n\\n  const HrefEvent = ClickEvent;\\n\\n  function CanvasHandler(loader, tooltip) {\\n    Handler.call(this, loader, tooltip);\\n    this._down = null;\\n    this._touch = null;\\n    this._first = true;\\n    this._events = {};\\n  }\\n\\n  const eventBundle = type => (\\n    type === TouchStartEvent ||\\n    type === TouchMoveEvent ||\\n    type === TouchEndEvent\\n  )\\n  ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent]\\n  : [type];\\n\\n  // lazily add listeners to the canvas as needed\\n  function eventListenerCheck(handler, type) {\\n    eventBundle(type).forEach(_ => addEventListener(handler, _));\\n  }\\n\\n  function addEventListener(handler, type) {\\n    const canvas = handler.canvas();\\n    if (canvas && !handler._events[type]) {\\n      handler._events[type] = 1;\\n      canvas.addEventListener(type, handler[type]\\n        ? evt => handler[type](evt)\\n        : evt => handler.fire(type, evt)\\n      );\\n    }\\n  }\\n\\n  function move(moveEvent, overEvent, outEvent) {\\n    return function(evt) {\\n      const a = this._active,\\n            p = this.pickEvent(evt);\\n\\n      if (p === a) {\\n        // active item and picked item are the same\\n        this.fire(moveEvent, evt); // fire move\\n      } else {\\n        // active item and picked item are different\\n        if (!a || !a.exit) {\\n          // fire out for prior active item\\n          // suppress if active item was removed from scene\\n          this.fire(outEvent, evt);\\n        }\\n        this._active = p;          // set new active item\\n        this.fire(overEvent, evt); // fire over for new active item\\n        this.fire(moveEvent, evt); // fire move for new active item\\n      }\\n    };\\n  }\\n\\n  function inactive(type) {\\n    return function(evt) {\\n      this.fire(type, evt);\\n      this._active = null;\\n    };\\n  }\\n\\n  vegaUtil.inherits(CanvasHandler, Handler, {\\n    initialize(el, origin, obj) {\\n      this._canvas = el && domFind(el, 'canvas');\\n\\n      // add minimal events required for proper state management\\n      [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent]\\n        .forEach(type => eventListenerCheck(this, type));\\n\\n      return Handler.prototype.initialize.call(this, el, origin, obj);\\n    },\\n\\n    // return the backing canvas instance\\n    canvas() {\\n      return this._canvas;\\n    },\\n\\n    // retrieve the current canvas context\\n    context() {\\n      return this._canvas.getContext('2d');\\n    },\\n\\n    // supported events\\n    events: Events,\\n\\n    // to keep old versions of firefox happy\\n    DOMMouseScroll(evt) {\\n      this.fire(MouseWheelEvent, evt);\\n    },\\n\\n    mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),\\n    dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),\\n\\n    mouseout: inactive(MouseOutEvent),\\n    dragleave: inactive(DragLeaveEvent),\\n\\n    mousedown(evt) {\\n      this._down = this._active;\\n      this.fire(MouseDownEvent, evt);\\n    },\\n\\n    click(evt) {\\n      if (this._down === this._active) {\\n        this.fire(ClickEvent, evt);\\n        this._down = null;\\n      }\\n    },\\n\\n    touchstart(evt) {\\n      this._touch = this.pickEvent(evt.changedTouches[0]);\\n\\n      if (this._first) {\\n        this._active = this._touch;\\n        this._first = false;\\n      }\\n\\n      this.fire(TouchStartEvent, evt, true);\\n    },\\n\\n    touchmove(evt) {\\n      this.fire(TouchMoveEvent, evt, true);\\n    },\\n\\n    touchend(evt) {\\n      this.fire(TouchEndEvent, evt, true);\\n      this._touch = null;\\n    },\\n\\n    // fire an event\\n    fire(type, evt, touch) {\\n      const a = touch ? this._touch : this._active,\\n            h = this._handlers[type];\\n\\n      // set event type relative to scenegraph items\\n      evt.vegaType = type;\\n\\n      // handle hyperlinks and tooltips first\\n      if (type === HrefEvent && a && a.href) {\\n        this.handleHref(evt, a, a.href);\\n      } else if (type === TooltipShowEvent || type === TooltipHideEvent) {\\n        this.handleTooltip(evt, a, type !== TooltipHideEvent);\\n      }\\n\\n      // invoke all registered handlers\\n      if (h) {\\n        for (let i=0, len=h.length; i<len; ++i) {\\n          h[i].handler.call(this._obj, evt, a);\\n        }\\n      }\\n    },\\n\\n    // add an event handler\\n    on(type, handler) {\\n      const name = this.eventName(type),\\n            h = this._handlers,\\n            i = this._handlerIndex(h[name], type, handler);\\n\\n      if (i < 0) {\\n        eventListenerCheck(this, type);\\n        (h[name] || (h[name] = [])).push({\\n          type:    type,\\n          handler: handler\\n        });\\n      }\\n\\n      return this;\\n    },\\n\\n    // remove an event handler\\n    off(type, handler) {\\n      const name = this.eventName(type),\\n            h = this._handlers[name],\\n            i = this._handlerIndex(h, type, handler);\\n\\n      if (i >= 0) {\\n        h.splice(i, 1);\\n      }\\n\\n      return this;\\n    },\\n\\n    pickEvent(evt) {\\n      const p = point(evt, this._canvas),\\n            o = this._origin;\\n      return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);\\n    },\\n\\n    // find the scenegraph item at the current mouse position\\n    // x, y -- the absolute x, y mouse coordinates on the canvas element\\n    // gx, gy -- the relative coordinates within the current group\\n    pick(scene, x, y, gx, gy) {\\n      const g = this.context(),\\n            mark = Marks[scene.marktype];\\n      return mark.pick.call(this, g, scene, x, y, gx, gy);\\n    }\\n  });\\n\\n  function devicePixelRatio() {\\n    return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;\\n  }\\n\\n  var pixelRatio = devicePixelRatio();\\n\\n  function resize(canvas, width, height, origin, scaleFactor, opt) {\\n    const inDOM = typeof HTMLElement !== 'undefined'\\n                && canvas instanceof HTMLElement\\n                && canvas.parentNode != null,\\n          context = canvas.getContext('2d'),\\n          ratio = inDOM ? pixelRatio : scaleFactor;\\n\\n    canvas.width = width * ratio;\\n    canvas.height = height * ratio;\\n\\n    for (const key in opt) {\\n      context[key] = opt[key];\\n    }\\n\\n    if (inDOM && ratio !== 1) {\\n      canvas.style.width = width + 'px';\\n      canvas.style.height = height + 'px';\\n    }\\n\\n    context.pixelRatio = ratio;\\n    context.setTransform(\\n      ratio, 0, 0, ratio,\\n      ratio * origin[0],\\n      ratio * origin[1]\\n    );\\n\\n    return canvas;\\n  }\\n\\n  function CanvasRenderer(loader) {\\n    Renderer.call(this, loader);\\n    this._options = {};\\n    this._redraw = false;\\n    this._dirty = new Bounds();\\n    this._tempb = new Bounds();\\n  }\\n\\n  const base = Renderer.prototype;\\n\\n  const viewBounds = (origin, width, height) => new Bounds()\\n    .set(0, 0, width, height)\\n    .translate(-origin[0], -origin[1]);\\n\\n  function clipToBounds(g, b, origin) {\\n    // expand bounds by 1 pixel, then round to pixel boundaries\\n    b.expand(1).round();\\n\\n    // align to base pixel grid in case of non-integer scaling (#2425)\\n    if (g.pixelRatio % 1) {\\n      b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);\\n    }\\n\\n    // to avoid artifacts translate if origin has fractional pixels\\n    b.translate(-(origin[0] % 1), -(origin[1] % 1));\\n\\n    // set clip path\\n    g.beginPath();\\n    g.rect(b.x1, b.y1, b.width(), b.height());\\n    g.clip();\\n\\n    return b;\\n  }\\n\\n  vegaUtil.inherits(CanvasRenderer, Renderer, {\\n    initialize(el, width, height, origin, scaleFactor, options) {\\n      this._options = options || {};\\n\\n      this._canvas = this._options.externalContext\\n        ? null\\n        : vegaCanvas.canvas(1, 1, this._options.type); // instantiate a small canvas\\n\\n      if (el && this._canvas) {\\n        domClear(el, 0).appendChild(this._canvas);\\n        this._canvas.setAttribute('class', 'marks');\\n      }\\n\\n      // this method will invoke resize to size the canvas appropriately\\n      return base.initialize.call(this, el, width, height, origin, scaleFactor);\\n    },\\n\\n    resize(width, height, origin, scaleFactor) {\\n      base.resize.call(this, width, height, origin, scaleFactor);\\n\\n      if (this._canvas) {\\n        // configure canvas size and transform\\n        resize(this._canvas, this._width, this._height,\\n          this._origin, this._scale, this._options.context);\\n      } else {\\n        // external context needs to be scaled and positioned to origin\\n        const ctx = this._options.externalContext;\\n        if (!ctx) vegaUtil.error('CanvasRenderer is missing a valid canvas or context');\\n        ctx.scale(this._scale, this._scale);\\n        ctx.translate(this._origin[0], this._origin[1]);\\n      }\\n\\n      this._redraw = true;\\n      return this;\\n    },\\n\\n    canvas() {\\n      return this._canvas;\\n    },\\n\\n    context() {\\n      return this._options.externalContext\\n        || (this._canvas ? this._canvas.getContext('2d') : null);\\n    },\\n\\n    dirty(item) {\\n      const b = this._tempb.clear().union(item.bounds);\\n      let g = item.mark.group;\\n\\n      while (g) {\\n        b.translate(g.x || 0, g.y || 0);\\n        g = g.mark.group;\\n      }\\n\\n      this._dirty.union(b);\\n    },\\n\\n    _render(scene) {\\n      const g = this.context(),\\n            o = this._origin,\\n            w = this._width,\\n            h = this._height,\\n            db = this._dirty,\\n            vb = viewBounds(o, w, h);\\n\\n      // setup\\n      g.save();\\n      const b = this._redraw || db.empty()\\n        ? (this._redraw = false, vb.expand(1))\\n        : clipToBounds(g, vb.intersect(db), o);\\n\\n      this.clear(-o[0], -o[1], w, h);\\n\\n      // render\\n      this.draw(g, scene, b);\\n\\n      // takedown\\n      g.restore();\\n      db.clear();\\n\\n      return this;\\n    },\\n\\n    draw(ctx, scene, bounds) {\\n      const mark = Marks[scene.marktype];\\n      if (scene.clip) clip$1(ctx, scene);\\n      mark.draw.call(this, ctx, scene, bounds);\\n      if (scene.clip) ctx.restore();\\n    },\\n\\n    clear(x, y, w, h) {\\n      const opt = this._options,\\n            g = this.context();\\n\\n      if (opt.type !== 'pdf' && !opt.externalContext) {\\n        // calling clear rect voids vector output in pdf mode\\n        // and could remove external context content (#2615)\\n        g.clearRect(x, y, w, h);\\n      }\\n\\n      if (this._bgcolor != null) {\\n        g.fillStyle = this._bgcolor;\\n        g.fillRect(x, y, w, h);\\n      }\\n    }\\n  });\\n\\n  function SVGHandler(loader, tooltip) {\\n    Handler.call(this, loader, tooltip);\\n    const h = this;\\n    h._hrefHandler = listener(h, (evt, item) => {\\n      if (item && item.href) h.handleHref(evt, item, item.href);\\n    });\\n    h._tooltipHandler = listener(h, (evt, item) => {\\n      h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);\\n    });\\n  }\\n\\n  // wrap an event listener for the SVG DOM\\n  const listener = (context, handler) => evt => {\\n    let item = evt.target.__data__;\\n    item = Array.isArray(item) ? item[0] : item;\\n    evt.vegaType = evt.type;\\n    handler.call(context._obj, evt, item);\\n  };\\n\\n  vegaUtil.inherits(SVGHandler, Handler, {\\n    initialize(el, origin, obj) {\\n      let svg = this._svg;\\n      if (svg) {\\n        svg.removeEventListener(HrefEvent, this._hrefHandler);\\n        svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);\\n        svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);\\n      }\\n      this._svg = svg = el && domFind(el, 'svg');\\n      if (svg) {\\n        svg.addEventListener(HrefEvent, this._hrefHandler);\\n        svg.addEventListener(TooltipShowEvent, this._tooltipHandler);\\n        svg.addEventListener(TooltipHideEvent, this._tooltipHandler);\\n      }\\n      return Handler.prototype.initialize.call(this, el, origin, obj);\\n    },\\n\\n    canvas() {\\n      return this._svg;\\n    },\\n\\n    // add an event handler\\n    on(type, handler) {\\n      const name = this.eventName(type),\\n            h = this._handlers,\\n            i = this._handlerIndex(h[name], type, handler);\\n\\n      if (i < 0) {\\n        const x = {\\n          type,\\n          handler,\\n          listener: listener(this, handler)\\n        };\\n\\n        (h[name] || (h[name] = [])).push(x);\\n        if (this._svg) {\\n          this._svg.addEventListener(name, x.listener);\\n        }\\n      }\\n\\n      return this;\\n    },\\n\\n    // remove an event handler\\n    off(type, handler) {\\n      const name = this.eventName(type),\\n            h = this._handlers[name],\\n            i = this._handlerIndex(h, type, handler);\\n\\n      if (i >= 0) {\\n        if (this._svg) {\\n          this._svg.removeEventListener(name, h[i].listener);\\n        }\\n        h.splice(i, 1);\\n      }\\n\\n      return this;\\n    }\\n  });\\n\\n  const ARIA_HIDDEN = 'aria-hidden';\\n  const ARIA_LABEL = 'aria-label';\\n  const ARIA_ROLE = 'role';\\n  const ARIA_ROLEDESCRIPTION = 'aria-roledescription';\\n  const GRAPHICS_OBJECT = 'graphics-object';\\n  const GRAPHICS_SYMBOL = 'graphics-symbol';\\n\\n  const bundle = (role, roledesc, label) => ({\\n    [ARIA_ROLE]: role,\\n    [ARIA_ROLEDESCRIPTION]: roledesc,\\n    [ARIA_LABEL]: label || undefined\\n  });\\n\\n  // these roles are covered by related roles\\n  // we can ignore them, no need to generate attributes\\n  const AriaIgnore = vegaUtil.toSet([\\n    'axis-domain',\\n    'axis-grid',\\n    'axis-label',\\n    'axis-tick',\\n    'axis-title',\\n    'legend-band',\\n    'legend-entry',\\n    'legend-gradient',\\n    'legend-label',\\n    'legend-title',\\n    'legend-symbol',\\n    'title'\\n  ]);\\n\\n  // aria attribute generators for guide roles\\n  const AriaGuides = {\\n    'axis': {desc: 'axis', caption: axisCaption},\\n    'legend': {desc: 'legend', caption: legendCaption},\\n    'title-text': {\\n      desc: 'title',\\n      caption: item => `Title text '${titleCaption(item)}'`\\n    },\\n    'title-subtitle': {\\n      desc: 'subtitle',\\n      caption: item => `Subtitle text '${titleCaption(item)}'`\\n    }\\n  };\\n\\n  // aria properties generated for mark item encoding channels\\n  const AriaEncode = {\\n    ariaRole: ARIA_ROLE,\\n    ariaRoleDescription: ARIA_ROLEDESCRIPTION,\\n    description: ARIA_LABEL\\n  };\\n\\n  function ariaItemAttributes(emit, item) {\\n    const hide = item.aria === false;\\n    emit(ARIA_HIDDEN, hide || undefined);\\n\\n    if (hide || item.description == null) {\\n      for (const prop in AriaEncode) {\\n        emit(AriaEncode[prop], undefined);\\n      }\\n    } else {\\n      const type = item.mark.marktype;\\n      emit(\\n        ARIA_LABEL,\\n        item.description\\n      );\\n      emit(\\n        ARIA_ROLE,\\n        item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL)\\n      );\\n      emit(\\n        ARIA_ROLEDESCRIPTION,\\n        item.ariaRoleDescription || `${type} mark`\\n      );\\n    }\\n  }\\n\\n  function ariaMarkAttributes(mark) {\\n    return mark.aria === false ? { [ARIA_HIDDEN]: true }\\n      : AriaIgnore[mark.role] ? null\\n      : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role])\\n      : ariaMark(mark);\\n  }\\n\\n  function ariaMark(mark) {\\n    const type = mark.marktype;\\n    const recurse = (\\n      type === 'group' ||\\n      type === 'text' ||\\n      mark.items.some(_ => _.description != null && _.aria !== false)\\n    );\\n    return bundle(\\n      recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL,\\n      `${type} mark container`,\\n      mark.description\\n    );\\n  }\\n\\n  function ariaGuide(mark, opt) {\\n    try {\\n      const item = mark.items[0],\\n            caption = opt.caption || (() => '');\\n      return bundle(\\n        opt.role || GRAPHICS_SYMBOL,\\n        opt.desc,\\n        item.description || caption(item)\\n      );\\n    } catch (err) {\\n      return null;\\n    }\\n  }\\n\\n  function titleCaption(item) {\\n    return vegaUtil.array(item.text).join(' ');\\n  }\\n\\n  function axisCaption(item) {\\n    const datum = item.datum,\\n          orient = item.orient,\\n          title = datum.title ? extractTitle(item) : null,\\n          ctx = item.context,\\n          scale = ctx.scales[datum.scale].value,\\n          locale = ctx.dataflow.locale(),\\n          type = scale.type,\\n          xy = (orient === 'left' || orient === 'right') ? 'Y' : 'X';\\n\\n    return `${xy}-axis`\\n      + (title ? ` titled '${title}'` : '')\\n      + ` for a ${vegaScale.isDiscrete(type) ? 'discrete' : type} scale`\\n      + ` with ${vegaScale.domainCaption(locale, scale, item)}`;\\n  }\\n\\n  function legendCaption(item) {\\n    const datum = item.datum,\\n          title = datum.title ? extractTitle(item) : null,\\n          type = `${datum.type || ''} legend`.trim(),\\n          scales = datum.scales,\\n          props = Object.keys(scales),\\n          ctx = item.context,\\n          scale = ctx.scales[scales[props[0]]].value,\\n          locale = ctx.dataflow.locale();\\n\\n    return capitalize(type)\\n      + (title ? ` titled '${title}'` : '')\\n      + ` for ${channelCaption(props)}`\\n      + ` with ${vegaScale.domainCaption(locale, scale, item)}`;\\n  }\\n\\n  function extractTitle(item) {\\n    try {\\n      return vegaUtil.array(vegaUtil.peek(item.items).items[0].text).join(' ');\\n    } catch (err) {\\n      return null;\\n    }\\n  }\\n\\n  function channelCaption(props) {\\n    props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));\\n    return props.length < 2 ? props[0]\\n      : props.slice(0, -1).join(', ') + ' and ' + vegaUtil.peek(props);\\n  }\\n\\n  function capitalize(s) {\\n    return s.length ? s[0].toUpperCase() + s.slice(1) : s;\\n  }\\n\\n  const innerText = val => (val + '')\\n    .replace(/&/g, '&amp;')\\n    .replace(/</g, '&lt;')\\n    .replace(/>/g, '&gt;');\\n\\n  const attrText = val => innerText(val)\\n    .replace(/\\\"/g, '&quot;')\\n    .replace(/\\\\t/g, '&#x9;')\\n    .replace(/\\\\n/g, '&#xA;')\\n    .replace(/\\\\r/g, '&#xD;');\\n\\n  function markup() {\\n    let buf = '',\\n        outer = '',\\n        inner = '';\\n\\n    const stack = [],\\n          clear = () => outer = inner = '',\\n          push = tag => {\\n            if (outer) { buf += `${outer}>${inner}`; clear(); }\\n            stack.push(tag);\\n          },\\n          attr = (name, value) => {\\n            if (value != null) outer += ` ${name}=\\\"${attrText(value)}\\\"`;\\n            return m;\\n          },\\n\\n          m = {\\n            open(tag, ...attrs) {\\n              push(tag);\\n              outer = '<' + tag;\\n              for (const set of attrs) {\\n                for (const key in set) attr(key, set[key]);\\n              }\\n              return m;\\n            },\\n            close() {\\n              const tag = stack.pop();\\n              if (outer) {\\n                buf += outer + (inner\\n                  ? `>${inner}</${tag}>`\\n                  : '/>');\\n              } else {\\n                buf += `</${tag}>`;\\n              }\\n              clear();\\n              return m;\\n            },\\n            attr,\\n            text: t => (inner += innerText(t), m),\\n            toString: () => buf\\n          };\\n\\n    return m;\\n  }\\n\\n  const serializeXML = node =>\\n    _serialize(markup(), node) + '';\\n\\n  function _serialize(m, node) {\\n    m.open(node.tagName);\\n\\n    if (node.hasAttributes()) {\\n      const attrs = node.attributes,\\n            n = attrs.length;\\n      for (let i=0; i<n; ++i) {\\n        m.attr(attrs[i].name, attrs[i].value);\\n      }\\n    }\\n\\n    if (node.hasChildNodes()) {\\n      const children = node.childNodes,\\n            n = children.length;\\n\\n      for (let i=0; i<n; i++) {\\n        const child = children[i];\\n        child.nodeType === 3 // text node\\n          ? m.text(child.nodeValue)\\n          : _serialize(m, child);\\n      }\\n    }\\n\\n    return m.close();\\n  }\\n\\n  const styles = {\\n    fill:             'fill',\\n    fillOpacity:      'fill-opacity',\\n    stroke:           'stroke',\\n    strokeOpacity:    'stroke-opacity',\\n    strokeWidth:      'stroke-width',\\n    strokeCap:        'stroke-linecap',\\n    strokeJoin:       'stroke-linejoin',\\n    strokeDash:       'stroke-dasharray',\\n    strokeDashOffset: 'stroke-dashoffset',\\n    strokeMiterLimit: 'stroke-miterlimit',\\n    opacity:          'opacity',\\n    blend:            'mix-blend-mode'\\n  };\\n\\n  // ensure miter limit default is consistent with canvas (#2498)\\n  const rootAttributes = {\\n    'fill': 'none',\\n    'stroke-miterlimit': 10\\n  };\\n\\n  const RootIndex = 0,\\n        ns = metadata.xmlns;\\n\\n  function SVGRenderer(loader) {\\n    Renderer.call(this, loader);\\n    this._dirtyID = 0;\\n    this._dirty = [];\\n    this._svg = null;\\n    this._root = null;\\n    this._defs = null;\\n  }\\n\\n  const base$1 = Renderer.prototype;\\n\\n  vegaUtil.inherits(SVGRenderer, Renderer, {\\n    /**\\n     * Initialize a new SVGRenderer instance.\\n     * @param {DOMElement} el - The containing DOM element for the display.\\n     * @param {number} width - The coordinate width of the display, in pixels.\\n     * @param {number} height - The coordinate height of the display, in pixels.\\n     * @param {Array<number>} origin - The origin of the display, in pixels.\\n     *   The coordinate system will be translated to this point.\\n     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\\n     *   the width and height to determine the final pixel size.\\n     * @return {SVGRenderer} - This renderer instance.\\n     */\\n    initialize(el, width, height, origin, scaleFactor) {\\n      // create the svg definitions cache\\n      this._defs = {};\\n      this._clearDefs();\\n\\n      if (el) {\\n        this._svg = domChild(el, 0, 'svg', ns);\\n        setAttributes(this._svg, metadata);\\n        this._svg.setAttribute('class', 'marks');\\n        domClear(el, 1);\\n\\n        // set the svg root group\\n        this._root = domChild(this._svg, RootIndex, 'g', ns);\\n        setAttributes(this._root, rootAttributes);\\n\\n        // ensure no additional child elements\\n        domClear(this._svg, RootIndex + 1);\\n      }\\n\\n      // set background color if defined\\n      this.background(this._bgcolor);\\n\\n      return base$1.initialize.call(this, el, width, height, origin, scaleFactor);\\n    },\\n\\n    /**\\n     * Get / set the background color.\\n     */\\n    background(bgcolor) {\\n      if (arguments.length && this._svg) {\\n        this._svg.style.setProperty('background-color', bgcolor);\\n      }\\n      return base$1.background.apply(this, arguments);\\n    },\\n\\n    /**\\n     * Resize the display.\\n     * @param {number} width - The new coordinate width of the display, in pixels.\\n     * @param {number} height - The new coordinate height of the display, in pixels.\\n     * @param {Array<number>} origin - The new origin of the display, in pixels.\\n     *   The coordinate system will be translated to this point.\\n     * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\\n     *   the width and height to determine the final pixel size.\\n     * @return {SVGRenderer} - This renderer instance;\\n     */\\n    resize(width, height, origin, scaleFactor) {\\n      base$1.resize.call(this, width, height, origin, scaleFactor);\\n\\n      if (this._svg) {\\n        setAttributes(this._svg, {\\n          width: this._width * this._scale,\\n          height: this._height * this._scale,\\n          viewBox: `0 0 ${this._width} ${this._height}`\\n        });\\n        this._root.setAttribute('transform', `translate(${this._origin})`);\\n      }\\n\\n      this._dirty = [];\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Returns the SVG element of the visualization.\\n     * @return {DOMElement} - The SVG element.\\n     */\\n    canvas() {\\n      return this._svg;\\n    },\\n\\n    /**\\n     * Returns an SVG text string for the rendered content,\\n     * or null if this renderer is currently headless.\\n     */\\n    svg() {\\n      const svg = this._svg,\\n            bg = this._bgcolor;\\n\\n      if (!svg) return null;\\n\\n      let node;\\n      if (bg) {\\n        svg.removeAttribute('style');\\n        node = domChild(svg, RootIndex, 'rect', ns);\\n        setAttributes(node, {width: this._width, height: this._height, fill: bg});\\n      }\\n\\n      const text = serializeXML(svg);\\n\\n      if (bg) {\\n        svg.removeChild(node);\\n        this._svg.style.setProperty('background-color', bg);\\n      }\\n\\n      return text;\\n    },\\n\\n    /**\\n     * Internal rendering method.\\n     * @param {object} scene - The root mark of a scenegraph to render.\\n     */\\n    _render(scene) {\\n      // perform spot updates and re-render markup\\n      if (this._dirtyCheck()) {\\n        if (this._dirtyAll) this._clearDefs();\\n        this.mark(this._root, scene);\\n        domClear(this._root, 1);\\n      }\\n\\n      this.defs();\\n\\n      this._dirty = [];\\n      ++this._dirtyID;\\n\\n      return this;\\n    },\\n\\n    // -- Manage rendering of items marked as dirty --\\n\\n    /**\\n     * Flag a mark item as dirty.\\n     * @param {Item} item - The mark item.\\n     */\\n    dirty(item) {\\n      if (item.dirty !== this._dirtyID) {\\n        item.dirty = this._dirtyID;\\n        this._dirty.push(item);\\n      }\\n    },\\n\\n    /**\\n     * Check if a mark item is considered dirty.\\n     * @param {Item} item - The mark item.\\n     */\\n    isDirty(item) {\\n      return this._dirtyAll\\n        || !item._svg\\n        || item.dirty === this._dirtyID;\\n    },\\n\\n    /**\\n     * Internal method to check dirty status and, if possible,\\n     * make targetted updates without a full rendering pass.\\n     */\\n    _dirtyCheck() {\\n      this._dirtyAll = true;\\n      const items = this._dirty;\\n      if (!items.length || !this._dirtyID) return true;\\n\\n      const id = ++this._dirtyID;\\n      let item, mark, type, mdef, i, n, o;\\n\\n      for (i=0, n=items.length; i<n; ++i) {\\n        item = items[i];\\n        mark = item.mark;\\n\\n        if (mark.marktype !== type) {\\n          // memoize mark instance lookup\\n          type = mark.marktype;\\n          mdef = Marks[type];\\n        }\\n\\n        if (mark.zdirty && mark.dirty !== id) {\\n          this._dirtyAll = false;\\n          dirtyParents(item, id);\\n          mark.items.forEach(i => { i.dirty = id; });\\n        }\\n        if (mark.zdirty) continue; // handle in standard drawing pass\\n\\n        if (item.exit) { // EXIT\\n          if (mdef.nested && mark.items.length) {\\n            // if nested mark with remaining points, update instead\\n            o = mark.items[0];\\n            if (o._svg) this._update(mdef, o._svg, o);\\n          } else if (item._svg) {\\n            // otherwise remove from DOM\\n            o = item._svg.parentNode;\\n            if (o) o.removeChild(item._svg);\\n          }\\n          item._svg = null;\\n          continue;\\n        }\\n\\n        item = (mdef.nested ? mark.items[0] : item);\\n        if (item._update === id) continue; // already visited\\n\\n        if (!item._svg || !item._svg.ownerSVGElement) {\\n          // ENTER\\n          this._dirtyAll = false;\\n          dirtyParents(item, id);\\n        } else {\\n          // IN-PLACE UPDATE\\n          this._update(mdef, item._svg, item);\\n        }\\n        item._update = id;\\n      }\\n      return !this._dirtyAll;\\n    },\\n\\n    // -- Construct & maintain scenegraph to SVG mapping ---\\n\\n    /**\\n     * Render a set of mark items.\\n     * @param {SVGElement} el - The parent element in the SVG tree.\\n     * @param {object} scene - The mark parent to render.\\n     * @param {SVGElement} prev - The previous sibling in the SVG tree.\\n     */\\n    mark(el, scene, prev) {\\n      if (!this.isDirty(scene)) return scene._svg;\\n\\n      const svg = this._svg,\\n            mdef = Marks[scene.marktype],\\n            events = scene.interactive === false ? 'none' : null,\\n            isGroup = mdef.tag === 'g';\\n\\n      let sibling = null,\\n          i = 0;\\n\\n      const parent = bind(scene, el, prev, 'g', svg);\\n      parent.setAttribute('class', cssClass(scene));\\n\\n      // apply aria attributes to parent container element\\n      const aria = ariaMarkAttributes(scene);\\n      for (const key in aria) setAttribute(parent, key, aria[key]);\\n\\n      if (!isGroup) {\\n        setAttribute(parent, 'pointer-events', events);\\n      }\\n      setAttribute(parent, 'clip-path',\\n        scene.clip ? clip(this, scene, scene.group) : null);\\n\\n      const process = item => {\\n        const dirty = this.isDirty(item),\\n              node = bind(item, parent, sibling, mdef.tag, svg);\\n\\n        if (dirty) {\\n          this._update(mdef, node, item);\\n          if (isGroup) recurse(this, node, item);\\n        }\\n\\n        sibling = node;\\n        ++i;\\n      };\\n\\n      if (mdef.nested) {\\n        if (scene.items.length) process(scene.items[0]);\\n      } else {\\n        visit(scene, process);\\n      }\\n\\n      domClear(parent, i);\\n      return parent;\\n    },\\n\\n    /**\\n     * Update the attributes of an SVG element for a mark item.\\n     * @param {object} mdef - The mark definition object\\n     * @param {SVGElement} el - The SVG element.\\n     * @param {Item} item - The mark item.\\n     */\\n    _update(mdef, el, item) {\\n      // set dom element and values cache\\n      // provides access to emit method\\n      element = el;\\n      values = el.__values__;\\n\\n      // apply aria-specific properties\\n      ariaItemAttributes(emit, item);\\n\\n      // apply svg attributes\\n      mdef.attr(emit, item, this);\\n\\n      // some marks need special treatment\\n      const extra = mark_extras[mdef.type];\\n      if (extra) extra.call(this, mdef, el, item);\\n\\n      // apply svg style attributes\\n      // note: element state may have been modified by 'extra' method\\n      if (element) this.style(element, item);\\n    },\\n\\n    /**\\n     * Update the presentation attributes of an SVG element for a mark item.\\n     * @param {SVGElement} el - The SVG element.\\n     * @param {Item} item - The mark item.\\n     */\\n    style(el, item) {\\n      if (item == null) return;\\n\\n      for (const prop in styles) {\\n        let value = prop === 'font' ? fontFamily(item) : item[prop];\\n        if (value === values[prop]) continue;\\n\\n        const name = styles[prop];\\n        if (value == null) {\\n          el.removeAttribute(name);\\n        } else {\\n          if (isGradient(value)) {\\n            value = gradientRef(value, this._defs.gradient, href());\\n          }\\n          el.setAttribute(name, value + '');\\n        }\\n\\n        values[prop] = value;\\n      }\\n    },\\n\\n    /**\\n     * Render SVG defs, as needed.\\n     * Must be called *after* marks have been processed to ensure the\\n     * collected state is current and accurate.\\n     */\\n    defs() {\\n      const svg = this._svg,\\n            defs = this._defs;\\n\\n      let el = defs.el,\\n          index = 0;\\n\\n      for (const id in defs.gradient) {\\n        if (!el) defs.el = (el = domChild(svg, RootIndex + 1, 'defs', ns));\\n        index = updateGradient(el, defs.gradient[id], index);\\n      }\\n\\n      for (const id in defs.clipping) {\\n        if (!el) defs.el = (el = domChild(svg, RootIndex + 1, 'defs', ns));\\n        index = updateClipping(el, defs.clipping[id], index);\\n      }\\n\\n      // clean-up\\n      if (el) {\\n        index === 0\\n          ? (svg.removeChild(el), defs.el = null)\\n          : domClear(el, index);\\n      }\\n    },\\n\\n    /**\\n     * Clear defs caches.\\n     */\\n    _clearDefs() {\\n      const def = this._defs;\\n      def.gradient = {};\\n      def.clipping = {};\\n    }\\n  });\\n\\n  // mark ancestor chain with a dirty id\\n  function dirtyParents(item, id) {\\n    for (; item && item.dirty !== id; item=item.mark.group) {\\n      item.dirty = id;\\n      if (item.mark && item.mark.dirty !== id) {\\n        item.mark.dirty = id;\\n      } else return;\\n    }\\n  }\\n\\n  // update gradient definitions\\n  function updateGradient(el, grad, index) {\\n    let i, n, stop;\\n\\n    if (grad.gradient === 'radial') {\\n      // SVG radial gradients automatically transform to normalized bbox\\n      // coordinates, in a way that is cumbersome to replicate in canvas.\\n      // We wrap the radial gradient in a pattern element, allowing us to\\n      // maintain a circular gradient that matches what canvas provides.\\n      let pt = domChild(el, index++, 'pattern', ns);\\n      setAttributes(pt, {\\n        id: patternPrefix + grad.id,\\n        viewBox: '0,0,1,1',\\n        width: '100%',\\n        height: '100%',\\n        preserveAspectRatio: 'xMidYMid slice'\\n      });\\n\\n      pt = domChild(pt, 0, 'rect', ns);\\n      setAttributes(pt, {\\n        width: 1,\\n        height: 1,\\n        fill: `url(${href()}#${grad.id})`\\n      });\\n\\n      el = domChild(el, index++, 'radialGradient', ns);\\n      setAttributes(el, {\\n        id: grad.id,\\n        fx: grad.x1,\\n        fy: grad.y1,\\n        fr: grad.r1,\\n        cx: grad.x2,\\n        cy: grad.y2,\\n        r: grad.r2\\n      });\\n    } else {\\n      el = domChild(el, index++, 'linearGradient', ns);\\n      setAttributes(el, {\\n        id: grad.id,\\n        x1: grad.x1,\\n        x2: grad.x2,\\n        y1: grad.y1,\\n        y2: grad.y2\\n      });\\n    }\\n\\n    for (i=0, n=grad.stops.length; i<n; ++i) {\\n      stop = domChild(el, i, 'stop', ns);\\n      stop.setAttribute('offset', grad.stops[i].offset);\\n      stop.setAttribute('stop-color', grad.stops[i].color);\\n    }\\n    domClear(el, i);\\n\\n    return index;\\n  }\\n\\n  // update clipping path definitions\\n  function updateClipping(el, clip, index) {\\n    let mask;\\n\\n    el = domChild(el, index, 'clipPath', ns);\\n    el.setAttribute('id', clip.id);\\n\\n    if (clip.path) {\\n      mask = domChild(el, 0, 'path', ns);\\n      mask.setAttribute('d', clip.path);\\n    } else {\\n      mask = domChild(el, 0, 'rect', ns);\\n      setAttributes(mask, {x: 0, y: 0, width: clip.width, height: clip.height});\\n    }\\n    domClear(el, 1);\\n\\n    return index + 1;\\n  }\\n\\n  // Recursively process group contents.\\n  function recurse(renderer, el, group) {\\n    el = el.lastChild.previousSibling;\\n    let prev, idx = 0;\\n\\n    visit(group, item => {\\n      prev = renderer.mark(el, item, prev);\\n      ++idx;\\n    });\\n\\n    // remove any extraneous DOM elements\\n    domClear(el, 1 + idx);\\n  }\\n\\n  // Bind a scenegraph item to an SVG DOM element.\\n  // Create new SVG elements as needed.\\n  function bind(item, el, sibling, tag, svg) {\\n    let node = item._svg, doc;\\n\\n    // create a new dom node if needed\\n    if (!node) {\\n      doc = el.ownerDocument;\\n      node = domCreate(doc, tag, ns);\\n      item._svg = node;\\n\\n      if (item.mark) {\\n        node.__data__ = item;\\n        node.__values__ = {fill: 'default'};\\n\\n        // if group, create background, content, and foreground elements\\n        if (tag === 'g') {\\n          const bg = domCreate(doc, 'path', ns);\\n          node.appendChild(bg);\\n          bg.__data__ = item;\\n\\n          const cg = domCreate(doc, 'g', ns);\\n          node.appendChild(cg);\\n          cg.__data__ = item;\\n\\n          const fg = domCreate(doc, 'path', ns);\\n          node.appendChild(fg);\\n          fg.__data__ = item;\\n          fg.__values__ = {fill: 'default'};\\n        }\\n      }\\n    }\\n\\n    // (re-)insert if (a) not contained in SVG or (b) sibling order has changed\\n    if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {\\n      el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);\\n    }\\n\\n    return node;\\n  }\\n\\n  // check if two nodes are ordered siblings\\n  function siblingCheck(node, sibling) {\\n    return node.parentNode\\n      && node.parentNode.childNodes.length > 1\\n      && node.previousSibling != sibling; // treat null/undefined the same\\n  }\\n\\n  // -- Set attributes & styles on SVG elements ---\\n\\n  let element = null, // temp var for current SVG element\\n      values = null;  // temp var for current values hash\\n\\n  // Extra configuration for certain mark types\\n  const mark_extras = {\\n    group(mdef, el, item) {\\n      const fg = element = el.childNodes[2];\\n      values = fg.__values__;\\n      mdef.foreground(emit, item, this);\\n\\n      values = el.__values__; // use parent's values hash\\n      element = el.childNodes[1];\\n      mdef.content(emit, item, this);\\n\\n      const bg = element = el.childNodes[0];\\n      mdef.background(emit, item, this);\\n\\n      const value = item.mark.interactive === false ? 'none' : null;\\n      if (value !== values.events) {\\n        setAttribute(fg, 'pointer-events', value);\\n        setAttribute(bg, 'pointer-events', value);\\n        values.events = value;\\n      }\\n\\n      if (item.strokeForeground && item.stroke) {\\n        const fill = item.fill;\\n        setAttribute(fg, 'display', null);\\n\\n        // set style of background\\n        this.style(bg, item);\\n        setAttribute(bg, 'stroke', null);\\n\\n        // set style of foreground\\n        if (fill) item.fill = null;\\n        values = fg.__values__;\\n        this.style(fg, item);\\n        if (fill) item.fill = fill;\\n\\n        // leave element null to prevent downstream styling\\n        element = null;\\n      } else {\\n        // ensure foreground is ignored\\n        setAttribute(fg, 'display', 'none');\\n      }\\n    },\\n    image(mdef, el, item) {\\n      if (item.smooth === false) {\\n        setStyle(el, 'image-rendering', 'optimizeSpeed');\\n        setStyle(el, 'image-rendering', 'pixelated');\\n      } else {\\n        setStyle(el, 'image-rendering', null);\\n      }\\n    },\\n    text(mdef, el, item) {\\n      const tl = textLines(item);\\n      let key, value, doc, lh;\\n\\n      if (vegaUtil.isArray(tl)) {\\n        // multi-line text\\n        value = tl.map(_ => textValue(item, _));\\n        key = value.join('\\\\n'); // content cache key\\n\\n        if (key !== values.text) {\\n          domClear(el, 0);\\n          doc = el.ownerDocument;\\n          lh = lineHeight(item);\\n          value.forEach((t, i) => {\\n            const ts = domCreate(doc, 'tspan', ns);\\n            ts.__data__ = item; // data binding\\n            ts.textContent = t;\\n            if (i) {\\n              ts.setAttribute('x', 0);\\n              ts.setAttribute('dy', lh);\\n            }\\n            el.appendChild(ts);\\n          });\\n          values.text = key;\\n        }\\n      } else {\\n        // single-line text\\n        value = textValue(item, tl);\\n        if (value !== values.text) {\\n          el.textContent = value;\\n          values.text = value;\\n        }\\n      }\\n\\n      setAttribute(el, 'font-family', fontFamily(item));\\n      setAttribute(el, 'font-size', fontSize(item) + 'px');\\n      setAttribute(el, 'font-style', item.fontStyle);\\n      setAttribute(el, 'font-variant', item.fontVariant);\\n      setAttribute(el, 'font-weight', item.fontWeight);\\n    }\\n  };\\n\\n  function emit(name, value, ns) {\\n    // early exit if value is unchanged\\n    if (value === values[name]) return;\\n\\n    // use appropriate method given namespace (ns)\\n    if (ns) {\\n      setAttributeNS(element, name, value, ns);\\n    } else {\\n      setAttribute(element, name, value);\\n    }\\n\\n    // note current value for future comparison\\n    values[name] = value;\\n  }\\n\\n  function setStyle(el, name, value) {\\n    if (value !== values[name]) {\\n      if (value == null) {\\n        el.style.removeProperty(name);\\n      } else {\\n        el.style.setProperty(name, value + '');\\n      }\\n      values[name] = value;\\n    }\\n  }\\n\\n  function setAttributes(el, attrs) {\\n    for (const key in attrs) {\\n      setAttribute(el, key, attrs[key]);\\n    }\\n  }\\n\\n  function setAttribute(el, name, value) {\\n    if (value != null) {\\n      // if value is provided, update DOM attribute\\n      el.setAttribute(name, value);\\n    } else {\\n      // else remove DOM attribute\\n      el.removeAttribute(name);\\n    }\\n  }\\n\\n  function setAttributeNS(el, name, value, ns) {\\n    if (value != null) {\\n      // if value is provided, update DOM attribute\\n      el.setAttributeNS(ns, name, value);\\n    } else {\\n      // else remove DOM attribute\\n      el.removeAttributeNS(ns, name);\\n    }\\n  }\\n\\n  function href() {\\n    let loc;\\n    return typeof window === 'undefined' ? ''\\n      : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length)\\n      : loc.href;\\n  }\\n\\n  function SVGStringRenderer(loader) {\\n    Renderer.call(this, loader);\\n    this._text = null;\\n    this._defs = {\\n      gradient: {},\\n      clipping: {}\\n    };\\n  }\\n\\n  vegaUtil.inherits(SVGStringRenderer, Renderer, {\\n    /**\\n     * Returns the rendered SVG text string,\\n     * or null if rendering has not yet occurred.\\n     */\\n    svg() {\\n      return this._text;\\n    },\\n\\n    /**\\n     * Internal rendering method.\\n     * @param {object} scene - The root mark of a scenegraph to render.\\n     */\\n    _render(scene) {\\n      const m = markup();\\n\\n      // svg tag\\n      m.open('svg', vegaUtil.extend({}, metadata, {\\n        class:   'marks',\\n        width:   this._width * this._scale,\\n        height:  this._height * this._scale,\\n        viewBox: `0 0 ${this._width} ${this._height}`\\n      }));\\n\\n      // background, if defined\\n      const bg = this._bgcolor;\\n      if (bg && bg !== 'transparent' && bg !== 'none') {\\n        m.open('rect', {\\n          width:  this._width,\\n          height: this._height,\\n          fill:   bg\\n        }).close();\\n      }\\n\\n      // root content group\\n      m.open('g', rootAttributes, {\\n        transform: 'translate(' + this._origin + ')'\\n      });\\n      this.mark(m, scene);\\n      m.close(); // </g>\\n\\n      // defs\\n      this.defs(m);\\n\\n      // get SVG text string\\n      this._text = m.close() + '';\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Render a set of mark items.\\n     * @param {object} m - The markup context.\\n     * @param {object} scene - The mark parent to render.\\n     */\\n    mark(m, scene) {\\n      const mdef = Marks[scene.marktype],\\n            tag  = mdef.tag,\\n            attrList = [ariaItemAttributes, mdef.attr];\\n\\n      // render opening group tag\\n      m.open('g',\\n        {\\n          'class': cssClass(scene),\\n          'clip-path': scene.clip ? clip(this, scene, scene.group) : null\\n        },\\n        ariaMarkAttributes(scene),\\n        {\\n          'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null\\n        }\\n      );\\n\\n      // render contained elements\\n      const process = item => {\\n        const href = this.href(item);\\n        if (href) m.open('a', href);\\n\\n        m.open(\\n          tag,\\n          this.attr(scene, item, attrList, tag !== 'g' ? tag : null)\\n        );\\n\\n        if (tag === 'text') {\\n          const tl = textLines(item);\\n          if (vegaUtil.isArray(tl)) {\\n            // multi-line text\\n            const attrs = {x: 0, dy: lineHeight(item)};\\n            for (let i=0; i<tl.length; ++i) {\\n              m.open('tspan', i ? attrs: null)\\n                .text(textValue(item, tl[i]))\\n                .close();\\n            }\\n          } else {\\n            // single-line text\\n            m.text(textValue(item, tl));\\n          }\\n        } else if (tag === 'g') {\\n          const fore = item.strokeForeground,\\n                fill = item.fill,\\n                stroke = item.stroke;\\n\\n          if (fore && stroke) {\\n            item.stroke = null;\\n          }\\n\\n          m.open(\\n            'path',\\n            this.attr(scene, item, mdef.background, 'bgrect')\\n          ).close();\\n\\n          // recurse for group content\\n          m.open('g', this.attr(scene, item, mdef.content));\\n          visit(item, scene => this.mark(m, scene));\\n          m.close();\\n\\n          if (fore && stroke) {\\n            if (fill) item.fill = null;\\n            item.stroke = stroke;\\n\\n            m.open(\\n              'path',\\n              this.attr(scene, item, mdef.foreground, 'bgrect')\\n            ).close();\\n\\n            if (fill) item.fill = fill;\\n          } else {\\n            m.open(\\n              'path',\\n              this.attr(scene, item, mdef.foreground, 'bgfore')\\n            ).close();\\n          }\\n        }\\n\\n        m.close(); // </tag>\\n        if (href) m.close(); // </a>\\n      };\\n\\n      if (mdef.nested) {\\n        if (scene.items && scene.items.length) process(scene.items[0]);\\n      } else {\\n        visit(scene, process);\\n      }\\n\\n      // render closing group tag\\n      return m.close(); // </g>\\n    },\\n\\n    /**\\n     * Get href attributes for a hyperlinked mark item.\\n     * @param {Item} item - The mark item.\\n     */\\n    href(item) {\\n      const href = item.href;\\n      let attr;\\n\\n      if (href) {\\n        if (attr = this._hrefs && this._hrefs[href]) {\\n          return attr;\\n        } else {\\n          this.sanitizeURL(href).then(attr => {\\n            // rewrite to use xlink namespace\\n            attr['xlink:href'] = attr.href;\\n            attr.href = null;\\n            (this._hrefs || (this._hrefs = {}))[href] = attr;\\n          });\\n        }\\n      }\\n      return null;\\n    },\\n\\n    /**\\n     * Get an object of SVG attributes for a mark item.\\n     * @param {object} scene - The mark parent.\\n     * @param {Item} item - The mark item.\\n     * @param {array|function} attrs - One or more attribute emitters.\\n     * @param {string} tag - The tag being rendered.\\n     */\\n    attr(scene, item, attrs, tag) {\\n      const object = {},\\n            emit = (name, value, ns, prefixed) => {\\n              object[prefixed || name] = value;\\n            };\\n\\n      // apply mark specific attributes\\n      if (Array.isArray(attrs)) {\\n        attrs.forEach(fn => fn(emit, item, this));\\n      } else {\\n        attrs(emit, item, this);\\n      }\\n\\n      // apply style attributes\\n      if (tag) {\\n        style(object, item, scene, tag, this._defs);\\n      }\\n\\n      return object;\\n    },\\n\\n    /**\\n     * Render SVG defs, as needed.\\n     * Must be called *after* marks have been processed to ensure the\\n     * collected state is current and accurate.\\n     * @param {object} m - The markup context.\\n     */\\n    defs(m) {\\n      const gradient = this._defs.gradient,\\n            clipping = this._defs.clipping,\\n            count = Object.keys(gradient).length + Object.keys(clipping).length;\\n\\n      if (count === 0) return; // nothing to do\\n\\n      m.open('defs');\\n\\n      for (const id in gradient) {\\n        const def = gradient[id],\\n              stops = def.stops;\\n\\n        if (def.gradient === 'radial') {\\n          // SVG radial gradients automatically transform to normalized bbox\\n          // coordinates, in a way that is cumbersome to replicate in canvas.\\n          // We wrap the radial gradient in a pattern element, allowing us to\\n          // maintain a circular gradient that matches what canvas provides.\\n\\n          m.open('pattern', {\\n            id: patternPrefix + id,\\n            viewBox: '0,0,1,1',\\n            width: '100%',\\n            height: '100%',\\n            preserveAspectRatio: 'xMidYMid slice'\\n          });\\n\\n          m.open('rect', {\\n            width:  '1',\\n            height: '1',\\n            fill:   'url(#' + id + ')'\\n          }).close();\\n\\n          m.close(); // </pattern>\\n\\n          m.open('radialGradient', {\\n            id: id,\\n            fx: def.x1,\\n            fy: def.y1,\\n            fr: def.r1,\\n            cx: def.x2,\\n            cy: def.y2,\\n            r: def.r2\\n          });\\n        } else {\\n          m.open('linearGradient', {\\n            id: id,\\n            x1: def.x1,\\n            x2: def.x2,\\n            y1: def.y1,\\n            y2: def.y2\\n          });\\n        }\\n\\n        for (let i = 0; i < stops.length; ++i) {\\n          m.open('stop', {\\n            offset: stops[i].offset,\\n            'stop-color': stops[i].color\\n          }).close();\\n        }\\n\\n        m.close();\\n      }\\n\\n      for (const id in clipping) {\\n        const def = clipping[id];\\n\\n        m.open('clipPath', {id: id});\\n        if (def.path) {\\n          m.open('path', {\\n            d: def.path\\n          }).close();\\n        } else {\\n          m.open('rect', {\\n            x: 0,\\n            y: 0,\\n            width: def.width,\\n            height: def.height\\n          }).close();\\n        }\\n        m.close();\\n      }\\n\\n      m.close();\\n    }\\n  });\\n\\n  // Helper function for attr for style presentation attributes\\n  function style(s, item, scene, tag, defs) {\\n    if (item == null) return s;\\n\\n    if (tag === 'bgrect' && scene.interactive === false) {\\n      s['pointer-events'] = 'none';\\n    }\\n\\n    if (tag === 'bgfore') {\\n      if (scene.interactive === false) {\\n        s['pointer-events'] = 'none';\\n      }\\n      s.display = 'none';\\n      if (item.fill !== null) return s;\\n    }\\n\\n    if (tag === 'image' && item.smooth === false) {\\n      s.style = 'image-rendering: optimizeSpeed; image-rendering: pixelated;';\\n    }\\n\\n    if (tag === 'text') {\\n      s['font-family'] = fontFamily(item);\\n      s['font-size'] = fontSize(item) + 'px';\\n      s['font-style'] = item.fontStyle;\\n      s['font-variant'] = item.fontVariant;\\n      s['font-weight'] = item.fontWeight;\\n    }\\n\\n    for (const prop in styles) {\\n      let value = item[prop];\\n      const name = styles[prop];\\n\\n      if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ; else if (value != null) {\\n        if (isGradient(value)) {\\n          value = gradientRef(value, defs.gradient, '');\\n        }\\n        s[name] = value;\\n      }\\n    }\\n\\n    return s;\\n  }\\n\\n  var Canvas = 'canvas';\\n  var PNG = 'png';\\n  var SVG = 'svg';\\n  var None = 'none';\\n\\n  var RenderType = {\\n    Canvas: Canvas,\\n    PNG:    PNG,\\n    SVG:    SVG,\\n    None:   None\\n  };\\n\\n  var modules = {};\\n\\n  modules[Canvas] = modules[PNG] = {\\n    renderer: CanvasRenderer,\\n    headless: CanvasRenderer,\\n    handler:  CanvasHandler\\n  };\\n\\n  modules[SVG] = {\\n    renderer: SVGRenderer,\\n    headless: SVGStringRenderer,\\n    handler:  SVGHandler\\n  };\\n\\n  modules[None] = {};\\n\\n  function renderModule(name, _) {\\n    name = String(name || '').toLowerCase();\\n    if (arguments.length > 1) {\\n      modules[name] = _;\\n      return this;\\n    } else {\\n      return modules[name];\\n    }\\n  }\\n\\n  function intersect(scene, bounds, filter) {\\n    const hits = [], // intersection results\\n          box = new Bounds().union(bounds), // defensive copy\\n          type = scene.marktype;\\n\\n    return type ? intersectMark(scene, box, filter, hits)\\n      : type === 'group' ? intersectGroup(scene, box, filter, hits)\\n      : vegaUtil.error('Intersect scene must be mark node or group item.');\\n  }\\n\\n  function intersectMark(mark, box, filter, hits) {\\n    if (visitMark(mark, box, filter)) {\\n      const items = mark.items,\\n            type = mark.marktype,\\n            n = items.length;\\n\\n      let i = 0;\\n\\n      if (type === 'group') {\\n        for (; i<n; ++i) {\\n          intersectGroup(items[i], box, filter, hits);\\n        }\\n      } else {\\n        for (const test = Marks[type].isect; i<n; ++i) {\\n          const item = items[i];\\n          if (intersectItem(item, box, test)) hits.push(item);\\n        }\\n      }\\n    }\\n    return hits;\\n  }\\n\\n  function visitMark(mark, box, filter) {\\n    // process if bounds intersect and if\\n    // (1) mark is a group mark (so we must recurse), or\\n    // (2) mark is interactive and passes filter\\n    return mark.bounds && box.intersects(mark.bounds) && (\\n      mark.marktype === 'group' ||\\n      mark.interactive !== false && (!filter || filter(mark))\\n    );\\n  }\\n\\n  function intersectGroup(group, box, filter, hits) {\\n    // test intersect against group\\n    // skip groups by default unless filter says otherwise\\n    if ((filter && filter(group.mark)) &&\\n        intersectItem(group, box, Marks.group.isect)) {\\n      hits.push(group);\\n    }\\n\\n    // recursively test children marks\\n    // translate box to group coordinate space\\n    const marks = group.items,\\n          n = marks && marks.length;\\n\\n    if (n) {\\n      const x = group.x || 0,\\n            y = group.y || 0;\\n      box.translate(-x, -y);\\n      for (let i=0; i<n; ++i) {\\n        intersectMark(marks[i], box, filter, hits);\\n      }\\n      box.translate(x, y);\\n    }\\n\\n    return hits;\\n  }\\n\\n  function intersectItem(item, box, test) {\\n    // test bounds enclosure, bounds intersection, then detailed test\\n    const bounds = item.bounds;\\n    return box.encloses(bounds) || (box.intersects(bounds) && test(item, box));\\n  }\\n\\n  const clipBounds = new Bounds();\\n\\n  function boundClip(mark) {\\n    const clip = mark.clip;\\n\\n    if (vegaUtil.isFunction(clip)) {\\n      clip(boundContext(clipBounds.clear()));\\n    } else if (clip) {\\n      clipBounds.set(0, 0, mark.group.width, mark.group.height);\\n    } else return;\\n\\n    mark.bounds.intersect(clipBounds);\\n  }\\n\\n  var TOLERANCE = 1e-9;\\n\\n  function sceneEqual(a, b, key) {\\n    return (a === b) ? true\\n      : (key === 'path') ? pathEqual(a, b)\\n      : (a instanceof Date && b instanceof Date) ? +a === +b\\n      : (vegaUtil.isNumber(a) && vegaUtil.isNumber(b)) ? Math.abs(a - b) <= TOLERANCE\\n      : (!a || !b || !vegaUtil.isObject(a) && !vegaUtil.isObject(b)) ? a == b\\n      : objectEqual(a, b);\\n  }\\n\\n  function pathEqual(a, b) {\\n    return sceneEqual(pathParse(a), pathParse(b));\\n  }\\n\\n  function objectEqual(a, b) {\\n    var ka = Object.keys(a),\\n        kb = Object.keys(b),\\n        key, i;\\n\\n    if (ka.length !== kb.length) return false;\\n\\n    ka.sort();\\n    kb.sort();\\n\\n    for (i = ka.length - 1; i >= 0; i--) {\\n      if (ka[i] != kb[i]) return false;\\n    }\\n\\n    for (i = ka.length - 1; i >= 0; i--) {\\n      key = ka[i];\\n      if (!sceneEqual(a[key], b[key], key)) return false;\\n    }\\n\\n    return typeof a === typeof b;\\n  }\\n\\n  function resetSVGDefIds() {\\n    resetSVGClipId();\\n    resetSVGGradientId();\\n  }\\n\\n  exports.Bounds = Bounds;\\n  exports.CanvasHandler = CanvasHandler;\\n  exports.CanvasRenderer = CanvasRenderer;\\n  exports.Gradient = Gradient;\\n  exports.GroupItem = GroupItem;\\n  exports.Handler = Handler;\\n  exports.Item = Item;\\n  exports.Marks = Marks;\\n  exports.RenderType = RenderType;\\n  exports.Renderer = Renderer;\\n  exports.ResourceLoader = ResourceLoader;\\n  exports.SVGHandler = SVGHandler;\\n  exports.SVGRenderer = SVGRenderer;\\n  exports.SVGStringRenderer = SVGStringRenderer;\\n  exports.Scenegraph = Scenegraph;\\n  exports.boundClip = boundClip;\\n  exports.boundContext = boundContext;\\n  exports.boundItem = boundItem;\\n  exports.boundMark = boundMark;\\n  exports.boundStroke = boundStroke;\\n  exports.domChild = domChild;\\n  exports.domClear = domClear;\\n  exports.domCreate = domCreate;\\n  exports.domFind = domFind;\\n  exports.font = font;\\n  exports.fontFamily = fontFamily;\\n  exports.fontSize = fontSize;\\n  exports.intersect = intersect;\\n  exports.intersectBoxLine = intersectBoxLine;\\n  exports.intersectPath = intersectPath;\\n  exports.intersectPoint = intersectPoint;\\n  exports.intersectRule = intersectRule;\\n  exports.lineHeight = lineHeight;\\n  exports.markup = markup;\\n  exports.multiLineOffset = multiLineOffset;\\n  exports.pathCurves = curves;\\n  exports.pathEqual = pathEqual;\\n  exports.pathParse = pathParse;\\n  exports.pathRectangle = vg_rect;\\n  exports.pathRender = pathRender;\\n  exports.pathSymbols = symbols;\\n  exports.pathTrail = vg_trail;\\n  exports.point = point;\\n  exports.renderModule = renderModule;\\n  exports.resetSVGClipId = resetSVGClipId;\\n  exports.resetSVGDefIds = resetSVGDefIds;\\n  exports.sceneEqual = sceneEqual;\\n  exports.sceneFromJSON = sceneFromJSON;\\n  exports.scenePickVisit = pickVisit;\\n  exports.sceneToJSON = sceneToJSON;\\n  exports.sceneVisit = visit;\\n  exports.sceneZOrder = zorder;\\n  exports.serializeXML = serializeXML;\\n  exports.textMetrics = textMetrics;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"d3\",\"vegaUtil\",\"d3Shape\",\"d3Path\",\"vegaCanvas\",\"vegaLoader\",\"vegaScale\",\"gradientRef\",\"g\",\"defs\",\"base\",\"type\",\"gradient\",\"id\",\"prefix\",\"patternPrefix\",\"gradient_id\",\"x1\",\"get\",\"y1\",\"r1\",\"x2\",\"y2\",\"r2\",\"val\",\"def\",\"curves\",\"orientation\",\"tension\",\"entry\",\"hasOwnProperty\",\"lookup\",\"curve\",\"pathParse\",\"pathstr\",\"result\",\"param\",\"n\",\"m\",\"path\",\"slice\",\"replace\",\"regexp\",\"split\",\"i\",\"length\",\"curr\",\"chunks\",\"trim\",\"cmd\",\"charAt\",\"parsed\",\"j\",\"push\",\"len\",\"cmdlen\",\"toLowerCase\",\"concat\",\"segments\",\"x\",\"y\",\"rx\",\"ry\",\"large\",\"sweep\",\"rotateX\",\"ox\",\"oy\",\"key\",\"join\",\"call\",\"arguments\",\"segmentCache\",\"th\",\"DegToRad\",\"sin_th\",\"Math\",\"sin\",\"cos_th\",\"cos\",\"abs\",\"px\",\"py\",\"pl\",\"sqrt\",\"a00\",\"a01\",\"a10\",\"a11\",\"x0\",\"y0\",\"sfactor_sq\",\"sfactor\",\"xc\",\"yc\",\"th0\",\"atan2\",\"th_arc\",\"th1\",\"Tau\",\"segs\",\"ceil\",\"HalfPi\",\"pathRender\",\"context\",\"l\",\"t\",\"sX\",\"sY\",\"previous\",\"controlX\",\"controlY\",\"beginPath\",\"current\",\"c\",\"temp\",\"lineTo\",\"moveTo\",\"tempX\",\"tempY\",\"bezierCurveTo\",\"quadraticCurveTo\",\"match\",\"tempControlX\",\"tempControlY\",\"drawArc\",\"closePath\",\"coords\",\"seg\",\"params\",\"bezierCache\",\"cx\",\"cy\",\"cos_th0\",\"sin_th0\",\"cos_th1\",\"sin_th1\",\"th_half\",\"sin_th_h2\",\"x3\",\"y3\",\"bez\",\"symbols\",\"_\",\"builtins\",\"customSymbol\",\"custom\",\"draw\",\"size\",\"rectangleX\",\"d\",\"rectangleY\",\"rectangleWidth\",\"width\",\"rectangleHeight\",\"height\",\"number\",\"clamp\",\"value\",\"min\",\"max\",\"vg_rect\",\"rectangle\",\"buffer\",\"w\",\"h\",\"s\",\"tl\",\"crTL\",\"tr\",\"crTR\",\"bl\",\"crBL\",\"br\",\"crBR\",\"rect\",\"C\",\"rectangle.x\",\"rectangle.y\",\"rectangle.width\",\"rectangle.height\",\"cornerRadius\",\"rectangle.cornerRadius\",\"rectangle.context\",\"vg_trail\",\"trail\",\"data\",\"defined0\",\"defined\",\"ready\",\"w2\",\"ux\",\"uy\",\"ud\",\"arc\",\"PI\",\"trail.x\",\"trail.y\",\"trail.size\",\"trail.defined\",\"trail.context\",\"a\",\"b\",\"hasCornerRadius\",\"item\",\"cornerRadiusTopLeft\",\"cornerRadiusTopRight\",\"cornerRadiusBottomRight\",\"cornerRadiusBottomLeft\",\"rectShape\",\"clip\",\"renderer\",\"_defs\",\"clip_id\",\"clipping\",\"isFunction\",\"Bounds\",\"clear\",\"union\",\"Item\",\"mark\",\"bounds\",\"GroupItem\",\"items\",\"ResourceLoader\",\"customLoader\",\"_pending\",\"_loader\",\"loader\",\"boundStroke\",\"miter\",\"stroke\",\"opacity\",\"strokeOpacity\",\"sw\",\"strokeWidth\",\"expand\",\"strokeJoin\",\"boundContext\",\"deg\",\"rot\",\"ma\",\"md\",\"mb\",\"mc\",\"quadExtrema\",\"cb\",\"cubicExtrema\",\"t0\",\"t1\",\"Epsilon\",\"r\",\"cubic\",\"s2\",\"t2\",\"intersectPath\",\"brush\",\"context$1\",\"intersect\",\"round\",\"isPointInPath\",\"intersectPoint\",\"box\",\"contains\",\"intersectRect\",\"intersects\",\"set\",\"intersectRule\",\"intersectBoxLine\",\"u\",\"v\",\"dx\",\"dy\",\"e\",\"p\",\"q\",\"blend\",\"globalCompositeOperation\",\"value$1\",\"dflt\",\"addStops\",\"stops\",\"addColorStop\",\"offset\",\"color\",\"spec\",\"createRadialGradient\",\"createLinearGradient\",\"image\",\"canvas\",\"ictx\",\"getContext\",\"scale\",\"fillStyle\",\"fillRect\",\"createPattern\",\"fill\",\"fillOpacity\",\"globalAlpha\",\"lw\",\"strokeStyle\",\"lineWidth\",\"lineCap\",\"strokeCap\",\"lineJoin\",\"miterLimit\",\"strokeMiterLimit\",\"setLineDash\",\"strokeDash\",\"Empty\",\"lineDashOffset\",\"strokeDashOffset\",\"compare\",\"zindex\",\"index\",\"zorder\",\"scene\",\"zdirty\",\"zitems\",\"output\",\"sort\",\"visit\",\"visitor\",\"pickVisit\",\"hit\",\"drawAll\",\"drawPath\",\"drawOne\",\"pick\",\"test\",\"truthy\",\"gx\",\"gy\",\"pixelRatio\",\"hitPath\",\"filled\",\"o\",\"Array\",\"isArray\",\"isPointInStroke\",\"lc\",\"translate\",\"markItemPath\",\"shape\",\"isect\",\"angle\",\"rotate\",\"tag\",\"nested\",\"attr\",\"emit\",\"bound\",\"markMultiItemPath\",\"tip\",\"clipGroup\",\"group\",\"strokeOffset\",\"rectanglePath\",\"off\",\"getImage\",\"url\",\"complete\",\"loadImage\",\"then\",\"imageWidth\",\"aspect\",\"imageHeight\",\"imageXOffset\",\"align\",\"imageYOffset\",\"baseline\",\"sx\",\"scaleX\",\"sy\",\"scaleY\",\"cache\",\"pathCache\",\"draw$2\",\"path$2\",\"useCanvas\",\"use\",\"textMetrics\",\"measureWidth\",\"estimateWidth\",\"text\",\"textValue\",\"fontSize\",\"currentFontHeight\",\"_measureWidth\",\"font\",\"currentFont\",\"widthCache\",\"undefined\",\"measureText\",\"lineHeight\",\"textLines\",\"lineBreak\",\"line\",\"limit\",\"widthGetter\",\"ellipsis\",\"rtl\",\"dir\",\"lo\",\"hi\",\"mid\",\"fontFamily\",\"quote\",\"String\",\"fontStyle\",\"fontVariant\",\"fontWeight\",\"offset$1\",\"anchorPoint\",\"radius\",\"theta\",\"tempBounds\",\"bound$5\",\"mode\",\"reduce\",\"rotatedPoints\",\"boundItem\",\"func\",\"opt\",\"Marks\",\"marktype\",\"boundMark\",\"hasItems\",\"DUMMY\",\"sceneToJSON\",\"indent\",\"JSON\",\"stringify\",\"keys\",\"sceneFromJSON\",\"json\",\"parse\",\"initialize\",\"parent\",\"Scenegraph\",\"root\",\"createMark\",\"name\",\"role\",\"interactive\",\"aria\",\"description\",\"domCreate\",\"doc\",\"ns\",\"document\",\"createElement\",\"createElementNS\",\"domFind\",\"el\",\"nodes\",\"childNodes\",\"tagName\",\"domChild\",\"ownerDocument\",\"insertBefore\",\"domClear\",\"removeChild\",\"cssClass\",\"point\",\"event\",\"getBoundingClientRect\",\"clientX\",\"left\",\"clientLeft\",\"clientY\",\"top\",\"clientTop\",\"Handler\",\"customTooltip\",\"_active\",\"_handlers\",\"_tooltip\",\"defaultTooltip\",\"handler\",\"element\",\"setAttribute\",\"Renderer\",\"_bgcolor\",\"_el\",\"CanvasHandler\",\"tooltip\",\"_touch\",\"_down\",\"_first\",\"_events\",\"eventListenerCheck\",\"TouchStartEvent\",\"TouchMoveEvent\",\"TouchEndEvent\",\"forEach\",\"addEventListener\",\"evt\",\"fire\",\"move\",\"moveEvent\",\"overEvent\",\"outEvent\",\"pickEvent\",\"exit\",\"inactive\",\"CanvasRenderer\",\"_options\",\"_redraw\",\"_dirty\",\"_tempb\",\"SVGHandler\",\"_hrefHandler\",\"listener\",\"href\",\"handleHref\",\"_tooltipHandler\",\"handleTooltip\",\"MouseOutEvent\",\"ariaItemAttributes\",\"hide\",\"ARIA_HIDDEN\",\"prop\",\"AriaEncode\",\"ARIA_LABEL\",\"ARIA_ROLE\",\"ariaRole\",\"GRAPHICS_OBJECT\",\"GRAPHICS_SYMBOL\",\"ARIA_ROLEDESCRIPTION\",\"ariaRoleDescription\",\"ariaMarkAttributes\",\"AriaIgnore\",\"AriaGuides\",\"ariaGuide\",\"ariaMark\",\"recurse\",\"some\",\"bundle\",\"caption\",\"desc\",\"err\",\"extractTitle\",\"array\",\"peek\",\"channelCaption\",\"props\",\"map\",\"markup\",\"buf\",\"outer\",\"inner\",\"stack\",\"innerText\",\"open\",\"attrs\",\"close\",\"pop\",\"toString\",\"_serialize\",\"node\",\"hasAttributes\",\"attributes\",\"hasChildNodes\",\"children\",\"child\",\"nodeType\",\"nodeValue\",\"SVGRenderer\",\"_dirtyID\",\"_root\",\"_svg\",\"dirtyParents\",\"dirty\",\"lastChild\",\"previousSibling\",\"prev\",\"idx\",\"bind\",\"sibling\",\"svg\",\"__data__\",\"__values__\",\"bg\",\"appendChild\",\"cg\",\"fg\",\"ownerSVGElement\",\"parentNode\",\"nextSibling\",\"firstChild\",\"values\",\"setAttributeNS\",\"removeAttributeNS\",\"setStyle\",\"style\",\"removeProperty\",\"setProperty\",\"setAttributes\",\"removeAttribute\",\"loc\",\"window\",\"location\",\"hash\",\"SVGStringRenderer\",\"_text\",\"display\",\"smooth\",\"styles\",\"intersectMark\",\"filter\",\"hits\",\"intersectGroup\",\"intersectItem\",\"marks\",\"encloses\",\"sceneEqual\",\"pathEqual\",\"Date\",\"isNumber\",\"TOLERANCE\",\"isObject\",\"objectEqual\",\"ka\",\"Object\",\"kb\",\"curveBasis\",\"curveBasisClosed\",\"curveBasisOpen\",\"curveBundle\",\"curveCardinal\",\"curveCardinalOpen\",\"curveCardinalClosed\",\"curveCatmullRom\",\"curveCatmullRomClosed\",\"curveCatmullRomOpen\",\"curveLinear\",\"curveLinearClosed\",\"horizontal\",\"curveMonotoneY\",\"vertical\",\"curveMonotoneX\",\"curveNatural\",\"curveStep\",\"curveStepAfter\",\"curveStepBefore\",\"HalfSqrt3\",\"Tan30\",\"arcShape\",\"startAngle\",\"sa\",\"endAngle\",\"ea\",\"padAngle\",\"pa\",\"innerRadius\",\"ir\",\"outerRadius\",\"or\",\"cr\",\"areavShape\",\"area\",\"yh\",\"areahShape\",\"xw\",\"lineShape\",\"symbolShape\",\"symbol\",\"sz\",\"trailShape\",\"ts\",\"prototype\",\"clone\",\"Number\",\"MAX_VALUE\",\"empty\",\"equals\",\"add\",\"floor\",\"alignsWith\",\"inherits\",\"pending\",\"sanitizeURL\",\"uri\",\"sanitize\",\"catch\",\"Image\",\"img\",\"cors\",\"crossOrigin\",\"onload\",\"img.onload\",\"onerror\",\"img.onerror\",\"src\",\"Promise\",\"accept\",\"poll\",\"setTimeout\",\"circleThreshold\",\"lx\",\"ly\",\"addL\",\"addX\",\"addY\",\"addp\",\"addpL\",\"py1\",\"px2\",\"py2\",\"px3\",\"py3\",\"ccw\",\"update\",\"arc$1\",\"area$1\",\"orient\",\"interpolate\",\"pickArea\",\"z\",\"Infinity\",\"hitBackground\",\"hitForeground\",\"hitCorner\",\"noBound\",\"fore\",\"strokeForeground\",\"save\",\"restore\",\"pick$1\",\"dw\",\"dh\",\"ix\",\"content\",\"background\",\"foreground\",\"metadata\",\"attr$1\",\"toDataURL\",\"bound$1\",\"draw$1\",\"ar0\",\"ar1\",\"imageSmoothingEnabled\",\"drawImage\",\"xOffset\",\"yOffset\",\"line$1\",\"pickLine\",\"pow\",\"dd\",\"path$1\",\"attr$2\",\"bound$2\",\"attr$3\",\"bound$3\",\"rule\",\"attr$4\",\"bound$4\",\"draw$3\",\"shape$1\",\"symbol$1\",\"lruCache\",\"textAlign\",\"attr$5\",\"draw$4\",\"lh\",\"str\",\"fillText\",\"strokeText\",\"hit$1\",\"ax\",\"ay\",\"intersectText\",\"trail$1\",\"pickTrail\",\"toJSON\",\"markdef\",\"origin\",\"obj\",\"_obj\",\"_origin\",\"_scene\",\"on\",\"_handlerIndex\",\"handlers\",\"apply\",\"eventName\",\"k\",\"indexOf\",\"MouseEvent\",\"dispatchEvent\",\"show\",\"mdef\",\"getItemBoundingClientRect\",\"right\",\"bottom\",\"scaleFactor\",\"resize\",\"bgcolor\",\"_width\",\"_height\",\"_scale\",\"render\",\"_call\",\"r._call\",\"_render\",\"renderAsync\",\"_ready\",\"resolve\",\"_load\",\"method\",\"redraw\",\"_canvas\",\"ClickEvent\",\"MouseDownEvent\",\"MouseMoveEvent\",\"DragLeaveEvent\",\"events\",\"Events\",\"DOMMouseScroll\",\"MouseWheelEvent\",\"mousemove\",\"MouseOverEvent\",\"dragover\",\"DragOverEvent\",\"DragEnterEvent\",\"mouseout\",\"dragleave\",\"mousedown\",\"click\",\"touchstart\",\"changedTouches\",\"touchmove\",\"touchend\",\"touch\",\"vegaType\",\"splice\",\"devicePixelRatio\",\"options\",\"externalContext\",\"inDOM\",\"HTMLElement\",\"ratio\",\"setTransform\",\"ctx\",\"error\",\"db\",\"vb\",\"clearRect\",\"target\",\"removeEventListener\",\"roledesc\",\"label\",\"toSet\",\"axisCaption\",\"datum\",\"title\",\"scales\",\"locale\",\"dataflow\",\"xy\",\"isDiscrete\",\"domainCaption\",\"legendCaption\",\"toUpperCase\",\"serializeXML\",\"rootAttributes\",\"xmlns\",\"base$1\",\"_clearDefs\",\"RootIndex\",\"viewBox\",\"_dirtyCheck\",\"_dirtyAll\",\"isDirty\",\"_update\",\"isGroup\",\"process\",\"extra\",\"mark_extras\",\"grad\",\"pt\",\"preserveAspectRatio\",\"fx\",\"fy\",\"fr\",\"stop\",\"mask\",\"textContent\",\"extend\",\"class\",\"transform\",\"attrList\",\"_hrefs\",\"object\",\"prefixed\",\"fn\",\"modules\",\"Canvas\",\"PNG\",\"headless\",\"SVG\",\"None\",\"clipBounds\",\"Gradient\",\"p0\",\"p1\",\"RenderType\",\"boundClip\",\"multiLineOffset\",\"pathCurves\",\"pathRectangle\",\"pathSymbols\",\"pathTrail\",\"renderModule\",\"resetSVGClipId\",\"resetSVGDefIds\",\"scenePickVisit\",\"sceneVisit\",\"sceneZOrder\",\"defineProperty\"]\n}\n"]