["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-util/build/vega-util.js"],"~:js","shadow$provide.module$node_modules$vega_util$build$vega_util=function(global$jscomp$0,require,module,exports){(function(global,factory){\"object\"===typeof exports&&\"undefined\"!==typeof module?factory(exports):\"function\"===typeof define&&define.amd?define([\"exports\"],factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory(global.vega={}))})(this,function(exports){function accessor(fn,fields,name){fn.fields=fields||[];fn.fname=name;return fn}function accessorFields(fn){return null==\nfn?null:fn.fields}function getter(path){return 1===path.length?get1(path[0]):getN(path)}function error(message){throw Error(message);}function splitAccessPath(p){function push(){path.push(s+p.substring(i,j));s=\"\";i=j+1}var path=[],n=p.length,q=null,b=0,s=\"\",i,j;p+=\"\";for(i=j=0;j<n;++j){var c=p[j];\"\\\\\"===c?(s+=p.substring(i,j),s+=p.substring(++j,++j),i=j):c===q?(push(),q=null,b=-1):q||(i===b&&'\"'===c?(i=j+1,q=c):i===b&&\"'\"===c?(i=j+1,q=c):\".\"!==c||b?\"[\"===c?(j>i&&push(),b=i=j+1):\"]\"===c&&(b||error(\"Access path missing open bracket: \"+\np),0<b&&push(),b=0,i=j+1):j>i?push():i=j+1)}b&&error(\"Access path missing closing bracket: \"+p);q&&error(\"Access path missing closing quote: \"+p);j>i&&(j++,push());return path}function field(field,name,opt){var path=splitAccessPath(field);field=1===path.length?path[0]:field;return accessor((opt&&opt.get||getter)(path),[field],name||field)}function log(method,level,input){level=[level].concat([].slice.call(input));console[method].apply(console,level)}function isObject(_){return _===Object(_)}function writeConfig(output,\nkey,value,recurse){if(\"__proto__\"!==key){var k;if(isObject(value)&&!isArray(value))for(k in output=isObject(output[key])?output[key]:output[key]={},value)recurse&&(!0===recurse||recurse[k])?writeConfig(output,k,value[k]):\"__proto__\"!==k&&(output[k]=value[k]);else output[key]=value}}function mergeNamed(a,b){function add(_){map[_.name]||(map[_.name]=1,out.push(_))}if(null==a)return b;var map={},out=[];b.forEach(add);a.forEach(add);return out}function peek(array){return array[array.length-1]}function toNumber(_){return null==\n_||\"\"===_?null:+_}function pan(domain,delta,lift,ground){var d0=lift(domain[0]);domain=lift(peek(domain));delta*=domain-d0;return[ground(d0-delta),ground(domain-delta)]}function zoom(domain,anchor,scale,lift,ground){var d0=lift(domain[0]);domain=lift(peek(domain));anchor=null!=anchor?lift(anchor):(d0+domain)/2;return[ground(anchor+(d0-anchor)*scale),ground(anchor+(domain-anchor)*scale)]}function array$jscomp$0(_){return null!=_?isArray(_)?_:[_]:[]}function isFunction(_){return\"function\"===typeof _}\nfunction extend(_){for(var x,k=void 0,i=1,len=arguments.length;i<len;++i)for(k in x=arguments[i],x)_[k]=x[k];return _}function has(object,property){return hop.call(object,property)}function isDate(_){return\"[object Date]\"===Object.prototype.toString.call(_)}function isNumber(_){return\"number\"===typeof _}function isString(_){return\"string\"===typeof _}function repeat(str,reps){for(var s=\"\";0<=--reps;)s+=str;return s}function $(x){return isArray(x)?\"[\"+x.map($)+\"]\":isObject(x)||isString(x)?JSON.stringify(x).replace(\"\\u2028\",\n\"\\\\u2028\").replace(\"\\u2029\",\"\\\\u2029\"):x}var get1=function(field){return function(obj){return obj[field]}},getN=function(path){var len=path.length;return function(obj){for(var i=0;i<len;++i)obj=obj[path[i]];return obj}},id=field(\"id\"),identity=accessor(function(_){return _},[],\"identity\"),zero=accessor(function(){return 0},[],\"zero\"),one=accessor(function(){return 1},[],\"one\"),truthy=accessor(function(){return!0},[],\"true\"),falsy=accessor(function(){return!1},[],\"false\"),isArray=Array.isArray,exp=\nfunction(sign){return function(x){return sign*Math.exp(x)}},log$1=function(sign){return function(x){return Math.log(sign*x)}},symlog=function(c){return function(x){return Math.sign(x)*Math.log1p(Math.abs(x/c))}},symexp=function(c){return function(x){return Math.sign(x)*Math.expm1(Math.abs(x))*c}},pow=function(exponent){return function(x){return 0>x?-Math.pow(-x,exponent):Math.pow(x,exponent)}},ascending=function(u,v){return(u<v||null==u)&&null!=v?-1:(u>v||null==v)&&null!=u?1:(v=v instanceof Date?\n+v:v,u=u instanceof Date?+u:u)!==u&&v===v?-1:v!==v&&u===u?1:0},comparator=function(fields,orders){return 1===fields.length?compare1(fields[0],orders[0]):compareN(fields,orders,fields.length)},compare1=function(field,order){return function(a,b){return ascending(field(a),field(b))*order}},compareN=function(fields,orders,n){orders.push(0);return function(a,b){var f=0;for(var i=-1;0===f&&++i<n;)f=fields[i],f=ascending(f(a),f(b));return f*orders[i]}},hop=Object.prototype.hasOwnProperty,NULL={},defaultParser=\nfunction(_){return isNumber(_)?_:isDate(_)?_:Date.parse(_)};exports.Debug=4;exports.Error=1;exports.Info=3;exports.None=0;exports.Warn=2;exports.accessor=accessor;exports.accessorFields=accessorFields;exports.accessorName=function(fn){return null==fn?null:fn.fname};exports.array=array$jscomp$0;exports.ascending=ascending;exports.clampRange=function(range,min,max){var lo=range[0];range=range[1];if(range<lo){var span=range;range=lo;lo=span}span=range-lo;return span>=max-min?[min,max]:[lo=Math.min(Math.max(lo,\nmin),max-span),lo+span]};exports.compare=function(fields,orders,opt){opt=opt||{};orders=array$jscomp$0(orders)||[];var ord=[],get=[],fmap={},gen=opt.comparator||comparator;array$jscomp$0(fields).forEach(function(f,i){null!=f&&(ord.push(\"descending\"===orders[i]?-1:1),get.push(f=isFunction(f)?f:field(f,null,opt)),(accessorFields(f)||[]).forEach(function(_){return fmap[_]=1}))});return 0===get.length?null:accessor(gen(get,ord),Object.keys(fmap))};exports.constant=function(_){return isFunction(_)?_:function(){return _}};\nexports.debounce=function(delay,handler){var tid;return function(e){tid&&clearTimeout(tid);tid=setTimeout(function(){return handler(e),tid=null},delay)}};exports.error=error;exports.extend=extend;exports.extent=function(array,f){var i=0,n,v,min,max;if(array&&(n=array.length))if(null==f){for(v=array[i];i<n&&(null==v||v!==v);v=array[++i]);for(min=max=v;i<n;++i)v=array[i],null!=v&&(v<min&&(min=v),v>max&&(max=v))}else{for(v=f(array[i]);i<n&&(null==v||v!==v);v=f(array[++i]));for(min=max=v;i<n;++i)v=f(array[i]),\nnull!=v&&(v<min&&(min=v),v>max&&(max=v))}return[min,max]};exports.extentIndex=function(array,f){var n=array.length,i=-1,c,u,v;if(null==f){for(;++i<n;){var b=array[i];if(null!=b&&b>=b){var a=c=b;break}}if(i===n)return[-1,-1];for(u=v=i;++i<n;)b=array[i],null!=b&&(a>b&&(a=b,u=i),c<b&&(c=b,v=i))}else{for(;++i<n;)if(b=f(array[i],i,array),null!=b&&b>=b){a=c=b;break}if(i===n)return[-1,-1];for(u=v=i;++i<n;)b=f(array[i],i,array),null!=b&&(a>b&&(a=b,u=i),c<b&&(c=b,v=i))}return[u,v]};exports.falsy=falsy;exports.fastmap=\nfunction(input){function has$1(key){return has(obj,key)&&obj[key]!==NULL}var obj={},test,map={size:0,empty:0,object:obj,has:has$1,get:function(key){return has$1(key)?obj[key]:void 0},set:function(key,value){has$1(key)||(++map.size,obj[key]===NULL&&--map.empty);obj[key]=value;return this},delete:function(key){has$1(key)&&(--map.size,++map.empty,obj[key]=NULL);return this},clear:function(){map.size=map.empty=0;map.object=obj={}},test:function(_){return arguments.length?(test=_,map):test},clean:function(){var next=\n{},size=0,key$274;for(key$274 in obj){var value=obj[key$274];value===NULL||test&&test(value)||(next[key$274]=value,++size)}map.size=size;map.empty=0;map.object=obj=next}};input&&Object.keys(input).forEach(function(key){map.set(key,input[key])});return map};exports.field=field;exports.flush=function(range,value,threshold,left,right,center){if(!threshold&&0!==threshold)return center;threshold=+threshold;var a=range[0],b=peek(range);b<a&&(range=a,a=b,b=range);range=Math.abs(value-a);value=Math.abs(b-\nvalue);return range<value&&range<=threshold?left:value<=threshold?right:center};exports.hasOwnProperty=has;exports.id=id;exports.identity=identity;exports.inherits=function(child,parent,members){parent=child.prototype=Object.create(parent.prototype);parent.constructor=child;return extend(parent,members)};exports.inrange=function(value,range,left,right){var r0=range[0];range=range[range.length-1];if(r0>range){var t=r0;r0=range;range=t}return(void 0===left||left?r0<=value:r0<value)&&(void 0===right||\nright?value<=range:value<range)};exports.isArray=isArray;exports.isBoolean=function(_){return\"boolean\"===typeof _};exports.isDate=isDate;exports.isFunction=isFunction;exports.isNumber=isNumber;exports.isObject=isObject;exports.isRegExp=function(_){return\"[object RegExp]\"===Object.prototype.toString.call(_)};exports.isString=isString;exports.key=function(fields,flat,opt){fields&&(fields=flat?array$jscomp$0(fields).map(function(f){return f.replace(/\\\\(.)/g,\"$1\")}):array$jscomp$0(fields));var len=fields&&\nfields.length,gen=opt&&opt.get||getter;opt=function(f){return gen(flat?[f]:splitAccessPath(f))};if(len)if(1===len){var get=opt(fields[0]);opt=function(_){return\"\"+get(_)}}else{var get$275=fields.map(opt);opt=function(_){for(var s=\"\"+get$275[0](_),i=0;++i<len;)s+=\"|\"+get$275[i](_);return s}}else opt=function(){return\"\"};return accessor(opt,fields,\"key\")};exports.lerp=function(array,frac){var lo=array[0];array=peek(array);return(frac=+frac)?1===frac?array:lo+frac*(array-lo):lo};exports.logger=function(_$jscomp$0,\nmethod){var level=_$jscomp$0||0;return{level:function(_){return arguments.length?(level=+_,this):level},error:function(){1<=level&&log(method||\"error\",\"ERROR\",arguments);return this},warn:function(){2<=level&&log(method||\"warn\",\"WARN\",arguments);return this},info:function(){3<=level&&log(method||\"log\",\"INFO\",arguments);return this},debug:function(){4<=level&&log(method||\"log\",\"DEBUG\",arguments);return this}}};exports.lruCache=function(maxsize){maxsize=+maxsize||1E4;var curr,prev,size,clear=function(){curr=\n{};prev={};size=0},update=function(key,value){++size>maxsize&&(prev=curr,curr={},size=1);return curr[key]=value};clear();return{clear:clear,has:function(key){return has(curr,key)||has(prev,key)},get:function(key){return has(curr,key)?curr[key]:has(prev,key)?update(key,prev[key]):void 0},set:function(key,value){return has(curr,key)?curr[key]=value:update(key,value)}}};exports.merge=function(compare,array0,array1,output){var n0=array0.length,n1=array1.length;if(!n1)return array0;if(!n0)return array1;\noutput=output||new array0.constructor(n0+n1);for(var i0=0,i1=0,i=0;i0<n0&&i1<n1;++i)output[i]=0<compare(array0[i0],array1[i1])?array1[i1++]:array0[i0++];for(;i0<n0;++i0,++i)output[i]=array0[i0];for(;i1<n1;++i1,++i)output[i]=array1[i1];return output};exports.mergeConfig=function(configs){for(var $jscomp$restParams=[],$jscomp$restIndex=0;$jscomp$restIndex<arguments.length;++$jscomp$restIndex)$jscomp$restParams[$jscomp$restIndex-0]=arguments[$jscomp$restIndex];return $jscomp$restParams.reduce(function(out,\nsource){for(var key$273 in source)\"signals\"===key$273?out.signals=mergeNamed(out.signals,source.signals):writeConfig(out,key$273,source[key$273],\"legend\"===key$273?{layout:1}:\"style\"===key$273?!0:null);return out},{})};exports.one=one;exports.pad=function(str,length,padchar,align){padchar=padchar||\" \";str+=\"\";length-=str.length;return 0>=length?str:\"left\"===align?repeat(padchar,length)+str:\"center\"===align?repeat(padchar,~~(length/2))+str+repeat(padchar,Math.ceil(length/2)):str+repeat(padchar,length)};\nexports.panLinear=function(domain,delta){return pan(domain,delta,toNumber,identity)};exports.panLog=function(domain,delta){var sign=Math.sign(domain[0]);return pan(domain,delta,log$1(sign),exp(sign))};exports.panPow=function(domain,delta,exponent){return pan(domain,delta,pow(exponent),pow(1/exponent))};exports.panSymlog=function(domain,delta,constant){return pan(domain,delta,symlog(constant),symexp(constant))};exports.peek=peek;exports.quarter=function(date){return 1+~~((new Date(date)).getMonth()/\n3)};exports.repeat=repeat;exports.span=function(array){return array&&peek(array)-array[0]||0};exports.splitAccessPath=splitAccessPath;exports.stringValue=$;exports.toBoolean=function(_){return null==_||\"\"===_?null:_&&\"false\"!==_&&\"0\"!==_?!!_:!1};exports.toDate=function(_,parser){parser=parser||defaultParser;return null==_||\"\"===_?null:parser(_)};exports.toNumber=toNumber;exports.toSet=function(_){for(var s={},n=_.length,i=0;i<n;++i)s[_[i]]=!0;return s};exports.toString=function(_){return null==_||\n\"\"===_?null:_+\"\"};exports.truncate=function(str,length,align,ellipsis){ellipsis=null!=ellipsis?ellipsis:\"â€¦\";str+=\"\";var n=str.length,l=Math.max(0,length-ellipsis.length);return n<=length?str:\"left\"===align?ellipsis+str.slice(n-l):\"center\"===align?str.slice(0,Math.ceil(l/2))+ellipsis+str.slice(n-~~(l/2)):str.slice(0,l)+ellipsis};exports.truthy=truthy;exports.utcquarter=function(date){return 1+~~((new Date(date)).getUTCMonth()/3)};exports.visitArray=function(array,filter,visitor){if(array)if(filter)for(var n=\narray.length,i=0;i<n;++i){var t=filter(array[i]);t&&visitor(t,i,array)}else array.forEach(visitor)};exports.writeConfig=writeConfig;exports.zero=zero;exports.zoomLinear=function(domain,anchor,scale){return zoom(domain,anchor,scale,toNumber,identity)};exports.zoomLog=function(domain,anchor,scale){var sign=Math.sign(domain[0]);return zoom(domain,anchor,scale,log$1(sign),exp(sign))};exports.zoomPow=function(domain,anchor,scale,exponent){return zoom(domain,anchor,scale,pow(exponent),pow(1/exponent))};\nexports.zoomSymlog=function(domain,anchor,scale,constant){return zoom(domain,anchor,scale,symlog(constant),symexp(constant))};Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_util$build$vega_util\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}));\n}(this, (function (exports) { 'use strict';\n\n  function accessor(fn, fields, name) {\n    fn.fields = fields || [];\n    fn.fname = name;\n    return fn;\n  }\n\n  function accessorName(fn) {\n    return fn == null ? null : fn.fname;\n  }\n\n  function accessorFields(fn) {\n    return fn == null ? null : fn.fields;\n  }\n\n  function getter(path) {\n    return path.length === 1 ? get1(path[0]) : getN(path);\n  }\n\n  const get1 = field => function(obj) {\n    return obj[field];\n  };\n\n  const getN = path => {\n    const len = path.length;\n    return function(obj) {\n      for (let i = 0; i < len; ++i) {\n        obj = obj[path[i]];\n      }\n      return obj;\n    };\n  };\n\n  function error(message) {\n    throw Error(message);\n  }\n\n  function splitAccessPath(p) {\n    const path = [],\n          n = p.length;\n\n    let q = null,\n        b = 0,\n        s = '',\n        i, j, c;\n\n    p = p + '';\n\n    function push() {\n      path.push(s + p.substring(i, j));\n      s = '';\n      i = j + 1;\n    }\n\n    for (i=j=0; j<n; ++j) {\n      c = p[j];\n      if (c === '\\\\') {\n        s += p.substring(i, j);\n        s += p.substring(++j, ++j);\n        i = j;\n      } else if (c === q) {\n        push();\n        q = null;\n        b = -1;\n      } else if (q) {\n        continue;\n      } else if (i === b && c === '\"') {\n        i = j + 1;\n        q = c;\n      } else if (i === b && c === \"'\") {\n        i = j + 1;\n        q = c;\n      } else if (c === '.' && !b) {\n        if (j > i) {\n          push();\n        } else {\n          i = j + 1;\n        }\n      } else if (c === '[') {\n        if (j > i) push();\n        b = i = j + 1;\n      } else if (c === ']') {\n        if (!b) error('Access path missing open bracket: ' + p);\n        if (b > 0) push();\n        b = 0;\n        i = j + 1;\n      }\n    }\n\n    if (b) error('Access path missing closing bracket: ' + p);\n    if (q) error('Access path missing closing quote: ' + p);\n\n    if (j > i) {\n      j++;\n      push();\n    }\n\n    return path;\n  }\n\n  function field(field, name, opt) {\n    const path = splitAccessPath(field);\n    field = path.length === 1 ? path[0] : field;\n    return accessor(\n      (opt && opt.get || getter)(path),\n      [field],\n      name || field\n    );\n  }\n\n  const id = field('id');\n\n  const identity = accessor(_ => _, [], 'identity');\n\n  const zero = accessor(() => 0, [], 'zero');\n\n  const one = accessor(() => 1, [], 'one');\n\n  const truthy = accessor(() => true, [], 'true');\n\n  const falsy = accessor(() => false, [], 'false');\n\n  function log(method, level, input) {\n    const args = [level].concat([].slice.call(input));\n    console[method].apply(console, args); // eslint-disable-line no-console\n  }\n\n  const None  = 0;\n  const Error$1 = 1;\n  const Warn  = 2;\n  const Info  = 3;\n  const Debug = 4;\n\n  function logger(_, method) {\n    let level = _ || None;\n    return {\n      level(_) {\n        if (arguments.length) {\n          level = +_;\n          return this;\n        } else {\n          return level;\n        }\n      },\n      error() {\n        if (level >= Error$1) log(method || 'error', 'ERROR', arguments);\n        return this;\n      },\n      warn() {\n        if (level >= Warn) log(method || 'warn', 'WARN', arguments);\n        return this;\n      },\n      info() {\n        if (level >= Info) log(method || 'log', 'INFO', arguments);\n        return this;\n      },\n      debug() {\n        if (level >= Debug) log(method || 'log', 'DEBUG', arguments);\n        return this;\n      }\n    };\n  }\n\n  var isArray = Array.isArray;\n\n  function isObject(_) {\n    return _ === Object(_);\n  }\n\n  const isLegalKey = key => key !== '__proto__';\n\n  function mergeConfig(...configs) {\n    return configs.reduce((out, source) => {\n      for (const key in source) {\n        if (key === 'signals') {\n          // for signals, we merge the signals arrays\n          // source signals take precedence over\n          // existing signals with the same name\n          out.signals = mergeNamed(out.signals, source.signals);\n        } else {\n          // otherwise, merge objects subject to recursion constraints\n          // for legend block, recurse for the layout entry only\n          // for style block, recurse for all properties\n          // otherwise, no recursion: objects overwrite, no merging\n          const r = key === 'legend' ? {layout: 1}\n            : key === 'style' ? true\n            : null;\n          writeConfig(out, key, source[key], r);\n        }\n      }\n      return out;\n    }, {});\n  }\n\n  function writeConfig(output, key, value, recurse) {\n    if (!isLegalKey(key)) return;\n\n    let k, o;\n    if (isObject(value) && !isArray(value)) {\n      o = isObject(output[key]) ? output[key] : (output[key] = {});\n      for (k in value) {\n        if (recurse && (recurse === true || recurse[k])) {\n          writeConfig(o, k, value[k]);\n        } else if (isLegalKey(k)) {\n          o[k] = value[k];\n        }\n      }\n    } else {\n      output[key] = value;\n    }\n  }\n\n  function mergeNamed(a, b) {\n    if (a == null) return b;\n\n    const map = {}, out = [];\n\n    function add(_) {\n      if (!map[_.name]) {\n        map[_.name] = 1;\n        out.push(_);\n      }\n    }\n\n    b.forEach(add);\n    a.forEach(add);\n    return out;\n  }\n\n  function peek(array) {\n    return array[array.length - 1];\n  }\n\n  function toNumber(_) {\n    return _ == null || _ === '' ? null : +_;\n  }\n\n  const exp = sign =>\n    x => sign * Math.exp(x);\n\n  const log$1 = sign =>\n    x => Math.log(sign * x);\n\n  const symlog = c =>\n    x => Math.sign(x) * Math.log1p(Math.abs(x / c));\n\n  const symexp = c =>\n    x => Math.sign(x) * Math.expm1(Math.abs(x)) * c;\n\n  const pow = exponent =>\n    x => x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n\n  function pan(domain, delta, lift, ground) {\n    const d0 = lift(domain[0]),\n          d1 = lift(peek(domain)),\n          dd = (d1 - d0) * delta;\n\n    return [\n      ground(d0 - dd),\n      ground(d1 - dd)\n    ];\n  }\n\n  function panLinear(domain, delta) {\n    return pan(domain, delta, toNumber, identity);\n  }\n\n  function panLog(domain, delta) {\n    var sign = Math.sign(domain[0]);\n    return pan(domain, delta, log$1(sign), exp(sign));\n  }\n\n  function panPow(domain, delta, exponent) {\n    return pan(domain, delta, pow(exponent), pow(1/exponent));\n  }\n\n  function panSymlog(domain, delta, constant) {\n    return pan(domain, delta, symlog(constant), symexp(constant));\n  }\n\n  function zoom(domain, anchor, scale, lift, ground) {\n    const d0 = lift(domain[0]),\n          d1 = lift(peek(domain)),\n          da = anchor != null ? lift(anchor) : (d0 + d1) / 2;\n\n    return [\n      ground(da + (d0 - da) * scale),\n      ground(da + (d1 - da) * scale)\n    ];\n  }\n\n  function zoomLinear(domain, anchor, scale) {\n    return zoom(domain, anchor, scale, toNumber, identity);\n  }\n\n  function zoomLog(domain, anchor, scale) {\n    const sign = Math.sign(domain[0]);\n    return zoom(domain, anchor, scale, log$1(sign), exp(sign));\n  }\n\n  function zoomPow(domain, anchor, scale, exponent) {\n    return zoom(domain, anchor, scale, pow(exponent), pow(1/exponent));\n  }\n\n  function zoomSymlog(domain, anchor, scale, constant) {\n    return zoom(domain, anchor, scale, symlog(constant), symexp(constant));\n  }\n\n  function quarter(date) {\n    return 1 + ~~(new Date(date).getMonth() / 3);\n  }\n\n  function utcquarter(date) {\n    return 1 + ~~(new Date(date).getUTCMonth() / 3);\n  }\n\n  function array(_) {\n    return _ != null ? (isArray(_) ? _ : [_]) : [];\n  }\n\n  /**\n   * Span-preserving range clamp. If the span of the input range is less\n   * than (max - min) and an endpoint exceeds either the min or max value,\n   * the range is translated such that the span is preserved and one\n   * endpoint touches the boundary of the min/max range.\n   * If the span exceeds (max - min), the range [min, max] is returned.\n   */\n  function clampRange(range, min, max) {\n    let lo = range[0],\n        hi = range[1],\n        span;\n\n    if (hi < lo) {\n      span = hi;\n      hi = lo;\n      lo = span;\n    }\n    span = hi - lo;\n\n    return span >= (max - min)\n      ? [min, max]\n      : [\n          (lo = Math.min(Math.max(lo, min), max - span)),\n          lo + span\n        ];\n  }\n\n  function isFunction(_) {\n    return typeof _ === 'function';\n  }\n\n  const DESCENDING = 'descending';\n\n  function compare(fields, orders, opt) {\n    opt = opt || {};\n    orders = array(orders) || [];\n\n    const ord = [], get = [], fmap = {},\n          gen = opt.comparator || comparator;\n\n    array(fields).forEach((f, i) => {\n      if (f == null) return;\n      ord.push(orders[i] === DESCENDING ? -1 : 1);\n      get.push(f = isFunction(f) ? f : field(f, null, opt));\n      (accessorFields(f) || []).forEach(_ => fmap[_] = 1);\n    });\n\n    return get.length === 0\n      ? null\n      : accessor(gen(get, ord), Object.keys(fmap));\n  }\n\n  const ascending = (u, v) => (u < v || u == null) && v != null ? -1\n    : (u > v || v == null) && u != null ? 1\n    : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? -1\n    : v !== v && u === u ? 1\n    : 0;\n\n  const comparator = (fields, orders) => fields.length === 1\n    ? compare1(fields[0], orders[0])\n    : compareN(fields, orders, fields.length);\n\n  const compare1 = (field, order) => function(a, b) {\n    return ascending(field(a), field(b)) * order;\n  };\n\n  const compareN = (fields, orders, n) => {\n    orders.push(0); // pad zero for convenient lookup\n    return function(a, b) {\n      let f, c = 0, i = -1;\n      while (c === 0 && ++i < n) {\n        f = fields[i];\n        c = ascending(f(a), f(b));\n      }\n      return c * orders[i];\n    };\n  };\n\n  function constant(_) {\n    return isFunction(_) ? _ : () => _;\n  }\n\n  function debounce(delay, handler) {\n    let tid;\n\n    return e => {\n      if (tid) clearTimeout(tid);\n      tid = setTimeout(\n        () => (handler(e), tid = null),\n        delay\n      );\n    };\n  }\n\n  function extend(_) {\n    for (let x, k, i=1, len=arguments.length; i<len; ++i) {\n      x = arguments[i];\n      for (k in x) { _[k] = x[k]; }\n    }\n    return _;\n  }\n\n  /**\n   * Return an array with minimum and maximum values, in the\n   * form [min, max]. Ignores null, undefined, and NaN values.\n   */\n  function extent(array, f) {\n    let i = 0, n, v, min, max;\n\n    if (array && (n = array.length)) {\n      if (f == null) {\n        // find first valid value\n        for (v = array[i]; i < n && (v == null || v !== v); v = array[++i]);\n        min = max = v;\n\n        // visit all other values\n        for (; i<n; ++i) {\n          v = array[i];\n          // skip null/undefined; NaN will fail all comparisons\n          if (v != null) {\n            if (v < min) min = v;\n            if (v > max) max = v;\n          }\n        }\n      } else {\n        // find first valid value\n        for (v = f(array[i]); i < n && (v == null || v !== v); v = f(array[++i]));\n        min = max = v;\n\n        // visit all other values\n        for (; i<n; ++i) {\n          v = f(array[i]);\n          // skip null/undefined; NaN will fail all comparisons\n          if (v != null) {\n            if (v < min) min = v;\n            if (v > max) max = v;\n          }\n        }\n      }\n    }\n\n    return [min, max];\n  }\n\n  function extentIndex(array, f) {\n    const n = array.length;\n    let i = -1, a, b, c, u, v;\n\n    if (f == null) {\n      while (++i < n) {\n        b = array[i];\n        if (b != null && b >= b) {\n          a = c = b;\n          break;\n        }\n      }\n      if (i === n) return [-1, -1];\n      u = v = i;\n      while (++i < n) {\n        b = array[i];\n        if (b != null) {\n          if (a > b) {\n            a = b;\n            u = i;\n          }\n          if (c < b) {\n            c = b;\n            v = i;\n          }\n        }\n      }\n    } else {\n      while (++i < n) {\n        b = f(array[i], i, array);\n        if (b != null && b >= b) {\n          a = c = b;\n          break;\n        }\n      }\n      if (i === n) return [-1, -1];\n      u = v = i;\n      while (++i < n) {\n        b = f(array[i], i, array);\n        if (b != null) {\n          if (a > b) {\n            a = b;\n            u = i;\n          }\n          if (c < b) {\n            c = b;\n            v = i;\n          }\n        }\n      }\n    }\n\n    return [u, v];\n  }\n\n  const hop = Object.prototype.hasOwnProperty;\n\n  function has(object, property) {\n    return hop.call(object, property);\n  }\n\n  const NULL = {};\n\n  function fastmap(input) {\n    let obj = {},\n        test;\n\n    function has$1(key) {\n      return has(obj, key) && obj[key] !== NULL;\n    }\n\n    const map = {\n      size: 0,\n      empty: 0,\n      object: obj,\n      has: has$1,\n      get(key) {\n        return has$1(key) ? obj[key] : undefined;\n      },\n      set(key, value) {\n        if (!has$1(key)) {\n          ++map.size;\n          if (obj[key] === NULL) --map.empty;\n        }\n        obj[key] = value;\n        return this;\n      },\n      delete(key) {\n        if (has$1(key)) {\n          --map.size;\n          ++map.empty;\n          obj[key] = NULL;\n        }\n        return this;\n      },\n      clear() {\n        map.size = map.empty = 0;\n        map.object = obj = {};\n      },\n      test(_) {\n        if (arguments.length) {\n          test = _;\n          return map;\n        } else {\n          return test;\n        }\n      },\n      clean() {\n        const next = {};\n        let size = 0;\n        for (const key in obj) {\n          const value = obj[key];\n          if (value !== NULL && (!test || !test(value))) {\n            next[key] = value;\n            ++size;\n          }\n        }\n        map.size = size;\n        map.empty = 0;\n        map.object = (obj = next);\n      }\n    };\n\n    if (input) Object.keys(input).forEach(key => {\n      map.set(key, input[key]);\n    });\n\n    return map;\n  }\n\n  function flush(range, value, threshold, left, right, center) {\n    if (!threshold && threshold !== 0) return center;\n\n    const t = +threshold;\n    let a = range[0],\n        b = peek(range),\n        l;\n\n    // swap endpoints if range is reversed\n    if (b < a) {\n      l = a; a = b; b = l;\n    }\n\n    // compare value to endpoints\n    l = Math.abs(value - a);\n    const r = Math.abs(b - value);\n\n    // adjust if value is within threshold distance of endpoint\n    return l < r && l <= t ? left : r <= t ? right : center;\n  }\n\n  function inherits(child, parent, members) {\n    const proto = (child.prototype = Object.create(parent.prototype));\n    proto.constructor = child;\n    return extend(proto, members);\n  }\n\n  /**\n   * Predicate that returns true if the value lies within the span\n   * of the given range. The left and right flags control the use\n   * of inclusive (true) or exclusive (false) comparisons.\n   */\n  function inrange(value, range, left, right) {\n    let r0 = range[0], r1 = range[range.length-1], t;\n    if (r0 > r1) {\n      t = r0;\n      r0 = r1;\n      r1 = t;\n    }\n    left = left === undefined || left;\n    right = right === undefined || right;\n\n    return (left ? r0 <= value : r0 < value) &&\n      (right ? value <= r1 : value < r1);\n  }\n\n  function isBoolean(_) {\n    return typeof _ === 'boolean';\n  }\n\n  function isDate(_) {\n    return Object.prototype.toString.call(_) === '[object Date]';\n  }\n\n  function isNumber(_) {\n    return typeof _ === 'number';\n  }\n\n  function isRegExp(_) {\n    return Object.prototype.toString.call(_) === '[object RegExp]';\n  }\n\n  function isString(_) {\n    return typeof _ === 'string';\n  }\n\n  function key(fields, flat, opt) {\n    if (fields) {\n      fields = flat\n        ? array(fields).map(f => f.replace(/\\\\(.)/g, '$1'))\n        : array(fields);\n    }\n\n    const len = fields && fields.length,\n          gen = opt && opt.get || getter,\n          map = f => gen(flat ? [f] : splitAccessPath(f));\n    let fn;\n\n    if (!len) {\n      fn = function() { return ''; };\n    } else if (len === 1) {\n      const get = map(fields[0]);\n      fn = function(_) { return '' + get(_); };\n    } else {\n      const get = fields.map(map);\n      fn = function(_) {\n        let s = '' + get[0](_), i = 0;\n        while (++i < len) s += '|' + get[i](_);\n        return s;\n      };\n    }\n\n    return accessor(fn, fields, 'key');\n  }\n\n  function lerp(array, frac) {\n    const lo = array[0],\n          hi = peek(array),\n          f = +frac;\n    return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);\n  }\n\n  const DEFAULT_MAX_SIZE = 10000;\n\n  // adapted from https://github.com/dominictarr/hashlru/ (MIT License)\n  function lruCache(maxsize) {\n    maxsize = +maxsize || DEFAULT_MAX_SIZE;\n\n    let curr, prev, size;\n\n    const clear = () => {\n      curr = {};\n      prev = {};\n      size = 0;\n    };\n\n    const update = (key, value) => {\n      if (++size > maxsize) {\n        prev = curr;\n        curr = {};\n        size = 1;\n      }\n      return (curr[key] = value);\n    };\n\n    clear();\n\n    return {\n      clear,\n      has: key => has(curr, key) || has(prev, key),\n      get: key => has(curr, key) ? curr[key]\n          : has(prev, key) ? update(key, prev[key])\n          : undefined,\n      set: (key, value) => has(curr, key)\n          ? (curr[key] = value)\n          : update(key, value)\n    };\n  }\n\n  function merge(compare, array0, array1, output) {\n    const n0 = array0.length,\n          n1 = array1.length;\n\n    if (!n1) return array0;\n    if (!n0) return array1;\n\n    const merged = output || new array0.constructor(n0 + n1);\n    let i0 = 0, i1 = 0, i = 0;\n\n    for (; i0<n0 && i1<n1; ++i) {\n      merged[i] = compare(array0[i0], array1[i1]) > 0\n         ? array1[i1++]\n         : array0[i0++];\n    }\n\n    for (; i0<n0; ++i0, ++i) {\n      merged[i] = array0[i0];\n    }\n\n    for (; i1<n1; ++i1, ++i) {\n      merged[i] = array1[i1];\n    }\n\n    return merged;\n  }\n\n  function repeat(str, reps) {\n    let s = '';\n    while (--reps >= 0) s += str;\n    return s;\n  }\n\n  function pad(str, length, padchar, align) {\n    const c = padchar || ' ',\n          s = str + '',\n          n = length - s.length;\n\n    return n <= 0 ? s\n      : align === 'left' ? repeat(c, n) + s\n      : align === 'center' ? repeat(c, ~~(n/2)) + s + repeat(c, Math.ceil(n/2))\n      : s + repeat(c, n);\n  }\n\n  /**\n   * Return the numerical span of an array: the difference between\n   * the last and first values.\n   */\n  function span(array) {\n    return array && (peek(array) - array[0]) || 0;\n  }\n\n  function $(x) {\n    return isArray(x) ? '[' + x.map($) + ']'\n      : isObject(x) || isString(x) ?\n        // Output valid JSON and JS source strings.\n        // See http://timelessrepo.com/json-isnt-a-javascript-subset\n        JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n      : x;\n  }\n\n  function toBoolean(_) {\n    return _ == null || _ === '' ? null : !_ || _ === 'false' || _ === '0' ? false : !!_;\n  }\n\n  const defaultParser = _ =>\n    isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);\n\n  function toDate(_, parser) {\n    parser = parser || defaultParser;\n    return _ == null || _ === '' ? null : parser(_);\n  }\n\n  function toString(_) {\n    return _ == null || _ === '' ? null : _ + '';\n  }\n\n  function toSet(_) {\n    const s = {},\n          n = _.length;\n    for (let i=0; i<n; ++i) s[_[i]] = true;\n    return s;\n  }\n\n  function truncate(str, length, align, ellipsis) {\n    const e = ellipsis != null ? ellipsis : '\\u2026',\n          s = str + '',\n          n = s.length,\n          l = Math.max(0, length - e.length);\n\n    return n <= length ? s\n      : align === 'left' ? e + s.slice(n - l)\n      : align === 'center' ? s.slice(0, Math.ceil(l/2)) + e + s.slice(n - ~~(l/2))\n      : s.slice(0, l) + e;\n  }\n\n  function visitArray(array, filter, visitor) {\n    if (array) {\n      if (filter) {\n        const n = array.length;\n        for (let i = 0; i < n; ++i) {\n          const t = filter(array[i]);\n          if (t) visitor(t, i, array);\n        }\n      } else {\n        array.forEach(visitor);\n      }\n    }\n  }\n\n  exports.Debug = Debug;\n  exports.Error = Error$1;\n  exports.Info = Info;\n  exports.None = None;\n  exports.Warn = Warn;\n  exports.accessor = accessor;\n  exports.accessorFields = accessorFields;\n  exports.accessorName = accessorName;\n  exports.array = array;\n  exports.ascending = ascending;\n  exports.clampRange = clampRange;\n  exports.compare = compare;\n  exports.constant = constant;\n  exports.debounce = debounce;\n  exports.error = error;\n  exports.extend = extend;\n  exports.extent = extent;\n  exports.extentIndex = extentIndex;\n  exports.falsy = falsy;\n  exports.fastmap = fastmap;\n  exports.field = field;\n  exports.flush = flush;\n  exports.hasOwnProperty = has;\n  exports.id = id;\n  exports.identity = identity;\n  exports.inherits = inherits;\n  exports.inrange = inrange;\n  exports.isArray = isArray;\n  exports.isBoolean = isBoolean;\n  exports.isDate = isDate;\n  exports.isFunction = isFunction;\n  exports.isNumber = isNumber;\n  exports.isObject = isObject;\n  exports.isRegExp = isRegExp;\n  exports.isString = isString;\n  exports.key = key;\n  exports.lerp = lerp;\n  exports.logger = logger;\n  exports.lruCache = lruCache;\n  exports.merge = merge;\n  exports.mergeConfig = mergeConfig;\n  exports.one = one;\n  exports.pad = pad;\n  exports.panLinear = panLinear;\n  exports.panLog = panLog;\n  exports.panPow = panPow;\n  exports.panSymlog = panSymlog;\n  exports.peek = peek;\n  exports.quarter = quarter;\n  exports.repeat = repeat;\n  exports.span = span;\n  exports.splitAccessPath = splitAccessPath;\n  exports.stringValue = $;\n  exports.toBoolean = toBoolean;\n  exports.toDate = toDate;\n  exports.toNumber = toNumber;\n  exports.toSet = toSet;\n  exports.toString = toString;\n  exports.truncate = truncate;\n  exports.truthy = truthy;\n  exports.utcquarter = utcquarter;\n  exports.visitArray = visitArray;\n  exports.writeConfig = writeConfig;\n  exports.zero = zero;\n  exports.zoomLinear = zoomLinear;\n  exports.zoomLog = zoomLog;\n  exports.zoomPow = zoomPow;\n  exports.zoomSymlog = zoomSymlog;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["compare","isFunction","object","peek","isNumber","lruCache","utcquarter","debounce","pad","prototype","isArray","delete","toDate","constant","hasOwnProperty","key","repeat","Warn","__esModule","info","warn","inrange","extentIndex","error","Info","lerp","id","flush","writeConfig","truthy","toString","vega","splitAccessPath","zero","fastmap","None","panLog","visitArray","level","isObject","panSymlog","signals","value","clampRange","span","identity","toSet","field","mergeConfig","ascending","panLinear","layout","inherits","debug","zoomLinear","accessor","panPow","Debug","empty","toBoolean","logger","truncate","accessorFields","quarter","zoomPow","accessorName","one","fields","extend","zoomSymlog","toNumber","falsy","set","clean","Error","size","has","clear","isRegExp","fname","get","merge","extent","isDate","array","stringValue","zoomLog","test","isBoolean","constructor","isString"]],"~:compiled-at",1600144479739,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_util$build$vega_util.js\",\n\"lineCount\":27,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-util/build/vega-util.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_util$build$vega_util\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}));\\n}(this, (function (exports) { 'use strict';\\n\\n  function accessor(fn, fields, name) {\\n    fn.fields = fields || [];\\n    fn.fname = name;\\n    return fn;\\n  }\\n\\n  function accessorName(fn) {\\n    return fn == null ? null : fn.fname;\\n  }\\n\\n  function accessorFields(fn) {\\n    return fn == null ? null : fn.fields;\\n  }\\n\\n  function getter(path) {\\n    return path.length === 1 ? get1(path[0]) : getN(path);\\n  }\\n\\n  const get1 = field => function(obj) {\\n    return obj[field];\\n  };\\n\\n  const getN = path => {\\n    const len = path.length;\\n    return function(obj) {\\n      for (let i = 0; i < len; ++i) {\\n        obj = obj[path[i]];\\n      }\\n      return obj;\\n    };\\n  };\\n\\n  function error(message) {\\n    throw Error(message);\\n  }\\n\\n  function splitAccessPath(p) {\\n    const path = [],\\n          n = p.length;\\n\\n    let q = null,\\n        b = 0,\\n        s = '',\\n        i, j, c;\\n\\n    p = p + '';\\n\\n    function push() {\\n      path.push(s + p.substring(i, j));\\n      s = '';\\n      i = j + 1;\\n    }\\n\\n    for (i=j=0; j<n; ++j) {\\n      c = p[j];\\n      if (c === '\\\\\\\\') {\\n        s += p.substring(i, j);\\n        s += p.substring(++j, ++j);\\n        i = j;\\n      } else if (c === q) {\\n        push();\\n        q = null;\\n        b = -1;\\n      } else if (q) {\\n        continue;\\n      } else if (i === b && c === '\\\"') {\\n        i = j + 1;\\n        q = c;\\n      } else if (i === b && c === \\\"'\\\") {\\n        i = j + 1;\\n        q = c;\\n      } else if (c === '.' && !b) {\\n        if (j > i) {\\n          push();\\n        } else {\\n          i = j + 1;\\n        }\\n      } else if (c === '[') {\\n        if (j > i) push();\\n        b = i = j + 1;\\n      } else if (c === ']') {\\n        if (!b) error('Access path missing open bracket: ' + p);\\n        if (b > 0) push();\\n        b = 0;\\n        i = j + 1;\\n      }\\n    }\\n\\n    if (b) error('Access path missing closing bracket: ' + p);\\n    if (q) error('Access path missing closing quote: ' + p);\\n\\n    if (j > i) {\\n      j++;\\n      push();\\n    }\\n\\n    return path;\\n  }\\n\\n  function field(field, name, opt) {\\n    const path = splitAccessPath(field);\\n    field = path.length === 1 ? path[0] : field;\\n    return accessor(\\n      (opt && opt.get || getter)(path),\\n      [field],\\n      name || field\\n    );\\n  }\\n\\n  const id = field('id');\\n\\n  const identity = accessor(_ => _, [], 'identity');\\n\\n  const zero = accessor(() => 0, [], 'zero');\\n\\n  const one = accessor(() => 1, [], 'one');\\n\\n  const truthy = accessor(() => true, [], 'true');\\n\\n  const falsy = accessor(() => false, [], 'false');\\n\\n  function log(method, level, input) {\\n    const args = [level].concat([].slice.call(input));\\n    console[method].apply(console, args); // eslint-disable-line no-console\\n  }\\n\\n  const None  = 0;\\n  const Error$1 = 1;\\n  const Warn  = 2;\\n  const Info  = 3;\\n  const Debug = 4;\\n\\n  function logger(_, method) {\\n    let level = _ || None;\\n    return {\\n      level(_) {\\n        if (arguments.length) {\\n          level = +_;\\n          return this;\\n        } else {\\n          return level;\\n        }\\n      },\\n      error() {\\n        if (level >= Error$1) log(method || 'error', 'ERROR', arguments);\\n        return this;\\n      },\\n      warn() {\\n        if (level >= Warn) log(method || 'warn', 'WARN', arguments);\\n        return this;\\n      },\\n      info() {\\n        if (level >= Info) log(method || 'log', 'INFO', arguments);\\n        return this;\\n      },\\n      debug() {\\n        if (level >= Debug) log(method || 'log', 'DEBUG', arguments);\\n        return this;\\n      }\\n    };\\n  }\\n\\n  var isArray = Array.isArray;\\n\\n  function isObject(_) {\\n    return _ === Object(_);\\n  }\\n\\n  const isLegalKey = key => key !== '__proto__';\\n\\n  function mergeConfig(...configs) {\\n    return configs.reduce((out, source) => {\\n      for (const key in source) {\\n        if (key === 'signals') {\\n          // for signals, we merge the signals arrays\\n          // source signals take precedence over\\n          // existing signals with the same name\\n          out.signals = mergeNamed(out.signals, source.signals);\\n        } else {\\n          // otherwise, merge objects subject to recursion constraints\\n          // for legend block, recurse for the layout entry only\\n          // for style block, recurse for all properties\\n          // otherwise, no recursion: objects overwrite, no merging\\n          const r = key === 'legend' ? {layout: 1}\\n            : key === 'style' ? true\\n            : null;\\n          writeConfig(out, key, source[key], r);\\n        }\\n      }\\n      return out;\\n    }, {});\\n  }\\n\\n  function writeConfig(output, key, value, recurse) {\\n    if (!isLegalKey(key)) return;\\n\\n    let k, o;\\n    if (isObject(value) && !isArray(value)) {\\n      o = isObject(output[key]) ? output[key] : (output[key] = {});\\n      for (k in value) {\\n        if (recurse && (recurse === true || recurse[k])) {\\n          writeConfig(o, k, value[k]);\\n        } else if (isLegalKey(k)) {\\n          o[k] = value[k];\\n        }\\n      }\\n    } else {\\n      output[key] = value;\\n    }\\n  }\\n\\n  function mergeNamed(a, b) {\\n    if (a == null) return b;\\n\\n    const map = {}, out = [];\\n\\n    function add(_) {\\n      if (!map[_.name]) {\\n        map[_.name] = 1;\\n        out.push(_);\\n      }\\n    }\\n\\n    b.forEach(add);\\n    a.forEach(add);\\n    return out;\\n  }\\n\\n  function peek(array) {\\n    return array[array.length - 1];\\n  }\\n\\n  function toNumber(_) {\\n    return _ == null || _ === '' ? null : +_;\\n  }\\n\\n  const exp = sign =>\\n    x => sign * Math.exp(x);\\n\\n  const log$1 = sign =>\\n    x => Math.log(sign * x);\\n\\n  const symlog = c =>\\n    x => Math.sign(x) * Math.log1p(Math.abs(x / c));\\n\\n  const symexp = c =>\\n    x => Math.sign(x) * Math.expm1(Math.abs(x)) * c;\\n\\n  const pow = exponent =>\\n    x => x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\\n\\n  function pan(domain, delta, lift, ground) {\\n    const d0 = lift(domain[0]),\\n          d1 = lift(peek(domain)),\\n          dd = (d1 - d0) * delta;\\n\\n    return [\\n      ground(d0 - dd),\\n      ground(d1 - dd)\\n    ];\\n  }\\n\\n  function panLinear(domain, delta) {\\n    return pan(domain, delta, toNumber, identity);\\n  }\\n\\n  function panLog(domain, delta) {\\n    var sign = Math.sign(domain[0]);\\n    return pan(domain, delta, log$1(sign), exp(sign));\\n  }\\n\\n  function panPow(domain, delta, exponent) {\\n    return pan(domain, delta, pow(exponent), pow(1/exponent));\\n  }\\n\\n  function panSymlog(domain, delta, constant) {\\n    return pan(domain, delta, symlog(constant), symexp(constant));\\n  }\\n\\n  function zoom(domain, anchor, scale, lift, ground) {\\n    const d0 = lift(domain[0]),\\n          d1 = lift(peek(domain)),\\n          da = anchor != null ? lift(anchor) : (d0 + d1) / 2;\\n\\n    return [\\n      ground(da + (d0 - da) * scale),\\n      ground(da + (d1 - da) * scale)\\n    ];\\n  }\\n\\n  function zoomLinear(domain, anchor, scale) {\\n    return zoom(domain, anchor, scale, toNumber, identity);\\n  }\\n\\n  function zoomLog(domain, anchor, scale) {\\n    const sign = Math.sign(domain[0]);\\n    return zoom(domain, anchor, scale, log$1(sign), exp(sign));\\n  }\\n\\n  function zoomPow(domain, anchor, scale, exponent) {\\n    return zoom(domain, anchor, scale, pow(exponent), pow(1/exponent));\\n  }\\n\\n  function zoomSymlog(domain, anchor, scale, constant) {\\n    return zoom(domain, anchor, scale, symlog(constant), symexp(constant));\\n  }\\n\\n  function quarter(date) {\\n    return 1 + ~~(new Date(date).getMonth() / 3);\\n  }\\n\\n  function utcquarter(date) {\\n    return 1 + ~~(new Date(date).getUTCMonth() / 3);\\n  }\\n\\n  function array(_) {\\n    return _ != null ? (isArray(_) ? _ : [_]) : [];\\n  }\\n\\n  /**\\n   * Span-preserving range clamp. If the span of the input range is less\\n   * than (max - min) and an endpoint exceeds either the min or max value,\\n   * the range is translated such that the span is preserved and one\\n   * endpoint touches the boundary of the min/max range.\\n   * If the span exceeds (max - min), the range [min, max] is returned.\\n   */\\n  function clampRange(range, min, max) {\\n    let lo = range[0],\\n        hi = range[1],\\n        span;\\n\\n    if (hi < lo) {\\n      span = hi;\\n      hi = lo;\\n      lo = span;\\n    }\\n    span = hi - lo;\\n\\n    return span >= (max - min)\\n      ? [min, max]\\n      : [\\n          (lo = Math.min(Math.max(lo, min), max - span)),\\n          lo + span\\n        ];\\n  }\\n\\n  function isFunction(_) {\\n    return typeof _ === 'function';\\n  }\\n\\n  const DESCENDING = 'descending';\\n\\n  function compare(fields, orders, opt) {\\n    opt = opt || {};\\n    orders = array(orders) || [];\\n\\n    const ord = [], get = [], fmap = {},\\n          gen = opt.comparator || comparator;\\n\\n    array(fields).forEach((f, i) => {\\n      if (f == null) return;\\n      ord.push(orders[i] === DESCENDING ? -1 : 1);\\n      get.push(f = isFunction(f) ? f : field(f, null, opt));\\n      (accessorFields(f) || []).forEach(_ => fmap[_] = 1);\\n    });\\n\\n    return get.length === 0\\n      ? null\\n      : accessor(gen(get, ord), Object.keys(fmap));\\n  }\\n\\n  const ascending = (u, v) => (u < v || u == null) && v != null ? -1\\n    : (u > v || v == null) && u != null ? 1\\n    : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? -1\\n    : v !== v && u === u ? 1\\n    : 0;\\n\\n  const comparator = (fields, orders) => fields.length === 1\\n    ? compare1(fields[0], orders[0])\\n    : compareN(fields, orders, fields.length);\\n\\n  const compare1 = (field, order) => function(a, b) {\\n    return ascending(field(a), field(b)) * order;\\n  };\\n\\n  const compareN = (fields, orders, n) => {\\n    orders.push(0); // pad zero for convenient lookup\\n    return function(a, b) {\\n      let f, c = 0, i = -1;\\n      while (c === 0 && ++i < n) {\\n        f = fields[i];\\n        c = ascending(f(a), f(b));\\n      }\\n      return c * orders[i];\\n    };\\n  };\\n\\n  function constant(_) {\\n    return isFunction(_) ? _ : () => _;\\n  }\\n\\n  function debounce(delay, handler) {\\n    let tid;\\n\\n    return e => {\\n      if (tid) clearTimeout(tid);\\n      tid = setTimeout(\\n        () => (handler(e), tid = null),\\n        delay\\n      );\\n    };\\n  }\\n\\n  function extend(_) {\\n    for (let x, k, i=1, len=arguments.length; i<len; ++i) {\\n      x = arguments[i];\\n      for (k in x) { _[k] = x[k]; }\\n    }\\n    return _;\\n  }\\n\\n  /**\\n   * Return an array with minimum and maximum values, in the\\n   * form [min, max]. Ignores null, undefined, and NaN values.\\n   */\\n  function extent(array, f) {\\n    let i = 0, n, v, min, max;\\n\\n    if (array && (n = array.length)) {\\n      if (f == null) {\\n        // find first valid value\\n        for (v = array[i]; i < n && (v == null || v !== v); v = array[++i]);\\n        min = max = v;\\n\\n        // visit all other values\\n        for (; i<n; ++i) {\\n          v = array[i];\\n          // skip null/undefined; NaN will fail all comparisons\\n          if (v != null) {\\n            if (v < min) min = v;\\n            if (v > max) max = v;\\n          }\\n        }\\n      } else {\\n        // find first valid value\\n        for (v = f(array[i]); i < n && (v == null || v !== v); v = f(array[++i]));\\n        min = max = v;\\n\\n        // visit all other values\\n        for (; i<n; ++i) {\\n          v = f(array[i]);\\n          // skip null/undefined; NaN will fail all comparisons\\n          if (v != null) {\\n            if (v < min) min = v;\\n            if (v > max) max = v;\\n          }\\n        }\\n      }\\n    }\\n\\n    return [min, max];\\n  }\\n\\n  function extentIndex(array, f) {\\n    const n = array.length;\\n    let i = -1, a, b, c, u, v;\\n\\n    if (f == null) {\\n      while (++i < n) {\\n        b = array[i];\\n        if (b != null && b >= b) {\\n          a = c = b;\\n          break;\\n        }\\n      }\\n      if (i === n) return [-1, -1];\\n      u = v = i;\\n      while (++i < n) {\\n        b = array[i];\\n        if (b != null) {\\n          if (a > b) {\\n            a = b;\\n            u = i;\\n          }\\n          if (c < b) {\\n            c = b;\\n            v = i;\\n          }\\n        }\\n      }\\n    } else {\\n      while (++i < n) {\\n        b = f(array[i], i, array);\\n        if (b != null && b >= b) {\\n          a = c = b;\\n          break;\\n        }\\n      }\\n      if (i === n) return [-1, -1];\\n      u = v = i;\\n      while (++i < n) {\\n        b = f(array[i], i, array);\\n        if (b != null) {\\n          if (a > b) {\\n            a = b;\\n            u = i;\\n          }\\n          if (c < b) {\\n            c = b;\\n            v = i;\\n          }\\n        }\\n      }\\n    }\\n\\n    return [u, v];\\n  }\\n\\n  const hop = Object.prototype.hasOwnProperty;\\n\\n  function has(object, property) {\\n    return hop.call(object, property);\\n  }\\n\\n  const NULL = {};\\n\\n  function fastmap(input) {\\n    let obj = {},\\n        test;\\n\\n    function has$1(key) {\\n      return has(obj, key) && obj[key] !== NULL;\\n    }\\n\\n    const map = {\\n      size: 0,\\n      empty: 0,\\n      object: obj,\\n      has: has$1,\\n      get(key) {\\n        return has$1(key) ? obj[key] : undefined;\\n      },\\n      set(key, value) {\\n        if (!has$1(key)) {\\n          ++map.size;\\n          if (obj[key] === NULL) --map.empty;\\n        }\\n        obj[key] = value;\\n        return this;\\n      },\\n      delete(key) {\\n        if (has$1(key)) {\\n          --map.size;\\n          ++map.empty;\\n          obj[key] = NULL;\\n        }\\n        return this;\\n      },\\n      clear() {\\n        map.size = map.empty = 0;\\n        map.object = obj = {};\\n      },\\n      test(_) {\\n        if (arguments.length) {\\n          test = _;\\n          return map;\\n        } else {\\n          return test;\\n        }\\n      },\\n      clean() {\\n        const next = {};\\n        let size = 0;\\n        for (const key in obj) {\\n          const value = obj[key];\\n          if (value !== NULL && (!test || !test(value))) {\\n            next[key] = value;\\n            ++size;\\n          }\\n        }\\n        map.size = size;\\n        map.empty = 0;\\n        map.object = (obj = next);\\n      }\\n    };\\n\\n    if (input) Object.keys(input).forEach(key => {\\n      map.set(key, input[key]);\\n    });\\n\\n    return map;\\n  }\\n\\n  function flush(range, value, threshold, left, right, center) {\\n    if (!threshold && threshold !== 0) return center;\\n\\n    const t = +threshold;\\n    let a = range[0],\\n        b = peek(range),\\n        l;\\n\\n    // swap endpoints if range is reversed\\n    if (b < a) {\\n      l = a; a = b; b = l;\\n    }\\n\\n    // compare value to endpoints\\n    l = Math.abs(value - a);\\n    const r = Math.abs(b - value);\\n\\n    // adjust if value is within threshold distance of endpoint\\n    return l < r && l <= t ? left : r <= t ? right : center;\\n  }\\n\\n  function inherits(child, parent, members) {\\n    const proto = (child.prototype = Object.create(parent.prototype));\\n    proto.constructor = child;\\n    return extend(proto, members);\\n  }\\n\\n  /**\\n   * Predicate that returns true if the value lies within the span\\n   * of the given range. The left and right flags control the use\\n   * of inclusive (true) or exclusive (false) comparisons.\\n   */\\n  function inrange(value, range, left, right) {\\n    let r0 = range[0], r1 = range[range.length-1], t;\\n    if (r0 > r1) {\\n      t = r0;\\n      r0 = r1;\\n      r1 = t;\\n    }\\n    left = left === undefined || left;\\n    right = right === undefined || right;\\n\\n    return (left ? r0 <= value : r0 < value) &&\\n      (right ? value <= r1 : value < r1);\\n  }\\n\\n  function isBoolean(_) {\\n    return typeof _ === 'boolean';\\n  }\\n\\n  function isDate(_) {\\n    return Object.prototype.toString.call(_) === '[object Date]';\\n  }\\n\\n  function isNumber(_) {\\n    return typeof _ === 'number';\\n  }\\n\\n  function isRegExp(_) {\\n    return Object.prototype.toString.call(_) === '[object RegExp]';\\n  }\\n\\n  function isString(_) {\\n    return typeof _ === 'string';\\n  }\\n\\n  function key(fields, flat, opt) {\\n    if (fields) {\\n      fields = flat\\n        ? array(fields).map(f => f.replace(/\\\\\\\\(.)/g, '$1'))\\n        : array(fields);\\n    }\\n\\n    const len = fields && fields.length,\\n          gen = opt && opt.get || getter,\\n          map = f => gen(flat ? [f] : splitAccessPath(f));\\n    let fn;\\n\\n    if (!len) {\\n      fn = function() { return ''; };\\n    } else if (len === 1) {\\n      const get = map(fields[0]);\\n      fn = function(_) { return '' + get(_); };\\n    } else {\\n      const get = fields.map(map);\\n      fn = function(_) {\\n        let s = '' + get[0](_), i = 0;\\n        while (++i < len) s += '|' + get[i](_);\\n        return s;\\n      };\\n    }\\n\\n    return accessor(fn, fields, 'key');\\n  }\\n\\n  function lerp(array, frac) {\\n    const lo = array[0],\\n          hi = peek(array),\\n          f = +frac;\\n    return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);\\n  }\\n\\n  const DEFAULT_MAX_SIZE = 10000;\\n\\n  // adapted from https://github.com/dominictarr/hashlru/ (MIT License)\\n  function lruCache(maxsize) {\\n    maxsize = +maxsize || DEFAULT_MAX_SIZE;\\n\\n    let curr, prev, size;\\n\\n    const clear = () => {\\n      curr = {};\\n      prev = {};\\n      size = 0;\\n    };\\n\\n    const update = (key, value) => {\\n      if (++size > maxsize) {\\n        prev = curr;\\n        curr = {};\\n        size = 1;\\n      }\\n      return (curr[key] = value);\\n    };\\n\\n    clear();\\n\\n    return {\\n      clear,\\n      has: key => has(curr, key) || has(prev, key),\\n      get: key => has(curr, key) ? curr[key]\\n          : has(prev, key) ? update(key, prev[key])\\n          : undefined,\\n      set: (key, value) => has(curr, key)\\n          ? (curr[key] = value)\\n          : update(key, value)\\n    };\\n  }\\n\\n  function merge(compare, array0, array1, output) {\\n    const n0 = array0.length,\\n          n1 = array1.length;\\n\\n    if (!n1) return array0;\\n    if (!n0) return array1;\\n\\n    const merged = output || new array0.constructor(n0 + n1);\\n    let i0 = 0, i1 = 0, i = 0;\\n\\n    for (; i0<n0 && i1<n1; ++i) {\\n      merged[i] = compare(array0[i0], array1[i1]) > 0\\n         ? array1[i1++]\\n         : array0[i0++];\\n    }\\n\\n    for (; i0<n0; ++i0, ++i) {\\n      merged[i] = array0[i0];\\n    }\\n\\n    for (; i1<n1; ++i1, ++i) {\\n      merged[i] = array1[i1];\\n    }\\n\\n    return merged;\\n  }\\n\\n  function repeat(str, reps) {\\n    let s = '';\\n    while (--reps >= 0) s += str;\\n    return s;\\n  }\\n\\n  function pad(str, length, padchar, align) {\\n    const c = padchar || ' ',\\n          s = str + '',\\n          n = length - s.length;\\n\\n    return n <= 0 ? s\\n      : align === 'left' ? repeat(c, n) + s\\n      : align === 'center' ? repeat(c, ~~(n/2)) + s + repeat(c, Math.ceil(n/2))\\n      : s + repeat(c, n);\\n  }\\n\\n  /**\\n   * Return the numerical span of an array: the difference between\\n   * the last and first values.\\n   */\\n  function span(array) {\\n    return array && (peek(array) - array[0]) || 0;\\n  }\\n\\n  function $(x) {\\n    return isArray(x) ? '[' + x.map($) + ']'\\n      : isObject(x) || isString(x) ?\\n        // Output valid JSON and JS source strings.\\n        // See http://timelessrepo.com/json-isnt-a-javascript-subset\\n        JSON.stringify(x).replace('\\\\u2028','\\\\\\\\u2028').replace('\\\\u2029', '\\\\\\\\u2029')\\n      : x;\\n  }\\n\\n  function toBoolean(_) {\\n    return _ == null || _ === '' ? null : !_ || _ === 'false' || _ === '0' ? false : !!_;\\n  }\\n\\n  const defaultParser = _ =>\\n    isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);\\n\\n  function toDate(_, parser) {\\n    parser = parser || defaultParser;\\n    return _ == null || _ === '' ? null : parser(_);\\n  }\\n\\n  function toString(_) {\\n    return _ == null || _ === '' ? null : _ + '';\\n  }\\n\\n  function toSet(_) {\\n    const s = {},\\n          n = _.length;\\n    for (let i=0; i<n; ++i) s[_[i]] = true;\\n    return s;\\n  }\\n\\n  function truncate(str, length, align, ellipsis) {\\n    const e = ellipsis != null ? ellipsis : '\\\\u2026',\\n          s = str + '',\\n          n = s.length,\\n          l = Math.max(0, length - e.length);\\n\\n    return n <= length ? s\\n      : align === 'left' ? e + s.slice(n - l)\\n      : align === 'center' ? s.slice(0, Math.ceil(l/2)) + e + s.slice(n - ~~(l/2))\\n      : s.slice(0, l) + e;\\n  }\\n\\n  function visitArray(array, filter, visitor) {\\n    if (array) {\\n      if (filter) {\\n        const n = array.length;\\n        for (let i = 0; i < n; ++i) {\\n          const t = filter(array[i]);\\n          if (t) visitor(t, i, array);\\n        }\\n      } else {\\n        array.forEach(visitor);\\n      }\\n    }\\n  }\\n\\n  exports.Debug = Debug;\\n  exports.Error = Error$1;\\n  exports.Info = Info;\\n  exports.None = None;\\n  exports.Warn = Warn;\\n  exports.accessor = accessor;\\n  exports.accessorFields = accessorFields;\\n  exports.accessorName = accessorName;\\n  exports.array = array;\\n  exports.ascending = ascending;\\n  exports.clampRange = clampRange;\\n  exports.compare = compare;\\n  exports.constant = constant;\\n  exports.debounce = debounce;\\n  exports.error = error;\\n  exports.extend = extend;\\n  exports.extent = extent;\\n  exports.extentIndex = extentIndex;\\n  exports.falsy = falsy;\\n  exports.fastmap = fastmap;\\n  exports.field = field;\\n  exports.flush = flush;\\n  exports.hasOwnProperty = has;\\n  exports.id = id;\\n  exports.identity = identity;\\n  exports.inherits = inherits;\\n  exports.inrange = inrange;\\n  exports.isArray = isArray;\\n  exports.isBoolean = isBoolean;\\n  exports.isDate = isDate;\\n  exports.isFunction = isFunction;\\n  exports.isNumber = isNumber;\\n  exports.isObject = isObject;\\n  exports.isRegExp = isRegExp;\\n  exports.isString = isString;\\n  exports.key = key;\\n  exports.lerp = lerp;\\n  exports.logger = logger;\\n  exports.lruCache = lruCache;\\n  exports.merge = merge;\\n  exports.mergeConfig = mergeConfig;\\n  exports.one = one;\\n  exports.pad = pad;\\n  exports.panLinear = panLinear;\\n  exports.panLog = panLog;\\n  exports.panPow = panPow;\\n  exports.panSymlog = panSymlog;\\n  exports.peek = peek;\\n  exports.quarter = quarter;\\n  exports.repeat = repeat;\\n  exports.span = span;\\n  exports.splitAccessPath = splitAccessPath;\\n  exports.stringValue = $;\\n  exports.toBoolean = toBoolean;\\n  exports.toDate = toDate;\\n  exports.toNumber = toNumber;\\n  exports.toSet = toSet;\\n  exports.toString = toString;\\n  exports.truncate = truncate;\\n  exports.truthy = truthy;\\n  exports.utcquarter = utcquarter;\\n  exports.visitArray = visitArray;\\n  exports.writeConfig = writeConfig;\\n  exports.zero = zero;\\n  exports.zoomLinear = zoomLinear;\\n  exports.zoomLog = zoomLog;\\n  exports.zoomPow = zoomPow;\\n  exports.zoomSymlog = zoomSymlog;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"accessor\",\"fn\",\"fields\",\"name\",\"fname\",\"accessorFields\",\"getter\",\"path\",\"length\",\"get1\",\"getN\",\"error\",\"message\",\"Error\",\"splitAccessPath\",\"p\",\"push\",\"s\",\"substring\",\"i\",\"j\",\"n\",\"q\",\"b\",\"c\",\"field\",\"opt\",\"get\",\"log\",\"method\",\"level\",\"input\",\"args\",\"concat\",\"slice\",\"call\",\"console\",\"apply\",\"isObject\",\"_\",\"Object\",\"writeConfig\",\"output\",\"key\",\"value\",\"recurse\",\"k\",\"isArray\",\"o\",\"mergeNamed\",\"a\",\"add\",\"map\",\"out\",\"forEach\",\"peek\",\"array\",\"toNumber\",\"pan\",\"domain\",\"delta\",\"lift\",\"ground\",\"d0\",\"d1\",\"dd\",\"zoom\",\"anchor\",\"scale\",\"da\",\"isFunction\",\"extend\",\"x\",\"len\",\"arguments\",\"has\",\"object\",\"property\",\"hop\",\"isDate\",\"prototype\",\"toString\",\"isNumber\",\"isString\",\"repeat\",\"str\",\"reps\",\"$\",\"JSON\",\"stringify\",\"replace\",\"obj\",\"id\",\"identity\",\"zero\",\"one\",\"truthy\",\"falsy\",\"Array\",\"exp\",\"sign\",\"Math\",\"log$1\",\"symlog\",\"log1p\",\"abs\",\"symexp\",\"expm1\",\"pow\",\"exponent\",\"ascending\",\"u\",\"v\",\"Date\",\"comparator\",\"orders\",\"compare1\",\"compareN\",\"order\",\"f\",\"hasOwnProperty\",\"NULL\",\"defaultParser\",\"parse\",\"Debug\",\"Error$1\",\"Info\",\"None\",\"Warn\",\"accessorName\",\"clampRange\",\"range\",\"min\",\"max\",\"lo\",\"hi\",\"span\",\"compare\",\"ord\",\"fmap\",\"gen\",\"DESCENDING\",\"keys\",\"constant\",\"debounce\",\"delay\",\"handler\",\"tid\",\"e\",\"clearTimeout\",\"setTimeout\",\"extent\",\"extentIndex\",\"fastmap\",\"has$1\",\"test\",\"size\",\"empty\",\"undefined\",\"set\",\"delete\",\"clear\",\"clean\",\"next\",\"flush\",\"threshold\",\"left\",\"right\",\"center\",\"t\",\"l\",\"r\",\"inherits\",\"child\",\"parent\",\"members\",\"proto\",\"create\",\"constructor\",\"inrange\",\"r0\",\"r1\",\"isBoolean\",\"isRegExp\",\"flat\",\"lerp\",\"frac\",\"logger\",\"warn\",\"info\",\"debug\",\"lruCache\",\"maxsize\",\"DEFAULT_MAX_SIZE\",\"curr\",\"prev\",\"update\",\"merge\",\"array0\",\"array1\",\"n0\",\"n1\",\"merged\",\"i0\",\"i1\",\"mergeConfig\",\"configs\",\"reduce\",\"source\",\"signals\",\"layout\",\"pad\",\"padchar\",\"align\",\"ceil\",\"panLinear\",\"panLog\",\"panPow\",\"panSymlog\",\"quarter\",\"date\",\"getMonth\",\"stringValue\",\"toBoolean\",\"toDate\",\"parser\",\"toSet\",\"truncate\",\"ellipsis\",\"utcquarter\",\"getUTCMonth\",\"visitArray\",\"filter\",\"visitor\",\"zoomLinear\",\"zoomLog\",\"zoomPow\",\"zoomSymlog\",\"defineProperty\"]\n}\n"]