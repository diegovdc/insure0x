["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-regression/build/vega-regression.js"],"~:js","shadow$provide.module$node_modules$vega_regression$build$vega_regression=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_statistics$build$vega_statistics\"),require(\"module$node_modules$vega_dataflow$build$vega_dataflow\"),require(\"module$node_modules$vega_util$build$vega_util\")):\"function\"===typeof define&&define.amd?define([\"exports\",\"vega-statistics\",\n\"vega-dataflow\",\"vega-util\"],factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory((global.vega=global.vega||{},global.vega.transforms={}),global.vega,global.vega,global.vega))})(this,function(exports,vegaStatistics,vegaDataflow,vegaUtil){function partition(data,groupby){var groups=[],get=function(f){return f(t)},n;if(null==groupby)groups.push(data);else{var map={};var i=0;for(n=data.length;i<n;++i){var t=data[i];var k=groupby.map(get);var g=map[k];g||(map[k]=g=[],g.dims=\nk,groups.push(g));g.push(t)}}return groups}function Loess(params){vegaDataflow.Transform.call(this,null,params)}function Regression(params){vegaDataflow.Transform.call(this,null,params)}Loess.Definition={type:\"Loess\",metadata:{generates:!0},params:[{name:\"x\",type:\"field\",required:!0},{name:\"y\",type:\"field\",required:!0},{name:\"groupby\",type:\"field\",array:!0},{name:\"bandwidth\",type:\"number\",\"default\":.3},{name:\"as\",type:\"string\",array:!0}]};vegaUtil.inherits(Loess,vegaDataflow.Transform,{transform:function(_,\npulse){var out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);if(!this.value||pulse.changed()||_.modified()){pulse=pulse.materialize(pulse.SOURCE).source;pulse=partition(pulse,_.groupby);var names=(_.groupby||[]).map(vegaUtil.accessorName),m=names.length,as=_.as||[vegaUtil.accessorName(_.x),vegaUtil.accessorName(_.y)],values=[];pulse.forEach(function(g){vegaStatistics.regressionLoess(g,_.x,_.y,_.bandwidth||.3).forEach(function(p){for(var t={},i=0;i<m;++i)t[names[i]]=g.dims[i];t[as[0]]=p[0];t[as[1]]=\np[1];values.push(vegaDataflow.ingest(t))})});this.value&&(out.rem=this.value);this.value=out.add=out.source=values}return out}});var Methods={linear:vegaStatistics.regressionLinear,log:vegaStatistics.regressionLog,exp:vegaStatistics.regressionExp,pow:vegaStatistics.regressionPow,quad:vegaStatistics.regressionQuad,poly:vegaStatistics.regressionPoly};Regression.Definition={type:\"Regression\",metadata:{generates:!0},params:[{name:\"x\",type:\"field\",required:!0},{name:\"y\",type:\"field\",required:!0},{name:\"groupby\",\ntype:\"field\",array:!0},{name:\"method\",type:\"string\",\"default\":\"linear\",values:Object.keys(Methods)},{name:\"order\",type:\"number\",\"default\":3},{name:\"extent\",type:\"number\",array:!0,length:2},{name:\"params\",type:\"boolean\",\"default\":!1},{name:\"as\",type:\"string\",array:!0}]};vegaUtil.inherits(Regression,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);if(!this.value||pulse.changed()||_.modified()){var source=pulse.materialize(pulse.SOURCE).source;source=\npartition(source,_.groupby);var names=(_.groupby||[]).map(vegaUtil.accessorName),method=_.method||\"linear\",order=_.order||3,dof=\"poly\"===method?order:\"quad\"===method?2:1,as=_.as||[vegaUtil.accessorName(_.x),vegaUtil.accessorName(_.y)],fit=Methods[method],values=[],domain=_.extent;vegaUtil.hasOwnProperty(Methods,method)||vegaUtil.error(\"Invalid regression method: \"+method);null!=domain&&\"log\"===method&&0>=domain[0]&&(pulse.dataflow.warn(\"Ignoring extent with values \\x3c\\x3d 0 for log regression.\"),\ndomain=null);source.forEach(function(g){if(g.length<=dof)pulse.dataflow.warn(\"Skipping regression with more parameters than data points.\");else{var model=fit(g,_.x,_.y,order);if(_.params)values.push(vegaDataflow.ingest({keys:g.dims,coef:model.coef,rSquared:model.rSquared}));else{var dom=domain||vegaUtil.extent(g,_.x),add=function(p){for(var t={},i=0;i<names.length;++i)t[names[i]]=g.dims[i];t[as[0]]=p[0];t[as[1]]=p[1];values.push(vegaDataflow.ingest(t))};\"linear\"===method?dom.forEach(function(x){return add([x,\nmodel.predict(x)])}):vegaStatistics.sampleCurve(model.predict,dom,25,200).forEach(add)}}});this.value&&(out.rem=this.value);this.value=out.add=out.source=values}return out}});exports.loess=Loess;exports.regression=Regression;Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_regression$build$vega_regression\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-statistics'), require('vega-dataflow'), require('vega-util')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-statistics', 'vega-dataflow', 'vega-util'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.vega));\n}(this, (function (exports, vegaStatistics, vegaDataflow, vegaUtil) { 'use strict';\n\n  function partition(data, groupby) {\n    var groups = [],\n        get = function(f) { return f(t); },\n        map, i, n, t, k, g;\n\n    // partition data points into stack groups\n    if (groupby == null) {\n      groups.push(data);\n    } else {\n      for (map={}, i=0, n=data.length; i<n; ++i) {\n        t = data[i];\n        k = groupby.map(get);\n        g = map[k];\n        if (!g) {\n          map[k] = (g = []);\n          g.dims = k;\n          groups.push(g);\n        }\n        g.push(t);\n      }\n    }\n\n    return groups;\n  }\n\n  /**\n   * Compute locally-weighted regression fits for one or more data groups.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.x - An accessor for the predictor data field.\n   * @param {function(object): *} params.y - An accessor for the predicted data field.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n   * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n   */\n  function Loess(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Loess.Definition = {\n    'type': 'Loess',\n    'metadata': {'generates': true},\n    'params': [\n      { 'name': 'x', 'type': 'field', 'required': true },\n      { 'name': 'y', 'type': 'field', 'required': true },\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'bandwidth', 'type': 'number', 'default': 0.3 },\n      { 'name': 'as', 'type': 'string', 'array': true }\n    ]\n  };\n\n  vegaUtil.inherits(Loess, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n      if (!this.value || pulse.changed() || _.modified()) {\n        const source = pulse.materialize(pulse.SOURCE).source,\n              groups = partition(source, _.groupby),\n              names = (_.groupby || []).map(vegaUtil.accessorName),\n              m = names.length,\n              as = _.as || [vegaUtil.accessorName(_.x), vegaUtil.accessorName(_.y)],\n              values = [];\n\n        groups.forEach(g => {\n          vegaStatistics.regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n            const t = {};\n            for (let i=0; i<m; ++i) {\n              t[names[i]] = g.dims[i];\n            }\n            t[as[0]] = p[0];\n            t[as[1]] = p[1];\n            values.push(vegaDataflow.ingest(t));\n          });\n        });\n\n        if (this.value) out.rem = this.value;\n        this.value = out.add = out.source = values;\n      }\n\n      return out;\n    }\n  });\n\n  const Methods = {\n    linear: vegaStatistics.regressionLinear,\n    log:    vegaStatistics.regressionLog,\n    exp:    vegaStatistics.regressionExp,\n    pow:    vegaStatistics.regressionPow,\n    quad:   vegaStatistics.regressionQuad,\n    poly:   vegaStatistics.regressionPoly\n  };\n\n  const degreesOfFreedom = (method, order) =>\n    method === 'poly' ? order : method === 'quad' ? 2 : 1;\n\n  /**\n   * Compute regression fits for one or more data groups.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.x - An accessor for the predictor data field.\n   * @param {function(object): *} params.y - An accessor for the predicted data field.\n   * @param {string} [params.method='linear'] - The regression method to apply.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n   * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n   * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n   */\n  function Regression(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Regression.Definition = {\n    'type': 'Regression',\n    'metadata': {'generates': true},\n    'params': [\n      { 'name': 'x', 'type': 'field', 'required': true },\n      { 'name': 'y', 'type': 'field', 'required': true },\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'method', 'type': 'string', 'default': 'linear', 'values': Object.keys(Methods) },\n      { 'name': 'order', 'type': 'number', 'default': 3 },\n      { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2 },\n      { 'name': 'params', 'type': 'boolean', 'default': false },\n      { 'name': 'as', 'type': 'string', 'array': true }\n    ]\n  };\n\n  vegaUtil.inherits(Regression, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n      if (!this.value || pulse.changed() || _.modified()) {\n        const source = pulse.materialize(pulse.SOURCE).source,\n              groups = partition(source, _.groupby),\n              names = (_.groupby || []).map(vegaUtil.accessorName),\n              method = _.method || 'linear',\n              order = _.order || 3,\n              dof = degreesOfFreedom(method, order),\n              as = _.as || [vegaUtil.accessorName(_.x), vegaUtil.accessorName(_.y)],\n              fit = Methods[method],\n              values = [];\n\n        let domain = _.extent;\n\n        if (!vegaUtil.hasOwnProperty(Methods, method)) {\n          vegaUtil.error('Invalid regression method: ' + method);\n        }\n\n        if (domain != null) {\n          if (method === 'log' && domain[0] <= 0) {\n            pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n            domain = null;\n          }\n        }\n\n        groups.forEach(g => {\n          const n = g.length;\n          if (n <= dof) {\n            pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n            return;\n          }\n\n          const model = fit(g, _.x, _.y, order);\n\n          if (_.params) {\n            // if parameter vectors requested return those\n            values.push(vegaDataflow.ingest({\n              keys: g.dims,\n              coef: model.coef,\n              rSquared: model.rSquared\n            }));\n            return;\n          }\n\n          const dom = domain || vegaUtil.extent(g, _.x),\n                add = p => {\n                  const t = {};\n                  for (let i=0; i<names.length; ++i) {\n                    t[names[i]] = g.dims[i];\n                  }\n                  t[as[0]] = p[0];\n                  t[as[1]] = p[1];\n                  values.push(vegaDataflow.ingest(t));\n                };\n\n          if (method === 'linear') {\n            // for linear regression we only need the end points\n            dom.forEach(x => add([x, model.predict(x)]));\n          } else {\n            // otherwise return trend line sample points\n            vegaStatistics.sampleCurve(model.predict, dom, 25, 200).forEach(add);\n          }\n        });\n\n        if (this.value) out.rem = this.value;\n        this.value = out.add = out.source = values;\n      }\n\n      return out;\n    }\n  });\n\n  exports.loess = Loess;\n  exports.regression = Regression;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vega_dataflow$build$vega_dataflow","~$shadow.js","~$module$node_modules$vega_statistics$build$vega_statistics","~$module$node_modules$vega_util$build$vega_util"]],"~:properties",["^5",["dims","keys","poly","__esModule","pow","transform","vega","log","rem","coef","rSquared","value","linear","exp","source","Definition","transforms","add","loess","quad","regression"]],"~:compiled-at",1600144479993,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_regression$build$vega_regression.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-regression/build/vega-regression.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_regression$build$vega_regression\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-statistics'), require('vega-dataflow'), require('vega-util')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-statistics', 'vega-dataflow', 'vega-util'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.vega));\\n}(this, (function (exports, vegaStatistics, vegaDataflow, vegaUtil) { 'use strict';\\n\\n  function partition(data, groupby) {\\n    var groups = [],\\n        get = function(f) { return f(t); },\\n        map, i, n, t, k, g;\\n\\n    // partition data points into stack groups\\n    if (groupby == null) {\\n      groups.push(data);\\n    } else {\\n      for (map={}, i=0, n=data.length; i<n; ++i) {\\n        t = data[i];\\n        k = groupby.map(get);\\n        g = map[k];\\n        if (!g) {\\n          map[k] = (g = []);\\n          g.dims = k;\\n          groups.push(g);\\n        }\\n        g.push(t);\\n      }\\n    }\\n\\n    return groups;\\n  }\\n\\n  /**\\n   * Compute locally-weighted regression fits for one or more data groups.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.x - An accessor for the predictor data field.\\n   * @param {function(object): *} params.y - An accessor for the predicted data field.\\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\\n   * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\\n   */\\n  function Loess(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Loess.Definition = {\\n    'type': 'Loess',\\n    'metadata': {'generates': true},\\n    'params': [\\n      { 'name': 'x', 'type': 'field', 'required': true },\\n      { 'name': 'y', 'type': 'field', 'required': true },\\n      { 'name': 'groupby', 'type': 'field', 'array': true },\\n      { 'name': 'bandwidth', 'type': 'number', 'default': 0.3 },\\n      { 'name': 'as', 'type': 'string', 'array': true }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Loess, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\\n\\n      if (!this.value || pulse.changed() || _.modified()) {\\n        const source = pulse.materialize(pulse.SOURCE).source,\\n              groups = partition(source, _.groupby),\\n              names = (_.groupby || []).map(vegaUtil.accessorName),\\n              m = names.length,\\n              as = _.as || [vegaUtil.accessorName(_.x), vegaUtil.accessorName(_.y)],\\n              values = [];\\n\\n        groups.forEach(g => {\\n          vegaStatistics.regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\\n            const t = {};\\n            for (let i=0; i<m; ++i) {\\n              t[names[i]] = g.dims[i];\\n            }\\n            t[as[0]] = p[0];\\n            t[as[1]] = p[1];\\n            values.push(vegaDataflow.ingest(t));\\n          });\\n        });\\n\\n        if (this.value) out.rem = this.value;\\n        this.value = out.add = out.source = values;\\n      }\\n\\n      return out;\\n    }\\n  });\\n\\n  const Methods = {\\n    linear: vegaStatistics.regressionLinear,\\n    log:    vegaStatistics.regressionLog,\\n    exp:    vegaStatistics.regressionExp,\\n    pow:    vegaStatistics.regressionPow,\\n    quad:   vegaStatistics.regressionQuad,\\n    poly:   vegaStatistics.regressionPoly\\n  };\\n\\n  const degreesOfFreedom = (method, order) =>\\n    method === 'poly' ? order : method === 'quad' ? 2 : 1;\\n\\n  /**\\n   * Compute regression fits for one or more data groups.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.x - An accessor for the predictor data field.\\n   * @param {function(object): *} params.y - An accessor for the predicted data field.\\n   * @param {string} [params.method='linear'] - The regression method to apply.\\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\\n   * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\\n   * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\\n   */\\n  function Regression(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Regression.Definition = {\\n    'type': 'Regression',\\n    'metadata': {'generates': true},\\n    'params': [\\n      { 'name': 'x', 'type': 'field', 'required': true },\\n      { 'name': 'y', 'type': 'field', 'required': true },\\n      { 'name': 'groupby', 'type': 'field', 'array': true },\\n      { 'name': 'method', 'type': 'string', 'default': 'linear', 'values': Object.keys(Methods) },\\n      { 'name': 'order', 'type': 'number', 'default': 3 },\\n      { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2 },\\n      { 'name': 'params', 'type': 'boolean', 'default': false },\\n      { 'name': 'as', 'type': 'string', 'array': true }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Regression, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\\n\\n      if (!this.value || pulse.changed() || _.modified()) {\\n        const source = pulse.materialize(pulse.SOURCE).source,\\n              groups = partition(source, _.groupby),\\n              names = (_.groupby || []).map(vegaUtil.accessorName),\\n              method = _.method || 'linear',\\n              order = _.order || 3,\\n              dof = degreesOfFreedom(method, order),\\n              as = _.as || [vegaUtil.accessorName(_.x), vegaUtil.accessorName(_.y)],\\n              fit = Methods[method],\\n              values = [];\\n\\n        let domain = _.extent;\\n\\n        if (!vegaUtil.hasOwnProperty(Methods, method)) {\\n          vegaUtil.error('Invalid regression method: ' + method);\\n        }\\n\\n        if (domain != null) {\\n          if (method === 'log' && domain[0] <= 0) {\\n            pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\\n            domain = null;\\n          }\\n        }\\n\\n        groups.forEach(g => {\\n          const n = g.length;\\n          if (n <= dof) {\\n            pulse.dataflow.warn('Skipping regression with more parameters than data points.');\\n            return;\\n          }\\n\\n          const model = fit(g, _.x, _.y, order);\\n\\n          if (_.params) {\\n            // if parameter vectors requested return those\\n            values.push(vegaDataflow.ingest({\\n              keys: g.dims,\\n              coef: model.coef,\\n              rSquared: model.rSquared\\n            }));\\n            return;\\n          }\\n\\n          const dom = domain || vegaUtil.extent(g, _.x),\\n                add = p => {\\n                  const t = {};\\n                  for (let i=0; i<names.length; ++i) {\\n                    t[names[i]] = g.dims[i];\\n                  }\\n                  t[as[0]] = p[0];\\n                  t[as[1]] = p[1];\\n                  values.push(vegaDataflow.ingest(t));\\n                };\\n\\n          if (method === 'linear') {\\n            // for linear regression we only need the end points\\n            dom.forEach(x => add([x, model.predict(x)]));\\n          } else {\\n            // otherwise return trend line sample points\\n            vegaStatistics.sampleCurve(model.predict, dom, 25, 200).forEach(add);\\n          }\\n        });\\n\\n        if (this.value) out.rem = this.value;\\n        this.value = out.add = out.source = values;\\n      }\\n\\n      return out;\\n    }\\n  });\\n\\n  exports.loess = Loess;\\n  exports.regression = Regression;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"transforms\",\"vegaStatistics\",\"vegaDataflow\",\"vegaUtil\",\"partition\",\"data\",\"groupby\",\"groups\",\"get\",\"f\",\"t\",\"n\",\"push\",\"map\",\"i\",\"length\",\"k\",\"g\",\"dims\",\"Loess\",\"params\",\"Transform\",\"call\",\"Regression\",\"Definition\",\"inherits\",\"transform\",\"_\",\"pulse\",\"out\",\"fork\",\"NO_SOURCE\",\"NO_FIELDS\",\"value\",\"changed\",\"modified\",\"source\",\"materialize\",\"SOURCE\",\"names\",\"accessorName\",\"m\",\"as\",\"x\",\"y\",\"values\",\"forEach\",\"regressionLoess\",\"bandwidth\",\"p\",\"ingest\",\"rem\",\"add\",\"Methods\",\"linear\",\"regressionLinear\",\"log\",\"regressionLog\",\"exp\",\"regressionExp\",\"pow\",\"regressionPow\",\"quad\",\"regressionQuad\",\"poly\",\"regressionPoly\",\"Object\",\"keys\",\"method\",\"order\",\"dof\",\"fit\",\"domain\",\"extent\",\"hasOwnProperty\",\"error\",\"dataflow\",\"warn\",\"model\",\"coef\",\"rSquared\",\"dom\",\"predict\",\"sampleCurve\",\"loess\",\"regression\",\"defineProperty\"]\n}\n"]