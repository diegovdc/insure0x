["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-projection/build/vega-projection.js"],"~:js","shadow$provide.module$node_modules$vega_projection$build$vega_projection=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$d3_geo$dist$d3_geo\"),require(\"module$node_modules$d3_geo_projection$dist$d3_geo_projection\")):\"function\"===typeof define&&define.amd?define([\"exports\",\"d3-geo\",\"d3-geo-projection\"],factory):(global=\"undefined\"!==typeof globalThis?\nglobalThis:global||self,factory(global.vega={},global.d3,global.d3))})(this,function(exports,d3Geo,d3GeoProjection){function create(type,constructor){return function projection(){var p=constructor();p.type=type;p.path=d3Geo.geoPath().projection(p);p.copy=p.copy||function(){var c=projection();projectionProperties.forEach(function(prop){if(p[prop])c[prop](p[prop]())});c.path.pointRadius(p.path.pointRadius());return c};return p}}function projection$jscomp$0(type,proj){if(!type||\"string\"!==typeof type)throw Error(\"Projection type must be a name string.\");\ntype=type.toLowerCase();return 1<arguments.length?(projections[type]=create(type,proj),this):projections[type]||null}var defaultPath=d3Geo.geoPath(),projectionProperties=\"clipAngle clipExtent scale translate center rotate parallels precision reflectX reflectY coefficient distance fraction lobes parallel radius ratio spacing tilt\".split(\" \"),projections={albers:d3Geo.geoAlbers,albersusa:d3Geo.geoAlbersUsa,azimuthalequalarea:d3Geo.geoAzimuthalEqualArea,azimuthalequidistant:d3Geo.geoAzimuthalEquidistant,\nconicconformal:d3Geo.geoConicConformal,conicequalarea:d3Geo.geoConicEqualArea,conicequidistant:d3Geo.geoConicEquidistant,equalEarth:d3Geo.geoEqualEarth,equirectangular:d3Geo.geoEquirectangular,gnomonic:d3Geo.geoGnomonic,identity:d3Geo.geoIdentity,mercator:d3Geo.geoMercator,mollweide:d3GeoProjection.geoMollweide,naturalEarth1:d3Geo.geoNaturalEarth1,orthographic:d3Geo.geoOrthographic,stereographic:d3Geo.geoStereographic,transversemercator:d3Geo.geoTransverseMercator},key;for(key in projections)projection$jscomp$0(key,\nprojections[key]);exports.getProjectionPath=function(proj){return proj&&proj.path||defaultPath};exports.projection=projection$jscomp$0;exports.projectionProperties=projectionProperties;Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_projection$build$vega_projection\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-geo'), require('d3-geo-projection')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'd3-geo', 'd3-geo-projection'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.d3, global.d3));\n}(this, (function (exports, d3Geo, d3GeoProjection) { 'use strict';\n\n  const defaultPath = d3Geo.geoPath();\n\n  const projectionProperties = [\n    // standard properties in d3-geo\n    'clipAngle',\n    'clipExtent',\n    'scale',\n    'translate',\n    'center',\n    'rotate',\n    'parallels',\n    'precision',\n    'reflectX',\n    'reflectY',\n\n    // extended properties in d3-geo-projections\n    'coefficient',\n    'distance',\n    'fraction',\n    'lobes',\n    'parallel',\n    'radius',\n    'ratio',\n    'spacing',\n    'tilt'\n  ];\n\n  /**\n   * Augment projections with their type and a copy method.\n   */\n  function create(type, constructor) {\n    return function projection() {\n      const p = constructor();\n\n      p.type = type;\n\n      p.path = d3Geo.geoPath().projection(p);\n\n      p.copy = p.copy || function() {\n        const c = projection();\n        projectionProperties.forEach(prop => {\n          if (p[prop]) c[prop](p[prop]());\n        });\n        c.path.pointRadius(p.path.pointRadius());\n        return c;\n      };\n\n      return p;\n    };\n  }\n\n  function projection(type, proj) {\n    if (!type || typeof type !== 'string') {\n      throw new Error('Projection type must be a name string.');\n    }\n    type = type.toLowerCase();\n    if (arguments.length > 1) {\n      projections[type] = create(type, proj);\n      return this;\n    } else {\n      return projections[type] || null;\n    }\n  }\n\n  function getProjectionPath(proj) {\n    return (proj && proj.path) || defaultPath;\n  }\n\n  const projections = {\n    // base d3-geo projection types\n    albers:               d3Geo.geoAlbers,\n    albersusa:            d3Geo.geoAlbersUsa,\n    azimuthalequalarea:   d3Geo.geoAzimuthalEqualArea,\n    azimuthalequidistant: d3Geo.geoAzimuthalEquidistant,\n    conicconformal:       d3Geo.geoConicConformal,\n    conicequalarea:       d3Geo.geoConicEqualArea,\n    conicequidistant:     d3Geo.geoConicEquidistant,\n    equalEarth:           d3Geo.geoEqualEarth,\n    equirectangular:      d3Geo.geoEquirectangular,\n    gnomonic:             d3Geo.geoGnomonic,\n    identity:             d3Geo.geoIdentity,\n    mercator:             d3Geo.geoMercator,\n    mollweide:            d3GeoProjection.geoMollweide,\n    naturalEarth1:        d3Geo.geoNaturalEarth1,\n    orthographic:         d3Geo.geoOrthographic,\n    stereographic:        d3Geo.geoStereographic,\n    transversemercator:   d3Geo.geoTransverseMercator\n  };\n\n  for (const key in projections) {\n    projection(key, projections[key]);\n  }\n\n  exports.getProjectionPath = getProjectionPath;\n  exports.projection = projection;\n  exports.projectionProperties = projectionProperties;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$d3_geo$dist$d3_geo","~$module$node_modules$d3_geo_projection$dist$d3_geo_projection"]],"~:properties",["^5",["azimuthalequalarea","mercator","orthographic","copy","projectionProperties","transversemercator","__esModule","path","vega","value","equalEarth","conicequalarea","conicconformal","naturalEarth1","identity","getProjectionPath","conicequidistant","azimuthalequidistant","stereographic","type","projection","mollweide","albers","gnomonic","equirectangular","albersusa"]],"~:compiled-at",1600144479957,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_projection$build$vega_projection.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-projection/build/vega-projection.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_projection$build$vega_projection\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-geo'), require('d3-geo-projection')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'd3-geo', 'd3-geo-projection'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.d3, global.d3));\\n}(this, (function (exports, d3Geo, d3GeoProjection) { 'use strict';\\n\\n  const defaultPath = d3Geo.geoPath();\\n\\n  const projectionProperties = [\\n    // standard properties in d3-geo\\n    'clipAngle',\\n    'clipExtent',\\n    'scale',\\n    'translate',\\n    'center',\\n    'rotate',\\n    'parallels',\\n    'precision',\\n    'reflectX',\\n    'reflectY',\\n\\n    // extended properties in d3-geo-projections\\n    'coefficient',\\n    'distance',\\n    'fraction',\\n    'lobes',\\n    'parallel',\\n    'radius',\\n    'ratio',\\n    'spacing',\\n    'tilt'\\n  ];\\n\\n  /**\\n   * Augment projections with their type and a copy method.\\n   */\\n  function create(type, constructor) {\\n    return function projection() {\\n      const p = constructor();\\n\\n      p.type = type;\\n\\n      p.path = d3Geo.geoPath().projection(p);\\n\\n      p.copy = p.copy || function() {\\n        const c = projection();\\n        projectionProperties.forEach(prop => {\\n          if (p[prop]) c[prop](p[prop]());\\n        });\\n        c.path.pointRadius(p.path.pointRadius());\\n        return c;\\n      };\\n\\n      return p;\\n    };\\n  }\\n\\n  function projection(type, proj) {\\n    if (!type || typeof type !== 'string') {\\n      throw new Error('Projection type must be a name string.');\\n    }\\n    type = type.toLowerCase();\\n    if (arguments.length > 1) {\\n      projections[type] = create(type, proj);\\n      return this;\\n    } else {\\n      return projections[type] || null;\\n    }\\n  }\\n\\n  function getProjectionPath(proj) {\\n    return (proj && proj.path) || defaultPath;\\n  }\\n\\n  const projections = {\\n    // base d3-geo projection types\\n    albers:               d3Geo.geoAlbers,\\n    albersusa:            d3Geo.geoAlbersUsa,\\n    azimuthalequalarea:   d3Geo.geoAzimuthalEqualArea,\\n    azimuthalequidistant: d3Geo.geoAzimuthalEquidistant,\\n    conicconformal:       d3Geo.geoConicConformal,\\n    conicequalarea:       d3Geo.geoConicEqualArea,\\n    conicequidistant:     d3Geo.geoConicEquidistant,\\n    equalEarth:           d3Geo.geoEqualEarth,\\n    equirectangular:      d3Geo.geoEquirectangular,\\n    gnomonic:             d3Geo.geoGnomonic,\\n    identity:             d3Geo.geoIdentity,\\n    mercator:             d3Geo.geoMercator,\\n    mollweide:            d3GeoProjection.geoMollweide,\\n    naturalEarth1:        d3Geo.geoNaturalEarth1,\\n    orthographic:         d3Geo.geoOrthographic,\\n    stereographic:        d3Geo.geoStereographic,\\n    transversemercator:   d3Geo.geoTransverseMercator\\n  };\\n\\n  for (const key in projections) {\\n    projection(key, projections[key]);\\n  }\\n\\n  exports.getProjectionPath = getProjectionPath;\\n  exports.projection = projection;\\n  exports.projectionProperties = projectionProperties;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"d3\",\"d3Geo\",\"d3GeoProjection\",\"create\",\"type\",\"constructor\",\"projection\",\"p\",\"path\",\"geoPath\",\"copy\",\"c\",\"projectionProperties\",\"forEach\",\"prop\",\"pointRadius\",\"proj\",\"Error\",\"toLowerCase\",\"arguments\",\"length\",\"projections\",\"defaultPath\",\"albers\",\"geoAlbers\",\"albersusa\",\"geoAlbersUsa\",\"azimuthalequalarea\",\"geoAzimuthalEqualArea\",\"azimuthalequidistant\",\"geoAzimuthalEquidistant\",\"conicconformal\",\"geoConicConformal\",\"conicequalarea\",\"geoConicEqualArea\",\"conicequidistant\",\"geoConicEquidistant\",\"equalEarth\",\"geoEqualEarth\",\"equirectangular\",\"geoEquirectangular\",\"gnomonic\",\"geoGnomonic\",\"identity\",\"geoIdentity\",\"mercator\",\"geoMercator\",\"mollweide\",\"geoMollweide\",\"naturalEarth1\",\"geoNaturalEarth1\",\"orthographic\",\"geoOrthographic\",\"stereographic\",\"geoStereographic\",\"transversemercator\",\"geoTransverseMercator\",\"key\",\"getProjectionPath\",\"Object\",\"defineProperty\",\"value\"]\n}\n"]