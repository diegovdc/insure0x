["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-crossfilter/build/vega-crossfilter.js"],"~:js","shadow$provide.module$node_modules$vega_crossfilter$build$vega_crossfilter=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$d3_array$dist$d3_array\"),require(\"module$node_modules$vega_dataflow$build$vega_dataflow\"),require(\"module$node_modules$vega_util$build$vega_util\")):\"function\"===typeof define&&define.amd?define([\"exports\",\"d3-array\",\"vega-dataflow\",\n\"vega-util\"],factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory((global.vega=global.vega||{},global.vega.transforms={}),global.d3,global.vega,global.vega))})(this,function(exports,d3Array,vegaDataflow,vegaUtil){function Bitmaps(){var width=8,data=[],seen=array32(0),curr=array$jscomp$0(0,width),prev=array$jscomp$0(0,width);return{data:function(){return data},seen:function(){var JSCompiler_inline_result=seen;var length=data.length;JSCompiler_inline_result.length>=length||\n(length=new JSCompiler_inline_result.constructor(length),length.set(JSCompiler_inline_result),JSCompiler_inline_result=length);return seen=JSCompiler_inline_result},add:function(array){for(var i=0,j=data.length,n=array.length,t;i<n;++i)t=array[i],t._index=j++,data.push(t)},remove:function(num,map){var n=data.length;num=Array(n-num);var reindex=data,i,j;for(i=0;!map[i]&&i<n;++i)num[i]=data[i],reindex[i]=i;for(j=i;i<n;++i){var t=data[i];map[i]?reindex[i]=-1:(reindex[i]=j,curr[j]=curr[i],prev[j]=prev[i],\nnum[j]=t,t._index=j++);curr[i]=0}data=num;return reindex},size:function(){return data.length},curr:function(){return curr},prev:function(){return prev},reset:function(k){return prev[k]=curr[k]},all:function(){return 257>width?255:65537>width?65535:4294967295},set:function(k,one){curr[k]|=one},clear:function(k,one){curr[k]&=~one},resize:function(n,m){if(n>curr.length||m>width)width=Math.max(m,width),curr=array$jscomp$0(n,width,curr),prev=array$jscomp$0(n,width)}}}function array$jscomp$0(n,m,array){n=\n(257>m?array8:65537>m?array16:array32)(n);array&&n.set(array);return n}function Dimension(index,i$jscomp$0,query){var bit=1<<i$jscomp$0;return{one:bit,zero:~bit,range:query.slice(),bisect:index.bisect,index:index.index,size:index.size,onAdd:function(added,curr){var range=this.bisect(this.range,added.value);added=added.index;var lo=range[0];range=range[1];var n1=added.length,i;for(i=0;i<lo;++i)curr[added[i]]|=bit;for(i=range;i<n1;++i)curr[added[i]]|=bit;return this}}}function SortedIndex(){var index$jscomp$0=\narray32(0),value$jscomp$0=[],size=0;return{insert:function(key,data,base){if(!data.length)return[];var n0=size,n1=data.length,addi=array32(n1),addv=Array(n1),i;for(i=0;i<n1;++i)addv[i]=key(data[i]),addi[i]=i;addv=sort(addv,addi);if(n0){key=value$jscomp$0;data=index$jscomp$0;value$jscomp$0=Array(n0+n1);index$jscomp$0=array32(n0+n1);i=addv;var value=value$jscomp$0,index=index$jscomp$0,i0=0,i1=0,i$jscomp$0;for(i$jscomp$0=0;i0<n0&&i1<n1;++i$jscomp$0)key[i0]<i[i1]?(value[i$jscomp$0]=key[i0],index[i$jscomp$0]=\ndata[i0++]):(value[i$jscomp$0]=i[i1],index[i$jscomp$0]=addi[i1++]+base);for(;i0<n0;++i0,++i$jscomp$0)value[i$jscomp$0]=key[i0],index[i$jscomp$0]=data[i0];for(;i1<n1;++i1,++i$jscomp$0)value[i$jscomp$0]=i[i1],index[i$jscomp$0]=addi[i1]+base}else{if(0<base)for(i=0;i<n1;++i)addi[i]+=base;value$jscomp$0=addv;index$jscomp$0=addi}size=n0+n1;return{index:addi,value:addv}},remove:function(num,map){var n=size,idx,i,j;for(i=0;!map[index$jscomp$0[i]]&&i<n;++i);for(j=i;i<n;++i)map[idx=index$jscomp$0[i]]||(index$jscomp$0[j]=\nidx,value$jscomp$0[j]=value$jscomp$0[i],++j);size=n-num},bisect:function(range,array){if(array)var n=array.length;else array=value$jscomp$0,n=size;return[d3Array.bisectLeft(array,range[0],0,n),d3Array.bisectRight(array,range[1],0,n)]},reindex:function(map){for(var i=0,n=size;i<n;++i)index$jscomp$0[i]=map[index$jscomp$0[i]]},index:function(){return index$jscomp$0},size:function(){return size}}}function sort(values,index){values.sort.call(index,function(a,b){a=values[a];b=values[b];return a<b?-1:a>\nb?1:0});return d3Array.permute(values,index)}function CrossFilter(params){vegaDataflow.Transform.call(this,Bitmaps(),params);this._dims=this._indices=null}function ResolveFilter(params){vegaDataflow.Transform.call(this,null,params)}var array8=function(n){return new Uint8Array(n)},array16=function(n){return new Uint16Array(n)},array32=function(n){return new Uint32Array(n)};CrossFilter.Definition={type:\"CrossFilter\",metadata:{},params:[{name:\"fields\",type:\"field\",array:!0,required:!0},{name:\"query\",\ntype:\"array\",array:!0,required:!0,content:{type:\"number\",array:!0,length:2}}]};vegaUtil.inherits(CrossFilter,vegaDataflow.Transform,{transform:function(_,pulse){return this._dims?_.modified(\"fields\")||_.fields.some(function(f){return pulse.modified(f.fields)})?this.reinit(_,pulse):this.eval(_,pulse):this.init(_,pulse)},init:function(_,pulse){for(var fields=_.fields,query=_.query,indices=this._indices={},dims=this._dims=[],m=query.length,i=0,key;i<m;++i)key=fields[i].fname,key=indices[key]||(indices[key]=\nSortedIndex()),dims.push(Dimension(key,i,query[i]));return this.eval(_,pulse)},reinit:function(_,pulse){var output=pulse.materialize().fork(),fields=_.fields,query=_.query,indices=this._indices,dims=this._dims,bits=this.value,curr=bits.curr(),prev=bits.prev(),all=bits.all(),out=output.rem=output.add,mod=output.mod,m=query.length,adds={},index,key,remMap;prev.set(curr);pulse.rem.length&&(remMap=this.remove(_,pulse,output));pulse.add.length&&bits.add(pulse.add);if(pulse.mod.length){var modMap={};var add=\npulse.mod;var i=0;for(key=add.length;i<key;++i)modMap[add[i]._index]=1}for(i=0;i<m;++i){var f=fields[i];if(!dims[i]||_.modified(\"fields\",i)||pulse.modified(f.fields))key=f.fname,(add=adds[key])||(indices[key]=index=SortedIndex(),adds[key]=add=index.insert(f,pulse.source,0)),dims[i]=Dimension(index,i,query[i]).onAdd(add,curr)}i=0;for(key=bits.data().length;i<key;++i)remMap[i]||(prev[i]!==curr[i]?out.push(i):modMap[i]&&curr[i]!==all&&mod.push(i));bits.mask=(1<<m)-1;return output},eval:function(_,pulse){var output=\npulse.materialize().fork(),m=this._dims.length,mask=0;pulse.rem.length&&(this.remove(_,pulse,output),mask|=(1<<m)-1);_.modified(\"query\")&&!_.modified(\"fields\")&&(mask|=this.update(_,pulse,output));pulse.add.length&&(this.insert(_,pulse,output),mask|=(1<<m)-1);pulse.mod.length&&(this.modify(pulse,output),mask|=(1<<m)-1);this.value.mask=mask;return output},insert:function(_,pulse,output){pulse=pulse.add;var bits=this.value,dims=this._dims,indices=this._indices;_=_.fields;var adds={};output=output.add;\nvar n=bits.size()+pulse.length,m=dims.length,k=bits.size();bits.resize(n,m);bits.add(pulse);var curr=bits.curr(),prev=bits.prev(),all=bits.all();for(bits=0;bits<m;++bits){var key=_[bits].fname;key=adds[key]||(adds[key]=indices[key].insert(_[bits],pulse,k));dims[bits].onAdd(key,curr)}for(;k<n;++k)prev[k]=all,curr[k]!==all&&output.push(k)},modify:function(pulse,output){output=output.mod;var bits=this.value,curr=bits.curr();bits=bits.all();pulse=pulse.mod;var n;var i=0;for(n=pulse.length;i<n;++i){var k=\npulse[i]._index;curr[k]!==bits&&output.push(k)}},remove:function(_,pulse,output){_=this._indices;var bits=this.value,curr=bits.curr(),prev=bits.prev();bits=bits.all();var map={};output=output.rem;var tuples=pulse.rem,n,f;var i=0;for(n=tuples.length;i<n;++i){var k=tuples[i]._index;map[k]=1;prev[k]=f=curr[k];curr[k]=bits;f!==bits&&output.push(k)}for(k in _)_[k].remove(n,map);this.reindex(pulse,n,map);return map},reindex:function(pulse,num,map){var indices=this._indices,bits=this.value;pulse.runAfter(function(){var indexMap=\nbits.remove(num,map),key;for(key in indices)indices[key].reindex(indexMap)})},update:function(_,pulse,output){var dims=this._dims,query=_.query;pulse=pulse.stamp;var m=dims.length,mask=0,q;for(q=output.filters=0;q<m;++q)if(_.modified(\"query\",q)){var i=q;++mask}if(1===mask)mask=dims[i].one,this.incrementOne(dims[i],query[i],output.add,output.rem);else for(mask=q=0;q<m;++q)_.modified(\"query\",q)&&(mask|=dims[q].one,this.incrementAll(dims[q],query[q],pulse,output.add),output.rem=output.add);return mask},\nincrementAll:function(dim,query,stamp,out){var bits=this.value,seen=bits.seen(),curr=bits.curr();bits=bits.prev();var index=dim.index(),old=dim.bisect(dim.range),range=dim.bisect(query),lo1=range[0];range=range[1];var lo0=old[0];old=old[1];var one=dim.one,j;if(lo1<lo0){var i=lo1;for(j=Math.min(lo0,range);i<j;++i){var k=index[i];seen[k]!==stamp&&(bits[k]=curr[k],seen[k]=stamp,out.push(k));curr[k]^=one}}else if(lo1>lo0)for(i=lo0,j=Math.min(lo1,old);i<j;++i)k=index[i],seen[k]!==stamp&&(bits[k]=curr[k],\nseen[k]=stamp,out.push(k)),curr[k]^=one;if(range>old)for(i=Math.max(lo1,old),j=range;i<j;++i)k=index[i],seen[k]!==stamp&&(bits[k]=curr[k],seen[k]=stamp,out.push(k)),curr[k]^=one;else if(range<old)for(i=Math.max(lo0,range),j=old;i<j;++i)k=index[i],seen[k]!==stamp&&(bits[k]=curr[k],seen[k]=stamp,out.push(k)),curr[k]^=one;dim.range=query.slice()},incrementOne:function(dim,query,add,rem){var curr=this.value.curr(),index=dim.index(),old=dim.bisect(dim.range),range=dim.bisect(query),lo1=range[0];range=\nrange[1];var lo0=old[0];old=old[1];var one=dim.one,j;if(lo1<lo0){var i=lo1;for(j=Math.min(lo0,range);i<j;++i){var k=index[i];curr[k]^=one;add.push(k)}}else if(lo1>lo0)for(i=lo0,j=Math.min(lo1,old);i<j;++i)k=index[i],curr[k]^=one,rem.push(k);if(range>old)for(i=Math.max(lo1,old),j=range;i<j;++i)k=index[i],curr[k]^=one,add.push(k);else if(range<old)for(i=Math.max(lo0,range),j=old;i<j;++i)k=index[i],curr[k]^=one,rem.push(k);dim.range=query.slice()}});ResolveFilter.Definition={type:\"ResolveFilter\",metadata:{},\nparams:[{name:\"ignore\",type:\"number\",required:!0,description:\"A bit mask indicating which filters to ignore.\"},{name:\"filter\",type:\"object\",required:!0,description:\"Per-tuple filter bitmaps from a CrossFilter transform.\"}]};vegaUtil.inherits(ResolveFilter,vegaDataflow.Transform,{transform:function(_,pulse){var ignore=~(_.ignore||0);_=_.filter;var mask=_.mask;if(0===(mask&ignore))return pulse.StopPropagation;pulse=pulse.fork(pulse.ALL);var data=_.data(),curr=_.curr(),prev=_.prev(),pass=function(k){return curr[k]&\nignore?null:data[k]};pulse.filter(pulse.MOD,pass);mask&mask-1?(pulse.filter(pulse.ADD,function(k){var c=curr[k]&ignore;return!c&&c^prev[k]&ignore?data[k]:null}),pulse.filter(pulse.REM,function(k){var c=curr[k]&ignore;return!c||c^c^prev[k]&ignore?null:data[k]})):(pulse.filter(pulse.ADD,pass),pulse.filter(pulse.REM,function(k){return(curr[k]&ignore)===mask?data[k]:null}));return pulse.filter(pulse.SOURCE,function(t){return pass(t._index)})}});exports.crossfilter=CrossFilter;exports.resolvefilter=ResolveFilter;\nObject.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_crossfilter$build$vega_crossfilter\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('vega-dataflow'), require('vega-util')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'vega-dataflow', 'vega-util'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.d3, global.vega, global.vega));\n}(this, (function (exports, d3Array, vegaDataflow, vegaUtil) { 'use strict';\n\n  const array8 = n => new Uint8Array(n);\n\n  const array16 = n => new Uint16Array(n);\n\n  const array32 = n => new Uint32Array(n);\n\n  /**\n   * Maintains CrossFilter state.\n   */\n  function Bitmaps() {\n\n    let width = 8,\n        data = [],\n        seen = array32(0),\n        curr = array(0, width),\n        prev = array(0, width);\n\n    return {\n      data: () => data,\n\n      seen: () => (seen = lengthen(seen, data.length)),\n\n      add(array) {\n        for (let i=0, j=data.length, n=array.length, t; i<n; ++i) {\n          t = array[i];\n          t._index = j++;\n          data.push(t);\n        }\n      },\n\n      remove(num, map) { // map: index -> boolean (true => remove)\n        const n = data.length,\n              copy = Array(n - num),\n              reindex = data; // reuse old data array for index map\n        let t, i, j;\n\n        // seek forward to first removal\n        for (i=0; !map[i] && i<n; ++i) {\n          copy[i] = data[i];\n          reindex[i] = i;\n        }\n\n        // condense arrays\n        for (j=i; i<n; ++i) {\n          t = data[i];\n          if (!map[i]) {\n            reindex[i] = j;\n            curr[j] = curr[i];\n            prev[j] = prev[i];\n            copy[j] = t;\n            t._index = j++;\n          } else {\n            reindex[i] = -1;\n          }\n          curr[i] = 0; // clear unused bits\n        }\n\n        data = copy;\n        return reindex;\n      },\n\n      size: () => data.length,\n\n      curr: () => curr,\n\n      prev: () => prev,\n\n      reset: k => prev[k] = curr[k],\n\n      all: () =>\n        width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\n\n      set(k, one) { curr[k] |= one; },\n\n      clear(k, one) { curr[k] &= ~one; },\n\n      resize(n, m) {\n        const k = curr.length;\n        if (n > k || m > width) {\n          width = Math.max(m, width);\n          curr = array(n, width, curr);\n          prev = array(n, width);\n        }\n      }\n    };\n  }\n\n  function lengthen(array, length, copy) {\n    if (array.length >= length) return array;\n    copy = copy || new array.constructor(length);\n    copy.set(array);\n    return copy;\n  }\n\n  function array(n, m, array) {\n    const copy = (m < 0x101 ? array8\n        : m < 0x10001 ? array16\n        : array32)(n);\n    if (array) copy.set(array);\n    return copy;\n  }\n\n  function Dimension(index, i, query) {\n    const bit = (1 << i);\n\n    return {\n      one:     bit,\n      zero:    ~bit,\n      range:   query.slice(),\n      bisect:  index.bisect,\n      index:   index.index,\n      size:    index.size,\n\n      onAdd(added, curr) {\n        const dim = this,\n              range = dim.bisect(dim.range, added.value),\n              idx = added.index,\n              lo = range[0],\n              hi = range[1],\n              n1 = idx.length;\n        let i;\n\n        for (i=0;  i<lo; ++i) curr[idx[i]] |= bit;\n        for (i=hi; i<n1; ++i) curr[idx[i]] |= bit;\n        return dim;\n      }\n    };\n  }\n\n  /**\n   * Maintains a list of values, sorted by key.\n   */\n  function SortedIndex() {\n    let index = array32(0),\n        value = [],\n        size = 0;\n\n    function insert(key, data, base) {\n      if (!data.length) return [];\n\n      const n0 = size,\n          n1 = data.length,\n          addi = array32(n1);\n      let addv = Array(n1),\n          oldv, oldi, i;\n\n      for (i=0; i<n1; ++i) {\n        addv[i] = key(data[i]);\n        addi[i] = i;\n      }\n      addv = sort(addv, addi);\n\n      if (n0) {\n        oldv = value;\n        oldi = index;\n        value = Array(n0 + n1);\n        index = array32(n0 + n1);\n        merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n      } else {\n        if (base > 0) for (i=0; i<n1; ++i) {\n          addi[i] += base;\n        }\n        value = addv;\n        index = addi;\n      }\n      size = n0 + n1;\n\n      return {index: addi, value: addv};\n    }\n\n    function remove(num, map) {\n      // map: index -> remove\n      const n = size;\n      let idx, i, j;\n\n      // seek forward to first removal\n      for (i=0; !map[index[i]] && i<n; ++i);\n\n      // condense index and value arrays\n      for (j=i; i<n; ++i) {\n        if (!map[idx=index[i]]) {\n          index[j] = idx;\n          value[j] = value[i];\n          ++j;\n        }\n      }\n\n      size = n - num;\n    }\n\n    function reindex(map) {\n      for (let i=0, n=size; i<n; ++i) {\n        index[i] = map[index[i]];\n      }\n    }\n\n    function bisect(range, array) {\n      let n;\n      if (array) {\n        n = array.length;\n      } else {\n        array = value;\n        n = size;\n      }\n      return [\n        d3Array.bisectLeft(array, range[0], 0, n),\n        d3Array.bisectRight(array, range[1], 0, n)\n      ];\n    }\n\n    return {\n      insert:  insert,\n      remove:  remove,\n      bisect:  bisect,\n      reindex: reindex,\n      index:   () => index,\n      size:    () => size\n    };\n  }\n\n  function sort(values, index) {\n    values.sort.call(index, (a, b) => {\n      const x = values[a],\n            y = values[b];\n      return x < y ? -1 : x > y ? 1 : 0;\n    });\n    return d3Array.permute(values, index);\n  }\n\n  function merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n    let i0 = 0, i1 = 0, i;\n\n    for (i=0; i0 < n0 && i1 < n1; ++i) {\n      if (value0[i0] < value1[i1]) {\n        value[i] = value0[i0];\n        index[i] = index0[i0++];\n      } else {\n        value[i] = value1[i1];\n        index[i] = index1[i1++] + base;\n      }\n    }\n\n    for (; i0 < n0; ++i0, ++i) {\n      value[i] = value0[i0];\n      index[i] = index0[i0];\n    }\n\n    for (; i1 < n1; ++i1, ++i) {\n      value[i] = value1[i1];\n      index[i] = index1[i1] + base;\n    }\n  }\n\n  /**\n   * An indexed multi-dimensional filter.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n   * @param {Array} params.query - An array of per-dimension range queries.\n   */\n  function CrossFilter(params) {\n    vegaDataflow.Transform.call(this, Bitmaps(), params);\n    this._indices = null;\n    this._dims = null;\n  }\n\n  CrossFilter.Definition = {\n    'type': 'CrossFilter',\n    'metadata': {},\n    'params': [\n      { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\n      { 'name': 'query', 'type': 'array', 'array': true, 'required': true,\n        'content': {'type': 'number', 'array': true, 'length': 2} }\n    ]\n  };\n\n  vegaUtil.inherits(CrossFilter, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      if (!this._dims) {\n        return this.init(_, pulse);\n      } else {\n        var init = _.modified('fields')\n              || _.fields.some(f => pulse.modified(f.fields));\n\n        return init\n          ? this.reinit(_, pulse)\n          : this.eval(_, pulse);\n      }\n    },\n\n    init(_, pulse) {\n      const fields = _.fields,\n            query = _.query,\n            indices = this._indices = {},\n            dims = this._dims = [],\n            m = query.length;\n      let i = 0, key, index;\n\n      // instantiate indices and dimensions\n      for (; i<m; ++i) {\n        key = fields[i].fname;\n        index = indices[key] || (indices[key] = SortedIndex());\n        dims.push(Dimension(index, i, query[i]));\n      }\n\n      return this.eval(_, pulse);\n    },\n\n    reinit(_, pulse) {\n      const output = pulse.materialize().fork(),\n            fields = _.fields,\n            query = _.query,\n            indices = this._indices,\n            dims = this._dims,\n            bits = this.value,\n            curr = bits.curr(),\n            prev = bits.prev(),\n            all = bits.all(),\n            out = (output.rem = output.add),\n            mod = output.mod,\n            m = query.length,\n            adds = {};\n      let add, index, key, mods, remMap, modMap, i, n, f;\n\n      // set prev to current state\n      prev.set(curr);\n\n      // if pulse has remove tuples, process them first\n      if (pulse.rem.length) {\n        remMap = this.remove(_, pulse, output);\n      }\n\n      // if pulse has added tuples, add them to state\n      if (pulse.add.length) {\n        bits.add(pulse.add);\n      }\n\n      // if pulse has modified tuples, create an index map\n      if (pulse.mod.length) {\n        modMap = {};\n        for (mods=pulse.mod, i=0, n=mods.length; i<n; ++i) {\n          modMap[mods[i]._index] = 1;\n        }\n      }\n\n      // re-initialize indices as needed, update curr bitmap\n      for (i=0; i<m; ++i) {\n        f = fields[i];\n        if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n          key = f.fname;\n          if (!(add = adds[key])) {\n            indices[key] = index = SortedIndex();\n            adds[key] = add = index.insert(f, pulse.source, 0);\n          }\n          dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n        }\n      }\n\n      // visit each tuple\n      // if filter state changed, push index to add/rem\n      // else if in mod and passes a filter, push index to mod\n      for (i=0, n=bits.data().length; i<n; ++i) {\n        if (remMap[i]) { // skip if removed tuple\n          continue;\n        } else if (prev[i] !== curr[i]) { // add if state changed\n          out.push(i);\n        } else if (modMap[i] && curr[i] !== all) { // otherwise, pass mods through\n          mod.push(i);\n        }\n      }\n\n      bits.mask = (1 << m) - 1;\n      return output;\n    },\n\n    eval(_, pulse) {\n      const output = pulse.materialize().fork(),\n            m = this._dims.length;\n      let mask = 0;\n\n      if (pulse.rem.length) {\n        this.remove(_, pulse, output);\n        mask |= (1 << m) - 1;\n      }\n\n      if (_.modified('query') && !_.modified('fields')) {\n        mask |= this.update(_, pulse, output);\n      }\n\n      if (pulse.add.length) {\n        this.insert(_, pulse, output);\n        mask |= (1 << m) - 1;\n      }\n\n      if (pulse.mod.length) {\n        this.modify(pulse, output);\n        mask |= (1 << m) - 1;\n      }\n\n      this.value.mask = mask;\n      return output;\n    },\n\n    insert(_, pulse, output) {\n      const tuples = pulse.add,\n            bits = this.value,\n            dims = this._dims,\n            indices = this._indices,\n            fields = _.fields,\n            adds = {},\n            out = output.add,\n            n = bits.size() + tuples.length,\n            m = dims.length;\n      let k = bits.size(), j, key, add;\n\n      // resize bitmaps and add tuples as needed\n      bits.resize(n, m);\n      bits.add(tuples);\n\n      const curr = bits.curr(),\n            prev = bits.prev(),\n            all  = bits.all();\n\n      // add to dimensional indices\n      for (j=0; j<m; ++j) {\n        key = fields[j].fname;\n        add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n        dims[j].onAdd(add, curr);\n      }\n\n      // set previous filters, output if passes at least one filter\n      for (; k < n; ++k) {\n        prev[k] = all;\n        if (curr[k] !== all) out.push(k);\n      }\n    },\n\n    modify(pulse, output) {\n      const out = output.mod,\n            bits = this.value,\n            curr = bits.curr(),\n            all  = bits.all(),\n            tuples = pulse.mod;\n      let i, n, k;\n\n      for (i=0, n=tuples.length; i<n; ++i) {\n        k = tuples[i]._index;\n        if (curr[k] !== all) out.push(k);\n      }\n    },\n\n    remove(_, pulse, output) {\n      const indices = this._indices,\n            bits = this.value,\n            curr = bits.curr(),\n            prev = bits.prev(),\n            all  = bits.all(),\n            map = {},\n            out = output.rem,\n            tuples = pulse.rem;\n      let i, n, k, f;\n\n      // process tuples, output if passes at least one filter\n      for (i=0, n=tuples.length; i<n; ++i) {\n        k = tuples[i]._index;\n        map[k] = 1; // build index map\n        prev[k] = (f = curr[k]);\n        curr[k] = all;\n        if (f !== all) out.push(k);\n      }\n\n      // remove from dimensional indices\n      for (k in indices) {\n        indices[k].remove(n, map);\n      }\n\n      this.reindex(pulse, n, map);\n      return map;\n    },\n\n    // reindex filters and indices after propagation completes\n    reindex(pulse, num, map) {\n      const indices = this._indices,\n            bits = this.value;\n\n      pulse.runAfter(() => {\n        const indexMap = bits.remove(num, map);\n        for (const key in indices) indices[key].reindex(indexMap);\n      });\n    },\n\n    update(_, pulse, output) {\n      const dims = this._dims,\n            query = _.query,\n            stamp = pulse.stamp,\n            m = dims.length;\n      let mask = 0, i, q;\n\n      // survey how many queries have changed\n      output.filters = 0;\n      for (q=0; q<m; ++q) {\n        if (_.modified('query', q)) { i = q; ++mask; }\n      }\n\n      if (mask === 1) {\n        // only one query changed, use more efficient update\n        mask = dims[i].one;\n        this.incrementOne(dims[i], query[i], output.add, output.rem);\n      } else {\n        // multiple queries changed, perform full record keeping\n        for (q=0, mask=0; q<m; ++q) {\n          if (!_.modified('query', q)) continue;\n          mask |= dims[q].one;\n          this.incrementAll(dims[q], query[q], stamp, output.add);\n          output.rem = output.add; // duplicate add/rem for downstream resolve\n        }\n      }\n\n      return mask;\n    },\n\n    incrementAll(dim, query, stamp, out) {\n      const bits = this.value,\n            seen = bits.seen(),\n            curr = bits.curr(),\n            prev = bits.prev(),\n            index = dim.index(),\n            old = dim.bisect(dim.range),\n            range = dim.bisect(query),\n            lo1 = range[0],\n            hi1 = range[1],\n            lo0 = old[0],\n            hi0 = old[1],\n            one = dim.one;\n      let i, j, k;\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          k = index[i];\n          if (seen[k] !== stamp) {\n            prev[k] = curr[k];\n            seen[k] = stamp;\n            out.push(k);\n          }\n          curr[k] ^= one;\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          k = index[i];\n          if (seen[k] !== stamp) {\n            prev[k] = curr[k];\n            seen[k] = stamp;\n            out.push(k);\n          }\n          curr[k] ^= one;\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          k = index[i];\n          if (seen[k] !== stamp) {\n            prev[k] = curr[k];\n            seen[k] = stamp;\n            out.push(k);\n          }\n          curr[k] ^= one;\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          k = index[i];\n          if (seen[k] !== stamp) {\n            prev[k] = curr[k];\n            seen[k] = stamp;\n            out.push(k);\n          }\n          curr[k] ^= one;\n        }\n      }\n\n      dim.range = query.slice();\n    },\n\n    incrementOne(dim, query, add, rem) {\n      const bits = this.value,\n            curr = bits.curr(),\n            index = dim.index(),\n            old = dim.bisect(dim.range),\n            range = dim.bisect(query),\n            lo1 = range[0],\n            hi1 = range[1],\n            lo0 = old[0],\n            hi0 = old[1],\n            one = dim.one;\n      let i, j, k;\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          k = index[i];\n          curr[k] ^= one;\n          add.push(k);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          k = index[i];\n          curr[k] ^= one;\n          rem.push(k);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          k = index[i];\n          curr[k] ^= one;\n          add.push(k);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          k = index[i];\n          curr[k] ^= one;\n          rem.push(k);\n        }\n      }\n\n      dim.range = query.slice();\n    }\n  });\n\n  /**\n   * Selectively filters tuples by resolving against a filter bitmap.\n   * Useful for processing the output of a cross-filter transform.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n   * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n   *   parameter value is a reference to a {@link CrossFilter} transform.\n   */\n  function ResolveFilter(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  ResolveFilter.Definition = {\n    'type': 'ResolveFilter',\n    'metadata': {},\n    'params': [\n      { 'name': 'ignore', 'type': 'number', 'required': true,\n        'description': 'A bit mask indicating which filters to ignore.' },\n      { 'name': 'filter', 'type': 'object', 'required': true,\n        'description': 'Per-tuple filter bitmaps from a CrossFilter transform.' }\n    ]\n  };\n\n  vegaUtil.inherits(ResolveFilter, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const ignore = ~(_.ignore || 0), // bit mask where zeros -> dims to ignore\n            bitmap = _.filter,\n            mask = bitmap.mask;\n\n      // exit early if no relevant filter changes\n      if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n      const output = pulse.fork(pulse.ALL),\n            data = bitmap.data(),\n            curr = bitmap.curr(),\n            prev = bitmap.prev(),\n            pass = k => !(curr[k] & ignore) ? data[k] : null;\n\n      // propagate all mod tuples that pass the filter\n      output.filter(output.MOD, pass);\n\n      // determine add & rem tuples via filter functions\n      // for efficiency, we do *not* populate new arrays,\n      // instead we add filter functions applied downstream\n\n      if (!(mask & (mask-1))) { // only one filter changed\n        output.filter(output.ADD, pass);\n        output.filter(output.REM, k =>\n          (curr[k] & ignore) === mask ? data[k] : null);\n\n      } else { // multiple filters changed\n        output.filter(output.ADD, k => {\n          const c = curr[k] & ignore,\n                f = !c && (c ^ (prev[k] & ignore));\n          return f ? data[k] : null;\n        });\n        output.filter(output.REM, k => {\n          const c = curr[k] & ignore,\n                f = c && !(c ^ (c ^ (prev[k] & ignore)));\n          return f ? data[k] : null;\n        });\n      }\n\n      // add filter to source data in case of reflow...\n      return output.filter(output.SOURCE, t => pass(t._index));\n    }\n  });\n\n  exports.crossfilter = CrossFilter;\n  exports.resolvefilter = ResolveFilter;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vega_dataflow$build$vega_dataflow","~$shadow.js","~$module$node_modules$vega_util$build$vega_util","~$module$node_modules$d3_array$dist$d3_array"]],"~:properties",["^5",["bisect","range","reinit","seen","index","_indices","crossfilter","__esModule","transform","reset","vega","zero","update","filters","rem","value","modify","eval","prev","remove","incrementOne","_dims","one","Definition","init","insert","transforms","resolvefilter","add","set","all","onAdd","incrementAll","curr","resize","size","clear","_index","data","reindex","mask"]],"~:compiled-at",1600144480009,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_crossfilter$build$vega_crossfilter.js\",\n\"lineCount\":22,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-crossfilter/build/vega-crossfilter.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_crossfilter$build$vega_crossfilter\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('vega-dataflow'), require('vega-util')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'vega-dataflow', 'vega-util'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.d3, global.vega, global.vega));\\n}(this, (function (exports, d3Array, vegaDataflow, vegaUtil) { 'use strict';\\n\\n  const array8 = n => new Uint8Array(n);\\n\\n  const array16 = n => new Uint16Array(n);\\n\\n  const array32 = n => new Uint32Array(n);\\n\\n  /**\\n   * Maintains CrossFilter state.\\n   */\\n  function Bitmaps() {\\n\\n    let width = 8,\\n        data = [],\\n        seen = array32(0),\\n        curr = array(0, width),\\n        prev = array(0, width);\\n\\n    return {\\n      data: () => data,\\n\\n      seen: () => (seen = lengthen(seen, data.length)),\\n\\n      add(array) {\\n        for (let i=0, j=data.length, n=array.length, t; i<n; ++i) {\\n          t = array[i];\\n          t._index = j++;\\n          data.push(t);\\n        }\\n      },\\n\\n      remove(num, map) { // map: index -> boolean (true => remove)\\n        const n = data.length,\\n              copy = Array(n - num),\\n              reindex = data; // reuse old data array for index map\\n        let t, i, j;\\n\\n        // seek forward to first removal\\n        for (i=0; !map[i] && i<n; ++i) {\\n          copy[i] = data[i];\\n          reindex[i] = i;\\n        }\\n\\n        // condense arrays\\n        for (j=i; i<n; ++i) {\\n          t = data[i];\\n          if (!map[i]) {\\n            reindex[i] = j;\\n            curr[j] = curr[i];\\n            prev[j] = prev[i];\\n            copy[j] = t;\\n            t._index = j++;\\n          } else {\\n            reindex[i] = -1;\\n          }\\n          curr[i] = 0; // clear unused bits\\n        }\\n\\n        data = copy;\\n        return reindex;\\n      },\\n\\n      size: () => data.length,\\n\\n      curr: () => curr,\\n\\n      prev: () => prev,\\n\\n      reset: k => prev[k] = curr[k],\\n\\n      all: () =>\\n        width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\\n\\n      set(k, one) { curr[k] |= one; },\\n\\n      clear(k, one) { curr[k] &= ~one; },\\n\\n      resize(n, m) {\\n        const k = curr.length;\\n        if (n > k || m > width) {\\n          width = Math.max(m, width);\\n          curr = array(n, width, curr);\\n          prev = array(n, width);\\n        }\\n      }\\n    };\\n  }\\n\\n  function lengthen(array, length, copy) {\\n    if (array.length >= length) return array;\\n    copy = copy || new array.constructor(length);\\n    copy.set(array);\\n    return copy;\\n  }\\n\\n  function array(n, m, array) {\\n    const copy = (m < 0x101 ? array8\\n        : m < 0x10001 ? array16\\n        : array32)(n);\\n    if (array) copy.set(array);\\n    return copy;\\n  }\\n\\n  function Dimension(index, i, query) {\\n    const bit = (1 << i);\\n\\n    return {\\n      one:     bit,\\n      zero:    ~bit,\\n      range:   query.slice(),\\n      bisect:  index.bisect,\\n      index:   index.index,\\n      size:    index.size,\\n\\n      onAdd(added, curr) {\\n        const dim = this,\\n              range = dim.bisect(dim.range, added.value),\\n              idx = added.index,\\n              lo = range[0],\\n              hi = range[1],\\n              n1 = idx.length;\\n        let i;\\n\\n        for (i=0;  i<lo; ++i) curr[idx[i]] |= bit;\\n        for (i=hi; i<n1; ++i) curr[idx[i]] |= bit;\\n        return dim;\\n      }\\n    };\\n  }\\n\\n  /**\\n   * Maintains a list of values, sorted by key.\\n   */\\n  function SortedIndex() {\\n    let index = array32(0),\\n        value = [],\\n        size = 0;\\n\\n    function insert(key, data, base) {\\n      if (!data.length) return [];\\n\\n      const n0 = size,\\n          n1 = data.length,\\n          addi = array32(n1);\\n      let addv = Array(n1),\\n          oldv, oldi, i;\\n\\n      for (i=0; i<n1; ++i) {\\n        addv[i] = key(data[i]);\\n        addi[i] = i;\\n      }\\n      addv = sort(addv, addi);\\n\\n      if (n0) {\\n        oldv = value;\\n        oldi = index;\\n        value = Array(n0 + n1);\\n        index = array32(n0 + n1);\\n        merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\\n      } else {\\n        if (base > 0) for (i=0; i<n1; ++i) {\\n          addi[i] += base;\\n        }\\n        value = addv;\\n        index = addi;\\n      }\\n      size = n0 + n1;\\n\\n      return {index: addi, value: addv};\\n    }\\n\\n    function remove(num, map) {\\n      // map: index -> remove\\n      const n = size;\\n      let idx, i, j;\\n\\n      // seek forward to first removal\\n      for (i=0; !map[index[i]] && i<n; ++i);\\n\\n      // condense index and value arrays\\n      for (j=i; i<n; ++i) {\\n        if (!map[idx=index[i]]) {\\n          index[j] = idx;\\n          value[j] = value[i];\\n          ++j;\\n        }\\n      }\\n\\n      size = n - num;\\n    }\\n\\n    function reindex(map) {\\n      for (let i=0, n=size; i<n; ++i) {\\n        index[i] = map[index[i]];\\n      }\\n    }\\n\\n    function bisect(range, array) {\\n      let n;\\n      if (array) {\\n        n = array.length;\\n      } else {\\n        array = value;\\n        n = size;\\n      }\\n      return [\\n        d3Array.bisectLeft(array, range[0], 0, n),\\n        d3Array.bisectRight(array, range[1], 0, n)\\n      ];\\n    }\\n\\n    return {\\n      insert:  insert,\\n      remove:  remove,\\n      bisect:  bisect,\\n      reindex: reindex,\\n      index:   () => index,\\n      size:    () => size\\n    };\\n  }\\n\\n  function sort(values, index) {\\n    values.sort.call(index, (a, b) => {\\n      const x = values[a],\\n            y = values[b];\\n      return x < y ? -1 : x > y ? 1 : 0;\\n    });\\n    return d3Array.permute(values, index);\\n  }\\n\\n  function merge(base, value0, index0, n0, value1, index1, n1, value, index) {\\n    let i0 = 0, i1 = 0, i;\\n\\n    for (i=0; i0 < n0 && i1 < n1; ++i) {\\n      if (value0[i0] < value1[i1]) {\\n        value[i] = value0[i0];\\n        index[i] = index0[i0++];\\n      } else {\\n        value[i] = value1[i1];\\n        index[i] = index1[i1++] + base;\\n      }\\n    }\\n\\n    for (; i0 < n0; ++i0, ++i) {\\n      value[i] = value0[i0];\\n      index[i] = index0[i0];\\n    }\\n\\n    for (; i1 < n1; ++i1, ++i) {\\n      value[i] = value1[i1];\\n      index[i] = index1[i1] + base;\\n    }\\n  }\\n\\n  /**\\n   * An indexed multi-dimensional filter.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\\n   * @param {Array} params.query - An array of per-dimension range queries.\\n   */\\n  function CrossFilter(params) {\\n    vegaDataflow.Transform.call(this, Bitmaps(), params);\\n    this._indices = null;\\n    this._dims = null;\\n  }\\n\\n  CrossFilter.Definition = {\\n    'type': 'CrossFilter',\\n    'metadata': {},\\n    'params': [\\n      { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\\n      { 'name': 'query', 'type': 'array', 'array': true, 'required': true,\\n        'content': {'type': 'number', 'array': true, 'length': 2} }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(CrossFilter, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      if (!this._dims) {\\n        return this.init(_, pulse);\\n      } else {\\n        var init = _.modified('fields')\\n              || _.fields.some(f => pulse.modified(f.fields));\\n\\n        return init\\n          ? this.reinit(_, pulse)\\n          : this.eval(_, pulse);\\n      }\\n    },\\n\\n    init(_, pulse) {\\n      const fields = _.fields,\\n            query = _.query,\\n            indices = this._indices = {},\\n            dims = this._dims = [],\\n            m = query.length;\\n      let i = 0, key, index;\\n\\n      // instantiate indices and dimensions\\n      for (; i<m; ++i) {\\n        key = fields[i].fname;\\n        index = indices[key] || (indices[key] = SortedIndex());\\n        dims.push(Dimension(index, i, query[i]));\\n      }\\n\\n      return this.eval(_, pulse);\\n    },\\n\\n    reinit(_, pulse) {\\n      const output = pulse.materialize().fork(),\\n            fields = _.fields,\\n            query = _.query,\\n            indices = this._indices,\\n            dims = this._dims,\\n            bits = this.value,\\n            curr = bits.curr(),\\n            prev = bits.prev(),\\n            all = bits.all(),\\n            out = (output.rem = output.add),\\n            mod = output.mod,\\n            m = query.length,\\n            adds = {};\\n      let add, index, key, mods, remMap, modMap, i, n, f;\\n\\n      // set prev to current state\\n      prev.set(curr);\\n\\n      // if pulse has remove tuples, process them first\\n      if (pulse.rem.length) {\\n        remMap = this.remove(_, pulse, output);\\n      }\\n\\n      // if pulse has added tuples, add them to state\\n      if (pulse.add.length) {\\n        bits.add(pulse.add);\\n      }\\n\\n      // if pulse has modified tuples, create an index map\\n      if (pulse.mod.length) {\\n        modMap = {};\\n        for (mods=pulse.mod, i=0, n=mods.length; i<n; ++i) {\\n          modMap[mods[i]._index] = 1;\\n        }\\n      }\\n\\n      // re-initialize indices as needed, update curr bitmap\\n      for (i=0; i<m; ++i) {\\n        f = fields[i];\\n        if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\\n          key = f.fname;\\n          if (!(add = adds[key])) {\\n            indices[key] = index = SortedIndex();\\n            adds[key] = add = index.insert(f, pulse.source, 0);\\n          }\\n          dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\\n        }\\n      }\\n\\n      // visit each tuple\\n      // if filter state changed, push index to add/rem\\n      // else if in mod and passes a filter, push index to mod\\n      for (i=0, n=bits.data().length; i<n; ++i) {\\n        if (remMap[i]) { // skip if removed tuple\\n          continue;\\n        } else if (prev[i] !== curr[i]) { // add if state changed\\n          out.push(i);\\n        } else if (modMap[i] && curr[i] !== all) { // otherwise, pass mods through\\n          mod.push(i);\\n        }\\n      }\\n\\n      bits.mask = (1 << m) - 1;\\n      return output;\\n    },\\n\\n    eval(_, pulse) {\\n      const output = pulse.materialize().fork(),\\n            m = this._dims.length;\\n      let mask = 0;\\n\\n      if (pulse.rem.length) {\\n        this.remove(_, pulse, output);\\n        mask |= (1 << m) - 1;\\n      }\\n\\n      if (_.modified('query') && !_.modified('fields')) {\\n        mask |= this.update(_, pulse, output);\\n      }\\n\\n      if (pulse.add.length) {\\n        this.insert(_, pulse, output);\\n        mask |= (1 << m) - 1;\\n      }\\n\\n      if (pulse.mod.length) {\\n        this.modify(pulse, output);\\n        mask |= (1 << m) - 1;\\n      }\\n\\n      this.value.mask = mask;\\n      return output;\\n    },\\n\\n    insert(_, pulse, output) {\\n      const tuples = pulse.add,\\n            bits = this.value,\\n            dims = this._dims,\\n            indices = this._indices,\\n            fields = _.fields,\\n            adds = {},\\n            out = output.add,\\n            n = bits.size() + tuples.length,\\n            m = dims.length;\\n      let k = bits.size(), j, key, add;\\n\\n      // resize bitmaps and add tuples as needed\\n      bits.resize(n, m);\\n      bits.add(tuples);\\n\\n      const curr = bits.curr(),\\n            prev = bits.prev(),\\n            all  = bits.all();\\n\\n      // add to dimensional indices\\n      for (j=0; j<m; ++j) {\\n        key = fields[j].fname;\\n        add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\\n        dims[j].onAdd(add, curr);\\n      }\\n\\n      // set previous filters, output if passes at least one filter\\n      for (; k < n; ++k) {\\n        prev[k] = all;\\n        if (curr[k] !== all) out.push(k);\\n      }\\n    },\\n\\n    modify(pulse, output) {\\n      const out = output.mod,\\n            bits = this.value,\\n            curr = bits.curr(),\\n            all  = bits.all(),\\n            tuples = pulse.mod;\\n      let i, n, k;\\n\\n      for (i=0, n=tuples.length; i<n; ++i) {\\n        k = tuples[i]._index;\\n        if (curr[k] !== all) out.push(k);\\n      }\\n    },\\n\\n    remove(_, pulse, output) {\\n      const indices = this._indices,\\n            bits = this.value,\\n            curr = bits.curr(),\\n            prev = bits.prev(),\\n            all  = bits.all(),\\n            map = {},\\n            out = output.rem,\\n            tuples = pulse.rem;\\n      let i, n, k, f;\\n\\n      // process tuples, output if passes at least one filter\\n      for (i=0, n=tuples.length; i<n; ++i) {\\n        k = tuples[i]._index;\\n        map[k] = 1; // build index map\\n        prev[k] = (f = curr[k]);\\n        curr[k] = all;\\n        if (f !== all) out.push(k);\\n      }\\n\\n      // remove from dimensional indices\\n      for (k in indices) {\\n        indices[k].remove(n, map);\\n      }\\n\\n      this.reindex(pulse, n, map);\\n      return map;\\n    },\\n\\n    // reindex filters and indices after propagation completes\\n    reindex(pulse, num, map) {\\n      const indices = this._indices,\\n            bits = this.value;\\n\\n      pulse.runAfter(() => {\\n        const indexMap = bits.remove(num, map);\\n        for (const key in indices) indices[key].reindex(indexMap);\\n      });\\n    },\\n\\n    update(_, pulse, output) {\\n      const dims = this._dims,\\n            query = _.query,\\n            stamp = pulse.stamp,\\n            m = dims.length;\\n      let mask = 0, i, q;\\n\\n      // survey how many queries have changed\\n      output.filters = 0;\\n      for (q=0; q<m; ++q) {\\n        if (_.modified('query', q)) { i = q; ++mask; }\\n      }\\n\\n      if (mask === 1) {\\n        // only one query changed, use more efficient update\\n        mask = dims[i].one;\\n        this.incrementOne(dims[i], query[i], output.add, output.rem);\\n      } else {\\n        // multiple queries changed, perform full record keeping\\n        for (q=0, mask=0; q<m; ++q) {\\n          if (!_.modified('query', q)) continue;\\n          mask |= dims[q].one;\\n          this.incrementAll(dims[q], query[q], stamp, output.add);\\n          output.rem = output.add; // duplicate add/rem for downstream resolve\\n        }\\n      }\\n\\n      return mask;\\n    },\\n\\n    incrementAll(dim, query, stamp, out) {\\n      const bits = this.value,\\n            seen = bits.seen(),\\n            curr = bits.curr(),\\n            prev = bits.prev(),\\n            index = dim.index(),\\n            old = dim.bisect(dim.range),\\n            range = dim.bisect(query),\\n            lo1 = range[0],\\n            hi1 = range[1],\\n            lo0 = old[0],\\n            hi0 = old[1],\\n            one = dim.one;\\n      let i, j, k;\\n\\n      // Fast incremental update based on previous lo index.\\n      if (lo1 < lo0) {\\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\\n          k = index[i];\\n          if (seen[k] !== stamp) {\\n            prev[k] = curr[k];\\n            seen[k] = stamp;\\n            out.push(k);\\n          }\\n          curr[k] ^= one;\\n        }\\n      } else if (lo1 > lo0) {\\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\\n          k = index[i];\\n          if (seen[k] !== stamp) {\\n            prev[k] = curr[k];\\n            seen[k] = stamp;\\n            out.push(k);\\n          }\\n          curr[k] ^= one;\\n        }\\n      }\\n\\n      // Fast incremental update based on previous hi index.\\n      if (hi1 > hi0) {\\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\\n          k = index[i];\\n          if (seen[k] !== stamp) {\\n            prev[k] = curr[k];\\n            seen[k] = stamp;\\n            out.push(k);\\n          }\\n          curr[k] ^= one;\\n        }\\n      } else if (hi1 < hi0) {\\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\\n          k = index[i];\\n          if (seen[k] !== stamp) {\\n            prev[k] = curr[k];\\n            seen[k] = stamp;\\n            out.push(k);\\n          }\\n          curr[k] ^= one;\\n        }\\n      }\\n\\n      dim.range = query.slice();\\n    },\\n\\n    incrementOne(dim, query, add, rem) {\\n      const bits = this.value,\\n            curr = bits.curr(),\\n            index = dim.index(),\\n            old = dim.bisect(dim.range),\\n            range = dim.bisect(query),\\n            lo1 = range[0],\\n            hi1 = range[1],\\n            lo0 = old[0],\\n            hi0 = old[1],\\n            one = dim.one;\\n      let i, j, k;\\n\\n      // Fast incremental update based on previous lo index.\\n      if (lo1 < lo0) {\\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\\n          k = index[i];\\n          curr[k] ^= one;\\n          add.push(k);\\n        }\\n      } else if (lo1 > lo0) {\\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\\n          k = index[i];\\n          curr[k] ^= one;\\n          rem.push(k);\\n        }\\n      }\\n\\n      // Fast incremental update based on previous hi index.\\n      if (hi1 > hi0) {\\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\\n          k = index[i];\\n          curr[k] ^= one;\\n          add.push(k);\\n        }\\n      } else if (hi1 < hi0) {\\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\\n          k = index[i];\\n          curr[k] ^= one;\\n          rem.push(k);\\n        }\\n      }\\n\\n      dim.range = query.slice();\\n    }\\n  });\\n\\n  /**\\n   * Selectively filters tuples by resolving against a filter bitmap.\\n   * Useful for processing the output of a cross-filter transform.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {object} params.ignore - A bit mask indicating which filters to ignore.\\n   * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\\n   *   parameter value is a reference to a {@link CrossFilter} transform.\\n   */\\n  function ResolveFilter(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  ResolveFilter.Definition = {\\n    'type': 'ResolveFilter',\\n    'metadata': {},\\n    'params': [\\n      { 'name': 'ignore', 'type': 'number', 'required': true,\\n        'description': 'A bit mask indicating which filters to ignore.' },\\n      { 'name': 'filter', 'type': 'object', 'required': true,\\n        'description': 'Per-tuple filter bitmaps from a CrossFilter transform.' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(ResolveFilter, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const ignore = ~(_.ignore || 0), // bit mask where zeros -> dims to ignore\\n            bitmap = _.filter,\\n            mask = bitmap.mask;\\n\\n      // exit early if no relevant filter changes\\n      if ((mask & ignore) === 0) return pulse.StopPropagation;\\n\\n      const output = pulse.fork(pulse.ALL),\\n            data = bitmap.data(),\\n            curr = bitmap.curr(),\\n            prev = bitmap.prev(),\\n            pass = k => !(curr[k] & ignore) ? data[k] : null;\\n\\n      // propagate all mod tuples that pass the filter\\n      output.filter(output.MOD, pass);\\n\\n      // determine add & rem tuples via filter functions\\n      // for efficiency, we do *not* populate new arrays,\\n      // instead we add filter functions applied downstream\\n\\n      if (!(mask & (mask-1))) { // only one filter changed\\n        output.filter(output.ADD, pass);\\n        output.filter(output.REM, k =>\\n          (curr[k] & ignore) === mask ? data[k] : null);\\n\\n      } else { // multiple filters changed\\n        output.filter(output.ADD, k => {\\n          const c = curr[k] & ignore,\\n                f = !c && (c ^ (prev[k] & ignore));\\n          return f ? data[k] : null;\\n        });\\n        output.filter(output.REM, k => {\\n          const c = curr[k] & ignore,\\n                f = c && !(c ^ (c ^ (prev[k] & ignore)));\\n          return f ? data[k] : null;\\n        });\\n      }\\n\\n      // add filter to source data in case of reflow...\\n      return output.filter(output.SOURCE, t => pass(t._index));\\n    }\\n  });\\n\\n  exports.crossfilter = CrossFilter;\\n  exports.resolvefilter = ResolveFilter;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"transforms\",\"d3\",\"d3Array\",\"vegaDataflow\",\"vegaUtil\",\"Bitmaps\",\"width\",\"data\",\"seen\",\"array32\",\"curr\",\"array\",\"prev\",\"length\",\"copy\",\"constructor\",\"set\",\"add\",\"i\",\"j\",\"n\",\"t\",\"_index\",\"push\",\"remove\",\"num\",\"map\",\"Array\",\"reindex\",\"size\",\"reset\",\"k\",\"all\",\"one\",\"clear\",\"resize\",\"m\",\"Math\",\"max\",\"array8\",\"array16\",\"Dimension\",\"index\",\"query\",\"bit\",\"zero\",\"range\",\"slice\",\"bisect\",\"onAdd\",\"added\",\"dim\",\"value\",\"idx\",\"lo\",\"hi\",\"n1\",\"SortedIndex\",\"insert\",\"key\",\"base\",\"n0\",\"addi\",\"addv\",\"sort\",\"oldv\",\"oldi\",\"i0\",\"i1\",\"value1\",\"bisectLeft\",\"bisectRight\",\"values\",\"call\",\"a\",\"b\",\"x\",\"y\",\"permute\",\"CrossFilter\",\"params\",\"Transform\",\"_dims\",\"_indices\",\"ResolveFilter\",\"Uint8Array\",\"Uint16Array\",\"Uint32Array\",\"Definition\",\"inherits\",\"transform\",\"_\",\"pulse\",\"modified\",\"fields\",\"some\",\"f\",\"reinit\",\"eval\",\"init\",\"indices\",\"dims\",\"fname\",\"output\",\"materialize\",\"fork\",\"bits\",\"out\",\"rem\",\"mod\",\"adds\",\"remMap\",\"modMap\",\"mods\",\"source\",\"mask\",\"update\",\"modify\",\"tuples\",\"runAfter\",\"indexMap\",\"stamp\",\"q\",\"filters\",\"incrementOne\",\"incrementAll\",\"old\",\"lo1\",\"hi1\",\"lo0\",\"hi0\",\"min\",\"ignore\",\"bitmap\",\"filter\",\"StopPropagation\",\"ALL\",\"pass\",\"MOD\",\"ADD\",\"c\",\"REM\",\"SOURCE\",\"crossfilter\",\"resolvefilter\",\"Object\",\"defineProperty\"]\n}\n"]