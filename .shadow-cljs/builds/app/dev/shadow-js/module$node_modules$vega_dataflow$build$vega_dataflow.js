["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-dataflow/build/vega-dataflow.js"],"~:js","shadow$provide.module$node_modules$vega_dataflow$build$vega_dataflow=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_util$build$vega_util\"),require(\"module$node_modules$vega_loader$build$vega_loader\"),require(\"module$node_modules$vega_format$build$vega_format\")):\"function\"===typeof define&&define.amd?define([\"exports\",\"vega-util\",\"vega-loader\",\n\"vega-format\"],factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory(global.vega={},global.vega,global.vega,global.vega))})(this,function(exports,vegaUtil,vegaLoader,vegaFormat){function UniqueList(idFunc){var $=idFunc||vegaUtil.identity,list=[],ids={};list.add=function(_){var id=$(_);ids[id]||(ids[id]=1,list.push(_));return list};list.remove=function(_){var id=$(_);ids[id]&&(ids[id]=0,_=list.indexOf(_),0<=_&&list.splice(_,1));return list};return list}function asyncCallback(df,\ncallback){var err;return $jscomp.asyncExecutePromiseGeneratorProgram(function($jscomp$generator$context){if(1==$jscomp$generator$context.nextAddress)return $jscomp$generator$context.setCatchFinallyBlocks(2),$jscomp$generator$context.yield(callback(df),4);if(2!=$jscomp$generator$context.nextAddress)return $jscomp$generator$context.leaveTryBlock(0);err=$jscomp$generator$context.enterCatchBlock();df.error(err);$jscomp$generator$context.jumpToEnd()})}function ingest(datum){datum=datum===Object(datum)?\ndatum:{data:datum};if(!datum[TUPLE_ID_KEY]){var id=TUPLE_ID++;datum[TUPLE_ID_KEY]=id}return datum}function rederive(t,d){for(var k in t)d[k]=t[k];return d}function isChangeSet(v){return v&&v.constructor===changeset}function changeset(){var add=[],rem=[],mod=[],remp=[],modp=[],clean=null,reflow=!1;return{constructor:changeset,insert:function(t){t=vegaUtil.array(t);for(var n=t.length,i=0;i<n;++i)add.push(t[i]);return this},remove:function(t){var a=vegaUtil.isFunction(t)?remp:rem;t=vegaUtil.array(t);\nfor(var n=t.length,i=0;i<n;++i)a.push(t[i]);return this},modify:function(t,field,value){field={field:field,value:vegaUtil.constant(value)};vegaUtil.isFunction(t)?(field.filter=t,modp.push(field)):(field.tuple=t,mod.push(field));return this},encode:function(t,set){vegaUtil.isFunction(t)?modp.push({filter:t,field:set}):mod.push({tuple:t,field:set});return this},clean:function(value){clean=value;return this},reflow:function(){reflow=!0;return this},pulse:function(pulse,tuples){function modify(t,f,v){v?\nt[f]=v(t):pulse.encode=f;reflow||(out[t[TUPLE_ID_KEY]]=t)}var cur={},out={},n;var i=0;for(n=tuples.length;i<n;++i)cur[tuples[i][TUPLE_ID_KEY]]=1;i=0;for(n=rem.length;i<n;++i){var t$jscomp$0=rem[i];cur[t$jscomp$0[TUPLE_ID_KEY]]=-1}i=0;for(n=remp.length;i<n;++i){var f$jscomp$0=remp[i];tuples.forEach(function(t){f$jscomp$0(t)&&(cur[t[TUPLE_ID_KEY]]=-1)})}i=0;for(n=add.length;i<n;++i){t$jscomp$0=add[i];var id=t$jscomp$0[TUPLE_ID_KEY];cur[id]?cur[id]=1:pulse.add.push(ingest(add[i]))}i=0;for(n=tuples.length;i<\nn;++i)t$jscomp$0=tuples[i],0>cur[t$jscomp$0[TUPLE_ID_KEY]]&&pulse.rem.push(t$jscomp$0);i=0;for(n=mod.length;i<n;++i){var m=mod[i];t$jscomp$0=m.tuple;f$jscomp$0=m.field;id=cur[t$jscomp$0[TUPLE_ID_KEY]];0<id&&(modify(t$jscomp$0,f$jscomp$0,m.value),pulse.modifies(f$jscomp$0))}i=0;for(n=modp.length;i<n;++i)m=modp[i],f$jscomp$0=m.filter,tuples.forEach(function(t){f$jscomp$0(t)&&0<cur[t[TUPLE_ID_KEY]]&&modify(t,m.field,m.value)}),pulse.modifies(m.field);if(reflow)pulse.mod=rem.length||remp.length?tuples.filter(function(t){return 0<\ncur[t[TUPLE_ID_KEY]]}):tuples.slice();else for(id in out)pulse.mod.push(out[id]);(clean||null==clean&&(rem.length||remp.length))&&pulse.clean(!0);return pulse}}}function Parameters(){Object.defineProperty(this,\"_:mod:_\",{writable:!0,value:{}})}function Operator(init,update,params,react){this.id=++OP_ID;this.value=init;this.qrank=this.rank=this.stamp=-1;this.flags=0;update&&(this._update=update);params&&this.parameters(params,react)}function flag(bit){return function(state){var f=this.flags;if(0===\narguments.length)return!!(f&bit);this.flags=state?f|bit:f&~bit;return this}}function EventStream(filter,apply,receive){this.id=++STREAM_ID;this.value=null;receive&&(this.receive=receive);filter&&(this._filter=filter);apply&&(this._apply=apply)}function stream$jscomp$0(filter,apply,receive){return new EventStream(filter,apply,receive)}function loadPending(df){var accept,pending=new Promise(function(a){return accept=a});pending.requests=0;pending.done=function(){0===--pending.requests&&(df._pending=\nnull,accept(df))};return df._pending=pending}function onStream(df,stream,target,update,params,options){var opt=vegaUtil.extend({},options,SKIP$1);vegaUtil.isFunction(target)||(target=vegaUtil.constant(target));if(void 0===update)params=function(e){return df.touch(target(e))};else if(vegaUtil.isFunction(update)){var op=new Operator(null,update,params,!1);params=function(e){op.evaluate(e);e=target(e);var v=op.value;isChangeSet(v)?df.pulse(e,v,options):df.update(e,v,opt)}}else params=function(e){return df.update(target(e),\nupdate,opt)};stream.apply(params)}function onOperator(df,source,target,update,params,options){void 0===update?source.targets().add(target):(options=options||{},update=new Operator(null,updater(target,update),params,!1),update.modified(options.force),update.rank=source.rank,source.targets().add(update),target&&(update.skip(!0),update.value=target.value,update.targets().add(target),df.connect(target,[update])))}function updater(target,update){update=vegaUtil.isFunction(update)?update:vegaUtil.constant(update);\nreturn target?function(_,pulse){_=update(_,pulse);target.skip()||(target.skip(_!==this.value).value=_);return _}:update}function Pulse(dataflow,stamp,encode){this.dataflow=dataflow;this.stamp=null==stamp?-1:stamp;this.add=[];this.rem=[];this.mod=[];this.fields=null;this.encode=encode||null}function materialize(data,filter){var out=[];vegaUtil.visitArray(data,filter,function(_){return out.push(_)});return out}function filter$jscomp$0(pulse,flags){var map={};pulse.visit(flags,function(t){map[t[TUPLE_ID_KEY]]=\n1});return function(t){return map[t[TUPLE_ID_KEY]]?null:t}}function addFilter(a,b){return a?function(t,i){return a(t,i)&&b(t,i)}:b}function MultiPulse(dataflow,stamp,pulses,encode){var n=pulses.length,c=0;this.dataflow=dataflow;this.stamp=stamp;this.fields=null;this.encode=encode||null;this.pulses=pulses;for(dataflow=0;dataflow<n;++dataflow)if(encode=pulses[dataflow],encode.stamp===stamp){if(encode.fields){var hash=this.fields||(this.fields={}),f;for(f in encode.fields)hash[f]=1}encode.changed(this.ADD)&&\n(c|=this.ADD);encode.changed(this.REM)&&(c|=this.REM);encode.changed(this.MOD)&&(c|=this.MOD)}this.changes=c}function reentrant(df){df.error(\"Dataflow already running. Use runAsync() to chain invocations.\");return df}function singlePulse(p,s){if(s&&s.stamp===p.stamp)return s;p=p.fork();s&&s!==StopPropagation&&(p.source=s.source);return p}function Heap(cmp){var nodes=[];return{clear:function(){return nodes=[]},size:function(){return nodes.length},peek:function(){return nodes[0]},push:function(x){nodes.push(x);\nreturn siftdown(nodes,0,nodes.length-1,cmp)},pop:function(){var last=nodes.pop();if(nodes.length){var item=nodes[0];nodes[0]=last;last=nodes;for(var idx=0,start=idx,end=last.length,item$jscomp$0=last[idx],cidx=(idx<<1)+1,ridx;cidx<end;)ridx=cidx+1,ridx<end&&0<=cmp(last[cidx],last[ridx])&&(cidx=ridx),last[idx]=last[cidx],idx=cidx,cidx=(idx<<1)+1;last[idx]=item$jscomp$0;siftdown(last,start,idx,cmp)}else item=last;return item}}}function siftdown(array,start,idx,cmp){for(var parent,pidx,item=array[idx];idx>\nstart;)if(pidx=idx-1>>1,parent=array[pidx],0>cmp(item,parent))array[idx]=parent,idx=pidx;else break;return array[idx]=item}function Dataflow(){this.logger(vegaUtil.logger());this.logLevel(vegaUtil.Error);this._rank=this._clock=0;this._locale=vegaFormat.defaultLocale();try{this._loader=vegaLoader.loader()}catch(e){}this._touched=UniqueList(vegaUtil.id);this._input={};this._pulse=null;this._heap=Heap(function(a,b){return a.qrank-b.qrank});this._postrun=[]}function logMethod(method){return function(){return this._log[method].apply(this,\narguments)}}function Transform(init,params){Operator.call(this,init,null,params)}function transform(type){type=type&&type.toLowerCase();return vegaUtil.hasOwnProperty(transforms,type)?transforms[type]:null}var TUPLE_ID_KEY=Symbol(\"vega_id\"),TUPLE_ID=1;Parameters.prototype={set:function(name,index,value,force){var v=this[name],mod=this[\"_:mod:_\"];if(null!=index&&0<=index){if(v[index]!==value||force)v[index]=value,mod[index+\":\"+name]=-1,mod[name]=-1}else if(v!==value||force)this[name]=value,mod[name]=\nvegaUtil.isArray(value)?1+value.length:-1;return this},modified:function(name,index){var mod=this[\"_:mod:_\"];if(!arguments.length){for(var k in mod)if(mod[k])return!0;return!1}if(vegaUtil.isArray(name)){for(k=0;k<name.length;++k)if(mod[name[k]])return!0;return!1}return null!=index&&0<=index?index+1<mod[name]||!!mod[index+\":\"+name]:!!mod[name]},clear:function(){this[\"_:mod:_\"]={};return this}};var OP_ID=0,NO_PARAMS=new Parameters;Operator.prototype={targets:function(){return this._targets||(this._targets=\nUniqueList(vegaUtil.id))},set:function(value){return this.value!==value?(this.value=value,1):0},skip:flag(1),modified:flag(2),parameters:function(params,react,initonly){var $jscomp$this=this;react=!1!==react;var argval=this._argval=this._argval||new Parameters,argops=this._argops=this._argops||[],deps=[],name$jscomp$0,n,i,add=function(name,index,value){value instanceof Operator?(value!==$jscomp$this&&(react&&value.targets().add($jscomp$this),deps.push(value)),argops.push({op:value,name:name,index:index})):\nargval.set(name,index,value)};for(name$jscomp$0 in params){var value$jscomp$0=params[name$jscomp$0];if(\"pulse\"===name$jscomp$0)vegaUtil.array(value$jscomp$0).forEach(function(op){op instanceof Operator?op!==$jscomp$this&&(op.targets().add($jscomp$this),deps.push(op)):vegaUtil.error(\"Pulse parameters must be operator instances.\")}),this.source=value$jscomp$0;else if(vegaUtil.isArray(value$jscomp$0))for(argval.set(name$jscomp$0,-1,Array(n=value$jscomp$0.length)),i=0;i<n;++i)add(name$jscomp$0,i,value$jscomp$0[i]);\nelse add(name$jscomp$0,-1,value$jscomp$0)}this.marshall().clear();initonly&&(argops.initonly=!0);return deps},marshall:function(stamp){var argval=this._argval||NO_PARAMS,argops=this._argops,i;if(argops){var n=argops.length;for(i=0;i<n;++i){var item=argops[i];var op=item.op;var mod=op.modified()&&op.stamp===stamp;argval.set(item.name,item.index,op.value,mod)}if(argops.initonly){for(i=0;i<n;++i)item=argops[i],item.op.targets().remove(this);this._update=this._argops=null}}return argval},detach:function(){var argops=\nthis._argops,n;if(argops){var i=0;for(n=argops.length;i<n;++i){var item=argops[i];item=item.op;item._targets&&item._targets.remove(this)}}},evaluate:function(pulse){var update=this._update;if(update){var params=this.marshall(pulse.stamp);update=update.call(this,params,pulse);params.clear();if(update!==this.value)this.value=update;else if(!this.modified())return pulse.StopPropagation}},run:function(pulse){if(pulse.stamp<this.stamp)return pulse.StopPropagation;if(this.skip()){this.skip(!1);var rv=0}else rv=\nthis.evaluate(pulse);return this.pulse=rv||pulse}};var STREAM_ID=0;EventStream.prototype={_filter:vegaUtil.truthy,_apply:vegaUtil.identity,targets:function(){return this._targets||(this._targets=UniqueList(vegaUtil.id))},consume:function(_){if(!arguments.length)return!!this._consume;this._consume=!!_;return this},receive:function(evt){if(this._filter(evt)){for(var val=this.value=this._apply(evt),trg=this._targets,n=trg?trg.length:0,i=0;i<n;++i)trg[i].receive(val);this._consume&&(evt.preventDefault(),\nevt.stopPropagation())}},filter:function(filter){filter=stream$jscomp$0(filter);this.targets().add(filter);return filter},apply:function(apply){apply=stream$jscomp$0(null,apply);this.targets().add(apply);return apply},merge:function(){var s=stream$jscomp$0();this.targets().add(s);for(var i=0,n=arguments.length;i<n;++i)arguments[i].targets().add(s);return s},throttle:function(pause){var t=-1;return this.filter(function(){var now=Date.now();return now-t>pause?(t=now,1):0})},debounce:function(delay){var s=\nstream$jscomp$0();this.targets().add(stream$jscomp$0(null,null,vegaUtil.debounce(delay,function(e){var df=e.dataflow;s.receive(e);df&&df.run&&df.run()})));return s},between:function(a,b){var active=!1;a.targets().add(stream$jscomp$0(null,null,function(){return active=!0}));b.targets().add(stream$jscomp$0(null,null,function(){return active=!1}));return this.filter(function(){return active})},detach:function(){}};var SKIP$1={skip:!0},StopPropagation={};Pulse.prototype={StopPropagation:StopPropagation,\nADD:1,REM:2,MOD:4,ADD_REM:3,ADD_MOD:5,ALL:7,REFLOW:8,SOURCE:16,NO_SOURCE:32,NO_FIELDS:64,fork:function(flags){return(new Pulse(this.dataflow)).init(this,flags)},clone:function(){var p=this.fork(7);p.add=p.add.slice();p.rem=p.rem.slice();p.mod=p.mod.slice();p.source&&(p.source=p.source.slice());return p.materialize(23)},addAll:function(){var p=this;p.source&&p.add!==p.rem&&(p.rem.length||p.source.length!==p.add.length)&&(p=(new Pulse(this.dataflow)).init(this),p.add=p.source,p.rem=[]);return p},init:function(src,\nflags){this.stamp=src.stamp;this.encode=src.encode;!src.fields||flags&64||(this.fields=src.fields);flags&1?(this.addF=src.addF,this.add=src.add):(this.addF=null,this.add=[]);flags&2?(this.remF=src.remF,this.rem=src.rem):(this.remF=null,this.rem=[]);flags&4?(this.modF=src.modF,this.mod=src.mod):(this.modF=null,this.mod=[]);flags&32?this.source=this.srcF=null:(this.srcF=src.srcF,this.source=src.source,src.cleans&&(this.cleans=src.cleans));return this},runAfter:function(func){this.dataflow.runAfter(func)},\nchanged:function(flags){flags=flags||7;return flags&1&&this.add.length||flags&2&&this.rem.length||flags&4&&this.mod.length},reflow:function(fork){if(fork)return this.fork(7).reflow();fork=this.add.length;var src=this.source&&this.source.length;src&&src!==fork&&(this.mod=this.source,fork&&this.filter(4,filter$jscomp$0(this,1)));return this},clean:function(value){return arguments.length?(this.cleans=!!value,this):this.cleans},modifies:function(_){var hash=this.fields||(this.fields={});vegaUtil.isArray(_)?\n_.forEach(function(f){return hash[f]=!0}):hash[_]=!0;return this},modified:function(_,nomod){var fields=this.fields;return(nomod||this.mod.length)&&fields?arguments.length?vegaUtil.isArray(_)?_.some(function(f){return fields[f]}):fields[_]:!!fields:!1},filter:function(flags,filter){flags&1&&(this.addF=addFilter(this.addF,filter));flags&2&&(this.remF=addFilter(this.remF,filter));flags&4&&(this.modF=addFilter(this.modF,filter));flags&16&&(this.srcF=addFilter(this.srcF,filter));return this},materialize:function(flags){flags=\nflags||7;flags&1&&this.addF&&(this.add=materialize(this.add,this.addF),this.addF=null);flags&2&&this.remF&&(this.rem=materialize(this.rem,this.remF),this.remF=null);flags&4&&this.modF&&(this.mod=materialize(this.mod,this.modF),this.modF=null);flags&16&&this.srcF&&(this.source=this.source.filter(this.srcF),this.srcF=null);return this},visit:function(flags,visitor){if(flags&16)return vegaUtil.visitArray(this.source,this.srcF,visitor),this;flags&1&&vegaUtil.visitArray(this.add,this.addF,visitor);flags&\n2&&vegaUtil.visitArray(this.rem,this.remF,visitor);flags&4&&vegaUtil.visitArray(this.mod,this.modF,visitor);var src=this.source;flags&8&&src&&(flags=this.add.length+this.mod.length,flags!==src.length&&(flags?vegaUtil.visitArray(src,filter$jscomp$0(this,5),visitor):vegaUtil.visitArray(src,this.srcF,visitor)));return this}};vegaUtil.inherits(MultiPulse,Pulse,{fork:function(flags){var p=(new Pulse(this.dataflow)).init(this,flags&this.NO_FIELDS);void 0!==flags&&(flags&p.ADD&&this.visit(p.ADD,function(t){return p.add.push(t)}),\nflags&p.REM&&this.visit(p.REM,function(t){return p.rem.push(t)}),flags&p.MOD&&this.visit(p.MOD,function(t){return p.mod.push(t)}));return p},changed:function(flags){return this.changes&flags},modified:function(_){var fields=this.fields;return fields&&this.changes&this.MOD?vegaUtil.isArray(_)?_.some(function(f){return fields[f]}):fields[_]:0},filter:function(){vegaUtil.error(\"MultiPulse does not support filtering.\")},materialize:function(){vegaUtil.error(\"MultiPulse does not support materialization.\")},\nvisit:function(flags,visitor){var pulses=this.pulses,n=pulses.length,i=0;if(flags&this.SOURCE)for(;i<n;++i)pulses[i].visit(flags,visitor);else for(;i<n;++i)pulses[i].stamp===this.stamp&&pulses[i].visit(flags,visitor);return this}});var NO_OPT={skip:!1,force:!1};Dataflow.prototype={stamp:function(){return this._clock},loader:function(_){return arguments.length?(this._loader=_,this):this._loader},locale:function(_){return arguments.length?(this._locale=_,this):this._locale},logger:function(logger){return arguments.length?\n(this._log=logger,this):this._log},error:logMethod(\"error\"),warn:logMethod(\"warn\"),info:logMethod(\"info\"),debug:logMethod(\"debug\"),logLevel:logMethod(\"level\"),cleanThreshold:1E4,add:function(init,update,params,react){var shift=1;init instanceof Operator||(init&&init.prototype instanceof Operator?init=new init:vegaUtil.isFunction(init)?init=new Operator(null,init):(shift=0,init=new Operator(init,update)));this.rank(init);shift&&(react=params,params=update);params&&this.connect(init,init.parameters(params,\nreact));this.touch(init);return init},connect:function(target,sources){for(var targetRank=target.rank,n=sources.length,i=0;i<n;++i)if(targetRank<sources[i].rank){this.rerank(target);break}},rank:function(op){op.rank=++this._rank},rerank:function(op){for(var queue=[op],cur,list,i;queue.length;)if(this.rank(cur=queue.pop()),list=cur._targets)for(i=list.length;0<=--i;)queue.push(cur=list[i]),cur===op&&vegaUtil.error(\"Cycle detected in dataflow graph.\")},pulse:function(op,changeset,options){this.touch(op,\noptions||NO_OPT);options=new Pulse(this,this._clock+(this._pulse?0:1));var t=op.pulse&&op.pulse.source||[];options.target=op;this._input[op.id]=changeset.pulse(options,t);return this},touch:function(op,options){options=options||NO_OPT;this._pulse?this._enqueue(op):this._touched.add(op);options.skip&&op.skip(!0);return this},update:function(op,value,options){options=options||NO_OPT;(op.set(value)||options.force)&&this.touch(op,options);return this},changeset:changeset,ingest:function(target,data,format){data=\nthis.parse(data,format);return this.pulse(target,this.changeset().insert(data))},parse:function(data,format){var locale=this.locale();return vegaLoader.read(data,format,locale.timeParse,locale.utcParse)},preload:function(target,url,format){var $jscomp$async$this=this,df,pending,res;return $jscomp.asyncExecutePromiseGeneratorProgram(function($jscomp$generator$context){if(1==$jscomp$generator$context.nextAddress)return df=$jscomp$async$this,pending=df._pending||loadPending(df),pending.requests+=1,$jscomp$generator$context.yield(df.request(url,\nformat),2);res=$jscomp$generator$context.yieldResult;df.pulse(target,df.changeset().remove(vegaUtil.truthy).insert(res.data||[]));pending.done();return $jscomp$generator$context.return(res)})},request:function(url,format){var $jscomp$async$this=this,df,status,data,err$312;return $jscomp.asyncExecutePromiseGeneratorProgram(function($jscomp$generator$context){switch($jscomp$generator$context.nextAddress){case 1:return df=$jscomp$async$this,status=0,$jscomp$generator$context.setCatchFinallyBlocks(2),\n$jscomp$generator$context.yield(df.loader().load(url,{context:\"dataflow\",response:vegaLoader.responseType(format&&format.type)}),4);case 4:data=$jscomp$generator$context.yieldResult;try{data=df.parse(data,format)}catch(err){status=-2,df.warn(\"Data ingestion failed\",url,err)}$jscomp$generator$context.leaveTryBlock(3);break;case 2:err$312=$jscomp$generator$context.enterCatchBlock(),status=-1,df.warn(\"Loading failed\",url,err$312);case 3:return $jscomp$generator$context.return({data:data,status:status})}})},\nevents:function(source,type,filter,apply){var df=this,s=stream$jscomp$0(filter,apply);filter=function(e){e.dataflow=df;try{s.receive(e)}catch(error){df.error(error)}finally{df.run()}};source=\"string\"===typeof source&&\"undefined\"!==typeof document?document.querySelectorAll(source):vegaUtil.array(source);apply=source.length;for(var i=0;i<apply;++i)source[i].addEventListener(type,filter);return s},on:function(source,target,update,params,options){(source instanceof Operator?onOperator:onStream)(this,\nsource,target,update,params,options);return this},evaluate:function(encode,prerun,postrun){var $jscomp$async$this=this,df,async,stamp,count,op$jscomp$0,next,error,err,pr,i;return $jscomp.asyncExecutePromiseGeneratorProgram(function($jscomp$generator$context){switch($jscomp$generator$context.nextAddress){case 1:df=$jscomp$async$this;async=[];if(df._pulse)return $jscomp$generator$context.return(reentrant(df));if(!df._pending){$jscomp$generator$context.jumpTo(2);break}return $jscomp$generator$context.yield(df._pending,\n2);case 2:if(!prerun){$jscomp$generator$context.jumpTo(4);break}return $jscomp$generator$context.yield(asyncCallback(df,prerun),4);case 4:if(!df._touched.length)return df.debug(\"Dataflow invoked, but nothing to do.\"),$jscomp$generator$context.return(df);stamp=++df._clock;df._pulse=new Pulse(df,stamp,encode);df._touched.forEach(function(op){return df._enqueue(op,!0)});df._touched=UniqueList(vegaUtil.id);count=0;$jscomp$generator$context.setCatchFinallyBlocks(6);case 8:if(!(0<df._heap.size())){$jscomp$generator$context.leaveTryBlock(7);\nbreak}op$jscomp$0=df._heap.pop();if(op$jscomp$0.rank!==op$jscomp$0.qrank){df._enqueue(op$jscomp$0,!0);$jscomp$generator$context.jumpTo(8);break}next=op$jscomp$0.run(df._getPulse(op$jscomp$0,encode));if(!next.then){next.async&&(async.push(next.async),next=StopPropagation);$jscomp$generator$context.jumpTo(10);break}return $jscomp$generator$context.yield(next,11);case 11:next=$jscomp$generator$context.yieldResult;case 10:next!==StopPropagation&&op$jscomp$0._targets&&op$jscomp$0._targets.forEach(function(op){return df._enqueue(op)});\n++count;$jscomp$generator$context.jumpTo(8);break;case 6:err=$jscomp$generator$context.enterCatchBlock(),df._heap.clear(),error=err;case 7:df._input={};df._pulse=null;df.debug(\"Pulse \"+stamp+\": \"+count+\" operators\");error&&(df._postrun=[],df.error(error));if(!df._postrun.length){$jscomp$generator$context.jumpTo(12);break}pr=df._postrun.sort(function(a,b){return b.priority-a.priority});df._postrun=[];i=0;case 13:if(!(i<pr.length)){$jscomp$generator$context.jumpTo(12);break}return $jscomp$generator$context.yield(asyncCallback(df,\npr[i].callback),14);case 14:++i;$jscomp$generator$context.jumpTo(13);break;case 12:if(!postrun){$jscomp$generator$context.jumpTo(17);break}return $jscomp$generator$context.yield(asyncCallback(df,postrun),17);case 17:return async.length&&Promise.all(async).then(function(cb){return df.runAsync(null,function(){cb.forEach(function(f){try{f(df)}catch(err$314){df.error(err$314)}})})}),$jscomp$generator$context.return(df)}})},run:function(encode,prerun,postrun){return this._pulse?reentrant(this):(this.evaluate(encode,\nprerun,postrun),this)},runAsync:function(encode,prerun,postrun){var $jscomp$async$this=this,clear;return $jscomp.asyncExecutePromiseGeneratorProgram(function($jscomp$generator$context){if(1==$jscomp$generator$context.nextAddress)return $jscomp$async$this._running?$jscomp$generator$context.yield($jscomp$async$this._running,1):$jscomp$generator$context.jumpTo(3);clear=function(){return $jscomp$async$this._running=null};($jscomp$async$this._running=$jscomp$async$this.evaluate(encode,prerun,postrun)).then(clear,\nclear);return $jscomp$generator$context.return($jscomp$async$this._running)})},runAfter:function(callback,enqueue,priority){if(this._pulse||enqueue)this._postrun.push({priority:priority||0,callback:callback});else try{callback(this)}catch(err){this.error(err)}},_enqueue:function(op,force){var q=op.stamp<this._clock;q&&(op.stamp=this._clock);if(q||force)op.qrank=op.rank,this._heap.push(op)},_getPulse:function(op,encode){var s=op.source,stamp=this._clock;return s&&vegaUtil.isArray(s)?new MultiPulse(this,\nstamp,s.map(function(_){return _.pulse}),encode):this._input[op.id]||singlePulse(this._pulse,s&&s.pulse)}};vegaUtil.inherits(Transform,Operator,{run:function(pulse){var $jscomp$this=this;if(pulse.stamp<this.stamp)return pulse.StopPropagation;var rv;this.skip()?this.skip(!1):rv=this.evaluate(pulse);rv=rv||pulse;rv.then?rv=rv.then(function(_){return $jscomp$this.pulse=_}):rv!==pulse.StopPropagation&&(this.pulse=rv);return rv},evaluate:function(pulse){var params=this.marshall(pulse.stamp);pulse=this.transform(params,\npulse);params.clear();return pulse},transform:function(){}});var transforms={};exports.Dataflow=Dataflow;exports.EventStream=EventStream;exports.MultiPulse=MultiPulse;exports.Operator=Operator;exports.Parameters=Parameters;exports.Pulse=Pulse;exports.Transform=Transform;exports.UniqueList=UniqueList;exports.asyncCallback=asyncCallback;exports.changeset=changeset;exports.definition=function(type){return(type=transform(type))&&type.Definition||null};exports.derive=function(t){return rederive(t,ingest({}))};\nexports.ingest=ingest;exports.isChangeSet=isChangeSet;exports.isTuple=function(t){return!(!t||!t[TUPLE_ID_KEY])};exports.rederive=rederive;exports.replace=function(t,d){d[TUPLE_ID_KEY]=t[TUPLE_ID_KEY];return d};exports.stableCompare=function(cmp,f){return cmp?f?function(a,b){return cmp(a,b)||f(a)[TUPLE_ID_KEY]-f(b)[TUPLE_ID_KEY]}:function(a,b){return cmp(a,b)||a[TUPLE_ID_KEY]-b[TUPLE_ID_KEY]}:null};exports.transform=transform;exports.transforms=transforms;exports.tupleid=function(t){return t[TUPLE_ID_KEY]};\nObject.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_dataflow$build$vega_dataflow\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-loader'), require('vega-format')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-loader', 'vega-format'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega, global.vega));\n}(this, (function (exports, vegaUtil, vegaLoader, vegaFormat) { 'use strict';\n\n  function UniqueList(idFunc) {\n    const $ = idFunc || vegaUtil.identity,\n          list = [],\n          ids = {};\n\n    list.add = _ => {\n      const id = $(_);\n      if (!ids[id]) {\n        ids[id] = 1;\n        list.push(_);\n      }\n      return list;\n    };\n\n    list.remove = _ => {\n      const id = $(_);\n      if (ids[id]) {\n        ids[id] = 0;\n        const idx = list.indexOf(_);\n        if (idx >= 0) list.splice(idx, 1);\n      }\n      return list;\n    };\n\n    return list;\n  }\n\n  /**\n   * Invoke and await a potentially async callback function. If\n   * an error occurs, trap it and route to Dataflow.error.\n   * @param {Dataflow} df - The dataflow instance\n   * @param {function} callback - A callback function to invoke\n   *   and then await. The dataflow will be passed as the single\n   *   argument to the function.\n   */\n  async function asyncCallback(df, callback) {\n    try { await callback(df); } catch (err) { df.error(err); }\n  }\n\n  const TUPLE_ID_KEY = Symbol('vega_id');\n  let TUPLE_ID = 1;\n\n  /**\n   * Checks if an input value is a registered tuple.\n   * @param {*} t - The value to check.\n   * @return {boolean} True if the input is a tuple, false otherwise.\n   */\n  function isTuple(t) {\n    return !!(t && tupleid(t));\n  }\n\n  /**\n   * Returns the id of a tuple.\n   * @param {object} t - The input tuple.\n   * @return {*} the tuple id.\n   */\n  function tupleid(t) {\n    return t[TUPLE_ID_KEY];\n  }\n\n  /**\n   * Sets the id of a tuple.\n   * @param {object} t - The input tuple.\n   * @param {*} id - The id value to set.\n   * @return {object} the input tuple.\n   */\n  function setid(t, id) {\n    t[TUPLE_ID_KEY] = id;\n    return t;\n  }\n\n  /**\n   * Ingest an object or value as a data tuple.\n   * If the input value is an object, an id field will be added to it. For\n   * efficiency, the input object is modified directly. A copy is not made.\n   * If the input value is a literal, it will be wrapped in a new object\n   * instance, with the value accessible as the 'data' property.\n   * @param datum - The value to ingest.\n   * @return {object} The ingested data tuple.\n   */\n  function ingest(datum) {\n    const t = (datum === Object(datum)) ? datum : {data: datum};\n    return tupleid(t) ? t : setid(t, TUPLE_ID++);\n  }\n\n  /**\n   * Given a source tuple, return a derived copy.\n   * @param {object} t - The source tuple.\n   * @return {object} The derived tuple.\n   */\n  function derive(t) {\n    return rederive(t, ingest({}));\n  }\n\n  /**\n   * Rederive a derived tuple by copying values from the source tuple.\n   * @param {object} t - The source tuple.\n   * @param {object} d - The derived tuple.\n   * @return {object} The derived tuple.\n   */\n  function rederive(t, d) {\n    for (const k in t) d[k] = t[k];\n    return d;\n  }\n\n  /**\n   * Replace an existing tuple with a new tuple.\n   * @param {object} t - The existing data tuple.\n   * @param {object} d - The new tuple that replaces the old.\n   * @return {object} The new tuple.\n   */\n  function replace(t, d) {\n    return setid(d, tupleid(t));\n  }\n\n  /**\n   * Generate an augmented comparator function that provides stable\n   * sorting by tuple id when the given comparator produces ties.\n   * @param {function} cmp - The comparator to augment.\n   * @param {function} [f] - Optional tuple accessor function.\n   * @return {function} An augmented comparator function.\n   */\n  function stableCompare(cmp, f) {\n    return !cmp ? null\n      : f ? (a, b) => cmp(a, b) || (tupleid(f(a)) - tupleid(f(b)))\n      : (a, b) => cmp(a, b) || (tupleid(a) - tupleid(b));\n  }\n\n  function isChangeSet(v) {\n    return v && v.constructor === changeset;\n  }\n\n  function changeset() {\n    const add = [],  // insert tuples\n          rem = [],  // remove tuples\n          mod = [],  // modify tuples\n          remp = [], // remove by predicate\n          modp = []; // modify by predicate\n    let clean = null,\n        reflow = false;\n\n    return {\n      constructor: changeset,\n      insert(t) {\n        const d = vegaUtil.array(t), n = d.length;\n        for (let i = 0; i < n; ++i) add.push(d[i]);\n        return this;\n      },\n      remove(t) {\n        const a = vegaUtil.isFunction(t) ? remp : rem,\n              d = vegaUtil.array(t),\n              n = d.length;\n        for (let i = 0; i < n; ++i) a.push(d[i]);\n        return this;\n      },\n      modify(t, field, value) {\n        const m = {field: field, value: vegaUtil.constant(value)};\n        if (vegaUtil.isFunction(t)) {\n          m.filter = t;\n          modp.push(m);\n        } else {\n          m.tuple = t;\n          mod.push(m);\n        }\n        return this;\n      },\n      encode(t, set) {\n        if (vegaUtil.isFunction(t)) modp.push({filter: t, field: set});\n        else mod.push({tuple: t, field: set});\n        return this;\n      },\n      clean(value) {\n        clean = value;\n        return this;\n      },\n      reflow() {\n        reflow = true;\n        return this;\n      },\n      pulse(pulse, tuples) {\n        const cur = {}, out = {};\n        let i, n, m, f, t, id;\n\n        // build lookup table of current tuples\n        for (i = 0, n = tuples.length; i < n; ++i) {\n          cur[tupleid(tuples[i])] = 1;\n        }\n\n        // process individual tuples to remove\n        for (i = 0, n = rem.length; i < n; ++i) {\n          t = rem[i];\n          cur[tupleid(t)] = -1;\n        }\n\n        // process predicate-based removals\n        for (i = 0, n = remp.length; i < n; ++i) {\n          f = remp[i];\n          tuples.forEach(t => {\n            if (f(t)) cur[tupleid(t)] = -1;\n          });\n        }\n\n        // process all add tuples\n        for (i = 0, n = add.length; i < n; ++i) {\n          t = add[i];\n          id = tupleid(t);\n          if (cur[id]) {\n            // tuple already resides in dataset\n            // if flagged for both add and remove, cancel\n            cur[id] = 1;\n          } else {\n            // tuple does not reside in dataset, add\n            pulse.add.push(ingest(add[i]));\n          }\n        }\n\n        // populate pulse rem list\n        for (i = 0, n = tuples.length; i < n; ++i) {\n          t = tuples[i];\n          if (cur[tupleid(t)] < 0) pulse.rem.push(t);\n        }\n\n        // modify helper method\n        function modify(t, f, v) {\n          if (v) {\n            t[f] = v(t);\n          } else {\n            pulse.encode = f;\n          }\n          if (!reflow) out[tupleid(t)] = t;\n        }\n\n        // process individual tuples to modify\n        for (i = 0, n = mod.length; i < n; ++i) {\n          m = mod[i];\n          t = m.tuple;\n          f = m.field;\n          id = cur[tupleid(t)];\n          if (id > 0) {\n            modify(t, f, m.value);\n            pulse.modifies(f);\n          }\n        }\n\n        // process predicate-based modifications\n        for (i = 0, n = modp.length; i < n; ++i) {\n          m = modp[i];\n          f = m.filter;\n          tuples.forEach(t => {\n            if (f(t) && cur[tupleid(t)] > 0) {\n              modify(t, m.field, m.value);\n            }\n          });\n          pulse.modifies(m.field);\n        }\n\n        // upon reflow request, populate mod with all non-removed tuples\n        // otherwise, populate mod with modified tuples only\n        if (reflow) {\n          pulse.mod = rem.length || remp.length\n            ? tuples.filter(t => cur[tupleid(t)] > 0)\n            : tuples.slice();\n        } else {\n          for (id in out) pulse.mod.push(out[id]);\n        }\n\n        // set pulse garbage collection request\n        if (clean || clean == null && (rem.length || remp.length)) {\n          pulse.clean(true);\n        }\n\n        return pulse;\n      }\n    };\n  }\n\n  const CACHE = '_:mod:_';\n\n  /**\n   * Hash that tracks modifications to assigned values.\n   * Callers *must* use the set method to update values.\n   */\n  function Parameters() {\n    Object.defineProperty(this, CACHE, {writable: true, value: {}});\n  }\n\n  Parameters.prototype = {\n    /**\n     * Set a parameter value. If the parameter value changes, the parameter\n     * will be recorded as modified.\n     * @param {string} name - The parameter name.\n     * @param {number} index - The index into an array-value parameter. Ignored if\n     *   the argument is undefined, null or less than zero.\n     * @param {*} value - The parameter value to set.\n     * @param {boolean} [force=false] - If true, records the parameter as modified\n     *   even if the value is unchanged.\n     * @return {Parameters} - This parameter object.\n     */\n    set(name, index, value, force) {\n      const o = this,\n            v = o[name],\n            mod = o[CACHE];\n\n      if (index != null && index >= 0) {\n        if (v[index] !== value || force) {\n          v[index] = value;\n          mod[index + ':' + name] = -1;\n          mod[name] = -1;\n        }\n      } else if (v !== value || force) {\n        o[name] = value;\n        mod[name] = vegaUtil.isArray(value) ? 1 + value.length : -1;\n      }\n\n      return o;\n    },\n\n    /**\n     * Tests if one or more parameters has been modified. If invoked with no\n     * arguments, returns true if any parameter value has changed. If the first\n     * argument is array, returns trues if any parameter name in the array has\n     * changed. Otherwise, tests if the given name and optional array index has\n     * changed.\n     * @param {string} name - The parameter name to test.\n     * @param {number} [index=undefined] - The parameter array index to test.\n     * @return {boolean} - Returns true if a queried parameter was modified.\n     */\n    modified(name, index) {\n      const mod = this[CACHE];\n      if (!arguments.length) {\n        for (const k in mod) { if (mod[k]) return true; }\n        return false;\n      } else if (vegaUtil.isArray(name)) {\n        for (let k = 0; k < name.length; ++k) {\n          if (mod[name[k]]) return true;\n        }\n        return false;\n      }\n      return (index != null && index >= 0)\n        ? (index + 1 < mod[name] || !!mod[index + ':' + name])\n        : !!mod[name];\n    },\n\n    /**\n     * Clears the modification records. After calling this method,\n     * all parameters are considered unmodified.\n     */\n    clear() {\n      this[CACHE] = {};\n      return this;\n    }\n  };\n\n  let OP_ID = 0;\n\n  const PULSE = 'pulse',\n        NO_PARAMS = new Parameters();\n\n  // Boolean Flags\n  const SKIP     = 1,\n        MODIFIED = 2;\n\n  /**\n   * An Operator is a processing node in a dataflow graph.\n   * Each operator stores a value and an optional value update function.\n   * Operators can accept a hash of named parameters. Parameter values can\n   * either be direct (JavaScript literals, arrays, objects) or indirect\n   * (other operators whose values will be pulled dynamically). Operators\n   * included as parameters will have this operator added as a dependency.\n   * @constructor\n   * @param {*} [init] - The initial value for this operator.\n   * @param {function(object, Pulse)} [update] - An update function. Upon\n   *   evaluation of this operator, the update function will be invoked and the\n   *   return value will be used as the new value of this operator.\n   * @param {object} [params] - The parameters for this operator.\n   * @param {boolean} [react=true] - Flag indicating if this operator should\n   *   listen for changes to upstream operators included as parameters.\n   * @see parameters\n   */\n  function Operator(init, update, params, react) {\n    this.id = ++OP_ID;\n    this.value = init;\n    this.stamp = -1;\n    this.rank = -1;\n    this.qrank = -1;\n    this.flags = 0;\n\n    if (update) {\n      this._update = update;\n    }\n    if (params) this.parameters(params, react);\n  }\n\n  function flag(bit) {\n    return function(state) {\n      const f = this.flags;\n      if (arguments.length === 0) return !!(f & bit);\n      this.flags = state ? (f | bit) : (f & ~bit);\n      return this;\n    };\n  }\n\n  Operator.prototype = {\n\n    /**\n     * Returns a list of target operators dependent on this operator.\n     * If this list does not exist, it is created and then returned.\n     * @return {UniqueList}\n     */\n    targets() {\n      return this._targets || (this._targets = UniqueList(vegaUtil.id));\n    },\n\n    /**\n     * Sets the value of this operator.\n     * @param {*} value - the value to set.\n     * @return {Number} Returns 1 if the operator value has changed\n     *   according to strict equality, returns 0 otherwise.\n     */\n    set(value) {\n      if (this.value !== value) {\n        this.value = value;\n        return 1;\n      } else {\n        return 0;\n      }\n    },\n\n    /**\n     * Indicates that operator evaluation should be skipped on the next pulse.\n     * This operator will still propagate incoming pulses, but its update function\n     * will not be invoked. The skip flag is reset after every pulse, so calling\n     * this method will affect processing of the next pulse only.\n     */\n    skip: flag(SKIP),\n\n    /**\n     * Indicates that this operator's value has been modified on its most recent\n     * pulse. Normally modification is checked via strict equality; however, in\n     * some cases it is more efficient to update the internal state of an object.\n     * In those cases, the modified flag can be used to trigger propagation. Once\n     * set, the modification flag persists across pulses until unset. The flag can\n     * be used with the last timestamp to test if a modification is recent.\n     */\n    modified: flag(MODIFIED),\n\n    /**\n     * Sets the parameters for this operator. The parameter values are analyzed for\n     * operator instances. If found, this operator will be added as a dependency\n     * of the parameterizing operator. Operator values are dynamically marshalled\n     * from each operator parameter prior to evaluation. If a parameter value is\n     * an array, the array will also be searched for Operator instances. However,\n     * the search does not recurse into sub-arrays or object properties.\n     * @param {object} params - A hash of operator parameters.\n     * @param {boolean} [react=true] - A flag indicating if this operator should\n     *   automatically update (react) when parameter values change. In other words,\n     *   this flag determines if the operator registers itself as a listener on\n     *   any upstream operators included in the parameters.\n     * @param {boolean} [initonly=false] - A flag indicating if this operator\n     *   should calculate an update only upon its initiatal evaluation, then\n     *   deregister dependencies and suppress all future update invocations.\n     * @return {Operator[]} - An array of upstream dependencies.\n     */\n    parameters(params, react, initonly) {\n      react = react !== false;\n      const argval = (this._argval = this._argval || new Parameters()),\n            argops = (this._argops = this._argops || []),\n            deps = [];\n      let name, value, n, i;\n\n      const add = (name, index, value) => {\n        if (value instanceof Operator) {\n          if (value !== this) {\n            if (react) value.targets().add(this);\n            deps.push(value);\n          }\n          argops.push({op:value, name:name, index:index});\n        } else {\n          argval.set(name, index, value);\n        }\n      };\n\n      for (name in params) {\n        value = params[name];\n\n        if (name === PULSE) {\n          vegaUtil.array(value).forEach(op => {\n            if (!(op instanceof Operator)) {\n              vegaUtil.error('Pulse parameters must be operator instances.');\n            } else if (op !== this) {\n              op.targets().add(this);\n              deps.push(op);\n            }\n          });\n          this.source = value;\n        } else if (vegaUtil.isArray(value)) {\n          argval.set(name, -1, Array(n = value.length));\n          for (i = 0; i < n; ++i) add(name, i, value[i]);\n        } else {\n          add(name, -1, value);\n        }\n      }\n\n      this.marshall().clear(); // initialize values\n      if (initonly) argops.initonly = true;\n\n      return deps;\n    },\n\n    /**\n     * Internal method for marshalling parameter values.\n     * Visits each operator dependency to pull the latest value.\n     * @return {Parameters} A Parameters object to pass to the update function.\n     */\n    marshall(stamp) {\n      const argval = this._argval || NO_PARAMS,\n            argops = this._argops;\n      let item, i, op, mod;\n\n      if (argops) {\n        const n = argops.length;\n        for (i = 0; i < n; ++i) {\n          item = argops[i];\n          op = item.op;\n          mod = op.modified() && op.stamp === stamp;\n          argval.set(item.name, item.index, op.value, mod);\n        }\n\n        if (argops.initonly) {\n          for (i = 0; i < n; ++i) {\n            item = argops[i];\n            item.op.targets().remove(this);\n          }\n          this._argops = null;\n          this._update = null;\n        }\n      }\n      return argval;\n    },\n\n    /**\n     * Detach this operator from the dataflow.\n     * Unregisters listeners on upstream dependencies.\n     */\n    detach() {\n      const argops = this._argops;\n      let i, n, item, op;\n\n      if (argops) {\n        for (i = 0, n = argops.length; i < n; ++i) {\n          item = argops[i];\n          op = item.op;\n          if (op._targets) {\n            op._targets.remove(this);\n          }\n        }\n      }\n    },\n\n    /**\n     * Delegate method to perform operator processing.\n     * Subclasses can override this method to perform custom processing.\n     * By default, it marshalls parameters and calls the update function\n     * if that function is defined. If the update function does not\n     * change the operator value then StopPropagation is returned.\n     * If no update function is defined, this method does nothing.\n     * @param {Pulse} pulse - the current dataflow pulse.\n     * @return The output pulse or StopPropagation. A falsy return value\n     *   (including undefined) will let the input pulse pass through.\n     */\n    evaluate(pulse) {\n      const update = this._update;\n      if (update) {\n        const params = this.marshall(pulse.stamp),\n              v = update.call(this, params, pulse);\n\n        params.clear();\n        if (v !== this.value) {\n          this.value = v;\n        } else if (!this.modified()) {\n          return pulse.StopPropagation;\n        }\n      }\n    },\n\n    /**\n     * Run this operator for the current pulse. If this operator has already\n     * been run at (or after) the pulse timestamp, returns StopPropagation.\n     * Internally, this method calls {@link evaluate} to perform processing.\n     * If {@link evaluate} returns a falsy value, the input pulse is returned.\n     * This method should NOT be overridden, instead overrride {@link evaluate}.\n     * @param {Pulse} pulse - the current dataflow pulse.\n     * @return the output pulse for this operator (or StopPropagation)\n     */\n    run(pulse) {\n      if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n      let rv;\n      if (this.skip()) {\n        this.skip(false);\n        rv = 0;\n      } else {\n        rv = this.evaluate(pulse);\n      }\n      return (this.pulse = rv || pulse);\n    }\n  };\n\n  /**\n   * Add an operator to the dataflow graph. This function accepts a\n   * variety of input argument types. The basic signature supports an\n   * initial value, update function and parameters. If the first parameter\n   * is an Operator instance, it will be added directly. If it is a\n   * constructor for an Operator subclass, a new instance will be instantiated.\n   * Otherwise, if the first parameter is a function instance, it will be used\n   * as the update function and a null initial value is assumed.\n   * @param {*} init - One of: the operator to add, the initial value of\n   *   the operator, an operator class to instantiate, or an update function.\n   * @param {function} [update] - The operator update function.\n   * @param {object} [params] - The operator parameters.\n   * @param {boolean} [react=true] - Flag indicating if this operator should\n   *   listen for changes to upstream operators included as parameters.\n   * @return {Operator} - The added operator.\n   */\n  function add(init, update, params, react) {\n    let shift = 1,\n        op;\n\n    if (init instanceof Operator) {\n      op = init;\n    } else if (init && init.prototype instanceof Operator) {\n      op = new init();\n    } else if (vegaUtil.isFunction(init)) {\n      op = new Operator(null, init);\n    } else {\n      shift = 0;\n      op = new Operator(init, update);\n    }\n\n    this.rank(op);\n    if (shift) {\n      react = params;\n      params = update;\n    }\n    if (params) this.connect(op, op.parameters(params, react));\n    this.touch(op);\n\n    return op;\n  }\n\n  /**\n   * Connect a target operator as a dependent of source operators.\n   * If necessary, this method will rerank the target operator and its\n   * dependents to ensure propagation proceeds in a topologically sorted order.\n   * @param {Operator} target - The target operator.\n   * @param {Array<Operator>} - The source operators that should propagate\n   *   to the target operator.\n   */\n  function connect(target, sources) {\n    const targetRank = target.rank,\n          n = sources.length;\n\n    for (let i = 0; i < n; ++i) {\n      if (targetRank < sources[i].rank) {\n        this.rerank(target);\n        return;\n      }\n    }\n  }\n\n  let STREAM_ID = 0;\n\n  /**\n   * Models an event stream.\n   * @constructor\n   * @param {function(Object, number): boolean} [filter] - Filter predicate.\n   *   Events pass through when truthy, events are suppressed when falsy.\n   * @param {function(Object): *} [apply] - Applied to input events to produce\n   *   new event values.\n   * @param {function(Object)} [receive] - Event callback function to invoke\n   *   upon receipt of a new event. Use to override standard event processing.\n   */\n  function EventStream(filter, apply, receive) {\n    this.id = ++STREAM_ID;\n    this.value = null;\n    if (receive) this.receive = receive;\n    if (filter) this._filter = filter;\n    if (apply) this._apply = apply;\n  }\n\n  /**\n   * Creates a new event stream instance with the provided\n   * (optional) filter, apply and receive functions.\n   * @param {function(Object, number): boolean} [filter] - Filter predicate.\n   *   Events pass through when truthy, events are suppressed when falsy.\n   * @param {function(Object): *} [apply] - Applied to input events to produce\n   *   new event values.\n   * @see EventStream\n   */\n  function stream(filter, apply, receive) {\n    return new EventStream(filter, apply, receive);\n  }\n\n  EventStream.prototype = {\n    _filter: vegaUtil.truthy,\n\n    _apply: vegaUtil.identity,\n\n    targets() {\n      return this._targets || (this._targets = UniqueList(vegaUtil.id));\n    },\n\n    consume(_) {\n      if (!arguments.length) return !!this._consume;\n      this._consume = !!_;\n      return this;\n    },\n\n    receive(evt) {\n      if (this._filter(evt)) {\n        const val = (this.value = this._apply(evt)),\n            trg = this._targets,\n            n = trg ? trg.length : 0;\n\n        for (let i = 0; i < n; ++i) trg[i].receive(val);\n\n        if (this._consume) {\n          evt.preventDefault();\n          evt.stopPropagation();\n        }\n      }\n    },\n\n    filter(filter) {\n      const s = stream(filter);\n      this.targets().add(s);\n      return s;\n    },\n\n    apply(apply) {\n      const s = stream(null, apply);\n      this.targets().add(s);\n      return s;\n    },\n\n    merge() {\n      const s = stream();\n\n      this.targets().add(s);\n      for (let i=0, n=arguments.length; i<n; ++i) {\n        arguments[i].targets().add(s);\n      }\n\n      return s;\n    },\n\n    throttle(pause) {\n      let t = -1;\n      return this.filter(() => {\n        const now = Date.now();\n        if ((now - t) > pause) {\n          t = now;\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n    },\n\n    debounce(delay) {\n      const s = stream();\n\n      this.targets().add(stream(null, null,\n        vegaUtil.debounce(delay, e => {\n          const df = e.dataflow;\n          s.receive(e);\n          if (df && df.run) df.run();\n        })\n      ));\n\n      return s;\n    },\n\n    between(a, b) {\n      let active = false;\n      a.targets().add(stream(null, null, () => active = true));\n      b.targets().add(stream(null, null, () => active = false));\n      return this.filter(() => active);\n    },\n\n    detach() {\n      // no-op for handling detach requests\n      // ensures compatibility with operators (#2753)\n    }\n  };\n\n  /**\n   * Create a new event stream from an event source.\n   * @param {object} source - The event source to monitor. The input must\n   *  support the addEventListener method.\n   * @param {string} type - The event type.\n   * @param {function(object): boolean} [filter] - Event filter function.\n   * @param {function(object): *} [apply] - Event application function.\n   *   If provided, this function will be invoked and the result will be\n   *   used as the downstream event value.\n   * @return {EventStream}\n   */\n  function events(source, type, filter, apply) {\n    const df = this,\n          s = stream(filter, apply),\n          send = function(e) {\n            e.dataflow = df;\n            try {\n              s.receive(e);\n            } catch (error) {\n              df.error(error);\n            } finally {\n              df.run();\n            }\n          };\n\n    let sources;\n    if (typeof source === 'string' && typeof document !== 'undefined') {\n      sources = document.querySelectorAll(source);\n    } else {\n      sources = vegaUtil.array(source);\n    }\n\n    const n = sources.length;\n    for (let i = 0; i < n; ++i) {\n      sources[i].addEventListener(type, send);\n    }\n\n    return s;\n  }\n\n  function parse(data, format) {\n    const locale = this.locale();\n    return vegaLoader.read(data, format, locale.timeParse, locale.utcParse);\n  }\n\n  /**\n   * Ingests new data into the dataflow. First parses the data using the\n   * vega-loader read method, then pulses a changeset to the target operator.\n   * @param {Operator} target - The Operator to target with ingested data,\n   *   typically a Collect transform instance.\n   * @param {*} data - The input data, prior to parsing. For JSON this may\n   *   be a string or an object. For CSV, TSV, etc should be a string.\n   * @param {object} format - The data format description for parsing\n   *   loaded data. This object is passed to the vega-loader read method.\n   * @returns {Dataflow}\n   */\n  function ingest$1(target, data, format) {\n    data = this.parse(data, format);\n    return this.pulse(target, this.changeset().insert(data));\n  }\n\n  /**\n   * Request data from an external source, parse it, and return a Promise.\n   * @param {string} url - The URL from which to load the data. This string\n   *   is passed to the vega-loader load method.\n   * @param {object} [format] - The data format description for parsing\n   *   loaded data. This object is passed to the vega-loader read method.\n   * @return {Promise} A Promise that resolves upon completion of the request.\n   *   The resolved object contains the following properties:\n   *   - data: an array of parsed data (or null upon error)\n   *   - status: a code for success (0), load fail (-1), or parse fail (-2)\n   */\n  async function request(url, format) {\n    const df = this;\n    let status = 0, data;\n\n    try {\n      data = await df.loader().load(url, {\n        context: 'dataflow',\n        response: vegaLoader.responseType(format && format.type)\n      });\n      try {\n        data = df.parse(data, format);\n      } catch (err) {\n        status = -2;\n        df.warn('Data ingestion failed', url, err);\n      }\n    } catch (err) {\n      status = -1;\n      df.warn('Loading failed', url, err);\n    }\n\n    return {data, status};\n  }\n\n  async function preload(target, url, format) {\n    const df = this,\n          pending = df._pending || loadPending(df);\n\n    pending.requests += 1;\n\n    const res = await df.request(url, format);\n    df.pulse(target, df.changeset().remove(vegaUtil.truthy).insert(res.data || []));\n\n    pending.done();\n    return res;\n  }\n\n  function loadPending(df) {\n    let accept;\n    const pending = new Promise(a => accept = a);\n\n    pending.requests = 0;\n\n    pending.done = () => {\n      if (--pending.requests === 0) {\n        df._pending = null;\n        accept(df);\n      }\n    };\n\n    return (df._pending = pending);\n  }\n\n  const SKIP$1 = {skip: true};\n\n  /**\n   * Perform operator updates in response to events. Applies an\n   * update function to compute a new operator value. If the update function\n   * returns a {@link ChangeSet}, the operator will be pulsed with those tuple\n   * changes. Otherwise, the operator value will be updated to the return value.\n   * @param {EventStream|Operator} source - The event source to react to.\n   *   This argument can be either an EventStream or an Operator.\n   * @param {Operator|function(object):Operator} target - The operator to update.\n   *   This argument can either be an Operator instance or (if the source\n   *   argument is an EventStream), a function that accepts an event object as\n   *   input and returns an Operator to target.\n   * @param {function(Parameters,Event): *} [update] - Optional update function\n   *   to compute the new operator value, or a literal value to set. Update\n   *   functions expect to receive a parameter object and event as arguments.\n   *   This function can either return a new operator value or (if the source\n   *   argument is an EventStream) a {@link ChangeSet} instance to pulse\n   *   the target operator with tuple changes.\n   * @param {object} [params] - The update function parameters.\n   * @param {object} [options] - Additional options hash. If not overridden,\n   *   updated operators will be skipped by default.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *  be skipped: it will not be evaluated, but its dependents will be.\n   * @param {boolean} [options.force] - If true, the operator will\n   *   be re-evaluated even if its value has not changed.\n   * @return {Dataflow}\n   */\n  function on(source, target, update, params, options) {\n    const fn = source instanceof Operator ? onOperator : onStream;\n    fn(this, source, target, update, params, options);\n    return this;\n  }\n\n  function onStream(df, stream, target, update, params, options) {\n    const opt = vegaUtil.extend({}, options, SKIP$1);\n    let func, op;\n\n    if (!vegaUtil.isFunction(target)) target = vegaUtil.constant(target);\n\n    if (update === undefined) {\n      func = e => df.touch(target(e));\n    } else if (vegaUtil.isFunction(update)) {\n      op = new Operator(null, update, params, false);\n      func = e => {\n        op.evaluate(e);\n        const t = target(e), v = op.value;\n        isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);\n      };\n    } else {\n      func = e => df.update(target(e), update, opt);\n    }\n\n    stream.apply(func);\n  }\n\n  function onOperator(df, source, target, update, params, options) {\n    if (update === undefined) {\n      source.targets().add(target);\n    } else {\n      const opt = options || {},\n            op = new Operator(null, updater(target, update), params, false);\n      op.modified(opt.force);\n      op.rank = source.rank;       // immediately follow source\n      source.targets().add(op);    // add dependency\n\n      if (target) {\n        op.skip(true);             // skip first invocation\n        op.value = target.value;   // initialize value\n        op.targets().add(target);  // chain dependencies\n        df.connect(target, [op]);  // rerank as needed, #1672\n      }\n    }\n  }\n\n  function updater(target, update) {\n    update = vegaUtil.isFunction(update) ? update : vegaUtil.constant(update);\n    return target\n      ? function(_, pulse) {\n          const value = update(_, pulse);\n          if (!target.skip()) {\n            target.skip(value !== this.value).value = value;\n          }\n          return value;\n        }\n      : update;\n  }\n\n  /**\n   * Assigns a rank to an operator. Ranks are assigned in increasing order\n   * by incrementing an internal rank counter.\n   * @param {Operator} op - The operator to assign a rank.\n   */\n  function rank(op) {\n    op.rank = ++this._rank;\n  }\n\n  /**\n   * Re-ranks an operator and all downstream target dependencies. This\n   * is necessary when upstream dependencies of higher rank are added to\n   * a target operator.\n   * @param {Operator} op - The operator to re-rank.\n   */\n  function rerank(op) {\n    const queue = [op];\n    let cur, list, i;\n\n    while (queue.length) {\n      this.rank(cur = queue.pop());\n      if (list = cur._targets) {\n        for (i=list.length; --i >= 0;) {\n          queue.push(cur = list[i]);\n          if (cur === op) vegaUtil.error('Cycle detected in dataflow graph.');\n        }\n      }\n    }\n  }\n\n  /**\n   * Sentinel value indicating pulse propagation should stop.\n   */\n  const StopPropagation = {};\n\n  // Pulse visit type flags\n  const ADD       = (1 << 0),\n        REM       = (1 << 1),\n        MOD       = (1 << 2),\n        ADD_REM   = ADD | REM,\n        ADD_MOD   = ADD | MOD,\n        ALL       = ADD | REM | MOD,\n        REFLOW    = (1 << 3),\n        SOURCE    = (1 << 4),\n        NO_SOURCE = (1 << 5),\n        NO_FIELDS = (1 << 6);\n\n  /**\n   * A Pulse enables inter-operator communication during a run of the\n   * dataflow graph. In addition to the current timestamp, a pulse may also\n   * contain a change-set of added, removed or modified data tuples, as well as\n   * a pointer to a full backing data source. Tuple change sets may not\n   * be fully materialized; for example, to prevent needless array creation\n   * a change set may include larger arrays and corresponding filter functions.\n   * The pulse provides a {@link visit} method to enable proper and efficient\n   * iteration over requested data tuples.\n   *\n   * In addition, each pulse can track modification flags for data tuple fields.\n   * Responsible transform operators should call the {@link modifies} method to\n   * indicate changes to data fields. The {@link modified} method enables\n   * querying of this modification state.\n   *\n   * @constructor\n   * @param {Dataflow} dataflow - The backing dataflow instance.\n   * @param {number} stamp - The current propagation timestamp.\n   * @param {string} [encode] - An optional encoding set name, which is then\n   *   accessible as Pulse.encode. Operators can respond to (or ignore) this\n   *   setting as appropriate. This parameter can be used in conjunction with\n   *   the Encode transform in the vega-encode module.\n   */\n  function Pulse(dataflow, stamp, encode) {\n    this.dataflow = dataflow;\n    this.stamp = stamp == null ? -1 : stamp;\n    this.add = [];\n    this.rem = [];\n    this.mod = [];\n    this.fields = null;\n    this.encode = encode || null;\n  }\n\n  function materialize(data, filter) {\n    const out = [];\n    vegaUtil.visitArray(data, filter, _ => out.push(_));\n    return out;\n  }\n\n  function filter(pulse, flags) {\n    const map = {};\n    pulse.visit(flags, t => { map[tupleid(t)] = 1; });\n    return t => map[tupleid(t)] ? null : t;\n  }\n\n  function addFilter(a, b) {\n    return a\n      ? (t, i) => a(t, i) && b(t, i)\n      : b;\n  }\n\n  Pulse.prototype = {\n\n    /**\n     * Sentinel value indicating pulse propagation should stop.\n     */\n    StopPropagation,\n\n    /**\n     * Boolean flag indicating ADD (added) tuples.\n     */\n    ADD,\n\n    /**\n     * Boolean flag indicating REM (removed) tuples.\n     */\n    REM,\n\n    /**\n     * Boolean flag indicating MOD (modified) tuples.\n     */\n    MOD,\n\n    /**\n     * Boolean flag indicating ADD (added) and REM (removed) tuples.\n     */\n    ADD_REM,\n\n    /**\n     * Boolean flag indicating ADD (added) and MOD (modified) tuples.\n     */\n    ADD_MOD,\n\n    /**\n     * Boolean flag indicating ADD, REM and MOD tuples.\n     */\n    ALL,\n\n    /**\n     * Boolean flag indicating all tuples in a data source\n     * except for the ADD, REM and MOD tuples.\n     */\n    REFLOW,\n\n    /**\n     * Boolean flag indicating a 'pass-through' to a\n     * backing data source, ignoring ADD, REM and MOD tuples.\n     */\n    SOURCE,\n\n    /**\n     * Boolean flag indicating that source data should be\n     * suppressed when creating a forked pulse.\n     */\n    NO_SOURCE,\n\n    /**\n     * Boolean flag indicating that field modifications should be\n     * suppressed when creating a forked pulse.\n     */\n    NO_FIELDS,\n\n    /**\n     * Creates a new pulse based on the values of this pulse.\n     * The dataflow, time stamp and field modification values are copied over.\n     * By default, new empty ADD, REM and MOD arrays are created.\n     * @param {number} flags - Integer of boolean flags indicating which (if any)\n     *   tuple arrays should be copied to the new pulse. The supported flag values\n     *   are ADD, REM and MOD. Array references are copied directly: new array\n     *   instances are not created.\n     * @return {Pulse} - The forked pulse instance.\n     * @see init\n     */\n    fork(flags) {\n      return new Pulse(this.dataflow).init(this, flags);\n    },\n\n    /**\n     * Creates a copy of this pulse with new materialized array\n     * instances for the ADD, REM, MOD, and SOURCE arrays.\n     * The dataflow, time stamp and field modification values are copied over.\n     * @return {Pulse} - The cloned pulse instance.\n     * @see init\n     */\n    clone() {\n      const p = this.fork(ALL);\n      p.add = p.add.slice();\n      p.rem = p.rem.slice();\n      p.mod = p.mod.slice();\n      if (p.source) p.source = p.source.slice();\n      return p.materialize(ALL | SOURCE);\n    },\n\n    /**\n     * Returns a pulse that adds all tuples from a backing source. This is\n     * useful for cases where operators are added to a dataflow after an\n     * upstream data pipeline has already been processed, ensuring that\n     * new operators can observe all tuples within a stream.\n     * @return {Pulse} - A pulse instance with all source tuples included\n     *   in the add array. If the current pulse already has all source\n     *   tuples in its add array, it is returned directly. If the current\n     *   pulse does not have a backing source, it is returned directly.\n     */\n    addAll() {\n      let p = this;\n      const reuse = !p.source\n        || p.add === p.rem // special case for indexed set (e.g., crossfilter)\n        || (!p.rem.length && p.source.length === p.add.length);\n\n      if (reuse) {\n        return p;\n      } else {\n        p = new Pulse(this.dataflow).init(this);\n        p.add = p.source;\n        p.rem = []; // new operators can ignore rem #2769\n        return p;\n      }\n    },\n\n    /**\n     * Initialize this pulse based on the values of another pulse. This method\n     * is used internally by {@link fork} to initialize a new forked tuple.\n     * The dataflow, time stamp and field modification values are copied over.\n     * By default, new empty ADD, REM and MOD arrays are created.\n     * @param {Pulse} src - The source pulse to copy from.\n     * @param {number} flags - Integer of boolean flags indicating which (if any)\n     *   tuple arrays should be copied to the new pulse. The supported flag values\n     *   are ADD, REM and MOD. Array references are copied directly: new array\n     *   instances are not created. By default, source data arrays are copied\n     *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.\n     * @return {Pulse} - Returns this Pulse instance.\n     */\n    init(src, flags) {\n      const p = this;\n      p.stamp = src.stamp;\n      p.encode = src.encode;\n\n      if (src.fields && !(flags & NO_FIELDS)) {\n        p.fields = src.fields;\n      }\n\n      if (flags & ADD) {\n        p.addF = src.addF;\n        p.add = src.add;\n      } else {\n        p.addF = null;\n        p.add = [];\n      }\n\n      if (flags & REM) {\n        p.remF = src.remF;\n        p.rem = src.rem;\n      } else {\n        p.remF = null;\n        p.rem = [];\n      }\n\n      if (flags & MOD) {\n        p.modF = src.modF;\n        p.mod = src.mod;\n      } else {\n        p.modF = null;\n        p.mod = [];\n      }\n\n      if (flags & NO_SOURCE) {\n        p.srcF = null;\n        p.source = null;\n      } else {\n        p.srcF = src.srcF;\n        p.source = src.source;\n        if (src.cleans) p.cleans = src.cleans;\n      }\n\n      return p;\n    },\n\n    /**\n     * Schedules a function to run after pulse propagation completes.\n     * @param {function} func - The function to run.\n     */\n    runAfter(func) {\n      this.dataflow.runAfter(func);\n    },\n\n    /**\n     * Indicates if tuples have been added, removed or modified.\n     * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.\n     *   Defaults to ALL, returning true if any tuple type has changed.\n     * @return {boolean} - Returns true if one or more queried tuple types have\n     *   changed, false otherwise.\n     */\n    changed(flags) {\n      const f = flags || ALL;\n      return ((f & ADD) && this.add.length)\n          || ((f & REM) && this.rem.length)\n          || ((f & MOD) && this.mod.length);\n    },\n\n    /**\n     * Forces a \"reflow\" of tuple values, such that all tuples in the backing\n     * source are added to the MOD set, unless already present in the ADD set.\n     * @param {boolean} [fork=false] - If true, returns a forked copy of this\n     *   pulse, and invokes reflow on that derived pulse.\n     * @return {Pulse} - The reflowed pulse instance.\n     */\n    reflow(fork) {\n      if (fork) return this.fork(ALL).reflow();\n\n      const len = this.add.length,\n            src = this.source && this.source.length;\n      if (src && src !== len) {\n        this.mod = this.source;\n        if (len) this.filter(MOD, filter(this, ADD));\n      }\n      return this;\n    },\n\n    /**\n     * Get/set metadata to pulse requesting garbage collection\n     * to reclaim currently unused resources.\n     */\n    clean(value) {\n      if (arguments.length) {\n        this.cleans = !!value;\n        return this;\n      } else {\n        return this.cleans;\n      }\n    },\n\n    /**\n     * Marks one or more data field names as modified to assist dependency\n     * tracking and incremental processing by transform operators.\n     * @param {string|Array<string>} _ - The field(s) to mark as modified.\n     * @return {Pulse} - This pulse instance.\n     */\n    modifies(_) {\n      const hash = this.fields || (this.fields = {});\n      if (vegaUtil.isArray(_)) {\n        _.forEach(f => hash[f] = true);\n      } else {\n        hash[_] = true;\n      }\n      return this;\n    },\n\n    /**\n     * Checks if one or more data fields have been modified during this pulse\n     * propagation timestamp.\n     * @param {string|Array<string>} _ - The field(s) to check for modified.\n     * @param {boolean} nomod - If true, will check the modified flag even if\n     *   no mod tuples exist. If false (default), mod tuples must be present.\n     * @return {boolean} - Returns true if any of the provided fields has been\n     *   marked as modified, false otherwise.\n     */\n    modified(_, nomod) {\n      const fields = this.fields;\n      return !((nomod || this.mod.length) && fields) ? false\n        : !arguments.length ? !!fields\n        : vegaUtil.isArray(_) ? _.some(f => fields[f])\n        : fields[_];\n    },\n\n    /**\n     * Adds a filter function to one more tuple sets. Filters are applied to\n     * backing tuple arrays, to determine the actual set of tuples considered\n     * added, removed or modified. They can be used to delay materialization of\n     * a tuple set in order to avoid expensive array copies. In addition, the\n     * filter functions can serve as value transformers: unlike standard predicate\n     * function (which return boolean values), Pulse filters should return the\n     * actual tuple value to process. If a tuple set is already filtered, the\n     * new filter function will be appended into a conjuntive ('and') query.\n     * @param {number} flags - Flags indicating the tuple set(s) to filter.\n     * @param {function(*):object} filter - Filter function that will be applied\n     *   to the tuple set array, and should return a data tuple if the value\n     *   should be included in the tuple set, and falsy (or null) otherwise.\n     * @return {Pulse} - Returns this pulse instance.\n     */\n    filter(flags, filter) {\n      const p = this;\n      if (flags & ADD) p.addF = addFilter(p.addF, filter);\n      if (flags & REM) p.remF = addFilter(p.remF, filter);\n      if (flags & MOD) p.modF = addFilter(p.modF, filter);\n      if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);\n      return p;\n    },\n\n    /**\n     * Materialize one or more tuple sets in this pulse. If the tuple set(s) have\n     * a registered filter function, it will be applied and the tuple set(s) will\n     * be replaced with materialized tuple arrays.\n     * @param {number} flags - Flags indicating the tuple set(s) to materialize.\n     * @return {Pulse} - Returns this pulse instance.\n     */\n    materialize(flags) {\n      flags = flags || ALL;\n      const p = this;\n      if ((flags & ADD) && p.addF) {\n        p.add = materialize(p.add, p.addF);\n        p.addF = null;\n      }\n      if ((flags & REM) && p.remF) {\n        p.rem = materialize(p.rem, p.remF);\n        p.remF = null;\n      }\n      if ((flags & MOD) && p.modF) {\n        p.mod = materialize(p.mod, p.modF);\n        p.modF = null;\n      }\n      if ((flags & SOURCE) && p.srcF) {\n        p.source = p.source.filter(p.srcF);\n        p.srcF = null;\n      }\n      return p;\n    },\n\n    /**\n     * Visit one or more tuple sets in this pulse.\n     * @param {number} flags - Flags indicating the tuple set(s) to visit.\n     *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source\n     *   has been set).\n     * @param {function(object):*} - Visitor function invoked per-tuple.\n     * @return {Pulse} - Returns this pulse instance.\n     */\n    visit(flags, visitor) {\n      const p = this, v = visitor;\n\n      if (flags & SOURCE) {\n        vegaUtil.visitArray(p.source, p.srcF, v);\n        return p;\n      }\n\n      if (flags & ADD) vegaUtil.visitArray(p.add, p.addF, v);\n      if (flags & REM) vegaUtil.visitArray(p.rem, p.remF, v);\n      if (flags & MOD) vegaUtil.visitArray(p.mod, p.modF, v);\n\n      const src = p.source;\n      if ((flags & REFLOW) && src) {\n        const sum = p.add.length + p.mod.length;\n        if (sum === src.length) ; else if (sum) {\n          vegaUtil.visitArray(src, filter(p, ADD_MOD), v);\n        } else {\n          // if no add/rem/mod tuples, visit source\n          vegaUtil.visitArray(src, p.srcF, v);\n        }\n      }\n\n      return p;\n    }\n  };\n\n  /**\n   * Represents a set of multiple pulses. Used as input for operators\n   * that accept multiple pulses at a time. Contained pulses are\n   * accessible via the public \"pulses\" array property. This pulse doe\n   * not carry added, removed or modified tuples directly. However,\n   * the visit method can be used to traverse all such tuples contained\n   * in sub-pulses with a timestamp matching this parent multi-pulse.\n   * @constructor\n   * @param {Dataflow} dataflow - The backing dataflow instance.\n   * @param {number} stamp - The timestamp.\n   * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.\n   */\n  function MultiPulse(dataflow, stamp, pulses, encode) {\n    const p = this,\n          n = pulses.length;\n    let c = 0;\n\n    this.dataflow = dataflow;\n    this.stamp = stamp;\n    this.fields = null;\n    this.encode = encode || null;\n    this.pulses = pulses;\n\n    for (let i = 0; i < n; ++i) {\n      const pulse = pulses[i];\n      if (pulse.stamp !== stamp) continue;\n\n      if (pulse.fields) {\n        const hash = p.fields || (p.fields = {});\n        for (const f in pulse.fields) { hash[f] = 1; }\n      }\n\n      if (pulse.changed(p.ADD)) c |= p.ADD;\n      if (pulse.changed(p.REM)) c |= p.REM;\n      if (pulse.changed(p.MOD)) c |= p.MOD;\n    }\n\n    this.changes = c;\n  }\n\n  vegaUtil.inherits(MultiPulse, Pulse, {\n    /**\n     * Creates a new pulse based on the values of this pulse.\n     * The dataflow, time stamp and field modification values are copied over.\n     * @return {Pulse}\n     */\n    fork(flags) {\n      const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);\n      if (flags !== undefined) {\n        if (flags & p.ADD) this.visit(p.ADD, t => p.add.push(t));\n        if (flags & p.REM) this.visit(p.REM, t => p.rem.push(t));\n        if (flags & p.MOD) this.visit(p.MOD, t => p.mod.push(t));\n      }\n      return p;\n    },\n\n    changed(flags) {\n      return this.changes & flags;\n    },\n\n    modified(_) {\n      const p = this, fields = p.fields;\n      return !(fields && (p.changes & p.MOD)) ? 0\n        : vegaUtil.isArray(_) ? _.some(f => fields[f])\n        : fields[_];\n    },\n\n    filter() {\n      vegaUtil.error('MultiPulse does not support filtering.');\n    },\n\n    materialize() {\n      vegaUtil.error('MultiPulse does not support materialization.');\n    },\n\n    visit(flags, visitor) {\n      const p = this,\n            pulses = p.pulses,\n            n = pulses.length;\n      let i = 0;\n\n      if (flags & p.SOURCE) {\n        for (; i < n; ++i) {\n          pulses[i].visit(flags, visitor);\n        }\n      } else {\n        for (; i < n; ++i) {\n          if (pulses[i].stamp === p.stamp) {\n            pulses[i].visit(flags, visitor);\n          }\n        }\n      }\n\n      return p;\n    }\n  });\n\n  /* eslint-disable require-atomic-updates */\n\n  /**\n   * Evaluates the dataflow and returns a Promise that resolves when pulse\n   * propagation completes. This method will increment the current timestamp\n   * and process all updated, pulsed and touched operators. When invoked for\n   * the first time, all registered operators will be processed. This method\n   * should not be invoked by third-party clients, use {@link runAsync} or\n   * {@link run} instead.\n   * @param {string} [encode] - The name of an encoding set to invoke during\n   *   propagation. This value is added to generated Pulse instances;\n   *   operators can then respond to (or ignore) this setting as appropriate.\n   *   This parameter can be used in conjunction with the Encode transform in\n   *   the vega-encode package.\n   * @param {function} [prerun] - An optional callback function to invoke\n   *   immediately before dataflow evaluation commences.\n   * @param {function} [postrun] - An optional callback function to invoke\n   *   after dataflow evaluation completes. The callback will be invoked\n   *   after those registered via {@link runAfter}.\n   * @return {Promise} - A promise that resolves to this dataflow after\n   *   evaluation completes.\n   */\n  async function evaluate(encode, prerun, postrun) {\n    const df = this,\n          async = [];\n\n    // if the pulse value is set, this is a re-entrant call\n    if (df._pulse) return reentrant(df);\n\n    // wait for pending datasets to load\n    if (df._pending) await df._pending;\n\n    // invoke prerun function, if provided\n    if (prerun) await asyncCallback(df, prerun);\n\n    // exit early if there are no updates\n    if (!df._touched.length) {\n      df.debug('Dataflow invoked, but nothing to do.');\n      return df;\n    }\n\n    // increment timestamp clock\n    const stamp = ++df._clock;\n\n    // set the current pulse\n    df._pulse = new Pulse(df, stamp, encode);\n\n    // initialize priority queue, reset touched operators\n    df._touched.forEach(op => df._enqueue(op, true));\n    df._touched = UniqueList(vegaUtil.id);\n\n    let count = 0, op, next, error;\n\n    try {\n      while (df._heap.size() > 0) {\n        // dequeue operator with highest priority\n        op = df._heap.pop();\n\n        // re-queue if rank changed\n        if (op.rank !== op.qrank) {\n          df._enqueue(op, true);\n          continue;\n        }\n\n        // otherwise, evaluate the operator\n        next = op.run(df._getPulse(op, encode));\n\n        if (next.then) {\n          // await if operator returns a promise directly\n          next = await next;\n        } else if (next.async) {\n          // queue parallel asynchronous execution\n          async.push(next.async);\n          next = StopPropagation;\n        }\n\n        // propagate evaluation, enqueue dependent operators\n        if (next !== StopPropagation) {\n          if (op._targets) op._targets.forEach(op => df._enqueue(op));\n        }\n\n        // increment visit counter\n        ++count;\n      }\n    } catch (err) {\n      df._heap.clear();\n      error = err;\n    }\n\n    // reset pulse map\n    df._input = {};\n    df._pulse = null;\n\n    df.debug(`Pulse ${stamp}: ${count} operators`);\n\n    if (error) {\n      df._postrun = [];\n      df.error(error);\n    }\n\n    // invoke callbacks queued via runAfter\n    if (df._postrun.length) {\n      const pr = df._postrun.sort((a, b) => b.priority - a.priority);\n      df._postrun = [];\n      for (let i=0; i<pr.length; ++i) {\n        await asyncCallback(df, pr[i].callback);\n      }\n    }\n\n    // invoke postrun function, if provided\n    if (postrun) await asyncCallback(df, postrun);\n\n    // handle non-blocking asynchronous callbacks\n    if (async.length) {\n      Promise.all(async)\n        .then(cb => df.runAsync(null, () => {\n          cb.forEach(f => { try { f(df); } catch (err) { df.error(err); } });\n        }));\n    }\n\n    return df;\n  }\n\n  /**\n   * Queues dataflow evaluation to run once any other queued evaluations have\n   * completed and returns a Promise that resolves when the queued pulse\n   * propagation completes. If provided, a callback function will be invoked\n   * immediately before evaluation commences. This method will ensure a\n   * separate evaluation is invoked for each time it is called.\n   * @param {string} [encode] - The name of an encoding set to invoke during\n   *   propagation. This value is added to generated Pulse instances;\n   *   operators can then respond to (or ignore) this setting as appropriate.\n   *   This parameter can be used in conjunction with the Encode transform in\n   *   the vega-encode package.\n   * @param {function} [prerun] - An optional callback function to invoke\n   *   immediately before dataflow evaluation commences.\n   * @param {function} [postrun] - An optional callback function to invoke\n   *   after dataflow evaluation completes. The callback will be invoked\n   *   after those registered via {@link runAfter}.\n   * @return {Promise} - A promise that resolves to this dataflow after\n   *   evaluation completes.\n   */\n  async function runAsync(encode, prerun, postrun) {\n    // await previously queued functions\n    while (this._running) await this._running;\n\n    // run dataflow, manage running promise\n    const clear = () => this._running = null;\n    (this._running = this.evaluate(encode, prerun, postrun))\n      .then(clear, clear);\n\n    return this._running;\n  }\n\n  /**\n   * Requests dataflow evaluation and the immediately returns this dataflow\n   * instance. If there are pending data loading or other asynchronous\n   * operations, the dataflow will evaluate asynchronously after this method\n   * has been invoked. To track when dataflow evaluation completes, use the\n   * {@link runAsync} method instead. This method will raise an error if\n   * invoked while the dataflow is already in the midst of evaluation.\n   * @param {string} [encode] - The name of an encoding set to invoke during\n   *   propagation. This value is added to generated Pulse instances;\n   *   operators can then respond to (or ignore) this setting as appropriate.\n   *   This parameter can be used in conjunction with the Encode transform in\n   *   the vega-encode module.\n   * @param {function} [prerun] - An optional callback function to invoke\n   *   immediately before dataflow evaluation commences.\n   * @param {function} [postrun] - An optional callback function to invoke\n   *   after dataflow evaluation completes. The callback will be invoked\n   *   after those registered via {@link runAfter}.\n   * @return {Dataflow} - This dataflow instance.\n   */\n  function run(encode, prerun, postrun) {\n    return this._pulse ? reentrant(this)\n      : (this.evaluate(encode, prerun, postrun), this);\n  }\n\n  /**\n   * Schedules a callback function to be invoked after the current pulse\n   * propagation completes. If no propagation is currently occurring,\n   * the function is invoked immediately. Callbacks scheduled via runAfter\n   * are invoked immediately upon completion of the current cycle, before\n   * any request queued via runAsync. This method is primarily intended for\n   * internal use. Third-party callers using runAfter to schedule a callback\n   * that invokes {@link run} or {@link runAsync} should not use this method,\n   * but instead use {@link runAsync} with prerun or postrun arguments.\n   * @param {function(Dataflow)} callback - The callback function to run.\n   *   The callback will be invoked with this Dataflow instance as its\n   *   sole argument.\n   * @param {boolean} enqueue - A boolean flag indicating that the\n   *   callback should be queued up to run after the next propagation\n   *   cycle, suppressing immediate invocation when propagation is not\n   *   currently occurring.\n   * @param {number} [priority] - A priority value used to sort registered\n   *   callbacks to determine execution order. This argument is intended\n   *   for internal Vega use only.\n   */\n  function runAfter(callback, enqueue, priority) {\n    if (this._pulse || enqueue) {\n      // pulse propagation is currently running, queue to run after\n      this._postrun.push({\n        priority: priority || 0,\n        callback: callback\n      });\n    } else {\n      // pulse propagation already complete, invoke immediately\n      try { callback(this); } catch (err) { this.error(err); }\n    }\n  }\n\n  /**\n   * Raise an error for re-entrant dataflow evaluation.\n   */\n  function reentrant(df) {\n    df.error('Dataflow already running. Use runAsync() to chain invocations.');\n    return df;\n  }\n\n  /**\n   * Enqueue an operator into the priority queue for evaluation. The operator\n   * will be enqueued if it has no registered pulse for the current cycle, or if\n   * the force argument is true. Upon enqueue, this method also sets the\n   * operator's qrank to the current rank value.\n   * @param {Operator} op - The operator to enqueue.\n   * @param {boolean} [force] - A flag indicating if the operator should be\n   *   forceably added to the queue, even if it has already been previously\n   *   enqueued during the current pulse propagation. This is useful when the\n   *   dataflow graph is dynamically modified and the operator rank changes.\n   */\n  function enqueue(op, force) {\n    const q = op.stamp < this._clock;\n    if (q) op.stamp = this._clock;\n    if (q || force) {\n      op.qrank = op.rank;\n      this._heap.push(op);\n    }\n  }\n\n  /**\n   * Provide a correct pulse for evaluating an operator. If the operator has an\n   * explicit source operator, we will try to pull the pulse(s) from it.\n   * If there is an array of source operators, we build a multi-pulse.\n   * Otherwise, we return a current pulse with correct source data.\n   * If the pulse is the pulse map has an explicit target set, we use that.\n   * Else if the pulse on the upstream source operator is current, we use that.\n   * Else we use the pulse from the pulse map, but copy the source tuple array.\n   * @param {Operator} op - The operator for which to get an input pulse.\n   * @param {string} [encode] - An (optional) encoding set name with which to\n   *   annotate the returned pulse. See {@link run} for more information.\n   */\n  function getPulse(op, encode) {\n    const s = op.source,\n          stamp = this._clock;\n\n    return s && vegaUtil.isArray(s)\n      ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode)\n      : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);\n  }\n\n  function singlePulse(p, s) {\n    if (s && s.stamp === p.stamp) {\n      return s;\n    }\n\n    p = p.fork();\n    if (s && s !== StopPropagation) {\n      p.source = s.source;\n    }\n    return p;\n  }\n\n  const NO_OPT = {skip: false, force: false};\n\n  /**\n   * Touches an operator, scheduling it to be evaluated. If invoked outside of\n   * a pulse propagation, the operator will be evaluated the next time this\n   * dataflow is run. If invoked in the midst of pulse propagation, the operator\n   * will be queued for evaluation if and only if the operator has not yet been\n   * evaluated on the current propagation timestamp.\n   * @param {Operator} op - The operator to touch.\n   * @param {object} [options] - Additional options hash.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *   be skipped: it will not be evaluated, but its dependents will be.\n   * @return {Dataflow}\n   */\n  function touch(op, options) {\n    const opt = options || NO_OPT;\n    if (this._pulse) {\n      // if in midst of propagation, add to priority queue\n      this._enqueue(op);\n    } else {\n      // otherwise, queue for next propagation\n      this._touched.add(op);\n    }\n    if (opt.skip) op.skip(true);\n    return this;\n  }\n\n  /**\n   * Updates the value of the given operator.\n   * @param {Operator} op - The operator to update.\n   * @param {*} value - The value to set.\n   * @param {object} [options] - Additional options hash.\n   * @param {boolean} [options.force] - If true, the operator will\n   *   be re-evaluated even if its value has not changed.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *   be skipped: it will not be evaluated, but its dependents will be.\n   * @return {Dataflow}\n   */\n  function update(op, value, options) {\n    const opt = options || NO_OPT;\n    if (op.set(value) || opt.force) {\n      this.touch(op, opt);\n    }\n    return this;\n  }\n\n  /**\n   * Pulses an operator with a changeset of tuples. If invoked outside of\n   * a pulse propagation, the pulse will be applied the next time this\n   * dataflow is run. If invoked in the midst of pulse propagation, the pulse\n   * will be added to the set of active pulses and will be applied if and\n   * only if the target operator has not yet been evaluated on the current\n   * propagation timestamp.\n   * @param {Operator} op - The operator to pulse.\n   * @param {ChangeSet} value - The tuple changeset to apply.\n   * @param {object} [options] - Additional options hash.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *   be skipped: it will not be evaluated, but its dependents will be.\n   * @return {Dataflow}\n   */\n  function pulse(op, changeset, options) {\n    this.touch(op, options || NO_OPT);\n\n    const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),\n          t = op.pulse && op.pulse.source || [];\n\n    p.target = op;\n    this._input[op.id] = changeset.pulse(p, t);\n\n    return this;\n  }\n\n  function Heap(cmp) {\n    let nodes = [];\n    return {\n      clear: () => nodes = [],\n      size: () => nodes.length,\n      peek: () => nodes[0],\n      push: x => {\n        nodes.push(x);\n        return siftdown(nodes, 0, nodes.length - 1, cmp);\n      },\n      pop: () => {\n        const last = nodes.pop();\n        let item;\n        if (nodes.length) {\n          item = nodes[0];\n          nodes[0] = last;\n          siftup(nodes, 0, cmp);\n        } else {\n          item = last;\n        }\n        return item;\n      }\n    };\n  }\n\n  function siftdown(array, start, idx, cmp) {\n    let parent, pidx;\n\n    const item = array[idx];\n    while (idx > start) {\n      pidx = (idx - 1) >> 1;\n      parent = array[pidx];\n      if (cmp(item, parent) < 0) {\n        array[idx] = parent;\n        idx = pidx;\n        continue;\n      }\n      break;\n    }\n    return (array[idx] = item);\n  }\n\n  function siftup(array, idx, cmp) {\n    const start = idx,\n          end = array.length,\n          item = array[idx];\n    let cidx = (idx << 1) + 1, ridx;\n\n    while (cidx < end) {\n      ridx = cidx + 1;\n      if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\n        cidx = ridx;\n      }\n      array[idx] = array[cidx];\n      idx = cidx;\n      cidx = (idx << 1) + 1;\n    }\n    array[idx] = item;\n    return siftdown(array, start, idx, cmp);\n  }\n\n  /**\n   * A dataflow graph for reactive processing of data streams.\n   * @constructor\n   */\n  function Dataflow() {\n    this.logger(vegaUtil.logger());\n    this.logLevel(vegaUtil.Error);\n\n    this._clock = 0;\n    this._rank = 0;\n    this._locale = vegaFormat.defaultLocale();\n    try {\n      this._loader = vegaLoader.loader();\n    } catch (e) {\n      // do nothing if loader module is unavailable\n    }\n\n    this._touched = UniqueList(vegaUtil.id);\n    this._input = {};\n    this._pulse = null;\n\n    this._heap = Heap((a, b) => a.qrank - b.qrank);\n    this._postrun = [];\n  }\n\n  function logMethod(method) {\n    return function() {\n      return this._log[method].apply(this, arguments);\n    };\n  }\n\n  Dataflow.prototype = {\n\n    /**\n     * The current timestamp of this dataflow. This value reflects the\n     * timestamp of the previous dataflow run. The dataflow is initialized\n     * with a stamp value of 0. The initial run of the dataflow will have\n     * a timestap of 1, and so on. This value will match the\n     * {@link Pulse.stamp} property.\n     * @return {number} - The current timestamp value.\n     */\n    stamp() {\n      return this._clock;\n    },\n\n    /**\n     * Gets or sets the loader instance to use for data file loading. A\n     * loader object must provide a \"load\" method for loading files and a\n     * \"sanitize\" method for checking URL/filename validity. Both methods\n     * should accept a URI and options hash as arguments, and return a Promise\n     * that resolves to the loaded file contents (load) or a hash containing\n     * sanitized URI data with the sanitized url assigned to the \"href\" property\n     * (sanitize).\n     * @param {object} _ - The loader instance to use.\n     * @return {object|Dataflow} - If no arguments are provided, returns\n     *   the current loader instance. Otherwise returns this Dataflow instance.\n     */\n    loader(_) {\n      if (arguments.length) {\n        this._loader = _;\n        return this;\n      } else {\n        return this._loader;\n      }\n    },\n\n    /**\n     * Gets or sets the locale instance to use for formatting and parsing\n     * string values. The locale object should be provided by the\n     * vega-format library, and include methods such as format, timeFormat,\n     * utcFormat, timeParse, and utcParse.\n     * @param {object} _ - The locale instance to use.\n     * @return {object|Dataflow} - If no arguments are provided, returns\n     *   the current locale instance. Otherwise returns this Dataflow instance.\n     */\n    locale(_) {\n      if (arguments.length) {\n        this._locale = _;\n        return this;\n      } else {\n        return this._locale;\n      }\n    },\n\n    /**\n     * Get or set the logger instance used to log messages. If no arguments are\n     * provided, returns the current logger instance. Otherwise, sets the logger\n     * and return this Dataflow instance. Provided loggers must support the full\n     * API of logger objects generated by the vega-util logger method. Note that\n     * by default the log level of the new logger will be used; use the logLevel\n     * method to adjust the log level as needed.\n     */\n    logger(logger) {\n      if (arguments.length) {\n        this._log = logger;\n        return this;\n      } else {\n        return this._log;\n      }\n    },\n\n    /**\n     * Logs an error message. By default, logged messages are written to console\n     * output. The message will only be logged if the current log level is high\n     * enough to permit error messages.\n     */\n    error: logMethod('error'),\n\n    /**\n     * Logs a warning message. By default, logged messages are written to console\n     * output. The message will only be logged if the current log level is high\n     * enough to permit warning messages.\n     */\n    warn: logMethod('warn'),\n\n    /**\n     * Logs a information message. By default, logged messages are written to\n     * console output. The message will only be logged if the current log level is\n     * high enough to permit information messages.\n     */\n    info: logMethod('info'),\n\n    /**\n     * Logs a debug message. By default, logged messages are written to console\n     * output. The message will only be logged if the current log level is high\n     * enough to permit debug messages.\n     */\n    debug: logMethod('debug'),\n\n    /**\n     * Get or set the current log level. If an argument is provided, it\n     * will be used as the new log level.\n     * @param {number} [level] - Should be one of None, Warn, Info\n     * @return {number} - The current log level.\n     */\n    logLevel: logMethod('level'),\n\n    /**\n     * Empty entry threshold for garbage cleaning. Map data structures will\n     * perform cleaning once the number of empty entries exceeds this value.\n     */\n    cleanThreshold: 1e4,\n\n    // OPERATOR REGISTRATION\n    add,\n    connect,\n    rank,\n    rerank,\n\n    // OPERATOR UPDATES\n    pulse,\n    touch,\n    update,\n    changeset,\n\n    // DATA LOADING\n    ingest: ingest$1,\n    parse,\n    preload,\n    request,\n\n    // EVENT HANDLING\n    events,\n    on,\n\n    // PULSE PROPAGATION\n    evaluate,\n    run,\n    runAsync,\n    runAfter,\n    _enqueue: enqueue,\n    _getPulse: getPulse\n  };\n\n  /**\n   * Abstract class for operators that process data tuples.\n   * Subclasses must provide a {@link transform} method for operator processing.\n   * @constructor\n   * @param {*} [init] - The initial value for this operator.\n   * @param {object} [params] - The parameters for this operator.\n   * @param {Operator} [source] - The operator from which to receive pulses.\n   */\n  function Transform(init, params) {\n    Operator.call(this, init, null, params);\n  }\n\n  vegaUtil.inherits(Transform, Operator, {\n    /**\n     * Overrides {@link Operator.evaluate} for transform operators.\n     * Internally, this method calls {@link evaluate} to perform processing.\n     * If {@link evaluate} returns a falsy value, the input pulse is returned.\n     * This method should NOT be overridden, instead overrride {@link evaluate}.\n     * @param {Pulse} pulse - the current dataflow pulse.\n     * @return the output pulse for this operator (or StopPropagation)\n     */\n    run(pulse) {\n      if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n\n      let rv;\n      if (this.skip()) {\n        this.skip(false);\n      } else {\n        rv = this.evaluate(pulse);\n      }\n      rv = rv || pulse;\n\n      if (rv.then) {\n        rv = rv.then(_ => this.pulse =_);\n      } else if (rv !== pulse.StopPropagation) {\n        this.pulse = rv;\n      }\n\n      return rv;\n    },\n\n    /**\n     * Overrides {@link Operator.evaluate} for transform operators.\n     * Marshalls parameter values and then invokes {@link transform}.\n     * @param {Pulse} pulse - the current dataflow pulse.\n     * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n         value (including undefined) will let the input pulse pass through.\n    */\n    evaluate(pulse) {\n      const params = this.marshall(pulse.stamp),\n            out = this.transform(params, pulse);\n      params.clear();\n      return out;\n    },\n\n    /**\n     * Process incoming pulses.\n     * Subclasses should override this method to implement transforms.\n     * @param {Parameters} _ - The operator parameter values.\n     * @param {Pulse} pulse - The current dataflow pulse.\n     * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n     *   value (including undefined) will let the input pulse pass through.\n     */\n    transform() {}\n  });\n\n  const transforms = {};\n\n  function definition(type) {\n    const t = transform(type);\n    return t && t.Definition || null;\n  }\n\n  function transform(type) {\n    type = type && type.toLowerCase();\n    return vegaUtil.hasOwnProperty(transforms, type) ? transforms[type] : null;\n  }\n\n  exports.Dataflow = Dataflow;\n  exports.EventStream = EventStream;\n  exports.MultiPulse = MultiPulse;\n  exports.Operator = Operator;\n  exports.Parameters = Parameters;\n  exports.Pulse = Pulse;\n  exports.Transform = Transform;\n  exports.UniqueList = UniqueList;\n  exports.asyncCallback = asyncCallback;\n  exports.changeset = changeset;\n  exports.definition = definition;\n  exports.derive = derive;\n  exports.ingest = ingest;\n  exports.isChangeSet = isChangeSet;\n  exports.isTuple = isTuple;\n  exports.rederive = rederive;\n  exports.replace = replace;\n  exports.stableCompare = stableCompare;\n  exports.transform = transform;\n  exports.transforms = transforms;\n  exports.tupleid = tupleid;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$vega_format$build$vega_format","~$module$node_modules$vega_loader$build$vega_loader","~$module$node_modules$vega_util$build$vega_util"]],"~:properties",["^5",["addAll","skip","modifies","_targets","_apply","callback","_running","peek","consume","REFLOW","dataflow","ADD","remF","SOURCE","debounce","materialize","priority","_argval","index","_input","logLevel","prototype","initonly","visit","Parameters","cleans","pop","_filter","_argops","rederive","isChangeSet","_enqueue","__esModule","addF","force","detach","info","warn","pulses","qrank","error","id","run","transform","flags","runAfter","push","vega","_pending","rank","srcF","update","StopPropagation","derive","touch","UniqueList","apply","rem","loader","MOD","pulse","name","locale","replace","value","modify","stableCompare","evaluate","connect","preload","context","ADD_MOD","status","field","marshall","request","remove","writable","debug","modF","changes","targets","on","filter","MultiPulse","isTuple","Pulse","definition","logger","events","asyncCallback","stamp","Transform","_pulse","_consume","mod","ADD_REM","EventStream","source","reflow","between","Operator","rerank","init","fields","modified","_log","target","ingest","changed","insert","_touched","clone","transforms","parse","NO_FIELDS","_getPulse","Dataflow","response","add","_clock","set","_heap","clean","tuple","size","fork","op","clear","cleanThreshold","tupleid","NO_SOURCE","ALL","parameters","REM","_update","data","merge","throttle","encode","done","receive","_postrun","requests","_locale","constructor","_loader","changeset","_rank","runAsync"]],"~:compiled-at",1600144479810,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_dataflow$build$vega_dataflow.js\",\n\"lineCount\":51,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-dataflow/build/vega-dataflow.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_dataflow$build$vega_dataflow\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-loader'), require('vega-format')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-loader', 'vega-format'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega, global.vega));\\n}(this, (function (exports, vegaUtil, vegaLoader, vegaFormat) { 'use strict';\\n\\n  function UniqueList(idFunc) {\\n    const $ = idFunc || vegaUtil.identity,\\n          list = [],\\n          ids = {};\\n\\n    list.add = _ => {\\n      const id = $(_);\\n      if (!ids[id]) {\\n        ids[id] = 1;\\n        list.push(_);\\n      }\\n      return list;\\n    };\\n\\n    list.remove = _ => {\\n      const id = $(_);\\n      if (ids[id]) {\\n        ids[id] = 0;\\n        const idx = list.indexOf(_);\\n        if (idx >= 0) list.splice(idx, 1);\\n      }\\n      return list;\\n    };\\n\\n    return list;\\n  }\\n\\n  /**\\n   * Invoke and await a potentially async callback function. If\\n   * an error occurs, trap it and route to Dataflow.error.\\n   * @param {Dataflow} df - The dataflow instance\\n   * @param {function} callback - A callback function to invoke\\n   *   and then await. The dataflow will be passed as the single\\n   *   argument to the function.\\n   */\\n  async function asyncCallback(df, callback) {\\n    try { await callback(df); } catch (err) { df.error(err); }\\n  }\\n\\n  const TUPLE_ID_KEY = Symbol('vega_id');\\n  let TUPLE_ID = 1;\\n\\n  /**\\n   * Checks if an input value is a registered tuple.\\n   * @param {*} t - The value to check.\\n   * @return {boolean} True if the input is a tuple, false otherwise.\\n   */\\n  function isTuple(t) {\\n    return !!(t && tupleid(t));\\n  }\\n\\n  /**\\n   * Returns the id of a tuple.\\n   * @param {object} t - The input tuple.\\n   * @return {*} the tuple id.\\n   */\\n  function tupleid(t) {\\n    return t[TUPLE_ID_KEY];\\n  }\\n\\n  /**\\n   * Sets the id of a tuple.\\n   * @param {object} t - The input tuple.\\n   * @param {*} id - The id value to set.\\n   * @return {object} the input tuple.\\n   */\\n  function setid(t, id) {\\n    t[TUPLE_ID_KEY] = id;\\n    return t;\\n  }\\n\\n  /**\\n   * Ingest an object or value as a data tuple.\\n   * If the input value is an object, an id field will be added to it. For\\n   * efficiency, the input object is modified directly. A copy is not made.\\n   * If the input value is a literal, it will be wrapped in a new object\\n   * instance, with the value accessible as the 'data' property.\\n   * @param datum - The value to ingest.\\n   * @return {object} The ingested data tuple.\\n   */\\n  function ingest(datum) {\\n    const t = (datum === Object(datum)) ? datum : {data: datum};\\n    return tupleid(t) ? t : setid(t, TUPLE_ID++);\\n  }\\n\\n  /**\\n   * Given a source tuple, return a derived copy.\\n   * @param {object} t - The source tuple.\\n   * @return {object} The derived tuple.\\n   */\\n  function derive(t) {\\n    return rederive(t, ingest({}));\\n  }\\n\\n  /**\\n   * Rederive a derived tuple by copying values from the source tuple.\\n   * @param {object} t - The source tuple.\\n   * @param {object} d - The derived tuple.\\n   * @return {object} The derived tuple.\\n   */\\n  function rederive(t, d) {\\n    for (const k in t) d[k] = t[k];\\n    return d;\\n  }\\n\\n  /**\\n   * Replace an existing tuple with a new tuple.\\n   * @param {object} t - The existing data tuple.\\n   * @param {object} d - The new tuple that replaces the old.\\n   * @return {object} The new tuple.\\n   */\\n  function replace(t, d) {\\n    return setid(d, tupleid(t));\\n  }\\n\\n  /**\\n   * Generate an augmented comparator function that provides stable\\n   * sorting by tuple id when the given comparator produces ties.\\n   * @param {function} cmp - The comparator to augment.\\n   * @param {function} [f] - Optional tuple accessor function.\\n   * @return {function} An augmented comparator function.\\n   */\\n  function stableCompare(cmp, f) {\\n    return !cmp ? null\\n      : f ? (a, b) => cmp(a, b) || (tupleid(f(a)) - tupleid(f(b)))\\n      : (a, b) => cmp(a, b) || (tupleid(a) - tupleid(b));\\n  }\\n\\n  function isChangeSet(v) {\\n    return v && v.constructor === changeset;\\n  }\\n\\n  function changeset() {\\n    const add = [],  // insert tuples\\n          rem = [],  // remove tuples\\n          mod = [],  // modify tuples\\n          remp = [], // remove by predicate\\n          modp = []; // modify by predicate\\n    let clean = null,\\n        reflow = false;\\n\\n    return {\\n      constructor: changeset,\\n      insert(t) {\\n        const d = vegaUtil.array(t), n = d.length;\\n        for (let i = 0; i < n; ++i) add.push(d[i]);\\n        return this;\\n      },\\n      remove(t) {\\n        const a = vegaUtil.isFunction(t) ? remp : rem,\\n              d = vegaUtil.array(t),\\n              n = d.length;\\n        for (let i = 0; i < n; ++i) a.push(d[i]);\\n        return this;\\n      },\\n      modify(t, field, value) {\\n        const m = {field: field, value: vegaUtil.constant(value)};\\n        if (vegaUtil.isFunction(t)) {\\n          m.filter = t;\\n          modp.push(m);\\n        } else {\\n          m.tuple = t;\\n          mod.push(m);\\n        }\\n        return this;\\n      },\\n      encode(t, set) {\\n        if (vegaUtil.isFunction(t)) modp.push({filter: t, field: set});\\n        else mod.push({tuple: t, field: set});\\n        return this;\\n      },\\n      clean(value) {\\n        clean = value;\\n        return this;\\n      },\\n      reflow() {\\n        reflow = true;\\n        return this;\\n      },\\n      pulse(pulse, tuples) {\\n        const cur = {}, out = {};\\n        let i, n, m, f, t, id;\\n\\n        // build lookup table of current tuples\\n        for (i = 0, n = tuples.length; i < n; ++i) {\\n          cur[tupleid(tuples[i])] = 1;\\n        }\\n\\n        // process individual tuples to remove\\n        for (i = 0, n = rem.length; i < n; ++i) {\\n          t = rem[i];\\n          cur[tupleid(t)] = -1;\\n        }\\n\\n        // process predicate-based removals\\n        for (i = 0, n = remp.length; i < n; ++i) {\\n          f = remp[i];\\n          tuples.forEach(t => {\\n            if (f(t)) cur[tupleid(t)] = -1;\\n          });\\n        }\\n\\n        // process all add tuples\\n        for (i = 0, n = add.length; i < n; ++i) {\\n          t = add[i];\\n          id = tupleid(t);\\n          if (cur[id]) {\\n            // tuple already resides in dataset\\n            // if flagged for both add and remove, cancel\\n            cur[id] = 1;\\n          } else {\\n            // tuple does not reside in dataset, add\\n            pulse.add.push(ingest(add[i]));\\n          }\\n        }\\n\\n        // populate pulse rem list\\n        for (i = 0, n = tuples.length; i < n; ++i) {\\n          t = tuples[i];\\n          if (cur[tupleid(t)] < 0) pulse.rem.push(t);\\n        }\\n\\n        // modify helper method\\n        function modify(t, f, v) {\\n          if (v) {\\n            t[f] = v(t);\\n          } else {\\n            pulse.encode = f;\\n          }\\n          if (!reflow) out[tupleid(t)] = t;\\n        }\\n\\n        // process individual tuples to modify\\n        for (i = 0, n = mod.length; i < n; ++i) {\\n          m = mod[i];\\n          t = m.tuple;\\n          f = m.field;\\n          id = cur[tupleid(t)];\\n          if (id > 0) {\\n            modify(t, f, m.value);\\n            pulse.modifies(f);\\n          }\\n        }\\n\\n        // process predicate-based modifications\\n        for (i = 0, n = modp.length; i < n; ++i) {\\n          m = modp[i];\\n          f = m.filter;\\n          tuples.forEach(t => {\\n            if (f(t) && cur[tupleid(t)] > 0) {\\n              modify(t, m.field, m.value);\\n            }\\n          });\\n          pulse.modifies(m.field);\\n        }\\n\\n        // upon reflow request, populate mod with all non-removed tuples\\n        // otherwise, populate mod with modified tuples only\\n        if (reflow) {\\n          pulse.mod = rem.length || remp.length\\n            ? tuples.filter(t => cur[tupleid(t)] > 0)\\n            : tuples.slice();\\n        } else {\\n          for (id in out) pulse.mod.push(out[id]);\\n        }\\n\\n        // set pulse garbage collection request\\n        if (clean || clean == null && (rem.length || remp.length)) {\\n          pulse.clean(true);\\n        }\\n\\n        return pulse;\\n      }\\n    };\\n  }\\n\\n  const CACHE = '_:mod:_';\\n\\n  /**\\n   * Hash that tracks modifications to assigned values.\\n   * Callers *must* use the set method to update values.\\n   */\\n  function Parameters() {\\n    Object.defineProperty(this, CACHE, {writable: true, value: {}});\\n  }\\n\\n  Parameters.prototype = {\\n    /**\\n     * Set a parameter value. If the parameter value changes, the parameter\\n     * will be recorded as modified.\\n     * @param {string} name - The parameter name.\\n     * @param {number} index - The index into an array-value parameter. Ignored if\\n     *   the argument is undefined, null or less than zero.\\n     * @param {*} value - The parameter value to set.\\n     * @param {boolean} [force=false] - If true, records the parameter as modified\\n     *   even if the value is unchanged.\\n     * @return {Parameters} - This parameter object.\\n     */\\n    set(name, index, value, force) {\\n      const o = this,\\n            v = o[name],\\n            mod = o[CACHE];\\n\\n      if (index != null && index >= 0) {\\n        if (v[index] !== value || force) {\\n          v[index] = value;\\n          mod[index + ':' + name] = -1;\\n          mod[name] = -1;\\n        }\\n      } else if (v !== value || force) {\\n        o[name] = value;\\n        mod[name] = vegaUtil.isArray(value) ? 1 + value.length : -1;\\n      }\\n\\n      return o;\\n    },\\n\\n    /**\\n     * Tests if one or more parameters has been modified. If invoked with no\\n     * arguments, returns true if any parameter value has changed. If the first\\n     * argument is array, returns trues if any parameter name in the array has\\n     * changed. Otherwise, tests if the given name and optional array index has\\n     * changed.\\n     * @param {string} name - The parameter name to test.\\n     * @param {number} [index=undefined] - The parameter array index to test.\\n     * @return {boolean} - Returns true if a queried parameter was modified.\\n     */\\n    modified(name, index) {\\n      const mod = this[CACHE];\\n      if (!arguments.length) {\\n        for (const k in mod) { if (mod[k]) return true; }\\n        return false;\\n      } else if (vegaUtil.isArray(name)) {\\n        for (let k = 0; k < name.length; ++k) {\\n          if (mod[name[k]]) return true;\\n        }\\n        return false;\\n      }\\n      return (index != null && index >= 0)\\n        ? (index + 1 < mod[name] || !!mod[index + ':' + name])\\n        : !!mod[name];\\n    },\\n\\n    /**\\n     * Clears the modification records. After calling this method,\\n     * all parameters are considered unmodified.\\n     */\\n    clear() {\\n      this[CACHE] = {};\\n      return this;\\n    }\\n  };\\n\\n  let OP_ID = 0;\\n\\n  const PULSE = 'pulse',\\n        NO_PARAMS = new Parameters();\\n\\n  // Boolean Flags\\n  const SKIP     = 1,\\n        MODIFIED = 2;\\n\\n  /**\\n   * An Operator is a processing node in a dataflow graph.\\n   * Each operator stores a value and an optional value update function.\\n   * Operators can accept a hash of named parameters. Parameter values can\\n   * either be direct (JavaScript literals, arrays, objects) or indirect\\n   * (other operators whose values will be pulled dynamically). Operators\\n   * included as parameters will have this operator added as a dependency.\\n   * @constructor\\n   * @param {*} [init] - The initial value for this operator.\\n   * @param {function(object, Pulse)} [update] - An update function. Upon\\n   *   evaluation of this operator, the update function will be invoked and the\\n   *   return value will be used as the new value of this operator.\\n   * @param {object} [params] - The parameters for this operator.\\n   * @param {boolean} [react=true] - Flag indicating if this operator should\\n   *   listen for changes to upstream operators included as parameters.\\n   * @see parameters\\n   */\\n  function Operator(init, update, params, react) {\\n    this.id = ++OP_ID;\\n    this.value = init;\\n    this.stamp = -1;\\n    this.rank = -1;\\n    this.qrank = -1;\\n    this.flags = 0;\\n\\n    if (update) {\\n      this._update = update;\\n    }\\n    if (params) this.parameters(params, react);\\n  }\\n\\n  function flag(bit) {\\n    return function(state) {\\n      const f = this.flags;\\n      if (arguments.length === 0) return !!(f & bit);\\n      this.flags = state ? (f | bit) : (f & ~bit);\\n      return this;\\n    };\\n  }\\n\\n  Operator.prototype = {\\n\\n    /**\\n     * Returns a list of target operators dependent on this operator.\\n     * If this list does not exist, it is created and then returned.\\n     * @return {UniqueList}\\n     */\\n    targets() {\\n      return this._targets || (this._targets = UniqueList(vegaUtil.id));\\n    },\\n\\n    /**\\n     * Sets the value of this operator.\\n     * @param {*} value - the value to set.\\n     * @return {Number} Returns 1 if the operator value has changed\\n     *   according to strict equality, returns 0 otherwise.\\n     */\\n    set(value) {\\n      if (this.value !== value) {\\n        this.value = value;\\n        return 1;\\n      } else {\\n        return 0;\\n      }\\n    },\\n\\n    /**\\n     * Indicates that operator evaluation should be skipped on the next pulse.\\n     * This operator will still propagate incoming pulses, but its update function\\n     * will not be invoked. The skip flag is reset after every pulse, so calling\\n     * this method will affect processing of the next pulse only.\\n     */\\n    skip: flag(SKIP),\\n\\n    /**\\n     * Indicates that this operator's value has been modified on its most recent\\n     * pulse. Normally modification is checked via strict equality; however, in\\n     * some cases it is more efficient to update the internal state of an object.\\n     * In those cases, the modified flag can be used to trigger propagation. Once\\n     * set, the modification flag persists across pulses until unset. The flag can\\n     * be used with the last timestamp to test if a modification is recent.\\n     */\\n    modified: flag(MODIFIED),\\n\\n    /**\\n     * Sets the parameters for this operator. The parameter values are analyzed for\\n     * operator instances. If found, this operator will be added as a dependency\\n     * of the parameterizing operator. Operator values are dynamically marshalled\\n     * from each operator parameter prior to evaluation. If a parameter value is\\n     * an array, the array will also be searched for Operator instances. However,\\n     * the search does not recurse into sub-arrays or object properties.\\n     * @param {object} params - A hash of operator parameters.\\n     * @param {boolean} [react=true] - A flag indicating if this operator should\\n     *   automatically update (react) when parameter values change. In other words,\\n     *   this flag determines if the operator registers itself as a listener on\\n     *   any upstream operators included in the parameters.\\n     * @param {boolean} [initonly=false] - A flag indicating if this operator\\n     *   should calculate an update only upon its initiatal evaluation, then\\n     *   deregister dependencies and suppress all future update invocations.\\n     * @return {Operator[]} - An array of upstream dependencies.\\n     */\\n    parameters(params, react, initonly) {\\n      react = react !== false;\\n      const argval = (this._argval = this._argval || new Parameters()),\\n            argops = (this._argops = this._argops || []),\\n            deps = [];\\n      let name, value, n, i;\\n\\n      const add = (name, index, value) => {\\n        if (value instanceof Operator) {\\n          if (value !== this) {\\n            if (react) value.targets().add(this);\\n            deps.push(value);\\n          }\\n          argops.push({op:value, name:name, index:index});\\n        } else {\\n          argval.set(name, index, value);\\n        }\\n      };\\n\\n      for (name in params) {\\n        value = params[name];\\n\\n        if (name === PULSE) {\\n          vegaUtil.array(value).forEach(op => {\\n            if (!(op instanceof Operator)) {\\n              vegaUtil.error('Pulse parameters must be operator instances.');\\n            } else if (op !== this) {\\n              op.targets().add(this);\\n              deps.push(op);\\n            }\\n          });\\n          this.source = value;\\n        } else if (vegaUtil.isArray(value)) {\\n          argval.set(name, -1, Array(n = value.length));\\n          for (i = 0; i < n; ++i) add(name, i, value[i]);\\n        } else {\\n          add(name, -1, value);\\n        }\\n      }\\n\\n      this.marshall().clear(); // initialize values\\n      if (initonly) argops.initonly = true;\\n\\n      return deps;\\n    },\\n\\n    /**\\n     * Internal method for marshalling parameter values.\\n     * Visits each operator dependency to pull the latest value.\\n     * @return {Parameters} A Parameters object to pass to the update function.\\n     */\\n    marshall(stamp) {\\n      const argval = this._argval || NO_PARAMS,\\n            argops = this._argops;\\n      let item, i, op, mod;\\n\\n      if (argops) {\\n        const n = argops.length;\\n        for (i = 0; i < n; ++i) {\\n          item = argops[i];\\n          op = item.op;\\n          mod = op.modified() && op.stamp === stamp;\\n          argval.set(item.name, item.index, op.value, mod);\\n        }\\n\\n        if (argops.initonly) {\\n          for (i = 0; i < n; ++i) {\\n            item = argops[i];\\n            item.op.targets().remove(this);\\n          }\\n          this._argops = null;\\n          this._update = null;\\n        }\\n      }\\n      return argval;\\n    },\\n\\n    /**\\n     * Detach this operator from the dataflow.\\n     * Unregisters listeners on upstream dependencies.\\n     */\\n    detach() {\\n      const argops = this._argops;\\n      let i, n, item, op;\\n\\n      if (argops) {\\n        for (i = 0, n = argops.length; i < n; ++i) {\\n          item = argops[i];\\n          op = item.op;\\n          if (op._targets) {\\n            op._targets.remove(this);\\n          }\\n        }\\n      }\\n    },\\n\\n    /**\\n     * Delegate method to perform operator processing.\\n     * Subclasses can override this method to perform custom processing.\\n     * By default, it marshalls parameters and calls the update function\\n     * if that function is defined. If the update function does not\\n     * change the operator value then StopPropagation is returned.\\n     * If no update function is defined, this method does nothing.\\n     * @param {Pulse} pulse - the current dataflow pulse.\\n     * @return The output pulse or StopPropagation. A falsy return value\\n     *   (including undefined) will let the input pulse pass through.\\n     */\\n    evaluate(pulse) {\\n      const update = this._update;\\n      if (update) {\\n        const params = this.marshall(pulse.stamp),\\n              v = update.call(this, params, pulse);\\n\\n        params.clear();\\n        if (v !== this.value) {\\n          this.value = v;\\n        } else if (!this.modified()) {\\n          return pulse.StopPropagation;\\n        }\\n      }\\n    },\\n\\n    /**\\n     * Run this operator for the current pulse. If this operator has already\\n     * been run at (or after) the pulse timestamp, returns StopPropagation.\\n     * Internally, this method calls {@link evaluate} to perform processing.\\n     * If {@link evaluate} returns a falsy value, the input pulse is returned.\\n     * This method should NOT be overridden, instead overrride {@link evaluate}.\\n     * @param {Pulse} pulse - the current dataflow pulse.\\n     * @return the output pulse for this operator (or StopPropagation)\\n     */\\n    run(pulse) {\\n      if (pulse.stamp < this.stamp) return pulse.StopPropagation;\\n      let rv;\\n      if (this.skip()) {\\n        this.skip(false);\\n        rv = 0;\\n      } else {\\n        rv = this.evaluate(pulse);\\n      }\\n      return (this.pulse = rv || pulse);\\n    }\\n  };\\n\\n  /**\\n   * Add an operator to the dataflow graph. This function accepts a\\n   * variety of input argument types. The basic signature supports an\\n   * initial value, update function and parameters. If the first parameter\\n   * is an Operator instance, it will be added directly. If it is a\\n   * constructor for an Operator subclass, a new instance will be instantiated.\\n   * Otherwise, if the first parameter is a function instance, it will be used\\n   * as the update function and a null initial value is assumed.\\n   * @param {*} init - One of: the operator to add, the initial value of\\n   *   the operator, an operator class to instantiate, or an update function.\\n   * @param {function} [update] - The operator update function.\\n   * @param {object} [params] - The operator parameters.\\n   * @param {boolean} [react=true] - Flag indicating if this operator should\\n   *   listen for changes to upstream operators included as parameters.\\n   * @return {Operator} - The added operator.\\n   */\\n  function add(init, update, params, react) {\\n    let shift = 1,\\n        op;\\n\\n    if (init instanceof Operator) {\\n      op = init;\\n    } else if (init && init.prototype instanceof Operator) {\\n      op = new init();\\n    } else if (vegaUtil.isFunction(init)) {\\n      op = new Operator(null, init);\\n    } else {\\n      shift = 0;\\n      op = new Operator(init, update);\\n    }\\n\\n    this.rank(op);\\n    if (shift) {\\n      react = params;\\n      params = update;\\n    }\\n    if (params) this.connect(op, op.parameters(params, react));\\n    this.touch(op);\\n\\n    return op;\\n  }\\n\\n  /**\\n   * Connect a target operator as a dependent of source operators.\\n   * If necessary, this method will rerank the target operator and its\\n   * dependents to ensure propagation proceeds in a topologically sorted order.\\n   * @param {Operator} target - The target operator.\\n   * @param {Array<Operator>} - The source operators that should propagate\\n   *   to the target operator.\\n   */\\n  function connect(target, sources) {\\n    const targetRank = target.rank,\\n          n = sources.length;\\n\\n    for (let i = 0; i < n; ++i) {\\n      if (targetRank < sources[i].rank) {\\n        this.rerank(target);\\n        return;\\n      }\\n    }\\n  }\\n\\n  let STREAM_ID = 0;\\n\\n  /**\\n   * Models an event stream.\\n   * @constructor\\n   * @param {function(Object, number): boolean} [filter] - Filter predicate.\\n   *   Events pass through when truthy, events are suppressed when falsy.\\n   * @param {function(Object): *} [apply] - Applied to input events to produce\\n   *   new event values.\\n   * @param {function(Object)} [receive] - Event callback function to invoke\\n   *   upon receipt of a new event. Use to override standard event processing.\\n   */\\n  function EventStream(filter, apply, receive) {\\n    this.id = ++STREAM_ID;\\n    this.value = null;\\n    if (receive) this.receive = receive;\\n    if (filter) this._filter = filter;\\n    if (apply) this._apply = apply;\\n  }\\n\\n  /**\\n   * Creates a new event stream instance with the provided\\n   * (optional) filter, apply and receive functions.\\n   * @param {function(Object, number): boolean} [filter] - Filter predicate.\\n   *   Events pass through when truthy, events are suppressed when falsy.\\n   * @param {function(Object): *} [apply] - Applied to input events to produce\\n   *   new event values.\\n   * @see EventStream\\n   */\\n  function stream(filter, apply, receive) {\\n    return new EventStream(filter, apply, receive);\\n  }\\n\\n  EventStream.prototype = {\\n    _filter: vegaUtil.truthy,\\n\\n    _apply: vegaUtil.identity,\\n\\n    targets() {\\n      return this._targets || (this._targets = UniqueList(vegaUtil.id));\\n    },\\n\\n    consume(_) {\\n      if (!arguments.length) return !!this._consume;\\n      this._consume = !!_;\\n      return this;\\n    },\\n\\n    receive(evt) {\\n      if (this._filter(evt)) {\\n        const val = (this.value = this._apply(evt)),\\n            trg = this._targets,\\n            n = trg ? trg.length : 0;\\n\\n        for (let i = 0; i < n; ++i) trg[i].receive(val);\\n\\n        if (this._consume) {\\n          evt.preventDefault();\\n          evt.stopPropagation();\\n        }\\n      }\\n    },\\n\\n    filter(filter) {\\n      const s = stream(filter);\\n      this.targets().add(s);\\n      return s;\\n    },\\n\\n    apply(apply) {\\n      const s = stream(null, apply);\\n      this.targets().add(s);\\n      return s;\\n    },\\n\\n    merge() {\\n      const s = stream();\\n\\n      this.targets().add(s);\\n      for (let i=0, n=arguments.length; i<n; ++i) {\\n        arguments[i].targets().add(s);\\n      }\\n\\n      return s;\\n    },\\n\\n    throttle(pause) {\\n      let t = -1;\\n      return this.filter(() => {\\n        const now = Date.now();\\n        if ((now - t) > pause) {\\n          t = now;\\n          return 1;\\n        } else {\\n          return 0;\\n        }\\n      });\\n    },\\n\\n    debounce(delay) {\\n      const s = stream();\\n\\n      this.targets().add(stream(null, null,\\n        vegaUtil.debounce(delay, e => {\\n          const df = e.dataflow;\\n          s.receive(e);\\n          if (df && df.run) df.run();\\n        })\\n      ));\\n\\n      return s;\\n    },\\n\\n    between(a, b) {\\n      let active = false;\\n      a.targets().add(stream(null, null, () => active = true));\\n      b.targets().add(stream(null, null, () => active = false));\\n      return this.filter(() => active);\\n    },\\n\\n    detach() {\\n      // no-op for handling detach requests\\n      // ensures compatibility with operators (#2753)\\n    }\\n  };\\n\\n  /**\\n   * Create a new event stream from an event source.\\n   * @param {object} source - The event source to monitor. The input must\\n   *  support the addEventListener method.\\n   * @param {string} type - The event type.\\n   * @param {function(object): boolean} [filter] - Event filter function.\\n   * @param {function(object): *} [apply] - Event application function.\\n   *   If provided, this function will be invoked and the result will be\\n   *   used as the downstream event value.\\n   * @return {EventStream}\\n   */\\n  function events(source, type, filter, apply) {\\n    const df = this,\\n          s = stream(filter, apply),\\n          send = function(e) {\\n            e.dataflow = df;\\n            try {\\n              s.receive(e);\\n            } catch (error) {\\n              df.error(error);\\n            } finally {\\n              df.run();\\n            }\\n          };\\n\\n    let sources;\\n    if (typeof source === 'string' && typeof document !== 'undefined') {\\n      sources = document.querySelectorAll(source);\\n    } else {\\n      sources = vegaUtil.array(source);\\n    }\\n\\n    const n = sources.length;\\n    for (let i = 0; i < n; ++i) {\\n      sources[i].addEventListener(type, send);\\n    }\\n\\n    return s;\\n  }\\n\\n  function parse(data, format) {\\n    const locale = this.locale();\\n    return vegaLoader.read(data, format, locale.timeParse, locale.utcParse);\\n  }\\n\\n  /**\\n   * Ingests new data into the dataflow. First parses the data using the\\n   * vega-loader read method, then pulses a changeset to the target operator.\\n   * @param {Operator} target - The Operator to target with ingested data,\\n   *   typically a Collect transform instance.\\n   * @param {*} data - The input data, prior to parsing. For JSON this may\\n   *   be a string or an object. For CSV, TSV, etc should be a string.\\n   * @param {object} format - The data format description for parsing\\n   *   loaded data. This object is passed to the vega-loader read method.\\n   * @returns {Dataflow}\\n   */\\n  function ingest$1(target, data, format) {\\n    data = this.parse(data, format);\\n    return this.pulse(target, this.changeset().insert(data));\\n  }\\n\\n  /**\\n   * Request data from an external source, parse it, and return a Promise.\\n   * @param {string} url - The URL from which to load the data. This string\\n   *   is passed to the vega-loader load method.\\n   * @param {object} [format] - The data format description for parsing\\n   *   loaded data. This object is passed to the vega-loader read method.\\n   * @return {Promise} A Promise that resolves upon completion of the request.\\n   *   The resolved object contains the following properties:\\n   *   - data: an array of parsed data (or null upon error)\\n   *   - status: a code for success (0), load fail (-1), or parse fail (-2)\\n   */\\n  async function request(url, format) {\\n    const df = this;\\n    let status = 0, data;\\n\\n    try {\\n      data = await df.loader().load(url, {\\n        context: 'dataflow',\\n        response: vegaLoader.responseType(format && format.type)\\n      });\\n      try {\\n        data = df.parse(data, format);\\n      } catch (err) {\\n        status = -2;\\n        df.warn('Data ingestion failed', url, err);\\n      }\\n    } catch (err) {\\n      status = -1;\\n      df.warn('Loading failed', url, err);\\n    }\\n\\n    return {data, status};\\n  }\\n\\n  async function preload(target, url, format) {\\n    const df = this,\\n          pending = df._pending || loadPending(df);\\n\\n    pending.requests += 1;\\n\\n    const res = await df.request(url, format);\\n    df.pulse(target, df.changeset().remove(vegaUtil.truthy).insert(res.data || []));\\n\\n    pending.done();\\n    return res;\\n  }\\n\\n  function loadPending(df) {\\n    let accept;\\n    const pending = new Promise(a => accept = a);\\n\\n    pending.requests = 0;\\n\\n    pending.done = () => {\\n      if (--pending.requests === 0) {\\n        df._pending = null;\\n        accept(df);\\n      }\\n    };\\n\\n    return (df._pending = pending);\\n  }\\n\\n  const SKIP$1 = {skip: true};\\n\\n  /**\\n   * Perform operator updates in response to events. Applies an\\n   * update function to compute a new operator value. If the update function\\n   * returns a {@link ChangeSet}, the operator will be pulsed with those tuple\\n   * changes. Otherwise, the operator value will be updated to the return value.\\n   * @param {EventStream|Operator} source - The event source to react to.\\n   *   This argument can be either an EventStream or an Operator.\\n   * @param {Operator|function(object):Operator} target - The operator to update.\\n   *   This argument can either be an Operator instance or (if the source\\n   *   argument is an EventStream), a function that accepts an event object as\\n   *   input and returns an Operator to target.\\n   * @param {function(Parameters,Event): *} [update] - Optional update function\\n   *   to compute the new operator value, or a literal value to set. Update\\n   *   functions expect to receive a parameter object and event as arguments.\\n   *   This function can either return a new operator value or (if the source\\n   *   argument is an EventStream) a {@link ChangeSet} instance to pulse\\n   *   the target operator with tuple changes.\\n   * @param {object} [params] - The update function parameters.\\n   * @param {object} [options] - Additional options hash. If not overridden,\\n   *   updated operators will be skipped by default.\\n   * @param {boolean} [options.skip] - If true, the operator will\\n   *  be skipped: it will not be evaluated, but its dependents will be.\\n   * @param {boolean} [options.force] - If true, the operator will\\n   *   be re-evaluated even if its value has not changed.\\n   * @return {Dataflow}\\n   */\\n  function on(source, target, update, params, options) {\\n    const fn = source instanceof Operator ? onOperator : onStream;\\n    fn(this, source, target, update, params, options);\\n    return this;\\n  }\\n\\n  function onStream(df, stream, target, update, params, options) {\\n    const opt = vegaUtil.extend({}, options, SKIP$1);\\n    let func, op;\\n\\n    if (!vegaUtil.isFunction(target)) target = vegaUtil.constant(target);\\n\\n    if (update === undefined) {\\n      func = e => df.touch(target(e));\\n    } else if (vegaUtil.isFunction(update)) {\\n      op = new Operator(null, update, params, false);\\n      func = e => {\\n        op.evaluate(e);\\n        const t = target(e), v = op.value;\\n        isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);\\n      };\\n    } else {\\n      func = e => df.update(target(e), update, opt);\\n    }\\n\\n    stream.apply(func);\\n  }\\n\\n  function onOperator(df, source, target, update, params, options) {\\n    if (update === undefined) {\\n      source.targets().add(target);\\n    } else {\\n      const opt = options || {},\\n            op = new Operator(null, updater(target, update), params, false);\\n      op.modified(opt.force);\\n      op.rank = source.rank;       // immediately follow source\\n      source.targets().add(op);    // add dependency\\n\\n      if (target) {\\n        op.skip(true);             // skip first invocation\\n        op.value = target.value;   // initialize value\\n        op.targets().add(target);  // chain dependencies\\n        df.connect(target, [op]);  // rerank as needed, #1672\\n      }\\n    }\\n  }\\n\\n  function updater(target, update) {\\n    update = vegaUtil.isFunction(update) ? update : vegaUtil.constant(update);\\n    return target\\n      ? function(_, pulse) {\\n          const value = update(_, pulse);\\n          if (!target.skip()) {\\n            target.skip(value !== this.value).value = value;\\n          }\\n          return value;\\n        }\\n      : update;\\n  }\\n\\n  /**\\n   * Assigns a rank to an operator. Ranks are assigned in increasing order\\n   * by incrementing an internal rank counter.\\n   * @param {Operator} op - The operator to assign a rank.\\n   */\\n  function rank(op) {\\n    op.rank = ++this._rank;\\n  }\\n\\n  /**\\n   * Re-ranks an operator and all downstream target dependencies. This\\n   * is necessary when upstream dependencies of higher rank are added to\\n   * a target operator.\\n   * @param {Operator} op - The operator to re-rank.\\n   */\\n  function rerank(op) {\\n    const queue = [op];\\n    let cur, list, i;\\n\\n    while (queue.length) {\\n      this.rank(cur = queue.pop());\\n      if (list = cur._targets) {\\n        for (i=list.length; --i >= 0;) {\\n          queue.push(cur = list[i]);\\n          if (cur === op) vegaUtil.error('Cycle detected in dataflow graph.');\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Sentinel value indicating pulse propagation should stop.\\n   */\\n  const StopPropagation = {};\\n\\n  // Pulse visit type flags\\n  const ADD       = (1 << 0),\\n        REM       = (1 << 1),\\n        MOD       = (1 << 2),\\n        ADD_REM   = ADD | REM,\\n        ADD_MOD   = ADD | MOD,\\n        ALL       = ADD | REM | MOD,\\n        REFLOW    = (1 << 3),\\n        SOURCE    = (1 << 4),\\n        NO_SOURCE = (1 << 5),\\n        NO_FIELDS = (1 << 6);\\n\\n  /**\\n   * A Pulse enables inter-operator communication during a run of the\\n   * dataflow graph. In addition to the current timestamp, a pulse may also\\n   * contain a change-set of added, removed or modified data tuples, as well as\\n   * a pointer to a full backing data source. Tuple change sets may not\\n   * be fully materialized; for example, to prevent needless array creation\\n   * a change set may include larger arrays and corresponding filter functions.\\n   * The pulse provides a {@link visit} method to enable proper and efficient\\n   * iteration over requested data tuples.\\n   *\\n   * In addition, each pulse can track modification flags for data tuple fields.\\n   * Responsible transform operators should call the {@link modifies} method to\\n   * indicate changes to data fields. The {@link modified} method enables\\n   * querying of this modification state.\\n   *\\n   * @constructor\\n   * @param {Dataflow} dataflow - The backing dataflow instance.\\n   * @param {number} stamp - The current propagation timestamp.\\n   * @param {string} [encode] - An optional encoding set name, which is then\\n   *   accessible as Pulse.encode. Operators can respond to (or ignore) this\\n   *   setting as appropriate. This parameter can be used in conjunction with\\n   *   the Encode transform in the vega-encode module.\\n   */\\n  function Pulse(dataflow, stamp, encode) {\\n    this.dataflow = dataflow;\\n    this.stamp = stamp == null ? -1 : stamp;\\n    this.add = [];\\n    this.rem = [];\\n    this.mod = [];\\n    this.fields = null;\\n    this.encode = encode || null;\\n  }\\n\\n  function materialize(data, filter) {\\n    const out = [];\\n    vegaUtil.visitArray(data, filter, _ => out.push(_));\\n    return out;\\n  }\\n\\n  function filter(pulse, flags) {\\n    const map = {};\\n    pulse.visit(flags, t => { map[tupleid(t)] = 1; });\\n    return t => map[tupleid(t)] ? null : t;\\n  }\\n\\n  function addFilter(a, b) {\\n    return a\\n      ? (t, i) => a(t, i) && b(t, i)\\n      : b;\\n  }\\n\\n  Pulse.prototype = {\\n\\n    /**\\n     * Sentinel value indicating pulse propagation should stop.\\n     */\\n    StopPropagation,\\n\\n    /**\\n     * Boolean flag indicating ADD (added) tuples.\\n     */\\n    ADD,\\n\\n    /**\\n     * Boolean flag indicating REM (removed) tuples.\\n     */\\n    REM,\\n\\n    /**\\n     * Boolean flag indicating MOD (modified) tuples.\\n     */\\n    MOD,\\n\\n    /**\\n     * Boolean flag indicating ADD (added) and REM (removed) tuples.\\n     */\\n    ADD_REM,\\n\\n    /**\\n     * Boolean flag indicating ADD (added) and MOD (modified) tuples.\\n     */\\n    ADD_MOD,\\n\\n    /**\\n     * Boolean flag indicating ADD, REM and MOD tuples.\\n     */\\n    ALL,\\n\\n    /**\\n     * Boolean flag indicating all tuples in a data source\\n     * except for the ADD, REM and MOD tuples.\\n     */\\n    REFLOW,\\n\\n    /**\\n     * Boolean flag indicating a 'pass-through' to a\\n     * backing data source, ignoring ADD, REM and MOD tuples.\\n     */\\n    SOURCE,\\n\\n    /**\\n     * Boolean flag indicating that source data should be\\n     * suppressed when creating a forked pulse.\\n     */\\n    NO_SOURCE,\\n\\n    /**\\n     * Boolean flag indicating that field modifications should be\\n     * suppressed when creating a forked pulse.\\n     */\\n    NO_FIELDS,\\n\\n    /**\\n     * Creates a new pulse based on the values of this pulse.\\n     * The dataflow, time stamp and field modification values are copied over.\\n     * By default, new empty ADD, REM and MOD arrays are created.\\n     * @param {number} flags - Integer of boolean flags indicating which (if any)\\n     *   tuple arrays should be copied to the new pulse. The supported flag values\\n     *   are ADD, REM and MOD. Array references are copied directly: new array\\n     *   instances are not created.\\n     * @return {Pulse} - The forked pulse instance.\\n     * @see init\\n     */\\n    fork(flags) {\\n      return new Pulse(this.dataflow).init(this, flags);\\n    },\\n\\n    /**\\n     * Creates a copy of this pulse with new materialized array\\n     * instances for the ADD, REM, MOD, and SOURCE arrays.\\n     * The dataflow, time stamp and field modification values are copied over.\\n     * @return {Pulse} - The cloned pulse instance.\\n     * @see init\\n     */\\n    clone() {\\n      const p = this.fork(ALL);\\n      p.add = p.add.slice();\\n      p.rem = p.rem.slice();\\n      p.mod = p.mod.slice();\\n      if (p.source) p.source = p.source.slice();\\n      return p.materialize(ALL | SOURCE);\\n    },\\n\\n    /**\\n     * Returns a pulse that adds all tuples from a backing source. This is\\n     * useful for cases where operators are added to a dataflow after an\\n     * upstream data pipeline has already been processed, ensuring that\\n     * new operators can observe all tuples within a stream.\\n     * @return {Pulse} - A pulse instance with all source tuples included\\n     *   in the add array. If the current pulse already has all source\\n     *   tuples in its add array, it is returned directly. If the current\\n     *   pulse does not have a backing source, it is returned directly.\\n     */\\n    addAll() {\\n      let p = this;\\n      const reuse = !p.source\\n        || p.add === p.rem // special case for indexed set (e.g., crossfilter)\\n        || (!p.rem.length && p.source.length === p.add.length);\\n\\n      if (reuse) {\\n        return p;\\n      } else {\\n        p = new Pulse(this.dataflow).init(this);\\n        p.add = p.source;\\n        p.rem = []; // new operators can ignore rem #2769\\n        return p;\\n      }\\n    },\\n\\n    /**\\n     * Initialize this pulse based on the values of another pulse. This method\\n     * is used internally by {@link fork} to initialize a new forked tuple.\\n     * The dataflow, time stamp and field modification values are copied over.\\n     * By default, new empty ADD, REM and MOD arrays are created.\\n     * @param {Pulse} src - The source pulse to copy from.\\n     * @param {number} flags - Integer of boolean flags indicating which (if any)\\n     *   tuple arrays should be copied to the new pulse. The supported flag values\\n     *   are ADD, REM and MOD. Array references are copied directly: new array\\n     *   instances are not created. By default, source data arrays are copied\\n     *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.\\n     * @return {Pulse} - Returns this Pulse instance.\\n     */\\n    init(src, flags) {\\n      const p = this;\\n      p.stamp = src.stamp;\\n      p.encode = src.encode;\\n\\n      if (src.fields && !(flags & NO_FIELDS)) {\\n        p.fields = src.fields;\\n      }\\n\\n      if (flags & ADD) {\\n        p.addF = src.addF;\\n        p.add = src.add;\\n      } else {\\n        p.addF = null;\\n        p.add = [];\\n      }\\n\\n      if (flags & REM) {\\n        p.remF = src.remF;\\n        p.rem = src.rem;\\n      } else {\\n        p.remF = null;\\n        p.rem = [];\\n      }\\n\\n      if (flags & MOD) {\\n        p.modF = src.modF;\\n        p.mod = src.mod;\\n      } else {\\n        p.modF = null;\\n        p.mod = [];\\n      }\\n\\n      if (flags & NO_SOURCE) {\\n        p.srcF = null;\\n        p.source = null;\\n      } else {\\n        p.srcF = src.srcF;\\n        p.source = src.source;\\n        if (src.cleans) p.cleans = src.cleans;\\n      }\\n\\n      return p;\\n    },\\n\\n    /**\\n     * Schedules a function to run after pulse propagation completes.\\n     * @param {function} func - The function to run.\\n     */\\n    runAfter(func) {\\n      this.dataflow.runAfter(func);\\n    },\\n\\n    /**\\n     * Indicates if tuples have been added, removed or modified.\\n     * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.\\n     *   Defaults to ALL, returning true if any tuple type has changed.\\n     * @return {boolean} - Returns true if one or more queried tuple types have\\n     *   changed, false otherwise.\\n     */\\n    changed(flags) {\\n      const f = flags || ALL;\\n      return ((f & ADD) && this.add.length)\\n          || ((f & REM) && this.rem.length)\\n          || ((f & MOD) && this.mod.length);\\n    },\\n\\n    /**\\n     * Forces a \\\"reflow\\\" of tuple values, such that all tuples in the backing\\n     * source are added to the MOD set, unless already present in the ADD set.\\n     * @param {boolean} [fork=false] - If true, returns a forked copy of this\\n     *   pulse, and invokes reflow on that derived pulse.\\n     * @return {Pulse} - The reflowed pulse instance.\\n     */\\n    reflow(fork) {\\n      if (fork) return this.fork(ALL).reflow();\\n\\n      const len = this.add.length,\\n            src = this.source && this.source.length;\\n      if (src && src !== len) {\\n        this.mod = this.source;\\n        if (len) this.filter(MOD, filter(this, ADD));\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Get/set metadata to pulse requesting garbage collection\\n     * to reclaim currently unused resources.\\n     */\\n    clean(value) {\\n      if (arguments.length) {\\n        this.cleans = !!value;\\n        return this;\\n      } else {\\n        return this.cleans;\\n      }\\n    },\\n\\n    /**\\n     * Marks one or more data field names as modified to assist dependency\\n     * tracking and incremental processing by transform operators.\\n     * @param {string|Array<string>} _ - The field(s) to mark as modified.\\n     * @return {Pulse} - This pulse instance.\\n     */\\n    modifies(_) {\\n      const hash = this.fields || (this.fields = {});\\n      if (vegaUtil.isArray(_)) {\\n        _.forEach(f => hash[f] = true);\\n      } else {\\n        hash[_] = true;\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Checks if one or more data fields have been modified during this pulse\\n     * propagation timestamp.\\n     * @param {string|Array<string>} _ - The field(s) to check for modified.\\n     * @param {boolean} nomod - If true, will check the modified flag even if\\n     *   no mod tuples exist. If false (default), mod tuples must be present.\\n     * @return {boolean} - Returns true if any of the provided fields has been\\n     *   marked as modified, false otherwise.\\n     */\\n    modified(_, nomod) {\\n      const fields = this.fields;\\n      return !((nomod || this.mod.length) && fields) ? false\\n        : !arguments.length ? !!fields\\n        : vegaUtil.isArray(_) ? _.some(f => fields[f])\\n        : fields[_];\\n    },\\n\\n    /**\\n     * Adds a filter function to one more tuple sets. Filters are applied to\\n     * backing tuple arrays, to determine the actual set of tuples considered\\n     * added, removed or modified. They can be used to delay materialization of\\n     * a tuple set in order to avoid expensive array copies. In addition, the\\n     * filter functions can serve as value transformers: unlike standard predicate\\n     * function (which return boolean values), Pulse filters should return the\\n     * actual tuple value to process. If a tuple set is already filtered, the\\n     * new filter function will be appended into a conjuntive ('and') query.\\n     * @param {number} flags - Flags indicating the tuple set(s) to filter.\\n     * @param {function(*):object} filter - Filter function that will be applied\\n     *   to the tuple set array, and should return a data tuple if the value\\n     *   should be included in the tuple set, and falsy (or null) otherwise.\\n     * @return {Pulse} - Returns this pulse instance.\\n     */\\n    filter(flags, filter) {\\n      const p = this;\\n      if (flags & ADD) p.addF = addFilter(p.addF, filter);\\n      if (flags & REM) p.remF = addFilter(p.remF, filter);\\n      if (flags & MOD) p.modF = addFilter(p.modF, filter);\\n      if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);\\n      return p;\\n    },\\n\\n    /**\\n     * Materialize one or more tuple sets in this pulse. If the tuple set(s) have\\n     * a registered filter function, it will be applied and the tuple set(s) will\\n     * be replaced with materialized tuple arrays.\\n     * @param {number} flags - Flags indicating the tuple set(s) to materialize.\\n     * @return {Pulse} - Returns this pulse instance.\\n     */\\n    materialize(flags) {\\n      flags = flags || ALL;\\n      const p = this;\\n      if ((flags & ADD) && p.addF) {\\n        p.add = materialize(p.add, p.addF);\\n        p.addF = null;\\n      }\\n      if ((flags & REM) && p.remF) {\\n        p.rem = materialize(p.rem, p.remF);\\n        p.remF = null;\\n      }\\n      if ((flags & MOD) && p.modF) {\\n        p.mod = materialize(p.mod, p.modF);\\n        p.modF = null;\\n      }\\n      if ((flags & SOURCE) && p.srcF) {\\n        p.source = p.source.filter(p.srcF);\\n        p.srcF = null;\\n      }\\n      return p;\\n    },\\n\\n    /**\\n     * Visit one or more tuple sets in this pulse.\\n     * @param {number} flags - Flags indicating the tuple set(s) to visit.\\n     *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source\\n     *   has been set).\\n     * @param {function(object):*} - Visitor function invoked per-tuple.\\n     * @return {Pulse} - Returns this pulse instance.\\n     */\\n    visit(flags, visitor) {\\n      const p = this, v = visitor;\\n\\n      if (flags & SOURCE) {\\n        vegaUtil.visitArray(p.source, p.srcF, v);\\n        return p;\\n      }\\n\\n      if (flags & ADD) vegaUtil.visitArray(p.add, p.addF, v);\\n      if (flags & REM) vegaUtil.visitArray(p.rem, p.remF, v);\\n      if (flags & MOD) vegaUtil.visitArray(p.mod, p.modF, v);\\n\\n      const src = p.source;\\n      if ((flags & REFLOW) && src) {\\n        const sum = p.add.length + p.mod.length;\\n        if (sum === src.length) ; else if (sum) {\\n          vegaUtil.visitArray(src, filter(p, ADD_MOD), v);\\n        } else {\\n          // if no add/rem/mod tuples, visit source\\n          vegaUtil.visitArray(src, p.srcF, v);\\n        }\\n      }\\n\\n      return p;\\n    }\\n  };\\n\\n  /**\\n   * Represents a set of multiple pulses. Used as input for operators\\n   * that accept multiple pulses at a time. Contained pulses are\\n   * accessible via the public \\\"pulses\\\" array property. This pulse doe\\n   * not carry added, removed or modified tuples directly. However,\\n   * the visit method can be used to traverse all such tuples contained\\n   * in sub-pulses with a timestamp matching this parent multi-pulse.\\n   * @constructor\\n   * @param {Dataflow} dataflow - The backing dataflow instance.\\n   * @param {number} stamp - The timestamp.\\n   * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.\\n   */\\n  function MultiPulse(dataflow, stamp, pulses, encode) {\\n    const p = this,\\n          n = pulses.length;\\n    let c = 0;\\n\\n    this.dataflow = dataflow;\\n    this.stamp = stamp;\\n    this.fields = null;\\n    this.encode = encode || null;\\n    this.pulses = pulses;\\n\\n    for (let i = 0; i < n; ++i) {\\n      const pulse = pulses[i];\\n      if (pulse.stamp !== stamp) continue;\\n\\n      if (pulse.fields) {\\n        const hash = p.fields || (p.fields = {});\\n        for (const f in pulse.fields) { hash[f] = 1; }\\n      }\\n\\n      if (pulse.changed(p.ADD)) c |= p.ADD;\\n      if (pulse.changed(p.REM)) c |= p.REM;\\n      if (pulse.changed(p.MOD)) c |= p.MOD;\\n    }\\n\\n    this.changes = c;\\n  }\\n\\n  vegaUtil.inherits(MultiPulse, Pulse, {\\n    /**\\n     * Creates a new pulse based on the values of this pulse.\\n     * The dataflow, time stamp and field modification values are copied over.\\n     * @return {Pulse}\\n     */\\n    fork(flags) {\\n      const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);\\n      if (flags !== undefined) {\\n        if (flags & p.ADD) this.visit(p.ADD, t => p.add.push(t));\\n        if (flags & p.REM) this.visit(p.REM, t => p.rem.push(t));\\n        if (flags & p.MOD) this.visit(p.MOD, t => p.mod.push(t));\\n      }\\n      return p;\\n    },\\n\\n    changed(flags) {\\n      return this.changes & flags;\\n    },\\n\\n    modified(_) {\\n      const p = this, fields = p.fields;\\n      return !(fields && (p.changes & p.MOD)) ? 0\\n        : vegaUtil.isArray(_) ? _.some(f => fields[f])\\n        : fields[_];\\n    },\\n\\n    filter() {\\n      vegaUtil.error('MultiPulse does not support filtering.');\\n    },\\n\\n    materialize() {\\n      vegaUtil.error('MultiPulse does not support materialization.');\\n    },\\n\\n    visit(flags, visitor) {\\n      const p = this,\\n            pulses = p.pulses,\\n            n = pulses.length;\\n      let i = 0;\\n\\n      if (flags & p.SOURCE) {\\n        for (; i < n; ++i) {\\n          pulses[i].visit(flags, visitor);\\n        }\\n      } else {\\n        for (; i < n; ++i) {\\n          if (pulses[i].stamp === p.stamp) {\\n            pulses[i].visit(flags, visitor);\\n          }\\n        }\\n      }\\n\\n      return p;\\n    }\\n  });\\n\\n  /* eslint-disable require-atomic-updates */\\n\\n  /**\\n   * Evaluates the dataflow and returns a Promise that resolves when pulse\\n   * propagation completes. This method will increment the current timestamp\\n   * and process all updated, pulsed and touched operators. When invoked for\\n   * the first time, all registered operators will be processed. This method\\n   * should not be invoked by third-party clients, use {@link runAsync} or\\n   * {@link run} instead.\\n   * @param {string} [encode] - The name of an encoding set to invoke during\\n   *   propagation. This value is added to generated Pulse instances;\\n   *   operators can then respond to (or ignore) this setting as appropriate.\\n   *   This parameter can be used in conjunction with the Encode transform in\\n   *   the vega-encode package.\\n   * @param {function} [prerun] - An optional callback function to invoke\\n   *   immediately before dataflow evaluation commences.\\n   * @param {function} [postrun] - An optional callback function to invoke\\n   *   after dataflow evaluation completes. The callback will be invoked\\n   *   after those registered via {@link runAfter}.\\n   * @return {Promise} - A promise that resolves to this dataflow after\\n   *   evaluation completes.\\n   */\\n  async function evaluate(encode, prerun, postrun) {\\n    const df = this,\\n          async = [];\\n\\n    // if the pulse value is set, this is a re-entrant call\\n    if (df._pulse) return reentrant(df);\\n\\n    // wait for pending datasets to load\\n    if (df._pending) await df._pending;\\n\\n    // invoke prerun function, if provided\\n    if (prerun) await asyncCallback(df, prerun);\\n\\n    // exit early if there are no updates\\n    if (!df._touched.length) {\\n      df.debug('Dataflow invoked, but nothing to do.');\\n      return df;\\n    }\\n\\n    // increment timestamp clock\\n    const stamp = ++df._clock;\\n\\n    // set the current pulse\\n    df._pulse = new Pulse(df, stamp, encode);\\n\\n    // initialize priority queue, reset touched operators\\n    df._touched.forEach(op => df._enqueue(op, true));\\n    df._touched = UniqueList(vegaUtil.id);\\n\\n    let count = 0, op, next, error;\\n\\n    try {\\n      while (df._heap.size() > 0) {\\n        // dequeue operator with highest priority\\n        op = df._heap.pop();\\n\\n        // re-queue if rank changed\\n        if (op.rank !== op.qrank) {\\n          df._enqueue(op, true);\\n          continue;\\n        }\\n\\n        // otherwise, evaluate the operator\\n        next = op.run(df._getPulse(op, encode));\\n\\n        if (next.then) {\\n          // await if operator returns a promise directly\\n          next = await next;\\n        } else if (next.async) {\\n          // queue parallel asynchronous execution\\n          async.push(next.async);\\n          next = StopPropagation;\\n        }\\n\\n        // propagate evaluation, enqueue dependent operators\\n        if (next !== StopPropagation) {\\n          if (op._targets) op._targets.forEach(op => df._enqueue(op));\\n        }\\n\\n        // increment visit counter\\n        ++count;\\n      }\\n    } catch (err) {\\n      df._heap.clear();\\n      error = err;\\n    }\\n\\n    // reset pulse map\\n    df._input = {};\\n    df._pulse = null;\\n\\n    df.debug(`Pulse ${stamp}: ${count} operators`);\\n\\n    if (error) {\\n      df._postrun = [];\\n      df.error(error);\\n    }\\n\\n    // invoke callbacks queued via runAfter\\n    if (df._postrun.length) {\\n      const pr = df._postrun.sort((a, b) => b.priority - a.priority);\\n      df._postrun = [];\\n      for (let i=0; i<pr.length; ++i) {\\n        await asyncCallback(df, pr[i].callback);\\n      }\\n    }\\n\\n    // invoke postrun function, if provided\\n    if (postrun) await asyncCallback(df, postrun);\\n\\n    // handle non-blocking asynchronous callbacks\\n    if (async.length) {\\n      Promise.all(async)\\n        .then(cb => df.runAsync(null, () => {\\n          cb.forEach(f => { try { f(df); } catch (err) { df.error(err); } });\\n        }));\\n    }\\n\\n    return df;\\n  }\\n\\n  /**\\n   * Queues dataflow evaluation to run once any other queued evaluations have\\n   * completed and returns a Promise that resolves when the queued pulse\\n   * propagation completes. If provided, a callback function will be invoked\\n   * immediately before evaluation commences. This method will ensure a\\n   * separate evaluation is invoked for each time it is called.\\n   * @param {string} [encode] - The name of an encoding set to invoke during\\n   *   propagation. This value is added to generated Pulse instances;\\n   *   operators can then respond to (or ignore) this setting as appropriate.\\n   *   This parameter can be used in conjunction with the Encode transform in\\n   *   the vega-encode package.\\n   * @param {function} [prerun] - An optional callback function to invoke\\n   *   immediately before dataflow evaluation commences.\\n   * @param {function} [postrun] - An optional callback function to invoke\\n   *   after dataflow evaluation completes. The callback will be invoked\\n   *   after those registered via {@link runAfter}.\\n   * @return {Promise} - A promise that resolves to this dataflow after\\n   *   evaluation completes.\\n   */\\n  async function runAsync(encode, prerun, postrun) {\\n    // await previously queued functions\\n    while (this._running) await this._running;\\n\\n    // run dataflow, manage running promise\\n    const clear = () => this._running = null;\\n    (this._running = this.evaluate(encode, prerun, postrun))\\n      .then(clear, clear);\\n\\n    return this._running;\\n  }\\n\\n  /**\\n   * Requests dataflow evaluation and the immediately returns this dataflow\\n   * instance. If there are pending data loading or other asynchronous\\n   * operations, the dataflow will evaluate asynchronously after this method\\n   * has been invoked. To track when dataflow evaluation completes, use the\\n   * {@link runAsync} method instead. This method will raise an error if\\n   * invoked while the dataflow is already in the midst of evaluation.\\n   * @param {string} [encode] - The name of an encoding set to invoke during\\n   *   propagation. This value is added to generated Pulse instances;\\n   *   operators can then respond to (or ignore) this setting as appropriate.\\n   *   This parameter can be used in conjunction with the Encode transform in\\n   *   the vega-encode module.\\n   * @param {function} [prerun] - An optional callback function to invoke\\n   *   immediately before dataflow evaluation commences.\\n   * @param {function} [postrun] - An optional callback function to invoke\\n   *   after dataflow evaluation completes. The callback will be invoked\\n   *   after those registered via {@link runAfter}.\\n   * @return {Dataflow} - This dataflow instance.\\n   */\\n  function run(encode, prerun, postrun) {\\n    return this._pulse ? reentrant(this)\\n      : (this.evaluate(encode, prerun, postrun), this);\\n  }\\n\\n  /**\\n   * Schedules a callback function to be invoked after the current pulse\\n   * propagation completes. If no propagation is currently occurring,\\n   * the function is invoked immediately. Callbacks scheduled via runAfter\\n   * are invoked immediately upon completion of the current cycle, before\\n   * any request queued via runAsync. This method is primarily intended for\\n   * internal use. Third-party callers using runAfter to schedule a callback\\n   * that invokes {@link run} or {@link runAsync} should not use this method,\\n   * but instead use {@link runAsync} with prerun or postrun arguments.\\n   * @param {function(Dataflow)} callback - The callback function to run.\\n   *   The callback will be invoked with this Dataflow instance as its\\n   *   sole argument.\\n   * @param {boolean} enqueue - A boolean flag indicating that the\\n   *   callback should be queued up to run after the next propagation\\n   *   cycle, suppressing immediate invocation when propagation is not\\n   *   currently occurring.\\n   * @param {number} [priority] - A priority value used to sort registered\\n   *   callbacks to determine execution order. This argument is intended\\n   *   for internal Vega use only.\\n   */\\n  function runAfter(callback, enqueue, priority) {\\n    if (this._pulse || enqueue) {\\n      // pulse propagation is currently running, queue to run after\\n      this._postrun.push({\\n        priority: priority || 0,\\n        callback: callback\\n      });\\n    } else {\\n      // pulse propagation already complete, invoke immediately\\n      try { callback(this); } catch (err) { this.error(err); }\\n    }\\n  }\\n\\n  /**\\n   * Raise an error for re-entrant dataflow evaluation.\\n   */\\n  function reentrant(df) {\\n    df.error('Dataflow already running. Use runAsync() to chain invocations.');\\n    return df;\\n  }\\n\\n  /**\\n   * Enqueue an operator into the priority queue for evaluation. The operator\\n   * will be enqueued if it has no registered pulse for the current cycle, or if\\n   * the force argument is true. Upon enqueue, this method also sets the\\n   * operator's qrank to the current rank value.\\n   * @param {Operator} op - The operator to enqueue.\\n   * @param {boolean} [force] - A flag indicating if the operator should be\\n   *   forceably added to the queue, even if it has already been previously\\n   *   enqueued during the current pulse propagation. This is useful when the\\n   *   dataflow graph is dynamically modified and the operator rank changes.\\n   */\\n  function enqueue(op, force) {\\n    const q = op.stamp < this._clock;\\n    if (q) op.stamp = this._clock;\\n    if (q || force) {\\n      op.qrank = op.rank;\\n      this._heap.push(op);\\n    }\\n  }\\n\\n  /**\\n   * Provide a correct pulse for evaluating an operator. If the operator has an\\n   * explicit source operator, we will try to pull the pulse(s) from it.\\n   * If there is an array of source operators, we build a multi-pulse.\\n   * Otherwise, we return a current pulse with correct source data.\\n   * If the pulse is the pulse map has an explicit target set, we use that.\\n   * Else if the pulse on the upstream source operator is current, we use that.\\n   * Else we use the pulse from the pulse map, but copy the source tuple array.\\n   * @param {Operator} op - The operator for which to get an input pulse.\\n   * @param {string} [encode] - An (optional) encoding set name with which to\\n   *   annotate the returned pulse. See {@link run} for more information.\\n   */\\n  function getPulse(op, encode) {\\n    const s = op.source,\\n          stamp = this._clock;\\n\\n    return s && vegaUtil.isArray(s)\\n      ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode)\\n      : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);\\n  }\\n\\n  function singlePulse(p, s) {\\n    if (s && s.stamp === p.stamp) {\\n      return s;\\n    }\\n\\n    p = p.fork();\\n    if (s && s !== StopPropagation) {\\n      p.source = s.source;\\n    }\\n    return p;\\n  }\\n\\n  const NO_OPT = {skip: false, force: false};\\n\\n  /**\\n   * Touches an operator, scheduling it to be evaluated. If invoked outside of\\n   * a pulse propagation, the operator will be evaluated the next time this\\n   * dataflow is run. If invoked in the midst of pulse propagation, the operator\\n   * will be queued for evaluation if and only if the operator has not yet been\\n   * evaluated on the current propagation timestamp.\\n   * @param {Operator} op - The operator to touch.\\n   * @param {object} [options] - Additional options hash.\\n   * @param {boolean} [options.skip] - If true, the operator will\\n   *   be skipped: it will not be evaluated, but its dependents will be.\\n   * @return {Dataflow}\\n   */\\n  function touch(op, options) {\\n    const opt = options || NO_OPT;\\n    if (this._pulse) {\\n      // if in midst of propagation, add to priority queue\\n      this._enqueue(op);\\n    } else {\\n      // otherwise, queue for next propagation\\n      this._touched.add(op);\\n    }\\n    if (opt.skip) op.skip(true);\\n    return this;\\n  }\\n\\n  /**\\n   * Updates the value of the given operator.\\n   * @param {Operator} op - The operator to update.\\n   * @param {*} value - The value to set.\\n   * @param {object} [options] - Additional options hash.\\n   * @param {boolean} [options.force] - If true, the operator will\\n   *   be re-evaluated even if its value has not changed.\\n   * @param {boolean} [options.skip] - If true, the operator will\\n   *   be skipped: it will not be evaluated, but its dependents will be.\\n   * @return {Dataflow}\\n   */\\n  function update(op, value, options) {\\n    const opt = options || NO_OPT;\\n    if (op.set(value) || opt.force) {\\n      this.touch(op, opt);\\n    }\\n    return this;\\n  }\\n\\n  /**\\n   * Pulses an operator with a changeset of tuples. If invoked outside of\\n   * a pulse propagation, the pulse will be applied the next time this\\n   * dataflow is run. If invoked in the midst of pulse propagation, the pulse\\n   * will be added to the set of active pulses and will be applied if and\\n   * only if the target operator has not yet been evaluated on the current\\n   * propagation timestamp.\\n   * @param {Operator} op - The operator to pulse.\\n   * @param {ChangeSet} value - The tuple changeset to apply.\\n   * @param {object} [options] - Additional options hash.\\n   * @param {boolean} [options.skip] - If true, the operator will\\n   *   be skipped: it will not be evaluated, but its dependents will be.\\n   * @return {Dataflow}\\n   */\\n  function pulse(op, changeset, options) {\\n    this.touch(op, options || NO_OPT);\\n\\n    const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),\\n          t = op.pulse && op.pulse.source || [];\\n\\n    p.target = op;\\n    this._input[op.id] = changeset.pulse(p, t);\\n\\n    return this;\\n  }\\n\\n  function Heap(cmp) {\\n    let nodes = [];\\n    return {\\n      clear: () => nodes = [],\\n      size: () => nodes.length,\\n      peek: () => nodes[0],\\n      push: x => {\\n        nodes.push(x);\\n        return siftdown(nodes, 0, nodes.length - 1, cmp);\\n      },\\n      pop: () => {\\n        const last = nodes.pop();\\n        let item;\\n        if (nodes.length) {\\n          item = nodes[0];\\n          nodes[0] = last;\\n          siftup(nodes, 0, cmp);\\n        } else {\\n          item = last;\\n        }\\n        return item;\\n      }\\n    };\\n  }\\n\\n  function siftdown(array, start, idx, cmp) {\\n    let parent, pidx;\\n\\n    const item = array[idx];\\n    while (idx > start) {\\n      pidx = (idx - 1) >> 1;\\n      parent = array[pidx];\\n      if (cmp(item, parent) < 0) {\\n        array[idx] = parent;\\n        idx = pidx;\\n        continue;\\n      }\\n      break;\\n    }\\n    return (array[idx] = item);\\n  }\\n\\n  function siftup(array, idx, cmp) {\\n    const start = idx,\\n          end = array.length,\\n          item = array[idx];\\n    let cidx = (idx << 1) + 1, ridx;\\n\\n    while (cidx < end) {\\n      ridx = cidx + 1;\\n      if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\\n        cidx = ridx;\\n      }\\n      array[idx] = array[cidx];\\n      idx = cidx;\\n      cidx = (idx << 1) + 1;\\n    }\\n    array[idx] = item;\\n    return siftdown(array, start, idx, cmp);\\n  }\\n\\n  /**\\n   * A dataflow graph for reactive processing of data streams.\\n   * @constructor\\n   */\\n  function Dataflow() {\\n    this.logger(vegaUtil.logger());\\n    this.logLevel(vegaUtil.Error);\\n\\n    this._clock = 0;\\n    this._rank = 0;\\n    this._locale = vegaFormat.defaultLocale();\\n    try {\\n      this._loader = vegaLoader.loader();\\n    } catch (e) {\\n      // do nothing if loader module is unavailable\\n    }\\n\\n    this._touched = UniqueList(vegaUtil.id);\\n    this._input = {};\\n    this._pulse = null;\\n\\n    this._heap = Heap((a, b) => a.qrank - b.qrank);\\n    this._postrun = [];\\n  }\\n\\n  function logMethod(method) {\\n    return function() {\\n      return this._log[method].apply(this, arguments);\\n    };\\n  }\\n\\n  Dataflow.prototype = {\\n\\n    /**\\n     * The current timestamp of this dataflow. This value reflects the\\n     * timestamp of the previous dataflow run. The dataflow is initialized\\n     * with a stamp value of 0. The initial run of the dataflow will have\\n     * a timestap of 1, and so on. This value will match the\\n     * {@link Pulse.stamp} property.\\n     * @return {number} - The current timestamp value.\\n     */\\n    stamp() {\\n      return this._clock;\\n    },\\n\\n    /**\\n     * Gets or sets the loader instance to use for data file loading. A\\n     * loader object must provide a \\\"load\\\" method for loading files and a\\n     * \\\"sanitize\\\" method for checking URL/filename validity. Both methods\\n     * should accept a URI and options hash as arguments, and return a Promise\\n     * that resolves to the loaded file contents (load) or a hash containing\\n     * sanitized URI data with the sanitized url assigned to the \\\"href\\\" property\\n     * (sanitize).\\n     * @param {object} _ - The loader instance to use.\\n     * @return {object|Dataflow} - If no arguments are provided, returns\\n     *   the current loader instance. Otherwise returns this Dataflow instance.\\n     */\\n    loader(_) {\\n      if (arguments.length) {\\n        this._loader = _;\\n        return this;\\n      } else {\\n        return this._loader;\\n      }\\n    },\\n\\n    /**\\n     * Gets or sets the locale instance to use for formatting and parsing\\n     * string values. The locale object should be provided by the\\n     * vega-format library, and include methods such as format, timeFormat,\\n     * utcFormat, timeParse, and utcParse.\\n     * @param {object} _ - The locale instance to use.\\n     * @return {object|Dataflow} - If no arguments are provided, returns\\n     *   the current locale instance. Otherwise returns this Dataflow instance.\\n     */\\n    locale(_) {\\n      if (arguments.length) {\\n        this._locale = _;\\n        return this;\\n      } else {\\n        return this._locale;\\n      }\\n    },\\n\\n    /**\\n     * Get or set the logger instance used to log messages. If no arguments are\\n     * provided, returns the current logger instance. Otherwise, sets the logger\\n     * and return this Dataflow instance. Provided loggers must support the full\\n     * API of logger objects generated by the vega-util logger method. Note that\\n     * by default the log level of the new logger will be used; use the logLevel\\n     * method to adjust the log level as needed.\\n     */\\n    logger(logger) {\\n      if (arguments.length) {\\n        this._log = logger;\\n        return this;\\n      } else {\\n        return this._log;\\n      }\\n    },\\n\\n    /**\\n     * Logs an error message. By default, logged messages are written to console\\n     * output. The message will only be logged if the current log level is high\\n     * enough to permit error messages.\\n     */\\n    error: logMethod('error'),\\n\\n    /**\\n     * Logs a warning message. By default, logged messages are written to console\\n     * output. The message will only be logged if the current log level is high\\n     * enough to permit warning messages.\\n     */\\n    warn: logMethod('warn'),\\n\\n    /**\\n     * Logs a information message. By default, logged messages are written to\\n     * console output. The message will only be logged if the current log level is\\n     * high enough to permit information messages.\\n     */\\n    info: logMethod('info'),\\n\\n    /**\\n     * Logs a debug message. By default, logged messages are written to console\\n     * output. The message will only be logged if the current log level is high\\n     * enough to permit debug messages.\\n     */\\n    debug: logMethod('debug'),\\n\\n    /**\\n     * Get or set the current log level. If an argument is provided, it\\n     * will be used as the new log level.\\n     * @param {number} [level] - Should be one of None, Warn, Info\\n     * @return {number} - The current log level.\\n     */\\n    logLevel: logMethod('level'),\\n\\n    /**\\n     * Empty entry threshold for garbage cleaning. Map data structures will\\n     * perform cleaning once the number of empty entries exceeds this value.\\n     */\\n    cleanThreshold: 1e4,\\n\\n    // OPERATOR REGISTRATION\\n    add,\\n    connect,\\n    rank,\\n    rerank,\\n\\n    // OPERATOR UPDATES\\n    pulse,\\n    touch,\\n    update,\\n    changeset,\\n\\n    // DATA LOADING\\n    ingest: ingest$1,\\n    parse,\\n    preload,\\n    request,\\n\\n    // EVENT HANDLING\\n    events,\\n    on,\\n\\n    // PULSE PROPAGATION\\n    evaluate,\\n    run,\\n    runAsync,\\n    runAfter,\\n    _enqueue: enqueue,\\n    _getPulse: getPulse\\n  };\\n\\n  /**\\n   * Abstract class for operators that process data tuples.\\n   * Subclasses must provide a {@link transform} method for operator processing.\\n   * @constructor\\n   * @param {*} [init] - The initial value for this operator.\\n   * @param {object} [params] - The parameters for this operator.\\n   * @param {Operator} [source] - The operator from which to receive pulses.\\n   */\\n  function Transform(init, params) {\\n    Operator.call(this, init, null, params);\\n  }\\n\\n  vegaUtil.inherits(Transform, Operator, {\\n    /**\\n     * Overrides {@link Operator.evaluate} for transform operators.\\n     * Internally, this method calls {@link evaluate} to perform processing.\\n     * If {@link evaluate} returns a falsy value, the input pulse is returned.\\n     * This method should NOT be overridden, instead overrride {@link evaluate}.\\n     * @param {Pulse} pulse - the current dataflow pulse.\\n     * @return the output pulse for this operator (or StopPropagation)\\n     */\\n    run(pulse) {\\n      if (pulse.stamp < this.stamp) return pulse.StopPropagation;\\n\\n      let rv;\\n      if (this.skip()) {\\n        this.skip(false);\\n      } else {\\n        rv = this.evaluate(pulse);\\n      }\\n      rv = rv || pulse;\\n\\n      if (rv.then) {\\n        rv = rv.then(_ => this.pulse =_);\\n      } else if (rv !== pulse.StopPropagation) {\\n        this.pulse = rv;\\n      }\\n\\n      return rv;\\n    },\\n\\n    /**\\n     * Overrides {@link Operator.evaluate} for transform operators.\\n     * Marshalls parameter values and then invokes {@link transform}.\\n     * @param {Pulse} pulse - the current dataflow pulse.\\n     * @return {Pulse} The output pulse (or StopPropagation). A falsy return\\n         value (including undefined) will let the input pulse pass through.\\n    */\\n    evaluate(pulse) {\\n      const params = this.marshall(pulse.stamp),\\n            out = this.transform(params, pulse);\\n      params.clear();\\n      return out;\\n    },\\n\\n    /**\\n     * Process incoming pulses.\\n     * Subclasses should override this method to implement transforms.\\n     * @param {Parameters} _ - The operator parameter values.\\n     * @param {Pulse} pulse - The current dataflow pulse.\\n     * @return {Pulse} The output pulse (or StopPropagation). A falsy return\\n     *   value (including undefined) will let the input pulse pass through.\\n     */\\n    transform() {}\\n  });\\n\\n  const transforms = {};\\n\\n  function definition(type) {\\n    const t = transform(type);\\n    return t && t.Definition || null;\\n  }\\n\\n  function transform(type) {\\n    type = type && type.toLowerCase();\\n    return vegaUtil.hasOwnProperty(transforms, type) ? transforms[type] : null;\\n  }\\n\\n  exports.Dataflow = Dataflow;\\n  exports.EventStream = EventStream;\\n  exports.MultiPulse = MultiPulse;\\n  exports.Operator = Operator;\\n  exports.Parameters = Parameters;\\n  exports.Pulse = Pulse;\\n  exports.Transform = Transform;\\n  exports.UniqueList = UniqueList;\\n  exports.asyncCallback = asyncCallback;\\n  exports.changeset = changeset;\\n  exports.definition = definition;\\n  exports.derive = derive;\\n  exports.ingest = ingest;\\n  exports.isChangeSet = isChangeSet;\\n  exports.isTuple = isTuple;\\n  exports.rederive = rederive;\\n  exports.replace = replace;\\n  exports.stableCompare = stableCompare;\\n  exports.transform = transform;\\n  exports.transforms = transforms;\\n  exports.tupleid = tupleid;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"vegaUtil\",\"vegaLoader\",\"vegaFormat\",\"UniqueList\",\"idFunc\",\"$\",\"identity\",\"list\",\"ids\",\"add\",\"list.add\",\"_\",\"id\",\"push\",\"remove\",\"list.remove\",\"idx\",\"indexOf\",\"splice\",\"asyncCallback\",\"df\",\"callback\",\"err\",\"error\",\"ingest\",\"datum\",\"t\",\"Object\",\"data\",\"TUPLE_ID_KEY\",\"rederive\",\"d\",\"k\",\"isChangeSet\",\"v\",\"constructor\",\"changeset\",\"rem\",\"mod\",\"remp\",\"modp\",\"clean\",\"reflow\",\"insert\",\"array\",\"n\",\"length\",\"i\",\"a\",\"isFunction\",\"modify\",\"field\",\"value\",\"m\",\"constant\",\"filter\",\"tuple\",\"encode\",\"set\",\"pulse\",\"tuples\",\"f\",\"out\",\"cur\",\"forEach\",\"modifies\",\"slice\",\"Parameters\",\"defineProperty\",\"CACHE\",\"writable\",\"Operator\",\"init\",\"update\",\"params\",\"react\",\"OP_ID\",\"qrank\",\"rank\",\"stamp\",\"flags\",\"_update\",\"parameters\",\"flag\",\"bit\",\"state\",\"arguments\",\"EventStream\",\"apply\",\"receive\",\"STREAM_ID\",\"_filter\",\"_apply\",\"stream\",\"loadPending\",\"accept\",\"pending\",\"Promise\",\"requests\",\"done\",\"pending.done\",\"_pending\",\"onStream\",\"target\",\"options\",\"opt\",\"extend\",\"SKIP$1\",\"undefined\",\"func\",\"e\",\"touch\",\"op\",\"evaluate\",\"onOperator\",\"source\",\"targets\",\"updater\",\"modified\",\"force\",\"skip\",\"connect\",\"Pulse\",\"dataflow\",\"fields\",\"materialize\",\"visitArray\",\"map\",\"visit\",\"addFilter\",\"b\",\"MultiPulse\",\"pulses\",\"c\",\"hash\",\"p\",\"changed\",\"ADD\",\"REM\",\"MOD\",\"changes\",\"reentrant\",\"singlePulse\",\"s\",\"fork\",\"StopPropagation\",\"Heap\",\"cmp\",\"nodes\",\"clear\",\"size\",\"peek\",\"x\",\"siftdown\",\"pop\",\"last\",\"item\",\"start\",\"end\",\"cidx\",\"ridx\",\"parent\",\"pidx\",\"Dataflow\",\"logger\",\"logLevel\",\"Error\",\"_rank\",\"_clock\",\"_locale\",\"defaultLocale\",\"_loader\",\"loader\",\"_touched\",\"_input\",\"_pulse\",\"_heap\",\"_postrun\",\"logMethod\",\"method\",\"_log\",\"Transform\",\"call\",\"transform\",\"type\",\"toLowerCase\",\"hasOwnProperty\",\"transforms\",\"Symbol\",\"TUPLE_ID\",\"prototype\",\"name\",\"index\",\"o\",\"isArray\",\"NO_PARAMS\",\"_targets\",\"SKIP\",\"MODIFIED\",\"initonly\",\"argval\",\"_argval\",\"argops\",\"_argops\",\"deps\",\"PULSE\",\"Array\",\"marshall\",\"detach\",\"run\",\"rv\",\"truthy\",\"consume\",\"_consume\",\"evt\",\"val\",\"trg\",\"preventDefault\",\"stopPropagation\",\"merge\",\"throttle\",\"pause\",\"now\",\"Date\",\"debounce\",\"delay\",\"between\",\"active\",\"ADD_REM\",\"ADD_MOD\",\"ALL\",\"REFLOW\",\"SOURCE\",\"NO_SOURCE\",\"NO_FIELDS\",\"clone\",\"addAll\",\"src\",\"addF\",\"remF\",\"modF\",\"srcF\",\"cleans\",\"runAfter\",\"len\",\"nomod\",\"some\",\"visitor\",\"sum\",\"inherits\",\"NO_OPT\",\"locale\",\"warn\",\"info\",\"debug\",\"cleanThreshold\",\"shift\",\"sources\",\"targetRank\",\"rerank\",\"queue\",\"_enqueue\",\"ingest$1\",\"format\",\"parse\",\"read\",\"timeParse\",\"utcParse\",\"preload\",\"url\",\"res\",\"request\",\"status\",\"load\",\"context\",\"response\",\"responseType\",\"events\",\"send\",\"document\",\"querySelectorAll\",\"addEventListener\",\"on\",\"fn\",\"prerun\",\"postrun\",\"async\",\"count\",\"next\",\"pr\",\"_getPulse\",\"then\",\"sort\",\"priority\",\"all\",\"cb\",\"runAsync\",\"_running\",\"enqueue\",\"q\",\"getPulse\",\"definition\",\"Definition\",\"derive\",\"isTuple\",\"replace\",\"stableCompare\",\"tupleid\"]\n}\n"]