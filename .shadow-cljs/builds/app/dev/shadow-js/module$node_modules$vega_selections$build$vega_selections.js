["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-selections/build/vega-selections.js"],"~:js","shadow$provide.module$node_modules$vega_selections$build$vega_selections=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_util$build$vega_util\"),require(\"module$node_modules$vega_expression$build$vega_expression\")):\"function\"===typeof define&&define.amd?define([\"exports\",\"vega-util\",\"vega-expression\"],factory):(global=\"undefined\"!==typeof globalThis?\nglobalThis:global||self,factory(global.vega={},global.vega,global.vega))})(this,function(exports,vegaUtil,vegaExpression){function testPoint(datum,entry){var fields=entry.fields;entry=entry.values;for(var n=fields.length,i=0,dval,f;i<n;++i)if(f=fields[i],f.getter=vegaUtil.field.getter||vegaUtil.field(f.field),dval=f.getter(datum),vegaUtil.isDate(dval)&&(dval=vegaUtil.toNumber(dval)),vegaUtil.isDate(entry[i])&&(entry[i]=vegaUtil.toNumber(entry[i])),vegaUtil.isDate(entry[i][0])&&(entry[i]=entry[i].map(vegaUtil.toNumber)),\n\"E\"===f.type){if(vegaUtil.isArray(entry[i])?0>entry[i].indexOf(dval):dval!==entry[i])return!1}else if(\"R\"===f.type){if(!vegaUtil.inrange(dval,entry[i]))return!1}else if(\"R-RE\"===f.type){if(!vegaUtil.inrange(dval,entry[i],!0,!1))return!1}else if(\"R-E\"===f.type){if(!vegaUtil.inrange(dval,entry[i],!1,!1))return!1}else if(\"R-LE\"===f.type&&!vegaUtil.inrange(dval,entry[i],!1,!0))return!1;return!0}var ops={E_union:function(base,value){if(!base.length)return value;for(var i=0,n=value.length;i<n;++i)0>base.indexOf(value[i])&&\nbase.push(value[i]);return base},E_intersect:function(base,value){return base.length?base.filter(function(v){return 0<=value.indexOf(v)}):value},R_union:function(base,value){var lo=vegaUtil.toNumber(value[0]),hi=vegaUtil.toNumber(value[1]);lo>hi&&(lo=value[1],hi=value[0]);if(!base.length)return[lo,hi];base[0]>lo&&(base[0]=lo);base[1]<hi&&(base[1]=hi);return base},R_intersect:function(base,value){var lo=vegaUtil.toNumber(value[0]),hi=vegaUtil.toNumber(value[1]);lo>hi&&(lo=value[1],hi=value[0]);if(!base.length)return[lo,\nhi];if(hi<base[0]||base[1]<lo)return[];base[0]<lo&&(base[0]=lo);base[1]>hi&&(base[1]=hi);return base}};exports.selectionResolve=function(name,op,isMulti){name=(name=this.context.data[name])?name.values.value:[];for(var resolved={},multiRes={},types={},entry,fields,unit$jscomp$0,field$jscomp$0,res,resUnit,n=name.length,i=0,j$jscomp$0,m;i<n;++i){entry=name[i];unit$jscomp$0=entry.unit;fields=entry.fields;entry=entry.values;j$jscomp$0=0;for(m=fields.length;j$jscomp$0<m;++j$jscomp$0)field$jscomp$0=fields[j$jscomp$0],\nres=resolved[field$jscomp$0.field]||(resolved[field$jscomp$0.field]={}),resUnit=res[unit$jscomp$0]||(res[unit$jscomp$0]=[]),types[field$jscomp$0.field]=field$jscomp$0=field$jscomp$0.type.charAt(0),field$jscomp$0=ops[field$jscomp$0+\"_union\"],res[unit$jscomp$0]=field$jscomp$0(resUnit,vegaUtil.array(entry[j$jscomp$0]));isMulti&&(resUnit=multiRes[unit$jscomp$0]||(multiRes[unit$jscomp$0]=[]),resUnit.push(vegaUtil.array(entry).reduce(function(obj,curr,j){return obj[fields[j].field]=curr,obj},{})))}op=op||\n\"union\";Object.keys(resolved).forEach(function(field){resolved[field]=Object.keys(resolved[field]).map(function(unit){return resolved[field][unit]}).reduce(function(acc,curr){return void 0===acc?curr:ops[types[field]+\"_\"+op](acc,curr)})});name=Object.keys(multiRes);isMulti&&name.length&&(isMulti={},unit$jscomp$0={},resolved.vlMulti=\"union\"===op?(isMulti.or=name.reduce(function(acc,k){return acc.push.apply(acc,multiRes[k]),acc},[]),isMulti):(unit$jscomp$0.and=name.map(function(k){var $jscomp$compprop15=\n{};return $jscomp$compprop15.or=multiRes[k],$jscomp$compprop15}),unit$jscomp$0));return resolved};exports.selectionTest=function(name,datum,op){var data=this.context.data[name];name=data?data.values.value:[];data=data?data[\"index:unit\"]&&data[\"index:unit\"].value:void 0;op=\"intersect\"===op;for(var n=name.length,i=0,entry,miss,count,unit;i<n;++i)if(entry=name[i],data&&op){if(miss=miss||{},count=miss[unit=entry.unit]||0,-1!==count){entry=testPoint(datum,entry);miss[unit]=entry?-1:++count;if(entry&&1===\ndata.size)return!0;if(!entry&&count===data.get(unit).count)return!1}}else if(entry=testPoint(datum,entry),op^entry)return entry;return n&&op};exports.selectionVisitor=function(name,args,scope,params){args[0].type!==vegaExpression.Literal&&vegaUtil.error(\"First argument to selection functions must be a string literal.\");name=args[0].value;args=2<=args.length&&vegaUtil.peek(args).value;var dataName=\":\"+name;\"intersect\"!==args||vegaUtil.hasOwnProperty(params,\"@unit\")||(params[\"@unit\"]=scope.getData(name).indataRef(scope,\n\"unit\"));vegaUtil.hasOwnProperty(params,dataName)||(params[dataName]=scope.getData(name).tuplesRef())};Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_selections$build$vega_selections\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-expression')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-expression'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega));\n}(this, (function (exports, vegaUtil, vegaExpression) { 'use strict';\n\n  const Intersect = 'intersect';\n  const Union = 'union';\n  const VlMulti = 'vlMulti';\n  const Or = 'or';\n  const And = 'and';\n\n  var TYPE_ENUM = 'E',\n      TYPE_RANGE_INC = 'R',\n      TYPE_RANGE_EXC = 'R-E',\n      TYPE_RANGE_LE = 'R-LE',\n      TYPE_RANGE_RE = 'R-RE',\n      UNIT_INDEX = 'index:unit';\n\n  // TODO: revisit date coercion?\n  function testPoint(datum, entry) {\n    var fields = entry.fields,\n        values = entry.values,\n        n = fields.length,\n        i = 0, dval, f;\n\n    for (; i<n; ++i) {\n      f = fields[i];\n      f.getter = vegaUtil.field.getter || vegaUtil.field(f.field);\n      dval = f.getter(datum);\n\n      if (vegaUtil.isDate(dval)) dval = vegaUtil.toNumber(dval);\n      if (vegaUtil.isDate(values[i])) values[i] = vegaUtil.toNumber(values[i]);\n      if (vegaUtil.isDate(values[i][0])) values[i] = values[i].map(vegaUtil.toNumber);\n\n      if (f.type === TYPE_ENUM) {\n        // Enumerated fields can either specify individual values (single/multi selections)\n        // or an array of values (interval selections).\n        if(vegaUtil.isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n          return false;\n        }\n      } else {\n        if (f.type === TYPE_RANGE_INC) {\n          if (!vegaUtil.inrange(dval, values[i])) return false;\n        } else if (f.type === TYPE_RANGE_RE) {\n          // Discrete selection of bins test within the range [bin_start, bin_end).\n          if (!vegaUtil.inrange(dval, values[i], true, false)) return false;\n        } else if (f.type === TYPE_RANGE_EXC) { // 'R-E'/'R-LE' included for completeness.\n          if (!vegaUtil.inrange(dval, values[i], false, false)) return false;\n        } else if (f.type === TYPE_RANGE_LE) {\n          if (!vegaUtil.inrange(dval, values[i], false, true)) return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Tests if a tuple is contained within an interactive selection.\n   * @param {string} name - The name of the data set representing the selection.\n   *  Tuples in the dataset are of the form\n   *  {unit: string, fields: array<fielddef>, values: array<*>}.\n   *  Fielddef is of the form\n   *  {field: string, channel: string, type: 'E' | 'R'} where\n   *  'type' identifies whether tuples in the dataset enumerate\n   *  values for the field, or specify a continuous range.\n   * @param {object} datum - The tuple to test for inclusion.\n   * @param {string} op - The set operation for combining selections.\n   *   One of 'intersect' or 'union' (default).\n   * @return {boolean} - True if the datum is in the selection, false otherwise.\n   */\n  function selectionTest(name, datum, op) {\n    var data = this.context.data[name],\n        entries = data ? data.values.value : [],\n        unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n        intersect = op === Intersect,\n        n = entries.length,\n        i = 0,\n        entry, miss, count, unit, b;\n\n    for (; i<n; ++i) {\n      entry = entries[i];\n\n      if (unitIdx && intersect) {\n        // multi selections union within the same unit and intersect across units.\n        miss = miss || {};\n        count = miss[unit=entry.unit] || 0;\n\n        // if we've already matched this unit, skip.\n        if (count === -1) continue;\n\n        b = testPoint(datum, entry);\n        miss[unit] = b ? -1 : ++count;\n\n        // if we match and there are no other units return true\n        // if we've missed against all tuples in this unit return false\n        if (b && unitIdx.size === 1) return true;\n        if (!b && count === unitIdx.get(unit).count) return false;\n      } else {\n        b = testPoint(datum, entry);\n\n        // if we find a miss and we do require intersection return false\n        // if we find a match and we don't require intersection return true\n        if (intersect ^ b) return b;\n      }\n    }\n\n    // if intersecting and we made it here, then we saw no misses\n    // if not intersecting, then we saw no matches\n    // if no active selections, return false\n    return n && intersect;\n  }\n\n  /**\n   * Resolves selection for use as a scale domain or reads via the API.\n   * @param {string} name - The name of the dataset representing the selection\n   * @param {string} [op='union'] - The set operation for combining selections.\n   *                 One of 'intersect' or 'union' (default).\n   * @returns {object} An object of selected fields and values.\n   */\n  function selectionResolve(name, op, isMulti) {\n    var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      resolved = {}, multiRes = {}, types = {},\n      entry, fields, values, unit, field, res, resUnit, type, union,\n      n = entries.length, i = 0, j, m;\n\n    // First union all entries within the same unit.\n    for (; i < n; ++i) {\n      entry = entries[i];\n      unit = entry.unit;\n      fields = entry.fields;\n      values = entry.values;\n\n      for (j = 0, m = fields.length; j < m; ++j) {\n        field = fields[j];\n        res = resolved[field.field] || (resolved[field.field] = {});\n        resUnit = res[unit] || (res[unit] = []);\n        types[field.field] = type = field.type.charAt(0);\n        union = ops[type + '_union'];\n        res[unit] = union(resUnit, vegaUtil.array(values[j]));\n      }\n\n      // If the same multi-selection is repeated over views and projected over\n      // an encoding, it may operate over different fields making it especially\n      // tricky to reliably resolve it. At best, we can de-dupe identical entries\n      // but doing so may be more computationally expensive than it is worth.\n      // Instead, for now, we simply transform our store representation into\n      // a more human-friendly one.\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push(vegaUtil.array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n      }\n    }\n\n    // Then resolve fields across units as per the op.\n    op = op || Union;\n    Object.keys(resolved).forEach(field => {\n      resolved[field] = Object.keys(resolved[field])\n        .map(unit => resolved[field][unit])\n        .reduce((acc, curr) => acc === undefined ? curr : ops[types[field] + '_' + op](acc, curr));\n    });\n\n    entries = Object.keys(multiRes);\n    if (isMulti && entries.length) {\n      resolved[VlMulti] = op === Union\n        ? {[Or]: entries.reduce((acc, k) => (acc.push.apply(acc, multiRes[k]), acc), [])}\n        : {[And]: entries.map(k => ({[Or]: multiRes[k]}))};\n    }\n\n    return resolved;\n  }\n\n  var ops = {\n    E_union: function(base, value) {\n      if (!base.length) return value;\n\n      var i = 0, n = value.length;\n      for (; i<n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\n      return base;\n    },\n\n    E_intersect: function(base, value) {\n      return !base.length ? value :\n        base.filter(v => value.indexOf(v) >= 0);\n    },\n\n    R_union: function(base, value) {\n      var lo = vegaUtil.toNumber(value[0]), hi = vegaUtil.toNumber(value[1]);\n      if (lo > hi) {\n        lo = value[1];\n        hi = value[0];\n      }\n\n      if (!base.length) return [lo, hi];\n      if (base[0] > lo) base[0] = lo;\n      if (base[1] < hi) base[1] = hi;\n      return base;\n    },\n\n    R_intersect: function(base, value) {\n      var lo = vegaUtil.toNumber(value[0]), hi = vegaUtil.toNumber(value[1]);\n      if (lo > hi) {\n        lo = value[1];\n        hi = value[0];\n      }\n\n      if (!base.length) return [lo, hi];\n      if (hi < base[0] || base[1] < lo) {\n        return [];\n      } else {\n        if (base[0] < lo) base[0] = lo;\n        if (base[1] > hi) base[1] = hi;\n      }\n      return base;\n    }\n  };\n\n  const DataPrefix = ':',\n        IndexPrefix = '@';\n\n  function selectionVisitor(name, args, scope, params) {\n    if (args[0].type !== vegaExpression.Literal) vegaUtil.error('First argument to selection functions must be a string literal.');\n\n    const data = args[0].value,\n          op = args.length >= 2 && vegaUtil.peek(args).value,\n          field = 'unit',\n          indexName = IndexPrefix + field,\n          dataName = DataPrefix + data;\n\n    // eslint-disable-next-line no-prototype-builtins\n    if (op === Intersect && !vegaUtil.hasOwnProperty(params, indexName)) {\n      params[indexName] = scope.getData(data).indataRef(scope, field);\n    }\n\n    // eslint-disable-next-line no-prototype-builtins\n    if (!vegaUtil.hasOwnProperty(params, dataName)) {\n      params[dataName] = scope.getData(data).tuplesRef();\n    }\n  }\n\n  exports.selectionResolve = selectionResolve;\n  exports.selectionTest = selectionTest;\n  exports.selectionVisitor = selectionVisitor;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vega_expression$build$vega_expression","~$shadow.js","~$module$node_modules$vega_util$build$vega_util"]],"~:properties",["^5",["selectionVisitor","E_union","__esModule","vega","selectionResolve","getter","value","R_union","R_intersect","selectionTest","E_intersect"]],"~:compiled-at",1600144480018,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_selections$build$vega_selections.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-selections/build/vega-selections.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_selections$build$vega_selections\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-expression')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-expression'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega));\\n}(this, (function (exports, vegaUtil, vegaExpression) { 'use strict';\\n\\n  const Intersect = 'intersect';\\n  const Union = 'union';\\n  const VlMulti = 'vlMulti';\\n  const Or = 'or';\\n  const And = 'and';\\n\\n  var TYPE_ENUM = 'E',\\n      TYPE_RANGE_INC = 'R',\\n      TYPE_RANGE_EXC = 'R-E',\\n      TYPE_RANGE_LE = 'R-LE',\\n      TYPE_RANGE_RE = 'R-RE',\\n      UNIT_INDEX = 'index:unit';\\n\\n  // TODO: revisit date coercion?\\n  function testPoint(datum, entry) {\\n    var fields = entry.fields,\\n        values = entry.values,\\n        n = fields.length,\\n        i = 0, dval, f;\\n\\n    for (; i<n; ++i) {\\n      f = fields[i];\\n      f.getter = vegaUtil.field.getter || vegaUtil.field(f.field);\\n      dval = f.getter(datum);\\n\\n      if (vegaUtil.isDate(dval)) dval = vegaUtil.toNumber(dval);\\n      if (vegaUtil.isDate(values[i])) values[i] = vegaUtil.toNumber(values[i]);\\n      if (vegaUtil.isDate(values[i][0])) values[i] = values[i].map(vegaUtil.toNumber);\\n\\n      if (f.type === TYPE_ENUM) {\\n        // Enumerated fields can either specify individual values (single/multi selections)\\n        // or an array of values (interval selections).\\n        if(vegaUtil.isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\\n          return false;\\n        }\\n      } else {\\n        if (f.type === TYPE_RANGE_INC) {\\n          if (!vegaUtil.inrange(dval, values[i])) return false;\\n        } else if (f.type === TYPE_RANGE_RE) {\\n          // Discrete selection of bins test within the range [bin_start, bin_end).\\n          if (!vegaUtil.inrange(dval, values[i], true, false)) return false;\\n        } else if (f.type === TYPE_RANGE_EXC) { // 'R-E'/'R-LE' included for completeness.\\n          if (!vegaUtil.inrange(dval, values[i], false, false)) return false;\\n        } else if (f.type === TYPE_RANGE_LE) {\\n          if (!vegaUtil.inrange(dval, values[i], false, true)) return false;\\n        }\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * Tests if a tuple is contained within an interactive selection.\\n   * @param {string} name - The name of the data set representing the selection.\\n   *  Tuples in the dataset are of the form\\n   *  {unit: string, fields: array<fielddef>, values: array<*>}.\\n   *  Fielddef is of the form\\n   *  {field: string, channel: string, type: 'E' | 'R'} where\\n   *  'type' identifies whether tuples in the dataset enumerate\\n   *  values for the field, or specify a continuous range.\\n   * @param {object} datum - The tuple to test for inclusion.\\n   * @param {string} op - The set operation for combining selections.\\n   *   One of 'intersect' or 'union' (default).\\n   * @return {boolean} - True if the datum is in the selection, false otherwise.\\n   */\\n  function selectionTest(name, datum, op) {\\n    var data = this.context.data[name],\\n        entries = data ? data.values.value : [],\\n        unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\\n        intersect = op === Intersect,\\n        n = entries.length,\\n        i = 0,\\n        entry, miss, count, unit, b;\\n\\n    for (; i<n; ++i) {\\n      entry = entries[i];\\n\\n      if (unitIdx && intersect) {\\n        // multi selections union within the same unit and intersect across units.\\n        miss = miss || {};\\n        count = miss[unit=entry.unit] || 0;\\n\\n        // if we've already matched this unit, skip.\\n        if (count === -1) continue;\\n\\n        b = testPoint(datum, entry);\\n        miss[unit] = b ? -1 : ++count;\\n\\n        // if we match and there are no other units return true\\n        // if we've missed against all tuples in this unit return false\\n        if (b && unitIdx.size === 1) return true;\\n        if (!b && count === unitIdx.get(unit).count) return false;\\n      } else {\\n        b = testPoint(datum, entry);\\n\\n        // if we find a miss and we do require intersection return false\\n        // if we find a match and we don't require intersection return true\\n        if (intersect ^ b) return b;\\n      }\\n    }\\n\\n    // if intersecting and we made it here, then we saw no misses\\n    // if not intersecting, then we saw no matches\\n    // if no active selections, return false\\n    return n && intersect;\\n  }\\n\\n  /**\\n   * Resolves selection for use as a scale domain or reads via the API.\\n   * @param {string} name - The name of the dataset representing the selection\\n   * @param {string} [op='union'] - The set operation for combining selections.\\n   *                 One of 'intersect' or 'union' (default).\\n   * @returns {object} An object of selected fields and values.\\n   */\\n  function selectionResolve(name, op, isMulti) {\\n    var data = this.context.data[name],\\n      entries = data ? data.values.value : [],\\n      resolved = {}, multiRes = {}, types = {},\\n      entry, fields, values, unit, field, res, resUnit, type, union,\\n      n = entries.length, i = 0, j, m;\\n\\n    // First union all entries within the same unit.\\n    for (; i < n; ++i) {\\n      entry = entries[i];\\n      unit = entry.unit;\\n      fields = entry.fields;\\n      values = entry.values;\\n\\n      for (j = 0, m = fields.length; j < m; ++j) {\\n        field = fields[j];\\n        res = resolved[field.field] || (resolved[field.field] = {});\\n        resUnit = res[unit] || (res[unit] = []);\\n        types[field.field] = type = field.type.charAt(0);\\n        union = ops[type + '_union'];\\n        res[unit] = union(resUnit, vegaUtil.array(values[j]));\\n      }\\n\\n      // If the same multi-selection is repeated over views and projected over\\n      // an encoding, it may operate over different fields making it especially\\n      // tricky to reliably resolve it. At best, we can de-dupe identical entries\\n      // but doing so may be more computationally expensive than it is worth.\\n      // Instead, for now, we simply transform our store representation into\\n      // a more human-friendly one.\\n      if (isMulti) {\\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\\n        resUnit.push(vegaUtil.array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\\n      }\\n    }\\n\\n    // Then resolve fields across units as per the op.\\n    op = op || Union;\\n    Object.keys(resolved).forEach(field => {\\n      resolved[field] = Object.keys(resolved[field])\\n        .map(unit => resolved[field][unit])\\n        .reduce((acc, curr) => acc === undefined ? curr : ops[types[field] + '_' + op](acc, curr));\\n    });\\n\\n    entries = Object.keys(multiRes);\\n    if (isMulti && entries.length) {\\n      resolved[VlMulti] = op === Union\\n        ? {[Or]: entries.reduce((acc, k) => (acc.push.apply(acc, multiRes[k]), acc), [])}\\n        : {[And]: entries.map(k => ({[Or]: multiRes[k]}))};\\n    }\\n\\n    return resolved;\\n  }\\n\\n  var ops = {\\n    E_union: function(base, value) {\\n      if (!base.length) return value;\\n\\n      var i = 0, n = value.length;\\n      for (; i<n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\\n      return base;\\n    },\\n\\n    E_intersect: function(base, value) {\\n      return !base.length ? value :\\n        base.filter(v => value.indexOf(v) >= 0);\\n    },\\n\\n    R_union: function(base, value) {\\n      var lo = vegaUtil.toNumber(value[0]), hi = vegaUtil.toNumber(value[1]);\\n      if (lo > hi) {\\n        lo = value[1];\\n        hi = value[0];\\n      }\\n\\n      if (!base.length) return [lo, hi];\\n      if (base[0] > lo) base[0] = lo;\\n      if (base[1] < hi) base[1] = hi;\\n      return base;\\n    },\\n\\n    R_intersect: function(base, value) {\\n      var lo = vegaUtil.toNumber(value[0]), hi = vegaUtil.toNumber(value[1]);\\n      if (lo > hi) {\\n        lo = value[1];\\n        hi = value[0];\\n      }\\n\\n      if (!base.length) return [lo, hi];\\n      if (hi < base[0] || base[1] < lo) {\\n        return [];\\n      } else {\\n        if (base[0] < lo) base[0] = lo;\\n        if (base[1] > hi) base[1] = hi;\\n      }\\n      return base;\\n    }\\n  };\\n\\n  const DataPrefix = ':',\\n        IndexPrefix = '@';\\n\\n  function selectionVisitor(name, args, scope, params) {\\n    if (args[0].type !== vegaExpression.Literal) vegaUtil.error('First argument to selection functions must be a string literal.');\\n\\n    const data = args[0].value,\\n          op = args.length >= 2 && vegaUtil.peek(args).value,\\n          field = 'unit',\\n          indexName = IndexPrefix + field,\\n          dataName = DataPrefix + data;\\n\\n    // eslint-disable-next-line no-prototype-builtins\\n    if (op === Intersect && !vegaUtil.hasOwnProperty(params, indexName)) {\\n      params[indexName] = scope.getData(data).indataRef(scope, field);\\n    }\\n\\n    // eslint-disable-next-line no-prototype-builtins\\n    if (!vegaUtil.hasOwnProperty(params, dataName)) {\\n      params[dataName] = scope.getData(data).tuplesRef();\\n    }\\n  }\\n\\n  exports.selectionResolve = selectionResolve;\\n  exports.selectionTest = selectionTest;\\n  exports.selectionVisitor = selectionVisitor;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"vegaUtil\",\"vegaExpression\",\"testPoint\",\"datum\",\"entry\",\"fields\",\"values\",\"n\",\"length\",\"i\",\"dval\",\"f\",\"getter\",\"field\",\"isDate\",\"toNumber\",\"map\",\"TYPE_ENUM\",\"type\",\"isArray\",\"indexOf\",\"TYPE_RANGE_INC\",\"inrange\",\"TYPE_RANGE_RE\",\"TYPE_RANGE_EXC\",\"TYPE_RANGE_LE\",\"ops\",\"E_union\",\"base\",\"value\",\"push\",\"E_intersect\",\"filter\",\"v\",\"R_union\",\"lo\",\"hi\",\"R_intersect\",\"selectionResolve\",\"name\",\"op\",\"isMulti\",\"entries\",\"data\",\"context\",\"resolved\",\"multiRes\",\"types\",\"unit\",\"res\",\"resUnit\",\"j\",\"m\",\"charAt\",\"union\",\"array\",\"reduce\",\"obj\",\"curr\",\"Union\",\"Object\",\"keys\",\"forEach\",\"acc\",\"undefined\",\"VlMulti\",\"Or\",\"k\",\"apply\",\"And\",\"selectionTest\",\"unitIdx\",\"UNIT_INDEX\",\"intersect\",\"Intersect\",\"miss\",\"count\",\"b\",\"size\",\"get\",\"selectionVisitor\",\"args\",\"scope\",\"params\",\"Literal\",\"error\",\"peek\",\"dataName\",\"DataPrefix\",\"hasOwnProperty\",\"indexName\",\"getData\",\"indataRef\",\"tuplesRef\",\"defineProperty\"]\n}\n"]