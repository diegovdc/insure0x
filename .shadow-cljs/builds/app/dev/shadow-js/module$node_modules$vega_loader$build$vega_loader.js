["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-loader/build/vega-loader.js"],"~:js","shadow$provide.module$node_modules$vega_loader$build$vega_loader=function(global$jscomp$0,require,module,exports$jscomp$0){var Buffer=require(\"module$node_modules$buffer$index\").Buffer;(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_util$build$vega_util\"),require(\"module$node_modules$d3_dsv$dist$d3_dsv\"),require(\"module$node_modules$topojson_client$dist$topojson_client\"),require(\"module$node_modules$vega_format$build$vega_format\")):\n\"function\"===typeof define&&define.amd?define([\"exports\",\"vega-util\",\"d3-dsv\",\"topojson-client\",\"vega-format\"],factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory(global.vega={},global.vega,global.d3,global.topojson,global.vega))})(this,function(exports,vegaUtil,d3Dsv,topojsonClient,vegaFormat){function load(uri,options){var $jscomp$async$this=this,opt,url;return $jscomp.asyncExecutePromiseGeneratorProgram(function($jscomp$generator$context){if(1==$jscomp$generator$context.nextAddress)return $jscomp$generator$context.yield($jscomp$async$this.sanitize(uri,\noptions),2);opt=$jscomp$generator$context.yieldResult;url=opt.href;return $jscomp$generator$context.return(opt.localFile?$jscomp$async$this.file(url):$jscomp$async$this.http(url,options))})}function sanitize(uri,options){var $jscomp$async$this=this,fileAccess,result,isFile,loadFile,base,isAllowed,hasProtocol;return $jscomp.asyncExecutePromiseGeneratorProgram(function($jscomp$generator$context){options=vegaUtil.extend({},$jscomp$async$this.options,options);fileAccess=$jscomp$async$this.fileAccess;\nresult={href:null};isAllowed=allowed_re.test(uri.replace(whitespace_re,\"\"));null!=uri&&\"string\"===typeof uri&&isAllowed||vegaUtil.error(\"Sanitize failure, invalid URI: \"+vegaUtil.stringValue(uri));hasProtocol=protocol_re.test(uri);(base=options.baseURL)&&!hasProtocol&&(uri.startsWith(\"/\")||\"/\"===base[base.length-1]||(uri=\"/\"+uri),uri=base+uri);loadFile=(isFile=uri.startsWith(\"file://\"))||\"file\"===options.mode||\"http\"!==options.mode&&!hasProtocol&&fileAccess;isFile?uri=uri.slice(7):uri.startsWith(\"//\")&&\n(\"file\"===options.defaultProtocol?(uri=uri.slice(2),loadFile=!0):uri=(options.defaultProtocol||\"http\")+\":\"+uri);Object.defineProperty(result,\"localFile\",{value:!!loadFile});result.href=uri;options.target&&(result.target=options.target+\"\");options.rel&&(result.rel=options.rel+\"\");\"image\"===options.context&&options.crossOrigin&&(result.crossOrigin=options.crossOrigin+\"\");return $jscomp$generator$context.return(result)})}function fileLoader(fs){return fs?function(filename){return new Promise(function(accept,\nreject){fs.readFile(filename,function(error,data){error?reject(error):accept(data)})})}:fileReject}function fileReject(){return $jscomp.asyncExecutePromiseGeneratorProgram(function($jscomp$generator$context){vegaUtil.error(\"No file system access.\");$jscomp$generator$context.jumpToEnd()})}function httpLoader(fetch){return fetch?function(url,options){var $jscomp$async$this=this,opt,type,response;return $jscomp.asyncExecutePromiseGeneratorProgram(function($jscomp$generator$context){if(1==$jscomp$generator$context.nextAddress)return opt=\nvegaUtil.extend({},$jscomp$async$this.options.http,options),type=options&&options.response,$jscomp$generator$context.yield(fetch(url,opt),2);response=$jscomp$generator$context.yieldResult;return $jscomp$generator$context.return(response.ok?vegaUtil.isFunction(response[type])?response[type]():response.text():vegaUtil.error(response.status+\"\"+response.statusText))})}:httpReject}function httpReject(){return $jscomp.asyncExecutePromiseGeneratorProgram(function($jscomp$generator$context){vegaUtil.error(\"No HTTP fetch method available.\");\n$jscomp$generator$context.jumpToEnd()})}function inferType(values,field){if(!values||!values.length)return\"unknown\";for(var n=values.length,m=typeTests.length,a=typeTests.map(function(_,i){return i+1}),i$jscomp$0=0,t=0,j=void 0,value=void 0;i$jscomp$0<n;++i$jscomp$0)for(value=field?values[i$jscomp$0][field]:values[i$jscomp$0],j=0;j<m;++j)if(a[j]&&null!=value&&value===value&&!typeTests[j](value)&&(a[j]=0,++t,t===typeTests.length))return\"string\";return typeList[a.reduce(function(u,v){return 0===u?v:\nu},0)-1]}function inferTypes(data,fields){return fields.reduce(function(types,field){types[field]=inferType(data,field);return types},{})}function delimitedFormat(delimiter){var parse=function(data,format){var delim={delimiter:delimiter};return dsv(data,format?vegaUtil.extend(format,delim):delim)};parse.responseType=\"text\";return parse}function dsv(data,format){format.header&&(data=format.header.map(vegaUtil.stringValue).join(format.delimiter)+\"\\n\"+data);return d3Dsv.dsvFormat(format.delimiter).parse(data+\n\"\")}function json(data,format){format=format&&format.property?vegaUtil.field(format.property):vegaUtil.identity;var JSCompiler_temp;if(JSCompiler_temp=vegaUtil.isObject(data))JSCompiler_temp=!(\"function\"===typeof Buffer&&vegaUtil.isFunction(Buffer.isBuffer)&&Buffer.isBuffer(data));return JSCompiler_temp?format(data):format(JSON.parse(data))}function topojson(data,format){var object;data=json(data,format);if(format&&format.feature){var method=topojsonClient.feature;var property=format.feature}else if(format&&\nformat.mesh){method=topojsonClient.mesh;property=format.mesh;var filter=filters[format.filter]}else vegaUtil.error(\"Missing TopoJSON feature or mesh parameter.\");return(object=(object=data.objects[property])?method(data,object,filter):vegaUtil.error(\"Invalid TopoJSON object: \"+property))&&object.features||[object]}function formats(name,reader){return 1<arguments.length?(format$jscomp$0[name]=reader,this):vegaUtil.hasOwnProperty(format$jscomp$0,name)?format$jscomp$0[name]:null}function parse$jscomp$0(data,\ntypes,timeParser,utcParser){if(data.length){var locale=vegaFormat.timeFormatDefaultLocale();timeParser=timeParser||locale.timeParse;utcParser=utcParser||locale.utcParse;locale=data.columns||Object.keys(data[0]);var j,m;\"auto\"===types&&(types=inferTypes(data,locale));locale=Object.keys(types);var parsers=locale.map(function(field){var type=types[field];if(type&&(type.startsWith(\"date:\")||type.startsWith(\"utc:\"))){field=type.split(/:(.+)?/,2);type=field[1];if(\"'\"===type[0]&&\"'\"===type[type.length-1]||\n'\"'===type[0]&&'\"'===type[type.length-1])type=type.slice(1,-1);return(\"utc\"===field[0]?utcParser:timeParser)(type)}if(!typeParsers[type])throw Error(\"Illegal format pattern: \"+field+\":\"+type);return typeParsers[type]});var i=0;var n=data.length;for(m=locale.length;i<n;++i){var datum=data[i];for(j=0;j<m;++j){var field$jscomp$0=locale[j];datum[field$jscomp$0]=parsers[j](datum[field$jscomp$0])}}}}var protocol_re=/^([A-Za-z]+:)?\\/\\//,allowed_re=/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i,\nwhitespace_re=/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g,isNumber=function(_){return!Number.isNaN(+_)&&!(_ instanceof Date)},typeParsers={boolean:vegaUtil.toBoolean,integer:vegaUtil.toNumber,number:vegaUtil.toNumber,date:vegaUtil.toDate,string:vegaUtil.toString,unknown:vegaUtil.identity},typeTests=[function(_){return\"true\"===_||\"false\"===_||!0===_||!1===_},function(_){return isNumber(_)&&Number.isInteger(+_)},isNumber,function(_){return!Number.isNaN(Date.parse(_))}],typeList=[\"boolean\",\n\"integer\",\"number\",\"date\"];dsv.responseType=\"text\";json.responseType=\"json\";var filters={interior:function(a,b){return a!==b},exterior:function(a,b){return a===b}};topojson.responseType=\"json\";var format$jscomp$0={dsv:dsv,csv:delimitedFormat(\",\"),tsv:delimitedFormat(\"\\t\"),json:json,topojson:topojson},loader=function(fetch,fs){return function(options){return{options:options||{},sanitize:sanitize,load:load,fileAccess:!!fs,file:fileLoader(fs),http:httpLoader(fetch)}}}(\"undefined\"!==typeof fetch&&fetch,\nnull);exports.format=format$jscomp$0;exports.formats=formats;exports.inferType=inferType;exports.inferTypes=inferTypes;exports.loader=loader;exports.read=function(data,schema,timeParser,utcParser){schema=schema||{};var reader=formats(schema.type||\"json\");reader||vegaUtil.error(\"Unknown data format type: \"+schema.type);data=reader(data,schema);schema.parse&&parse$jscomp$0(data,schema.parse,timeParser,utcParser);vegaUtil.hasOwnProperty(data,\"columns\")&&delete data.columns;return data};exports.responseType=\nfunction(type){return(type=formats(type))&&type.responseType||\"text\"};exports.typeParsers=typeParsers;Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_loader$build$vega_loader\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('d3-dsv'), require('topojson-client'), require('vega-format')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'd3-dsv', 'topojson-client', 'vega-format'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.d3, global.topojson, global.vega));\n}(this, (function (exports, vegaUtil, d3Dsv, topojsonClient, vegaFormat) { 'use strict';\n\n  // Matches absolute URLs with optional protocol\n  //   https://...    file://...    //...\n  const protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n  // Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://\n  const allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i; // eslint-disable-line no-useless-escape\n  const whitespace_re = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g; // eslint-disable-line no-control-regex\n\n\n  // Special treatment in node.js for the file: protocol\n  const fileProtocol = 'file://';\n\n  /**\n   * Factory for a loader constructor that provides methods for requesting\n   * files from either the network or disk, and for sanitizing request URIs.\n   * @param {function} fetch - The Fetch API for HTTP network requests.\n   *   If null or undefined, HTTP loading will be disabled.\n   * @param {object} fs - The file system interface for file loading.\n   *   If null or undefined, local file loading will be disabled.\n   * @return {function} A loader constructor with the following signature:\n   *   param {object} [options] - Optional default loading options to use.\n   *   return {object} - A new loader instance.\n   */\n  function loaderFactory(fetch, fs) {\n    return options => ({\n      options: options || {},\n      sanitize: sanitize,\n      load: load,\n      fileAccess: !!fs,\n      file: fileLoader(fs),\n      http: httpLoader(fetch)\n    });\n  }\n\n  /**\n   * Load an external resource, typically either from the web or from the local\n   * filesystem. This function uses {@link sanitize} to first sanitize the uri,\n   * then calls either {@link http} (for web requests) or {@link file} (for\n   * filesystem loading).\n   * @param {string} uri - The resource indicator (e.g., URL or filename).\n   * @param {object} [options] - Optional loading options. These options will\n   *   override any existing default options.\n   * @return {Promise} - A promise that resolves to the loaded content.\n   */\n  async function load(uri, options) {\n    const opt = await this.sanitize(uri, options),\n          url = opt.href;\n\n    return opt.localFile\n      ? this.file(url)\n      : this.http(url, options);\n  }\n\n  /**\n   * URI sanitizer function.\n   * @param {string} uri - The uri (url or filename) to sanity check.\n   * @param {object} options - An options hash.\n   * @return {Promise} - A promise that resolves to an object containing\n   *  sanitized uri data, or rejects it the input uri is deemed invalid.\n   *  The properties of the resolved object are assumed to be\n   *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be\n   *  provided by the 'href' property of the returned object.\n   */\n  async function sanitize(uri, options) {\n    options = vegaUtil.extend({}, this.options, options);\n\n    const fileAccess = this.fileAccess,\n          result = {href: null};\n\n    let isFile, loadFile, base;\n\n    const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));\n\n    if (uri == null || typeof uri !== 'string' || !isAllowed) {\n      vegaUtil.error('Sanitize failure, invalid URI: ' + vegaUtil.stringValue(uri));\n    }\n\n    const hasProtocol = protocol_re.test(uri);\n\n    // if relative url (no protocol/host), prepend baseURL\n    if ((base = options.baseURL) && !hasProtocol) {\n      // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n      if (!uri.startsWith('/') && base[base.length-1] !== '/') {\n        uri = '/' + uri;\n      }\n      uri = base + uri;\n    }\n\n    // should we load from file system?\n    loadFile = (isFile = uri.startsWith(fileProtocol))\n      || options.mode === 'file'\n      || options.mode !== 'http' && !hasProtocol && fileAccess;\n\n    if (isFile) {\n      // strip file protocol\n      uri = uri.slice(fileProtocol.length);\n    } else if (uri.startsWith('//')) {\n      if (options.defaultProtocol === 'file') {\n        // if is file, strip protocol and set loadFile flag\n        uri = uri.slice(2);\n        loadFile = true;\n      } else {\n        // if relative protocol (starts with '//'), prepend default protocol\n        uri = (options.defaultProtocol || 'http') + ':' + uri;\n      }\n    }\n\n    // set non-enumerable mode flag to indicate local file load\n    Object.defineProperty(result, 'localFile', {value: !!loadFile});\n\n    // set uri\n    result.href = uri;\n\n    // set default result target, if specified\n    if (options.target) {\n      result.target = options.target + '';\n    }\n\n    // set default result rel, if specified (#1542)\n    if (options.rel) {\n      result.rel = options.rel + '';\n    }\n\n    // provide control over cross-origin image handling (#2238)\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image\n    if (options.context === 'image' && options.crossOrigin) {\n      result.crossOrigin = options.crossOrigin + '';\n    }\n\n    // return\n    return result;\n  }\n\n  /**\n   * File system loader factory.\n   * @param {object} fs - The file system interface.\n   * @return {function} - A file loader with the following signature:\n   *   param {string} filename - The file system path to load.\n   *   param {string} filename - The file system path to load.\n   *   return {Promise} A promise that resolves to the file contents.\n   */\n  function fileLoader(fs) {\n    return fs\n      ? filename => new Promise((accept, reject) => {\n          fs.readFile(filename, (error, data) => {\n            if (error) reject(error);\n            else accept(data);\n          });\n        })\n      : fileReject;\n  }\n\n  /**\n   * Default file system loader that simply rejects.\n   */\n  async function fileReject() {\n    vegaUtil.error('No file system access.');\n  }\n\n  /**\n   * HTTP request handler factory.\n   * @param {function} fetch - The Fetch API method.\n   * @return {function} - An http loader with the following signature:\n   *   param {string} url - The url to request.\n   *   param {object} options - An options hash.\n   *   return {Promise} - A promise that resolves to the file contents.\n   */\n  function httpLoader(fetch) {\n    return fetch\n      ? async function(url, options) {\n          const opt = vegaUtil.extend({}, this.options.http, options),\n                type = options && options.response,\n                response = await fetch(url, opt);\n\n          return !response.ok\n            ? vegaUtil.error(response.status + '' + response.statusText)\n            : vegaUtil.isFunction(response[type]) ? response[type]()\n            : response.text();\n        }\n      : httpReject;\n  }\n\n  /**\n   * Default http request handler that simply rejects.\n   */\n  async function httpReject() {\n    vegaUtil.error('No HTTP fetch method available.');\n  }\n\n  const isValid = _ => _ != null && _ === _;\n\n  const isBoolean = _ => _ === 'true'\n    || _ === 'false'\n    || _ === true\n    || _ === false;\n\n  const isDate = _ => !Number.isNaN(Date.parse(_));\n\n  const isNumber = _ => !Number.isNaN(+_) && !(_ instanceof Date);\n\n  const isInteger = _ => isNumber(_) && Number.isInteger(+_);\n\n  const typeParsers = {\n    boolean: vegaUtil.toBoolean,\n    integer: vegaUtil.toNumber,\n    number:  vegaUtil.toNumber,\n    date:    vegaUtil.toDate,\n    string:  vegaUtil.toString,\n    unknown: vegaUtil.identity\n  };\n\n  const typeTests = [\n    isBoolean,\n    isInteger,\n    isNumber,\n    isDate\n  ];\n\n  const typeList = [\n    'boolean',\n    'integer',\n    'number',\n    'date'\n  ];\n\n  function inferType(values, field) {\n    if (!values || !values.length) return 'unknown';\n\n    const n = values.length,\n          m = typeTests.length,\n          a = typeTests.map((_, i) => i + 1);\n\n    for (let i = 0, t = 0, j, value; i < n; ++i) {\n      value = field ? values[i][field] : values[i];\n      for (j = 0; j < m; ++j) {\n        if (a[j] && isValid(value) && !typeTests[j](value)) {\n          a[j] = 0;\n          ++t;\n          if (t === typeTests.length) return 'string';\n        }\n      }\n    }\n\n    return typeList[\n      a.reduce((u, v) => u === 0 ? v : u, 0) - 1\n    ];\n  }\n\n  function inferTypes(data, fields) {\n    return fields.reduce((types, field) => {\n      types[field] = inferType(data, field);\n      return types;\n    }, {});\n  }\n\n  function delimitedFormat(delimiter) {\n    const parse = function(data, format) {\n      const delim = {delimiter: delimiter};\n      return dsv(data, format ? vegaUtil.extend(format, delim) : delim);\n    };\n\n    parse.responseType = 'text';\n\n    return parse;\n  }\n\n  function dsv(data, format) {\n    if (format.header) {\n      data = format.header\n        .map(vegaUtil.stringValue)\n        .join(format.delimiter) + '\\n' + data;\n    }\n    return d3Dsv.dsvFormat(format.delimiter).parse(data + '');\n  }\n\n  dsv.responseType = 'text';\n\n  function isBuffer(_) {\n    return (typeof Buffer === 'function' && vegaUtil.isFunction(Buffer.isBuffer))\n      ? Buffer.isBuffer(_) : false;\n  }\n\n  function json(data, format) {\n    const prop = (format && format.property) ? vegaUtil.field(format.property) : vegaUtil.identity;\n    return vegaUtil.isObject(data) && !isBuffer(data)\n      ? parseJSON(prop(data))\n      : prop(JSON.parse(data));\n  }\n\n  json.responseType = 'json';\n\n  function parseJSON(data, format) {\n    return (format && format.copy)\n      ? JSON.parse(JSON.stringify(data))\n      : data;\n  }\n\n  const filters = {\n    interior: (a, b) => a !== b,\n    exterior: (a, b) => a === b\n  };\n\n  function topojson(data, format) {\n    let method, object, property, filter;\n    data = json(data, format);\n\n    if (format && format.feature) {\n      method = topojsonClient.feature;\n      property = format.feature;\n    } else if (format && format.mesh) {\n      method = topojsonClient.mesh;\n      property = format.mesh;\n      filter = filters[format.filter];\n    } else {\n      vegaUtil.error('Missing TopoJSON feature or mesh parameter.');\n    }\n\n    object = (object = data.objects[property])\n      ? method(data, object, filter)\n      : vegaUtil.error('Invalid TopoJSON object: ' + property);\n\n    return object && object.features || [object];\n  }\n\n  topojson.responseType = 'json';\n\n  const format = {\n    dsv: dsv,\n    csv: delimitedFormat(','),\n    tsv: delimitedFormat('\\t'),\n    json: json,\n    topojson: topojson\n  };\n\n  function formats(name, reader) {\n    if (arguments.length > 1) {\n      format[name] = reader;\n      return this;\n    } else {\n      return vegaUtil.hasOwnProperty(format, name) ? format[name] : null;\n    }\n  }\n\n  function responseType(type) {\n    const f = formats(type);\n    return f && f.responseType || 'text';\n  }\n\n  function read(data, schema, timeParser, utcParser) {\n    schema = schema || {};\n\n    const reader = formats(schema.type || 'json');\n    if (!reader) vegaUtil.error('Unknown data format type: ' + schema.type);\n\n    data = reader(data, schema);\n    if (schema.parse) parse(data, schema.parse, timeParser, utcParser);\n\n    if (vegaUtil.hasOwnProperty(data, 'columns')) delete data.columns;\n    return data;\n  }\n\n  function parse(data, types, timeParser, utcParser) {\n    if (!data.length) return; // early exit for empty data\n\n    const locale = vegaFormat.timeFormatDefaultLocale();\n    timeParser = timeParser || locale.timeParse;\n    utcParser = utcParser || locale.utcParse;\n\n    let fields = data.columns || Object.keys(data[0]),\n        datum, field, i, j, n, m;\n\n    if (types === 'auto') types = inferTypes(data, fields);\n\n    fields = Object.keys(types);\n    const parsers = fields.map(field => {\n      const type = types[field];\n      let parts, pattern;\n\n      if (type && (type.startsWith('date:') || type.startsWith('utc:'))) {\n        parts = type.split(/:(.+)?/, 2);  // split on first :\n        pattern = parts[1];\n\n        if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n            (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n          pattern = pattern.slice(1, -1);\n        }\n\n        const parse = parts[0] === 'utc' ? utcParser : timeParser;\n        return parse(pattern);\n      }\n\n      if (!typeParsers[type]) {\n        throw Error('Illegal format pattern: ' + field + ':' + type);\n      }\n\n      return typeParsers[type];\n    });\n\n    for (i=0, n=data.length, m=fields.length; i<n; ++i) {\n      datum = data[i];\n      for (j=0; j<m; ++j) {\n        field = fields[j];\n        datum[field] = parsers[j](datum[field]);\n      }\n    }\n  }\n\n  var loader = loaderFactory(\n    typeof fetch !== 'undefined' && fetch, // use built-in fetch API\n    null // no file system access\n  );\n\n  exports.format = format;\n  exports.formats = formats;\n  exports.inferType = inferType;\n  exports.inferTypes = inferTypes;\n  exports.loader = loader;\n  exports.read = read;\n  exports.responseType = responseType;\n  exports.typeParsers = typeParsers;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$d3_dsv$dist$d3_dsv","~$shadow.js","~$module$node_modules$vega_format$build$vega_format","~$module$node_modules$vega_util$build$vega_util","~$module$node_modules$topojson_client$dist$topojson_client","~$module$node_modules$buffer$index"]],"~:properties",["^5",["inferType","dsv","json","boolean","typeParsers","string","responseType","fileAccess","load","__esModule","http","csv","exterior","read","vega","interior","topojson","loader","href","value","delimiter","number","tsv","inferTypes","integer","rel","unknown","localFile","formats","target","date","file","options","crossOrigin","sanitize","format"]],"~:compiled-at",1600144479800,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_loader$build$vega_loader.js\",\n\"lineCount\":17,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-loader/build/vega-loader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_loader$build$vega_loader\\\"] = function(global,require,module,exports) {\\nvar Buffer = require('buffer').Buffer;\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('d3-dsv'), require('topojson-client'), require('vega-format')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'd3-dsv', 'topojson-client', 'vega-format'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.d3, global.topojson, global.vega));\\n}(this, (function (exports, vegaUtil, d3Dsv, topojsonClient, vegaFormat) { 'use strict';\\n\\n  // Matches absolute URLs with optional protocol\\n  //   https://...    file://...    //...\\n  const protocol_re = /^([A-Za-z]+:)?\\\\/\\\\//;\\n\\n  // Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://\\n  const allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\\\\-]+(?:[^a-z+.\\\\-:]|$))/i; // eslint-disable-line no-useless-escape\\n  const whitespace_re = /[\\\\u0000-\\\\u0020\\\\u00A0\\\\u1680\\\\u180E\\\\u2000-\\\\u2029\\\\u205f\\\\u3000]/g; // eslint-disable-line no-control-regex\\n\\n\\n  // Special treatment in node.js for the file: protocol\\n  const fileProtocol = 'file://';\\n\\n  /**\\n   * Factory for a loader constructor that provides methods for requesting\\n   * files from either the network or disk, and for sanitizing request URIs.\\n   * @param {function} fetch - The Fetch API for HTTP network requests.\\n   *   If null or undefined, HTTP loading will be disabled.\\n   * @param {object} fs - The file system interface for file loading.\\n   *   If null or undefined, local file loading will be disabled.\\n   * @return {function} A loader constructor with the following signature:\\n   *   param {object} [options] - Optional default loading options to use.\\n   *   return {object} - A new loader instance.\\n   */\\n  function loaderFactory(fetch, fs) {\\n    return options => ({\\n      options: options || {},\\n      sanitize: sanitize,\\n      load: load,\\n      fileAccess: !!fs,\\n      file: fileLoader(fs),\\n      http: httpLoader(fetch)\\n    });\\n  }\\n\\n  /**\\n   * Load an external resource, typically either from the web or from the local\\n   * filesystem. This function uses {@link sanitize} to first sanitize the uri,\\n   * then calls either {@link http} (for web requests) or {@link file} (for\\n   * filesystem loading).\\n   * @param {string} uri - The resource indicator (e.g., URL or filename).\\n   * @param {object} [options] - Optional loading options. These options will\\n   *   override any existing default options.\\n   * @return {Promise} - A promise that resolves to the loaded content.\\n   */\\n  async function load(uri, options) {\\n    const opt = await this.sanitize(uri, options),\\n          url = opt.href;\\n\\n    return opt.localFile\\n      ? this.file(url)\\n      : this.http(url, options);\\n  }\\n\\n  /**\\n   * URI sanitizer function.\\n   * @param {string} uri - The uri (url or filename) to sanity check.\\n   * @param {object} options - An options hash.\\n   * @return {Promise} - A promise that resolves to an object containing\\n   *  sanitized uri data, or rejects it the input uri is deemed invalid.\\n   *  The properties of the resolved object are assumed to be\\n   *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be\\n   *  provided by the 'href' property of the returned object.\\n   */\\n  async function sanitize(uri, options) {\\n    options = vegaUtil.extend({}, this.options, options);\\n\\n    const fileAccess = this.fileAccess,\\n          result = {href: null};\\n\\n    let isFile, loadFile, base;\\n\\n    const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));\\n\\n    if (uri == null || typeof uri !== 'string' || !isAllowed) {\\n      vegaUtil.error('Sanitize failure, invalid URI: ' + vegaUtil.stringValue(uri));\\n    }\\n\\n    const hasProtocol = protocol_re.test(uri);\\n\\n    // if relative url (no protocol/host), prepend baseURL\\n    if ((base = options.baseURL) && !hasProtocol) {\\n      // Ensure that there is a slash between the baseURL (e.g. hostname) and url\\n      if (!uri.startsWith('/') && base[base.length-1] !== '/') {\\n        uri = '/' + uri;\\n      }\\n      uri = base + uri;\\n    }\\n\\n    // should we load from file system?\\n    loadFile = (isFile = uri.startsWith(fileProtocol))\\n      || options.mode === 'file'\\n      || options.mode !== 'http' && !hasProtocol && fileAccess;\\n\\n    if (isFile) {\\n      // strip file protocol\\n      uri = uri.slice(fileProtocol.length);\\n    } else if (uri.startsWith('//')) {\\n      if (options.defaultProtocol === 'file') {\\n        // if is file, strip protocol and set loadFile flag\\n        uri = uri.slice(2);\\n        loadFile = true;\\n      } else {\\n        // if relative protocol (starts with '//'), prepend default protocol\\n        uri = (options.defaultProtocol || 'http') + ':' + uri;\\n      }\\n    }\\n\\n    // set non-enumerable mode flag to indicate local file load\\n    Object.defineProperty(result, 'localFile', {value: !!loadFile});\\n\\n    // set uri\\n    result.href = uri;\\n\\n    // set default result target, if specified\\n    if (options.target) {\\n      result.target = options.target + '';\\n    }\\n\\n    // set default result rel, if specified (#1542)\\n    if (options.rel) {\\n      result.rel = options.rel + '';\\n    }\\n\\n    // provide control over cross-origin image handling (#2238)\\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image\\n    if (options.context === 'image' && options.crossOrigin) {\\n      result.crossOrigin = options.crossOrigin + '';\\n    }\\n\\n    // return\\n    return result;\\n  }\\n\\n  /**\\n   * File system loader factory.\\n   * @param {object} fs - The file system interface.\\n   * @return {function} - A file loader with the following signature:\\n   *   param {string} filename - The file system path to load.\\n   *   param {string} filename - The file system path to load.\\n   *   return {Promise} A promise that resolves to the file contents.\\n   */\\n  function fileLoader(fs) {\\n    return fs\\n      ? filename => new Promise((accept, reject) => {\\n          fs.readFile(filename, (error, data) => {\\n            if (error) reject(error);\\n            else accept(data);\\n          });\\n        })\\n      : fileReject;\\n  }\\n\\n  /**\\n   * Default file system loader that simply rejects.\\n   */\\n  async function fileReject() {\\n    vegaUtil.error('No file system access.');\\n  }\\n\\n  /**\\n   * HTTP request handler factory.\\n   * @param {function} fetch - The Fetch API method.\\n   * @return {function} - An http loader with the following signature:\\n   *   param {string} url - The url to request.\\n   *   param {object} options - An options hash.\\n   *   return {Promise} - A promise that resolves to the file contents.\\n   */\\n  function httpLoader(fetch) {\\n    return fetch\\n      ? async function(url, options) {\\n          const opt = vegaUtil.extend({}, this.options.http, options),\\n                type = options && options.response,\\n                response = await fetch(url, opt);\\n\\n          return !response.ok\\n            ? vegaUtil.error(response.status + '' + response.statusText)\\n            : vegaUtil.isFunction(response[type]) ? response[type]()\\n            : response.text();\\n        }\\n      : httpReject;\\n  }\\n\\n  /**\\n   * Default http request handler that simply rejects.\\n   */\\n  async function httpReject() {\\n    vegaUtil.error('No HTTP fetch method available.');\\n  }\\n\\n  const isValid = _ => _ != null && _ === _;\\n\\n  const isBoolean = _ => _ === 'true'\\n    || _ === 'false'\\n    || _ === true\\n    || _ === false;\\n\\n  const isDate = _ => !Number.isNaN(Date.parse(_));\\n\\n  const isNumber = _ => !Number.isNaN(+_) && !(_ instanceof Date);\\n\\n  const isInteger = _ => isNumber(_) && Number.isInteger(+_);\\n\\n  const typeParsers = {\\n    boolean: vegaUtil.toBoolean,\\n    integer: vegaUtil.toNumber,\\n    number:  vegaUtil.toNumber,\\n    date:    vegaUtil.toDate,\\n    string:  vegaUtil.toString,\\n    unknown: vegaUtil.identity\\n  };\\n\\n  const typeTests = [\\n    isBoolean,\\n    isInteger,\\n    isNumber,\\n    isDate\\n  ];\\n\\n  const typeList = [\\n    'boolean',\\n    'integer',\\n    'number',\\n    'date'\\n  ];\\n\\n  function inferType(values, field) {\\n    if (!values || !values.length) return 'unknown';\\n\\n    const n = values.length,\\n          m = typeTests.length,\\n          a = typeTests.map((_, i) => i + 1);\\n\\n    for (let i = 0, t = 0, j, value; i < n; ++i) {\\n      value = field ? values[i][field] : values[i];\\n      for (j = 0; j < m; ++j) {\\n        if (a[j] && isValid(value) && !typeTests[j](value)) {\\n          a[j] = 0;\\n          ++t;\\n          if (t === typeTests.length) return 'string';\\n        }\\n      }\\n    }\\n\\n    return typeList[\\n      a.reduce((u, v) => u === 0 ? v : u, 0) - 1\\n    ];\\n  }\\n\\n  function inferTypes(data, fields) {\\n    return fields.reduce((types, field) => {\\n      types[field] = inferType(data, field);\\n      return types;\\n    }, {});\\n  }\\n\\n  function delimitedFormat(delimiter) {\\n    const parse = function(data, format) {\\n      const delim = {delimiter: delimiter};\\n      return dsv(data, format ? vegaUtil.extend(format, delim) : delim);\\n    };\\n\\n    parse.responseType = 'text';\\n\\n    return parse;\\n  }\\n\\n  function dsv(data, format) {\\n    if (format.header) {\\n      data = format.header\\n        .map(vegaUtil.stringValue)\\n        .join(format.delimiter) + '\\\\n' + data;\\n    }\\n    return d3Dsv.dsvFormat(format.delimiter).parse(data + '');\\n  }\\n\\n  dsv.responseType = 'text';\\n\\n  function isBuffer(_) {\\n    return (typeof Buffer === 'function' && vegaUtil.isFunction(Buffer.isBuffer))\\n      ? Buffer.isBuffer(_) : false;\\n  }\\n\\n  function json(data, format) {\\n    const prop = (format && format.property) ? vegaUtil.field(format.property) : vegaUtil.identity;\\n    return vegaUtil.isObject(data) && !isBuffer(data)\\n      ? parseJSON(prop(data))\\n      : prop(JSON.parse(data));\\n  }\\n\\n  json.responseType = 'json';\\n\\n  function parseJSON(data, format) {\\n    return (format && format.copy)\\n      ? JSON.parse(JSON.stringify(data))\\n      : data;\\n  }\\n\\n  const filters = {\\n    interior: (a, b) => a !== b,\\n    exterior: (a, b) => a === b\\n  };\\n\\n  function topojson(data, format) {\\n    let method, object, property, filter;\\n    data = json(data, format);\\n\\n    if (format && format.feature) {\\n      method = topojsonClient.feature;\\n      property = format.feature;\\n    } else if (format && format.mesh) {\\n      method = topojsonClient.mesh;\\n      property = format.mesh;\\n      filter = filters[format.filter];\\n    } else {\\n      vegaUtil.error('Missing TopoJSON feature or mesh parameter.');\\n    }\\n\\n    object = (object = data.objects[property])\\n      ? method(data, object, filter)\\n      : vegaUtil.error('Invalid TopoJSON object: ' + property);\\n\\n    return object && object.features || [object];\\n  }\\n\\n  topojson.responseType = 'json';\\n\\n  const format = {\\n    dsv: dsv,\\n    csv: delimitedFormat(','),\\n    tsv: delimitedFormat('\\\\t'),\\n    json: json,\\n    topojson: topojson\\n  };\\n\\n  function formats(name, reader) {\\n    if (arguments.length > 1) {\\n      format[name] = reader;\\n      return this;\\n    } else {\\n      return vegaUtil.hasOwnProperty(format, name) ? format[name] : null;\\n    }\\n  }\\n\\n  function responseType(type) {\\n    const f = formats(type);\\n    return f && f.responseType || 'text';\\n  }\\n\\n  function read(data, schema, timeParser, utcParser) {\\n    schema = schema || {};\\n\\n    const reader = formats(schema.type || 'json');\\n    if (!reader) vegaUtil.error('Unknown data format type: ' + schema.type);\\n\\n    data = reader(data, schema);\\n    if (schema.parse) parse(data, schema.parse, timeParser, utcParser);\\n\\n    if (vegaUtil.hasOwnProperty(data, 'columns')) delete data.columns;\\n    return data;\\n  }\\n\\n  function parse(data, types, timeParser, utcParser) {\\n    if (!data.length) return; // early exit for empty data\\n\\n    const locale = vegaFormat.timeFormatDefaultLocale();\\n    timeParser = timeParser || locale.timeParse;\\n    utcParser = utcParser || locale.utcParse;\\n\\n    let fields = data.columns || Object.keys(data[0]),\\n        datum, field, i, j, n, m;\\n\\n    if (types === 'auto') types = inferTypes(data, fields);\\n\\n    fields = Object.keys(types);\\n    const parsers = fields.map(field => {\\n      const type = types[field];\\n      let parts, pattern;\\n\\n      if (type && (type.startsWith('date:') || type.startsWith('utc:'))) {\\n        parts = type.split(/:(.+)?/, 2);  // split on first :\\n        pattern = parts[1];\\n\\n        if ((pattern[0] === '\\\\'' && pattern[pattern.length-1] === '\\\\'') ||\\n            (pattern[0] === '\\\"'  && pattern[pattern.length-1] === '\\\"')) {\\n          pattern = pattern.slice(1, -1);\\n        }\\n\\n        const parse = parts[0] === 'utc' ? utcParser : timeParser;\\n        return parse(pattern);\\n      }\\n\\n      if (!typeParsers[type]) {\\n        throw Error('Illegal format pattern: ' + field + ':' + type);\\n      }\\n\\n      return typeParsers[type];\\n    });\\n\\n    for (i=0, n=data.length, m=fields.length; i<n; ++i) {\\n      datum = data[i];\\n      for (j=0; j<m; ++j) {\\n        field = fields[j];\\n        datum[field] = parsers[j](datum[field]);\\n      }\\n    }\\n  }\\n\\n  var loader = loaderFactory(\\n    typeof fetch !== 'undefined' && fetch, // use built-in fetch API\\n    null // no file system access\\n  );\\n\\n  exports.format = format;\\n  exports.formats = formats;\\n  exports.inferType = inferType;\\n  exports.inferTypes = inferTypes;\\n  exports.loader = loader;\\n  exports.read = read;\\n  exports.responseType = responseType;\\n  exports.typeParsers = typeParsers;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Buffer\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"d3\",\"topojson\",\"vegaUtil\",\"d3Dsv\",\"topojsonClient\",\"vegaFormat\",\"load\",\"uri\",\"options\",\"opt\",\"url\",\"sanitize\",\"href\",\"localFile\",\"file\",\"http\",\"fileAccess\",\"result\",\"isFile\",\"loadFile\",\"base\",\"isAllowed\",\"hasProtocol\",\"extend\",\"allowed_re\",\"test\",\"replace\",\"whitespace_re\",\"error\",\"stringValue\",\"protocol_re\",\"baseURL\",\"startsWith\",\"length\",\"fileProtocol\",\"mode\",\"slice\",\"defaultProtocol\",\"Object\",\"defineProperty\",\"value\",\"target\",\"rel\",\"context\",\"crossOrigin\",\"fileLoader\",\"fs\",\"filename\",\"Promise\",\"accept\",\"reject\",\"readFile\",\"data\",\"fileReject\",\"httpLoader\",\"fetch\",\"type\",\"response\",\"ok\",\"isFunction\",\"text\",\"status\",\"statusText\",\"httpReject\",\"inferType\",\"values\",\"field\",\"n\",\"m\",\"typeTests\",\"a\",\"map\",\"_\",\"i\",\"t\",\"j\",\"typeList\",\"reduce\",\"u\",\"v\",\"inferTypes\",\"fields\",\"types\",\"delimitedFormat\",\"delimiter\",\"parse\",\"format\",\"delim\",\"dsv\",\"responseType\",\"header\",\"join\",\"dsvFormat\",\"json\",\"prop\",\"property\",\"identity\",\"isBuffer\",\"object\",\"feature\",\"method\",\"mesh\",\"filter\",\"filters\",\"objects\",\"features\",\"formats\",\"name\",\"reader\",\"arguments\",\"hasOwnProperty\",\"timeParser\",\"utcParser\",\"locale\",\"timeFormatDefaultLocale\",\"timeParse\",\"utcParse\",\"columns\",\"keys\",\"parsers\",\"parts\",\"split\",\"pattern\",\"typeParsers\",\"Error\",\"datum\",\"isNumber\",\"Number\",\"isNaN\",\"Date\",\"boolean\",\"toBoolean\",\"integer\",\"toNumber\",\"number\",\"date\",\"toDate\",\"string\",\"toString\",\"unknown\",\"isBoolean\",\"isInteger\",\"isDate\",\"interior\",\"b\",\"exterior\",\"csv\",\"tsv\",\"loader\",\"loaderFactory\",\"read\",\"schema\",\"f\"]\n}\n"]