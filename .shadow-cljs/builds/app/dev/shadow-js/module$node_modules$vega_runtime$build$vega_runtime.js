["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-runtime/build/vega-runtime.js"],"~:js","shadow$provide.module$node_modules$vega_runtime$build$vega_runtime=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_util$build$vega_util\"),require(\"module$node_modules$vega_dataflow$build$vega_dataflow\")):\"function\"===typeof define&&define.amd?define([\"exports\",\"vega-util\",\"vega-dataflow\"],factory):(global=\"undefined\"!==typeof globalThis?globalThis:\nglobal||self,factory(global.vega={},global.vega,global.vega))})(this,function(exports,vegaUtil,vegaDataflow){function expression(ctx,args,code){\";\"!==code[code.length-1]&&(code=\"return(\"+code+\");\");args=Function.apply(null,args.concat(code));return ctx&&ctx.functions?args.bind(ctx.functions):args}function parseParameter(spec,ctx,params){if(!spec||!vegaUtil.isObject(spec))return spec;for(var i=0,n=PARSERS.length,p;i<n;++i)if(p=PARSERS[i],vegaUtil.hasOwnProperty(spec,p.key))return p.parse(spec,ctx,\nparams);return spec}function Context(df,transforms,functions,expr){this.dataflow=df;this.transforms=transforms;this.events=df.events.bind(df);this.expr=expr||expressionCodegen;this.signals={};this.scales={};this.nodes={};this.data={};this.fn={};functions&&(this.functions=Object.create(functions),this.functions.context=this)}function Subcontext(ctx){this.dataflow=ctx.dataflow;this.transforms=ctx.transforms;this.events=ctx.events;this.expr=ctx.expr;this.signals=Object.create(ctx.signals);this.scales=\nObject.create(ctx.scales);this.nodes=Object.create(ctx.nodes);this.data=Object.create(ctx.data);this.fn=Object.create(ctx.fn);ctx.functions&&(this.functions=Object.create(ctx.functions),this.functions.context=this)}var Skip=vegaUtil.toSet([\"rule\"]),Swap=vegaUtil.toSet([\"group\",\"image\",\"rect\"]),expressionCodegen={operator:function(ctx,expr){return expression(ctx,[\"_\"],expr.code)},parameter:function(ctx,expr){return expression(ctx,[\"datum\",\"_\"],expr.code)},event:function(ctx,expr){return expression(ctx,\n[\"event\"],expr.code)},handler:function(ctx,expr){return expression(ctx,[\"_\",\"event\"],\"var datum\\x3devent.item\\x26\\x26event.item.datum;return \"+expr.code+\";\")},encode:function(ctx,encode){var marktype=encode.marktype;encode=encode.channels;var code=\"var o\\x3ditem,datum\\x3do.datum,m\\x3d0,$;\";for(name in encode){var o=\"o[\"+vegaUtil.stringValue(name)+\"]\";code+=\"$\\x3d\"+encode[name].code+\";if(\"+o+\"!\\x3d\\x3d$)\"+o+\"\\x3d$,m\\x3d1;\"}var name=\"\";Skip[marktype]||(encode.x2&&(encode.x?(Swap[marktype]&&(name+=\"if(o.x\\x3eo.x2)$\\x3do.x,o.x\\x3do.x2,o.x2\\x3d$;\"),\nname+=\"o.width\\x3do.x2-o.x;\"):name+=\"o.x\\x3do.x2-(o.width||0);\"),encode.xc&&(name+=\"o.x\\x3do.xc-(o.width||0)/2;\"),encode.y2&&(encode.y?(Swap[marktype]&&(name+=\"if(o.y\\x3eo.y2)$\\x3do.y,o.y\\x3do.y2,o.y2\\x3d$;\"),name+=\"o.height\\x3do.y2-o.y;\"):name+=\"o.y\\x3do.y2-(o.height||0);\"),encode.yc&&(name+=\"o.y\\x3do.yc-(o.height||0)/2;\"));code+=name;return expression(ctx,[\"item\",\"_\"],code+\"return m;\")},codegen:{get:function(path){path=\"[\"+path.map(vegaUtil.stringValue).join(\"][\")+\"]\";var get=Function(\"_\",\"return _\"+\npath+\";\");get.path=path;return get},comparator:function(fields,orders){var t;fields=Function(\"a\",\"b\",\"var u, v; return \"+fields.map(function(f,i){var o=orders[i];if(f.path){var u=\"a\"+f.path;f=\"b\"+f.path}else(t=t||{})[\"f\"+i]=f,u=\"this.f\"+i+\"(a)\",f=\"this.f\"+i+\"(b)\";i=-o;return\"((u \\x3d \"+u+\") \\x3c (v \\x3d \"+f+\") || u \\x3d\\x3d null) \\x26\\x26 v !\\x3d null ? \"+i+\"\\n  : (u \\x3e v || v \\x3d\\x3d null) \\x26\\x26 u !\\x3d null ? \"+o+\"\\n  : ((v \\x3d v instanceof Date ? +v : v), (u \\x3d u instanceof Date ? +u : u)) !\\x3d\\x3d u \\x26\\x26 v \\x3d\\x3d\\x3d v ? \"+\ni+\"\\n  : v !\\x3d\\x3d v \\x26\\x26 u \\x3d\\x3d\\x3d u ? \"+o+\" : \"}).join(\"\")+\"0;\");return t?fields.bind(t):fields}}},PARSERS=[{key:\"$ref\",parse:function(_,ctx){return ctx.get(_.$ref)||vegaUtil.error(\"Operator not defined: \"+_.$ref)}},{key:\"$key\",parse:function(_,ctx){var k=\"k:\"+_.$key+\"_\"+!!_.$flat;return ctx.fn[k]||(ctx.fn[k]=vegaUtil.key(_.$key,_.$flat,ctx.expr.codegen))}},{key:\"$expr\",parse:function(_,ctx,params){_.$params&&ctx.parseParameters(_.$params,params);params=\"e:\"+_.$expr.code+\"_\"+_.$name;\nreturn ctx.fn[params]||(ctx.fn[params]=vegaUtil.accessor(ctx.parameterExpression(_.$expr),_.$fields,_.$name))}},{key:\"$field\",parse:function(_,ctx){if(!_.$field)return null;var k=\"f:\"+_.$field+\"_\"+_.$name;return ctx.fn[k]||(ctx.fn[k]=vegaUtil.field(_.$field,_.$name,ctx.expr.codegen))}},{key:\"$encode\",parse:function(_,ctx){_=_.$encode;var encode={},name;for(name in _){var enc=_[name];encode[name]=vegaUtil.accessor(ctx.encodeExpression(enc.$expr),enc.$fields);encode[name].output=enc.$output}return encode}},\n{key:\"$compare\",parse:function(_$jscomp$0,ctx){var k=\"c:\"+_$jscomp$0.$compare+\"_\"+_$jscomp$0.$order,c=vegaUtil.array(_$jscomp$0.$compare).map(function(_){return _&&_.$tupleid?vegaDataflow.tupleid:_});return ctx.fn[k]||(ctx.fn[k]=vegaUtil.compare(c,_$jscomp$0.$order,ctx.expr.codegen))}},{key:\"$context\",parse:function(_,ctx){return ctx}},{key:\"$subflow\",parse:function(_,ctx){var spec=_.$subflow;return function(dataflow,key,parent){var subctx=ctx.fork().parse(spec);dataflow=subctx.get(spec.operators[0].id);\n(key=subctx.signals.parent)&&key.set(parent);dataflow.detachSubflow=function(){return ctx.detach(subctx)};return dataflow}}},{key:\"$tupleid\",parse:function(){return vegaDataflow.tupleid}}],SKIP={skip:!0};Context.prototype=Subcontext.prototype={fork:function(){var ctx=new Subcontext(this);(this.subcontext||(this.subcontext=[])).push(ctx);return ctx},detach:function(ctx){this.subcontext=this.subcontext.filter(function(c){return c!==ctx});for(var keys=Object.keys(ctx.nodes),$jscomp$iter$98=$jscomp.makeIterator(keys),\n$jscomp$key$key=$jscomp$iter$98.next();!$jscomp$key$key.done;$jscomp$key$key=$jscomp$iter$98.next())ctx.nodes[$jscomp$key$key.value]._targets=null;keys=$jscomp.makeIterator(keys);for($jscomp$key$key=keys.next();!$jscomp$key$key.done;$jscomp$key$key=keys.next())ctx.nodes[$jscomp$key$key.value].detach();ctx.nodes=null},get:function(id){return this.nodes[id]},set:function(id,node){return this.nodes[id]=node},add:function(spec,op){var ctx=this,df=ctx.dataflow,data=spec.value;ctx.set(spec.id,op);\"collect\"===\n(spec.type+\"\").toLowerCase()&&data&&(data.$ingest?df.ingest(op,data.$ingest,data.$format):data.$request?df.preload(op,data.$request,data.$format):df.pulse(op,df.changeset().insert(data)));spec.root&&(ctx.root=op);if(spec.parent){var p=ctx.get(spec.parent.$ref);p?(df.connect(p,[op]),op.targets().add(p)):(ctx.unresolved=ctx.unresolved||[]).push(function(){p=ctx.get(spec.parent.$ref);df.connect(p,[op]);op.targets().add(p)})}spec.signal&&(ctx.signals[spec.signal]=op);spec.scale&&(ctx.scales[spec.scale]=\nop);if(spec.data){data={};for(var name in spec.data)data.$jscomp$loop$prop$data$389$530=ctx.data[name]||(ctx.data[name]={}),spec.data[name].forEach(function($jscomp$loop$529){return function(role){return $jscomp$loop$529.$jscomp$loop$prop$data$389$530[role]=op}}(data)),data={$jscomp$loop$prop$data$389$530:data.$jscomp$loop$prop$data$389$530}}},resolve:function(){(this.unresolved||[]).forEach(function(fn){return fn()});delete this.unresolved;return this},operator:function(spec,update){this.add(spec,\nthis.dataflow.add(spec.value,update))},transform:function(spec,type){this.add(spec,this.dataflow.add(this.transforms[(type+\"\").toLowerCase()]))},stream:function(spec,stream){this.set(spec.id,stream)},update:function(spec,stream,target,update,params){this.dataflow.on(stream,target,update,params,spec.options)},operatorExpression:function(expr){return this.expr.operator(this,expr)},parameterExpression:function(expr){return this.expr.parameter(this,expr)},eventExpression:function(expr){return this.expr.event(this,\nexpr)},handlerExpression:function(expr){return this.expr.handler(this,expr)},encodeExpression:function(encode){return this.expr.encode(this,encode)},parse:function(spec){var ctx=this,operators=spec.operators||[];spec.background&&(ctx.background=spec.background);spec.eventConfig&&(ctx.eventConfig=spec.eventConfig);spec.locale&&(ctx.locale=spec.locale);operators.forEach(function(entry){return ctx.parseOperator(entry)});operators.forEach(function(entry){return ctx.parseOperatorParameters(entry)});(spec.streams||\n[]).forEach(function(entry){return ctx.parseStream(entry)});(spec.updates||[]).forEach(function(entry){return ctx.parseUpdate(entry)});return ctx.resolve()},parseOperator:function(spec){\"operator\"!==(spec.type+\"\").toLowerCase()&&spec.type?this.transform(spec,spec.type):this.operator(spec,spec.update?this.operatorExpression(spec.update):null)},parseOperatorParameters:function(spec){if(spec.params){var op=this.get(spec.id);op||vegaUtil.error(\"Invalid operator id: \"+spec.id);this.dataflow.connect(op,\nop.parameters(this.parseParameters(spec.params),spec.react,spec.initonly))}},parseParameters:function(spec,params){params=params||{};var ctx=this,key;for(key in spec){var value=spec[key];params[key]=vegaUtil.isArray(value)?value.map(function(v){return parseParameter(v,ctx,params)}):parseParameter(value,ctx,params)}return params},parseStream:function(spec){var ctx=this,filter=null!=spec.filter?ctx.eventExpression(spec.filter):void 0,stream=null!=spec.stream?ctx.get(spec.stream):void 0;if(spec.source)stream=\nctx.events(spec.source,spec.type,filter);else if(spec.merge){var args=spec.merge.map(function(_){return ctx.get(_)});stream=args[0].merge.apply(args[0],args.slice(1))}spec.between&&(args=spec.between.map(function(_){return ctx.get(_)}),stream=stream.between(args[0],args[1]));spec.filter&&(stream=stream.filter(filter));null!=spec.throttle&&(stream=stream.throttle(+spec.throttle));null!=spec.debounce&&(stream=stream.debounce(+spec.debounce));null==stream&&vegaUtil.error(\"Invalid stream definition: \"+\nJSON.stringify(spec));spec.consume&&stream.consume(!0);ctx.stream(spec,stream)},parseUpdate:function(spec){var srcid=vegaUtil.isObject(srcid=spec.source)?srcid.$ref:srcid;srcid=this.get(srcid);var update=spec.update,params=void 0;srcid||vegaUtil.error(\"Source not defined: \"+spec.source);var target=spec.target&&spec.target.$expr?this.eventExpression(spec.target.$expr):this.get(spec.target);update&&update.$expr&&(update.$params&&(params=this.parseParameters(update.$params)),update=this.handlerExpression(update.$expr));\nthis.update(spec,srcid,target,update,params)},getState:function(options){var ctx$jscomp$0=this,state={};if(options.signals){var signals=state.signals={};Object.keys(ctx$jscomp$0.signals).forEach(function(key){var op=ctx$jscomp$0.signals[key];options.signals(key,op)&&(signals[key]=op.value)})}if(options.data){var data=state.data={};Object.keys(ctx$jscomp$0.data).forEach(function(key){var dataset=ctx$jscomp$0.data[key];options.data(key,dataset)&&(data[key]=dataset.input.value)})}ctx$jscomp$0.subcontext&&\n!1!==options.recurse&&(state.subcontext=ctx$jscomp$0.subcontext.map(function(ctx){return ctx.getState(options)}));return state},setState:function(state){var ctx=this,df=ctx.dataflow,data=state.data,signals=state.signals;Object.keys(signals||{}).forEach(function(key){df.update(ctx.signals[key],signals[key],SKIP)});Object.keys(data||{}).forEach(function(key){df.pulse(ctx.data[key].input,df.changeset().remove(vegaUtil.truthy).insert(data[key]))});(state.subcontext||[]).forEach(function(substate,i){(i=\nctx.subcontext[i])&&i.setState(substate)})}};exports.context=function(df,transforms,functions,expr){return new Context(df,transforms,functions,expr)};Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_runtime$build$vega_runtime\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-dataflow')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-dataflow'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega));\n}(this, (function (exports, vegaUtil, vegaDataflow) { 'use strict';\n\n  /**\n   * Parse a serialized dataflow specification.\n   */\n  function parse(spec) {\n    const ctx = this,\n          operators = spec.operators || [];\n\n    // parse background\n    if (spec.background) {\n      ctx.background = spec.background;\n    }\n\n    // parse event configuration\n    if (spec.eventConfig) {\n      ctx.eventConfig = spec.eventConfig;\n    }\n\n    // parse locale configuration\n    if (spec.locale) {\n      ctx.locale = spec.locale;\n    }\n\n    // parse operators\n    operators.forEach(entry => ctx.parseOperator(entry));\n\n    // parse operator parameters\n    operators.forEach(entry => ctx.parseOperatorParameters(entry));\n\n    // parse streams\n    (spec.streams || []).forEach(entry => ctx.parseStream(entry));\n\n    // parse updates\n    (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));\n\n    return ctx.resolve();\n  }\n\n  const Skip = vegaUtil.toSet(['rule']),\n        Swap = vegaUtil.toSet(['group', 'image', 'rect']);\n\n  function adjustSpatial(encode, marktype) {\n    let code = '';\n\n    if (Skip[marktype]) return code;\n\n    if (encode.x2) {\n      if (encode.x) {\n        if (Swap[marktype]) {\n          code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n        }\n        code += 'o.width=o.x2-o.x;';\n      } else {\n        code += 'o.x=o.x2-(o.width||0);';\n      }\n    }\n\n    if (encode.xc) {\n      code += 'o.x=o.xc-(o.width||0)/2;';\n    }\n\n    if (encode.y2) {\n      if (encode.y) {\n        if (Swap[marktype]) {\n          code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n        }\n        code += 'o.height=o.y2-o.y;';\n      } else {\n        code += 'o.y=o.y2-(o.height||0);';\n      }\n    }\n\n    if (encode.yc) {\n      code += 'o.y=o.yc-(o.height||0)/2;';\n    }\n\n    return code;\n  }\n\n  function canonicalType(type) {\n    return (type + '').toLowerCase();\n  }\n\n  function isOperator(type) {\n     return canonicalType(type) === 'operator';\n  }\n\n  function isCollect(type) {\n    return canonicalType(type) === 'collect';\n  }\n\n  function expression(ctx, args, code) {\n    // wrap code in return statement if expression does not terminate\n    if (code[code.length-1] !== ';') {\n      code = 'return(' + code + ');';\n    }\n    var fn = Function.apply(null, args.concat(code));\n    return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n  }\n\n  // generate code for comparing a single field\n  function _compare(u, v, lt, gt) {\n    return `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt}\n  : (u > v || v == null) && u != null ? ${gt}\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}\n  : v !== v && u === u ? ${gt} : `;\n  }\n\n  var expressionCodegen = {\n    /**\n     * Parse an expression used to update an operator value.\n     */\n    operator: (ctx, expr) => expression(ctx, ['_'], expr.code),\n\n    /**\n     * Parse an expression provided as an operator parameter value.\n     */\n    parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),\n\n    /**\n     * Parse an expression applied to an event stream.\n     */\n    event: (ctx, expr) => expression(ctx, ['event'], expr.code),\n\n    /**\n     * Parse an expression used to handle an event-driven operator update.\n     */\n    handler: (ctx, expr) => {\n      const code = `var datum=event.item&&event.item.datum;return ${expr.code};`;\n      return expression(ctx, ['_', 'event'], code);\n    },\n\n    /**\n     * Parse an expression that performs visual encoding.\n     */\n    encode: (ctx, encode) => {\n      const {marktype, channels} = encode;\n\n      let code = 'var o=item,datum=o.datum,m=0,$;';\n      for (const name in channels) {\n        const o ='o[' + vegaUtil.stringValue(name) + ']';\n        code += `$=${channels[name].code};if(${o}!==$)${o}=$,m=1;`;\n      }\n      code += adjustSpatial(channels, marktype);\n      code += 'return m;';\n\n      return expression(ctx, ['item', '_'], code);\n    },\n\n    /**\n     * Optimized code generators for access and comparison.\n     */\n    codegen: {\n      get(path) {\n        const ref = `[${path.map(vegaUtil.stringValue).join('][')}]`;\n        const get = Function('_', `return _${ref};`);\n        get.path = ref;\n        return get;\n      },\n      comparator(fields, orders) {\n        let t;\n        const map = (f, i) => {\n          const o = orders[i];\n          let u, v;\n          if (f.path) {\n            u = `a${f.path}`;\n            v = `b${f.path}`;\n          } else {\n            (t = t || {})['f'+i] = f;\n            u = `this.f${i}(a)`;\n            v = `this.f${i}(b)`;\n          }\n          return _compare(u, v, -o, o);\n        };\n\n        const fn = Function('a', 'b', 'var u, v; return '\n          + fields.map(map).join('') + '0;');\n        return t ? fn.bind(t) : fn;\n      }\n    }\n  };\n\n  /**\n   * Parse a dataflow operator.\n   */\n  function parseOperator(spec) {\n    const ctx = this;\n    if (isOperator(spec.type) || !spec.type) {\n      ctx.operator(\n        spec,\n        spec.update ? ctx.operatorExpression(spec.update) : null\n      );\n    } else {\n      ctx.transform(spec, spec.type);\n    }\n  }\n\n  /**\n   * Parse and assign operator parameters.\n   */\n  function parseOperatorParameters(spec) {\n    const ctx = this;\n    if (spec.params) {\n      const op = ctx.get(spec.id);\n      if (!op) vegaUtil.error('Invalid operator id: ' + spec.id);\n      ctx.dataflow.connect(op, op.parameters(\n        ctx.parseParameters(spec.params),\n        spec.react,\n        spec.initonly\n      ));\n    }\n  }\n\n  /**\n   * Parse a set of operator parameters.\n   */\n  function parseParameters(spec, params) {\n    params = params || {};\n    const ctx = this;\n\n    for (const key in spec) {\n      const value = spec[key];\n      params[key] = vegaUtil.isArray(value)\n        ? value.map(v => parseParameter(v, ctx, params))\n        : parseParameter(value, ctx, params);\n    }\n\n    return params;\n  }\n\n  /**\n   * Parse a single parameter.\n   */\n  function parseParameter(spec, ctx, params) {\n    if (!spec || !vegaUtil.isObject(spec)) return spec;\n\n    for (let i=0, n=PARSERS.length, p; i<n; ++i) {\n      p = PARSERS[i];\n      if (vegaUtil.hasOwnProperty(spec, p.key)) {\n        return p.parse(spec, ctx, params);\n      }\n    }\n\n    return spec;\n  }\n\n  /** Reference parsers. */\n  var PARSERS = [\n    {key: '$ref',      parse: getOperator},\n    {key: '$key',      parse: getKey},\n    {key: '$expr',     parse: getExpression},\n    {key: '$field',    parse: getField},\n    {key: '$encode',   parse: getEncode},\n    {key: '$compare',  parse: getCompare},\n    {key: '$context',  parse: getContext},\n    {key: '$subflow',  parse: getSubflow},\n    {key: '$tupleid',  parse: getTupleId}\n  ];\n\n  /**\n   * Resolve an operator reference.\n   */\n  function getOperator(_, ctx) {\n    return ctx.get(_.$ref) || vegaUtil.error('Operator not defined: ' + _.$ref);\n  }\n\n  /**\n   * Resolve an expression reference.\n   */\n  function getExpression(_, ctx, params) {\n    if (_.$params) { // parse expression parameters\n      ctx.parseParameters(_.$params, params);\n    }\n    const k = 'e:' + _.$expr.code + '_' + _.$name;\n    return ctx.fn[k] || (ctx.fn[k] = vegaUtil.accessor(\n      ctx.parameterExpression(_.$expr),\n      _.$fields,\n      _.$name\n    ));\n  }\n\n  /**\n   * Resolve a key accessor reference.\n   */\n  function getKey(_, ctx) {\n    const k = 'k:' + _.$key + '_' + (!!_.$flat);\n    return ctx.fn[k] || (ctx.fn[k] = vegaUtil.key(_.$key, _.$flat, ctx.expr.codegen));\n  }\n\n  /**\n   * Resolve a field accessor reference.\n   */\n  function getField(_, ctx) {\n    if (!_.$field) return null;\n    const k = 'f:' + _.$field + '_' + _.$name;\n    return ctx.fn[k] || (ctx.fn[k] = vegaUtil.field(_.$field, _.$name, ctx.expr.codegen));\n  }\n\n  /**\n   * Resolve a comparator function reference.\n   */\n  function getCompare(_, ctx) {\n    // As of Vega 5.5.3, $tupleid sort is no longer used.\n    // Keep here for now for backwards compatibility.\n    const k = 'c:' + _.$compare + '_' + _.$order,\n          c = vegaUtil.array(_.$compare).map(_ => (_ && _.$tupleid) ? vegaDataflow.tupleid : _);\n    return ctx.fn[k] || (ctx.fn[k] = vegaUtil.compare(c, _.$order, ctx.expr.codegen));\n  }\n\n  /**\n   * Resolve an encode operator reference.\n   */\n  function getEncode(_, ctx) {\n    const spec = _.$encode,\n          encode = {};\n\n    for (const name in spec) {\n      const enc = spec[name];\n      encode[name] = vegaUtil.accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\n      encode[name].output = enc.$output;\n    }\n    return encode;\n  }\n\n  /**\n   * Resolve a context reference.\n   */\n  function getContext(_, ctx) {\n    return ctx;\n  }\n\n  /**\n   * Resolve a recursive subflow specification.\n   */\n  function getSubflow(_, ctx) {\n    const spec = _.$subflow;\n    return function(dataflow, key, parent) {\n      const subctx = ctx.fork().parse(spec),\n            op = subctx.get(spec.operators[0].id),\n            p = subctx.signals.parent;\n      if (p) p.set(parent);\n      op.detachSubflow = () => ctx.detach(subctx);\n      return op;\n    };\n  }\n\n  /**\n   * Resolve a tuple id reference.\n   */\n  function getTupleId() {\n    return vegaDataflow.tupleid;\n  }\n\n  /**\n   * Parse an event stream specification.\n   */\n  function parseStream(spec) {\n    var ctx = this,\n        filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\n        stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n        args;\n\n    if (spec.source) {\n      stream = ctx.events(spec.source, spec.type, filter);\n    }\n    else if (spec.merge) {\n      args = spec.merge.map(_ => ctx.get(_));\n      stream = args[0].merge.apply(args[0], args.slice(1));\n    }\n\n    if (spec.between) {\n      args = spec.between.map(_ => ctx.get(_));\n      stream = stream.between(args[0], args[1]);\n    }\n\n    if (spec.filter) {\n      stream = stream.filter(filter);\n    }\n\n    if (spec.throttle != null) {\n      stream = stream.throttle(+spec.throttle);\n    }\n\n    if (spec.debounce != null) {\n      stream = stream.debounce(+spec.debounce);\n    }\n\n    if (stream == null) {\n      vegaUtil.error('Invalid stream definition: ' + JSON.stringify(spec));\n    }\n\n    if (spec.consume) stream.consume(true);\n\n    ctx.stream(spec, stream);\n  }\n\n  /**\n   * Parse an event-driven operator update.\n   */\n  function parseUpdate(spec) {\n    var ctx = this,\n        srcid = vegaUtil.isObject(srcid = spec.source) ? srcid.$ref : srcid,\n        source = ctx.get(srcid),\n        target = null,\n        update = spec.update,\n        params = undefined;\n\n    if (!source) vegaUtil.error('Source not defined: ' + spec.source);\n\n    target = spec.target && spec.target.$expr\n      ? ctx.eventExpression(spec.target.$expr)\n      : ctx.get(spec.target);\n\n    if (update && update.$expr) {\n      if (update.$params) {\n        params = ctx.parseParameters(update.$params);\n      }\n      update = ctx.handlerExpression(update.$expr);\n    }\n\n    ctx.update(spec, source, target, update, params);\n  }\n\n  var SKIP = {skip: true};\n\n  function getState(options) {\n    var ctx = this,\n        state = {};\n\n    if (options.signals) {\n      var signals = (state.signals = {});\n      Object.keys(ctx.signals).forEach(key => {\n        var op = ctx.signals[key];\n        if (options.signals(key, op)) {\n          signals[key] = op.value;\n        }\n      });\n    }\n\n    if (options.data) {\n      var data = (state.data = {});\n      Object.keys(ctx.data).forEach(key => {\n        var dataset = ctx.data[key];\n        if (options.data(key, dataset)) {\n          data[key] = dataset.input.value;\n        }\n      });\n    }\n\n    if (ctx.subcontext && options.recurse !== false) {\n      state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));\n    }\n\n    return state;\n  }\n\n  function setState(state) {\n    var ctx = this,\n        df = ctx.dataflow,\n        data = state.data,\n        signals = state.signals;\n\n    Object.keys(signals || {}).forEach(key => {\n      df.update(ctx.signals[key], signals[key], SKIP);\n    });\n\n    Object.keys(data || {}).forEach(key => {\n      df.pulse(\n        ctx.data[key].input,\n        df.changeset().remove(vegaUtil.truthy).insert(data[key])\n      );\n    });\n\n    (state.subcontext  || []).forEach((substate, i) => {\n      var subctx = ctx.subcontext[i];\n      if (subctx) subctx.setState(substate);\n    });\n  }\n\n  /**\n   * Context objects store the current parse state.\n   * Enables lookup of parsed operators, event streams, accessors, etc.\n   * Provides a 'fork' method for creating child contexts for subflows.\n   */\n  function context(df, transforms, functions, expr) {\n    return new Context(df, transforms, functions, expr);\n  }\n\n  function Context(df, transforms, functions, expr) {\n    this.dataflow = df;\n    this.transforms = transforms;\n    this.events = df.events.bind(df);\n    this.expr = expr || expressionCodegen,\n    this.signals = {};\n    this.scales = {};\n    this.nodes = {};\n    this.data = {};\n    this.fn = {};\n    if (functions) {\n      this.functions = Object.create(functions);\n      this.functions.context = this;\n    }\n  }\n\n  function Subcontext(ctx) {\n    this.dataflow = ctx.dataflow;\n    this.transforms = ctx.transforms;\n    this.events = ctx.events;\n    this.expr = ctx.expr;\n    this.signals = Object.create(ctx.signals);\n    this.scales = Object.create(ctx.scales);\n    this.nodes = Object.create(ctx.nodes);\n    this.data = Object.create(ctx.data);\n    this.fn = Object.create(ctx.fn);\n    if (ctx.functions) {\n      this.functions = Object.create(ctx.functions);\n      this.functions.context = this;\n    }\n  }\n\n  Context.prototype = Subcontext.prototype = {\n    fork() {\n      const ctx = new Subcontext(this);\n      (this.subcontext || (this.subcontext = [])).push(ctx);\n      return ctx;\n    },\n    detach(ctx) {\n      this.subcontext = this.subcontext.filter(c => c !== ctx);\n\n      // disconnect all nodes in the subcontext\n      // wipe out targets first for better efficiency\n      const keys = Object.keys(ctx.nodes);\n      for (const key of keys) ctx.nodes[key]._targets = null;\n      for (const key of keys) ctx.nodes[key].detach();\n      ctx.nodes = null;\n    },\n    get(id) {\n      return this.nodes[id];\n    },\n    set(id, node) {\n      return this.nodes[id] = node;\n    },\n    add(spec, op) {\n      const ctx = this,\n            df = ctx.dataflow,\n            data = spec.value;\n\n      ctx.set(spec.id, op);\n\n      if (isCollect(spec.type) && data) {\n        if (data.$ingest) {\n          df.ingest(op, data.$ingest, data.$format);\n        } else if (data.$request) {\n          df.preload(op, data.$request, data.$format);\n        } else {\n          df.pulse(op, df.changeset().insert(data));\n        }\n      }\n\n      if (spec.root) {\n        ctx.root = op;\n      }\n\n      if (spec.parent) {\n        var p = ctx.get(spec.parent.$ref);\n        if (p) {\n          df.connect(p, [op]);\n          op.targets().add(p);\n        } else {\n          (ctx.unresolved = ctx.unresolved || []).push(() => {\n            p = ctx.get(spec.parent.$ref);\n            df.connect(p, [op]);\n            op.targets().add(p);\n          });\n        }\n      }\n\n      if (spec.signal) {\n        ctx.signals[spec.signal] = op;\n      }\n\n      if (spec.scale) {\n        ctx.scales[spec.scale] = op;\n      }\n\n      if (spec.data) {\n        for (const name in spec.data) {\n          const data = ctx.data[name] || (ctx.data[name] = {});\n          spec.data[name].forEach(role => data[role] = op);\n        }\n      }\n    },\n    resolve() {\n      (this.unresolved || []).forEach(fn => fn());\n      delete this.unresolved;\n      return this;\n    },\n    operator(spec, update) {\n      this.add(spec, this.dataflow.add(spec.value, update));\n    },\n    transform(spec, type) {\n      this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n    },\n    stream(spec, stream) {\n      this.set(spec.id, stream);\n    },\n    update(spec, stream, target, update, params) {\n      this.dataflow.on(stream, target, update, params, spec.options);\n    },\n\n    // expression parsing\n    operatorExpression(expr) {\n      return this.expr.operator(this, expr);\n    },\n    parameterExpression(expr) {\n      return this.expr.parameter(this, expr);\n    },\n    eventExpression(expr) {\n      return this.expr.event(this, expr);\n    },\n    handlerExpression(expr) {\n      return this.expr.handler(this, expr);\n    },\n    encodeExpression(encode) {\n      return this.expr.encode(this, encode);\n    },\n\n    // parse methods\n    parse,\n    parseOperator,\n    parseOperatorParameters,\n    parseParameters,\n    parseStream,\n    parseUpdate,\n\n    // state methods\n    getState,\n    setState\n  };\n\n  exports.context = context;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vega_dataflow$build$vega_dataflow","~$shadow.js","~$module$node_modules$vega_util$build$vega_util"]],"~:properties",["^5",["skip","_targets","unresolved","stream","handler","dataflow","expr","output","parameter","resolve","prototype","codegen","subcontext","parseUpdate","operator","detachSubflow","key","__esModule","detach","path","fn","transform","root","vega","event","update","operatorExpression","$jscomp$loop$prop$data$389$530","setState","getState","locale","scales","signals","value","parseOperatorParameters","eventConfig","context","eventExpression","functions","comparator","events","nodes","transforms","parse","add","set","fork","parseParameters","parameterExpression","encodeExpression","data","background","get","encode","handlerExpression","parseOperator","parseStream"]],"~:compiled-at",1600144480025,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_runtime$build$vega_runtime.js\",\n\"lineCount\":23,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-runtime/build/vega-runtime.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_runtime$build$vega_runtime\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-dataflow')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-dataflow'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega));\\n}(this, (function (exports, vegaUtil, vegaDataflow) { 'use strict';\\n\\n  /**\\n   * Parse a serialized dataflow specification.\\n   */\\n  function parse(spec) {\\n    const ctx = this,\\n          operators = spec.operators || [];\\n\\n    // parse background\\n    if (spec.background) {\\n      ctx.background = spec.background;\\n    }\\n\\n    // parse event configuration\\n    if (spec.eventConfig) {\\n      ctx.eventConfig = spec.eventConfig;\\n    }\\n\\n    // parse locale configuration\\n    if (spec.locale) {\\n      ctx.locale = spec.locale;\\n    }\\n\\n    // parse operators\\n    operators.forEach(entry => ctx.parseOperator(entry));\\n\\n    // parse operator parameters\\n    operators.forEach(entry => ctx.parseOperatorParameters(entry));\\n\\n    // parse streams\\n    (spec.streams || []).forEach(entry => ctx.parseStream(entry));\\n\\n    // parse updates\\n    (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));\\n\\n    return ctx.resolve();\\n  }\\n\\n  const Skip = vegaUtil.toSet(['rule']),\\n        Swap = vegaUtil.toSet(['group', 'image', 'rect']);\\n\\n  function adjustSpatial(encode, marktype) {\\n    let code = '';\\n\\n    if (Skip[marktype]) return code;\\n\\n    if (encode.x2) {\\n      if (encode.x) {\\n        if (Swap[marktype]) {\\n          code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\\n        }\\n        code += 'o.width=o.x2-o.x;';\\n      } else {\\n        code += 'o.x=o.x2-(o.width||0);';\\n      }\\n    }\\n\\n    if (encode.xc) {\\n      code += 'o.x=o.xc-(o.width||0)/2;';\\n    }\\n\\n    if (encode.y2) {\\n      if (encode.y) {\\n        if (Swap[marktype]) {\\n          code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\\n        }\\n        code += 'o.height=o.y2-o.y;';\\n      } else {\\n        code += 'o.y=o.y2-(o.height||0);';\\n      }\\n    }\\n\\n    if (encode.yc) {\\n      code += 'o.y=o.yc-(o.height||0)/2;';\\n    }\\n\\n    return code;\\n  }\\n\\n  function canonicalType(type) {\\n    return (type + '').toLowerCase();\\n  }\\n\\n  function isOperator(type) {\\n     return canonicalType(type) === 'operator';\\n  }\\n\\n  function isCollect(type) {\\n    return canonicalType(type) === 'collect';\\n  }\\n\\n  function expression(ctx, args, code) {\\n    // wrap code in return statement if expression does not terminate\\n    if (code[code.length-1] !== ';') {\\n      code = 'return(' + code + ');';\\n    }\\n    var fn = Function.apply(null, args.concat(code));\\n    return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\\n  }\\n\\n  // generate code for comparing a single field\\n  function _compare(u, v, lt, gt) {\\n    return `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt}\\n  : (u > v || v == null) && u != null ? ${gt}\\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}\\n  : v !== v && u === u ? ${gt} : `;\\n  }\\n\\n  var expressionCodegen = {\\n    /**\\n     * Parse an expression used to update an operator value.\\n     */\\n    operator: (ctx, expr) => expression(ctx, ['_'], expr.code),\\n\\n    /**\\n     * Parse an expression provided as an operator parameter value.\\n     */\\n    parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),\\n\\n    /**\\n     * Parse an expression applied to an event stream.\\n     */\\n    event: (ctx, expr) => expression(ctx, ['event'], expr.code),\\n\\n    /**\\n     * Parse an expression used to handle an event-driven operator update.\\n     */\\n    handler: (ctx, expr) => {\\n      const code = `var datum=event.item&&event.item.datum;return ${expr.code};`;\\n      return expression(ctx, ['_', 'event'], code);\\n    },\\n\\n    /**\\n     * Parse an expression that performs visual encoding.\\n     */\\n    encode: (ctx, encode) => {\\n      const {marktype, channels} = encode;\\n\\n      let code = 'var o=item,datum=o.datum,m=0,$;';\\n      for (const name in channels) {\\n        const o ='o[' + vegaUtil.stringValue(name) + ']';\\n        code += `$=${channels[name].code};if(${o}!==$)${o}=$,m=1;`;\\n      }\\n      code += adjustSpatial(channels, marktype);\\n      code += 'return m;';\\n\\n      return expression(ctx, ['item', '_'], code);\\n    },\\n\\n    /**\\n     * Optimized code generators for access and comparison.\\n     */\\n    codegen: {\\n      get(path) {\\n        const ref = `[${path.map(vegaUtil.stringValue).join('][')}]`;\\n        const get = Function('_', `return _${ref};`);\\n        get.path = ref;\\n        return get;\\n      },\\n      comparator(fields, orders) {\\n        let t;\\n        const map = (f, i) => {\\n          const o = orders[i];\\n          let u, v;\\n          if (f.path) {\\n            u = `a${f.path}`;\\n            v = `b${f.path}`;\\n          } else {\\n            (t = t || {})['f'+i] = f;\\n            u = `this.f${i}(a)`;\\n            v = `this.f${i}(b)`;\\n          }\\n          return _compare(u, v, -o, o);\\n        };\\n\\n        const fn = Function('a', 'b', 'var u, v; return '\\n          + fields.map(map).join('') + '0;');\\n        return t ? fn.bind(t) : fn;\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Parse a dataflow operator.\\n   */\\n  function parseOperator(spec) {\\n    const ctx = this;\\n    if (isOperator(spec.type) || !spec.type) {\\n      ctx.operator(\\n        spec,\\n        spec.update ? ctx.operatorExpression(spec.update) : null\\n      );\\n    } else {\\n      ctx.transform(spec, spec.type);\\n    }\\n  }\\n\\n  /**\\n   * Parse and assign operator parameters.\\n   */\\n  function parseOperatorParameters(spec) {\\n    const ctx = this;\\n    if (spec.params) {\\n      const op = ctx.get(spec.id);\\n      if (!op) vegaUtil.error('Invalid operator id: ' + spec.id);\\n      ctx.dataflow.connect(op, op.parameters(\\n        ctx.parseParameters(spec.params),\\n        spec.react,\\n        spec.initonly\\n      ));\\n    }\\n  }\\n\\n  /**\\n   * Parse a set of operator parameters.\\n   */\\n  function parseParameters(spec, params) {\\n    params = params || {};\\n    const ctx = this;\\n\\n    for (const key in spec) {\\n      const value = spec[key];\\n      params[key] = vegaUtil.isArray(value)\\n        ? value.map(v => parseParameter(v, ctx, params))\\n        : parseParameter(value, ctx, params);\\n    }\\n\\n    return params;\\n  }\\n\\n  /**\\n   * Parse a single parameter.\\n   */\\n  function parseParameter(spec, ctx, params) {\\n    if (!spec || !vegaUtil.isObject(spec)) return spec;\\n\\n    for (let i=0, n=PARSERS.length, p; i<n; ++i) {\\n      p = PARSERS[i];\\n      if (vegaUtil.hasOwnProperty(spec, p.key)) {\\n        return p.parse(spec, ctx, params);\\n      }\\n    }\\n\\n    return spec;\\n  }\\n\\n  /** Reference parsers. */\\n  var PARSERS = [\\n    {key: '$ref',      parse: getOperator},\\n    {key: '$key',      parse: getKey},\\n    {key: '$expr',     parse: getExpression},\\n    {key: '$field',    parse: getField},\\n    {key: '$encode',   parse: getEncode},\\n    {key: '$compare',  parse: getCompare},\\n    {key: '$context',  parse: getContext},\\n    {key: '$subflow',  parse: getSubflow},\\n    {key: '$tupleid',  parse: getTupleId}\\n  ];\\n\\n  /**\\n   * Resolve an operator reference.\\n   */\\n  function getOperator(_, ctx) {\\n    return ctx.get(_.$ref) || vegaUtil.error('Operator not defined: ' + _.$ref);\\n  }\\n\\n  /**\\n   * Resolve an expression reference.\\n   */\\n  function getExpression(_, ctx, params) {\\n    if (_.$params) { // parse expression parameters\\n      ctx.parseParameters(_.$params, params);\\n    }\\n    const k = 'e:' + _.$expr.code + '_' + _.$name;\\n    return ctx.fn[k] || (ctx.fn[k] = vegaUtil.accessor(\\n      ctx.parameterExpression(_.$expr),\\n      _.$fields,\\n      _.$name\\n    ));\\n  }\\n\\n  /**\\n   * Resolve a key accessor reference.\\n   */\\n  function getKey(_, ctx) {\\n    const k = 'k:' + _.$key + '_' + (!!_.$flat);\\n    return ctx.fn[k] || (ctx.fn[k] = vegaUtil.key(_.$key, _.$flat, ctx.expr.codegen));\\n  }\\n\\n  /**\\n   * Resolve a field accessor reference.\\n   */\\n  function getField(_, ctx) {\\n    if (!_.$field) return null;\\n    const k = 'f:' + _.$field + '_' + _.$name;\\n    return ctx.fn[k] || (ctx.fn[k] = vegaUtil.field(_.$field, _.$name, ctx.expr.codegen));\\n  }\\n\\n  /**\\n   * Resolve a comparator function reference.\\n   */\\n  function getCompare(_, ctx) {\\n    // As of Vega 5.5.3, $tupleid sort is no longer used.\\n    // Keep here for now for backwards compatibility.\\n    const k = 'c:' + _.$compare + '_' + _.$order,\\n          c = vegaUtil.array(_.$compare).map(_ => (_ && _.$tupleid) ? vegaDataflow.tupleid : _);\\n    return ctx.fn[k] || (ctx.fn[k] = vegaUtil.compare(c, _.$order, ctx.expr.codegen));\\n  }\\n\\n  /**\\n   * Resolve an encode operator reference.\\n   */\\n  function getEncode(_, ctx) {\\n    const spec = _.$encode,\\n          encode = {};\\n\\n    for (const name in spec) {\\n      const enc = spec[name];\\n      encode[name] = vegaUtil.accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\\n      encode[name].output = enc.$output;\\n    }\\n    return encode;\\n  }\\n\\n  /**\\n   * Resolve a context reference.\\n   */\\n  function getContext(_, ctx) {\\n    return ctx;\\n  }\\n\\n  /**\\n   * Resolve a recursive subflow specification.\\n   */\\n  function getSubflow(_, ctx) {\\n    const spec = _.$subflow;\\n    return function(dataflow, key, parent) {\\n      const subctx = ctx.fork().parse(spec),\\n            op = subctx.get(spec.operators[0].id),\\n            p = subctx.signals.parent;\\n      if (p) p.set(parent);\\n      op.detachSubflow = () => ctx.detach(subctx);\\n      return op;\\n    };\\n  }\\n\\n  /**\\n   * Resolve a tuple id reference.\\n   */\\n  function getTupleId() {\\n    return vegaDataflow.tupleid;\\n  }\\n\\n  /**\\n   * Parse an event stream specification.\\n   */\\n  function parseStream(spec) {\\n    var ctx = this,\\n        filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\\n        stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\\n        args;\\n\\n    if (spec.source) {\\n      stream = ctx.events(spec.source, spec.type, filter);\\n    }\\n    else if (spec.merge) {\\n      args = spec.merge.map(_ => ctx.get(_));\\n      stream = args[0].merge.apply(args[0], args.slice(1));\\n    }\\n\\n    if (spec.between) {\\n      args = spec.between.map(_ => ctx.get(_));\\n      stream = stream.between(args[0], args[1]);\\n    }\\n\\n    if (spec.filter) {\\n      stream = stream.filter(filter);\\n    }\\n\\n    if (spec.throttle != null) {\\n      stream = stream.throttle(+spec.throttle);\\n    }\\n\\n    if (spec.debounce != null) {\\n      stream = stream.debounce(+spec.debounce);\\n    }\\n\\n    if (stream == null) {\\n      vegaUtil.error('Invalid stream definition: ' + JSON.stringify(spec));\\n    }\\n\\n    if (spec.consume) stream.consume(true);\\n\\n    ctx.stream(spec, stream);\\n  }\\n\\n  /**\\n   * Parse an event-driven operator update.\\n   */\\n  function parseUpdate(spec) {\\n    var ctx = this,\\n        srcid = vegaUtil.isObject(srcid = spec.source) ? srcid.$ref : srcid,\\n        source = ctx.get(srcid),\\n        target = null,\\n        update = spec.update,\\n        params = undefined;\\n\\n    if (!source) vegaUtil.error('Source not defined: ' + spec.source);\\n\\n    target = spec.target && spec.target.$expr\\n      ? ctx.eventExpression(spec.target.$expr)\\n      : ctx.get(spec.target);\\n\\n    if (update && update.$expr) {\\n      if (update.$params) {\\n        params = ctx.parseParameters(update.$params);\\n      }\\n      update = ctx.handlerExpression(update.$expr);\\n    }\\n\\n    ctx.update(spec, source, target, update, params);\\n  }\\n\\n  var SKIP = {skip: true};\\n\\n  function getState(options) {\\n    var ctx = this,\\n        state = {};\\n\\n    if (options.signals) {\\n      var signals = (state.signals = {});\\n      Object.keys(ctx.signals).forEach(key => {\\n        var op = ctx.signals[key];\\n        if (options.signals(key, op)) {\\n          signals[key] = op.value;\\n        }\\n      });\\n    }\\n\\n    if (options.data) {\\n      var data = (state.data = {});\\n      Object.keys(ctx.data).forEach(key => {\\n        var dataset = ctx.data[key];\\n        if (options.data(key, dataset)) {\\n          data[key] = dataset.input.value;\\n        }\\n      });\\n    }\\n\\n    if (ctx.subcontext && options.recurse !== false) {\\n      state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));\\n    }\\n\\n    return state;\\n  }\\n\\n  function setState(state) {\\n    var ctx = this,\\n        df = ctx.dataflow,\\n        data = state.data,\\n        signals = state.signals;\\n\\n    Object.keys(signals || {}).forEach(key => {\\n      df.update(ctx.signals[key], signals[key], SKIP);\\n    });\\n\\n    Object.keys(data || {}).forEach(key => {\\n      df.pulse(\\n        ctx.data[key].input,\\n        df.changeset().remove(vegaUtil.truthy).insert(data[key])\\n      );\\n    });\\n\\n    (state.subcontext  || []).forEach((substate, i) => {\\n      var subctx = ctx.subcontext[i];\\n      if (subctx) subctx.setState(substate);\\n    });\\n  }\\n\\n  /**\\n   * Context objects store the current parse state.\\n   * Enables lookup of parsed operators, event streams, accessors, etc.\\n   * Provides a 'fork' method for creating child contexts for subflows.\\n   */\\n  function context(df, transforms, functions, expr) {\\n    return new Context(df, transforms, functions, expr);\\n  }\\n\\n  function Context(df, transforms, functions, expr) {\\n    this.dataflow = df;\\n    this.transforms = transforms;\\n    this.events = df.events.bind(df);\\n    this.expr = expr || expressionCodegen,\\n    this.signals = {};\\n    this.scales = {};\\n    this.nodes = {};\\n    this.data = {};\\n    this.fn = {};\\n    if (functions) {\\n      this.functions = Object.create(functions);\\n      this.functions.context = this;\\n    }\\n  }\\n\\n  function Subcontext(ctx) {\\n    this.dataflow = ctx.dataflow;\\n    this.transforms = ctx.transforms;\\n    this.events = ctx.events;\\n    this.expr = ctx.expr;\\n    this.signals = Object.create(ctx.signals);\\n    this.scales = Object.create(ctx.scales);\\n    this.nodes = Object.create(ctx.nodes);\\n    this.data = Object.create(ctx.data);\\n    this.fn = Object.create(ctx.fn);\\n    if (ctx.functions) {\\n      this.functions = Object.create(ctx.functions);\\n      this.functions.context = this;\\n    }\\n  }\\n\\n  Context.prototype = Subcontext.prototype = {\\n    fork() {\\n      const ctx = new Subcontext(this);\\n      (this.subcontext || (this.subcontext = [])).push(ctx);\\n      return ctx;\\n    },\\n    detach(ctx) {\\n      this.subcontext = this.subcontext.filter(c => c !== ctx);\\n\\n      // disconnect all nodes in the subcontext\\n      // wipe out targets first for better efficiency\\n      const keys = Object.keys(ctx.nodes);\\n      for (const key of keys) ctx.nodes[key]._targets = null;\\n      for (const key of keys) ctx.nodes[key].detach();\\n      ctx.nodes = null;\\n    },\\n    get(id) {\\n      return this.nodes[id];\\n    },\\n    set(id, node) {\\n      return this.nodes[id] = node;\\n    },\\n    add(spec, op) {\\n      const ctx = this,\\n            df = ctx.dataflow,\\n            data = spec.value;\\n\\n      ctx.set(spec.id, op);\\n\\n      if (isCollect(spec.type) && data) {\\n        if (data.$ingest) {\\n          df.ingest(op, data.$ingest, data.$format);\\n        } else if (data.$request) {\\n          df.preload(op, data.$request, data.$format);\\n        } else {\\n          df.pulse(op, df.changeset().insert(data));\\n        }\\n      }\\n\\n      if (spec.root) {\\n        ctx.root = op;\\n      }\\n\\n      if (spec.parent) {\\n        var p = ctx.get(spec.parent.$ref);\\n        if (p) {\\n          df.connect(p, [op]);\\n          op.targets().add(p);\\n        } else {\\n          (ctx.unresolved = ctx.unresolved || []).push(() => {\\n            p = ctx.get(spec.parent.$ref);\\n            df.connect(p, [op]);\\n            op.targets().add(p);\\n          });\\n        }\\n      }\\n\\n      if (spec.signal) {\\n        ctx.signals[spec.signal] = op;\\n      }\\n\\n      if (spec.scale) {\\n        ctx.scales[spec.scale] = op;\\n      }\\n\\n      if (spec.data) {\\n        for (const name in spec.data) {\\n          const data = ctx.data[name] || (ctx.data[name] = {});\\n          spec.data[name].forEach(role => data[role] = op);\\n        }\\n      }\\n    },\\n    resolve() {\\n      (this.unresolved || []).forEach(fn => fn());\\n      delete this.unresolved;\\n      return this;\\n    },\\n    operator(spec, update) {\\n      this.add(spec, this.dataflow.add(spec.value, update));\\n    },\\n    transform(spec, type) {\\n      this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\\n    },\\n    stream(spec, stream) {\\n      this.set(spec.id, stream);\\n    },\\n    update(spec, stream, target, update, params) {\\n      this.dataflow.on(stream, target, update, params, spec.options);\\n    },\\n\\n    // expression parsing\\n    operatorExpression(expr) {\\n      return this.expr.operator(this, expr);\\n    },\\n    parameterExpression(expr) {\\n      return this.expr.parameter(this, expr);\\n    },\\n    eventExpression(expr) {\\n      return this.expr.event(this, expr);\\n    },\\n    handlerExpression(expr) {\\n      return this.expr.handler(this, expr);\\n    },\\n    encodeExpression(encode) {\\n      return this.expr.encode(this, encode);\\n    },\\n\\n    // parse methods\\n    parse,\\n    parseOperator,\\n    parseOperatorParameters,\\n    parseParameters,\\n    parseStream,\\n    parseUpdate,\\n\\n    // state methods\\n    getState,\\n    setState\\n  };\\n\\n  exports.context = context;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"vegaUtil\",\"vegaDataflow\",\"expression\",\"ctx\",\"args\",\"code\",\"length\",\"fn\",\"Function\",\"apply\",\"concat\",\"functions\",\"bind\",\"parseParameter\",\"spec\",\"params\",\"isObject\",\"i\",\"n\",\"PARSERS\",\"p\",\"hasOwnProperty\",\"key\",\"parse\",\"Context\",\"df\",\"transforms\",\"expr\",\"dataflow\",\"events\",\"expressionCodegen\",\"signals\",\"scales\",\"nodes\",\"data\",\"Object\",\"create\",\"context\",\"Subcontext\",\"Skip\",\"toSet\",\"Swap\",\"operator\",\"parameter\",\"event\",\"handler\",\"encode\",\"marktype\",\"channels\",\"name\",\"o\",\"stringValue\",\"x2\",\"x\",\"xc\",\"y2\",\"y\",\"yc\",\"codegen\",\"get\",\"path\",\"ref\",\"map\",\"join\",\"comparator\",\"fields\",\"orders\",\"t\",\"f\",\"u\",\"v\",\"lt\",\"getOperator\",\"_\",\"$ref\",\"error\",\"getKey\",\"k\",\"$key\",\"$flat\",\"getExpression\",\"$params\",\"parseParameters\",\"$expr\",\"$name\",\"accessor\",\"parameterExpression\",\"$fields\",\"getField\",\"$field\",\"field\",\"getEncode\",\"$encode\",\"enc\",\"encodeExpression\",\"output\",\"$output\",\"getCompare\",\"$compare\",\"$order\",\"c\",\"array\",\"$tupleid\",\"tupleid\",\"compare\",\"getContext\",\"getSubflow\",\"$subflow\",\"parent\",\"subctx\",\"fork\",\"op\",\"operators\",\"id\",\"set\",\"detachSubflow\",\"op.detachSubflow\",\"detach\",\"getTupleId\",\"SKIP\",\"skip\",\"prototype\",\"subcontext\",\"push\",\"filter\",\"keys\",\"_targets\",\"node\",\"add\",\"value\",\"type\",\"toLowerCase\",\"$ingest\",\"ingest\",\"$format\",\"$request\",\"preload\",\"pulse\",\"changeset\",\"insert\",\"root\",\"connect\",\"targets\",\"unresolved\",\"signal\",\"scale\",\"forEach\",\"role\",\"resolve\",\"update\",\"transform\",\"stream\",\"target\",\"on\",\"options\",\"operatorExpression\",\"eventExpression\",\"handlerExpression\",\"background\",\"eventConfig\",\"locale\",\"entry\",\"parseOperator\",\"parseOperatorParameters\",\"streams\",\"parseStream\",\"updates\",\"parseUpdate\",\"parameters\",\"react\",\"initonly\",\"isArray\",\"undefined\",\"source\",\"merge\",\"slice\",\"between\",\"throttle\",\"debounce\",\"JSON\",\"stringify\",\"consume\",\"srcid\",\"getState\",\"state\",\"dataset\",\"input\",\"recurse\",\"setState\",\"remove\",\"truthy\",\"substate\",\"defineProperty\"]\n}\n"]