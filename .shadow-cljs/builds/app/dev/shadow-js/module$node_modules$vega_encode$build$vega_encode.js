["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-encode/build/vega-encode.js"],"~:js","shadow$provide.module$node_modules$vega_encode$build$vega_encode=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_dataflow$build$vega_dataflow\"),require(\"module$node_modules$vega_scale$build$vega_scale\"),require(\"module$node_modules$vega_util$build$vega_util\"),require(\"module$node_modules$d3_array$dist$d3_array\"),require(\"module$node_modules$d3_interpolate$dist$d3_interpolate\")):\n\"function\"===typeof define&&define.amd?define(\"exports vega-dataflow vega-scale vega-util d3-array d3-interpolate\".split(\" \"),factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory((global.vega=global.vega||{},global.vega.transforms={}),global.vega,global.vega,global.vega,global.d3,global.d3))})(this,function(exports,vegaDataflow,vegaScale,vegaUtil,d3Array,d3Interpolate){function AxisTicks(params){vegaDataflow.Transform.call(this,null,params)}function DataJoin(params){vegaDataflow.Transform.call(this,\nnull,params)}function defaultItemCreate(){return vegaDataflow.ingest({})}function newMap(key){var map=vegaUtil.fastmap().test(function(t){return t.exit});map.lookup=function(t){return map.get(key(t))};return map}function Encode(params){vegaDataflow.Transform.call(this,null,params)}function LegendEntries(params){vegaDataflow.Transform.call(this,[],params)}function LinkPath(params){vegaDataflow.Transform.call(this,{},params)}function Pie(params){vegaDataflow.Transform.call(this,null,params)}function includePad(type){return vegaScale.isContinuous(type)&&\ntype!==vegaScale.Sequential}function Scale(params){vegaDataflow.Transform.call(this,null,params);this.modified(!0)}function domainCheck(type,domain,df){vegaScale.isLogarithmic(type)&&Math.abs(domain.reduce(function(s,v){return s+(0>v?-1:0<v?1:0)},0))!==domain.length&&df.warn(\"Log scale domain includes zero: \"+vegaUtil.stringValue(domain));return domain}function adjustScheme(scheme,extent,reverse){return vegaUtil.isFunction(scheme)&&(extent||reverse)?vegaScale.interpolateRange(scheme,flip(extent||\n[0,1],reverse)):scheme}function flip(array,reverse){return reverse?array.slice().reverse():array}function SortItems(params){vegaDataflow.Transform.call(this,null,params)}function Stack(params){vegaDataflow.Transform.call(this,null,params)}function stackCenter(group,max,field,y0,y1){max=(max-group.sum)/2;for(var m=group.length,j=0,t;j<m;++j)t=group[j],t[y0]=max,t[y1]=max+=Math.abs(field(t))}function stackNormalize(group,max,field,y0,y1){max=1/group.sum;for(var last=0,m=group.length,j=0,v=0,t;j<m;++j)t=\ngroup[j],t[y0]=last,t[y1]=last=max*(v+=Math.abs(field(t)))}function stackZero(group,max,field,y0,y1){for(var lastNeg=max=0,m=group.length,j=0,v,t;j<m;++j)t=group[j],v=+field(t),0>v?(t[y0]=lastNeg,t[y1]=lastNeg+=v):(t[y0]=max,t[y1]=max+=v)}function partition(data,groupby,sort,field){var groups=[],get=function(f){return f(t)},n;if(null==groupby)groups.push(data.slice());else{var map={};var i=0;for(n=data.length;i<n;++i){var t=data[i];var k=groupby.map(get);var g=map[k];g||(map[k]=g=[],groups.push(g));\ng.push(t)}}get=k=0;for(data=groups.length;k<data;++k){g=groups[k];groupby=i=0;for(n=g.length;i<n;++i)groupby+=Math.abs(field(g[i]));g.sum=groupby;groupby>get&&(get=groupby);sort&&g.sort(sort)}groups.max=get;return groups}vegaUtil.inherits(AxisTicks,vegaDataflow.Transform,{transform:function(_,pulse){if(this.value&&!_.modified())return pulse.StopPropagation;var locale=pulse.dataflow.locale();pulse=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);var ticks=this.value,scale=_.scale,count=vegaScale.tickCount(scale,\nnull==_.count?_.values?_.values.length:10:_.count,_.minstep),format=_.format||vegaScale.tickFormat(locale,scale,count,_.formatSpecifier,_.formatType,!!_.values),values=_.values?vegaScale.validTicks(scale,_.values,count):vegaScale.tickValues(scale,count);ticks&&(pulse.rem=ticks);ticks=values.map(function(value,i){return vegaDataflow.ingest({index:i/(values.length-1||1),value:value,label:format(value)})});_.extra&&ticks.length&&ticks.push(vegaDataflow.ingest({index:-1,extra:{value:ticks[0].value},label:\"\"}));\npulse.source=ticks;this.value=pulse.add=ticks;return pulse}});vegaUtil.inherits(DataJoin,vegaDataflow.Transform,{transform:function(_,pulse){var df=pulse.dataflow,out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),item=_.item||defaultItemCreate,key=_.key||vegaDataflow.tupleid,map=this.value;vegaUtil.isArray(out.encode)&&(out.encode=null);map&&(_.modified(\"key\")||pulse.modified(key))&&vegaUtil.error(\"DataJoin does not support modified key function or fields.\");map||(pulse=pulse.addAll(),this.value=map=\nnewMap(key));pulse.visit(pulse.ADD,function(t){var k=key(t),x=map.get(k);x?x.exit?(map.empty--,out.add.push(x)):out.mod.push(x):(x=item(t),map.set(k,x),out.add.push(x));x.datum=t;x.exit=!1});pulse.visit(pulse.MOD,function(t){var k=key(t);if(k=map.get(k))k.datum=t,out.mod.push(k)});pulse.visit(pulse.REM,function(t){var k=key(t);k=map.get(k);t!==k.datum||k.exit||(out.rem.push(k),k.exit=!0,++map.empty)});pulse.changed(pulse.ADD_MOD)&&out.modifies(\"datum\");(pulse.clean()||_.clean&&map.empty>df.cleanThreshold)&&\ndf.runAfter(map.clean);return out}});vegaUtil.inherits(Encode,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.ADD_REM),fmod=_.mod||!1,encoders=_.encoders,encode=pulse.encode;if(vegaUtil.isArray(encode))if(out.changed()||encode.every(function(e){return encoders[e]}))encode=encode[0],out.encode=null;else return pulse.StopPropagation;var reenter=\"enter\"===encode,update=encoders.update||vegaUtil.falsy,enter=encoders.enter||vegaUtil.falsy,exit=encoders.exit||vegaUtil.falsy,\nset=(encode&&!reenter?encoders[encode]:update)||vegaUtil.falsy;pulse.changed(pulse.ADD)&&(pulse.visit(pulse.ADD,function(t){enter(t,_);update(t,_)}),out.modifies(enter.output),out.modifies(update.output),set!==vegaUtil.falsy&&set!==update&&(pulse.visit(pulse.ADD,function(t){set(t,_)}),out.modifies(set.output)));pulse.changed(pulse.REM)&&exit!==vegaUtil.falsy&&(pulse.visit(pulse.REM,function(t){exit(t,_)}),out.modifies(exit.output));if(reenter||set!==vegaUtil.falsy)encode=pulse.MOD|(_.modified()?pulse.REFLOW:\n0),reenter?(pulse.visit(encode,function(t){var mod=enter(t,_)||fmod;(set(t,_)||mod)&&out.mod.push(t)}),out.mod.length&&out.modifies(enter.output)):pulse.visit(encode,function(t){(set(t,_)||fmod)&&out.mod.push(t)}),out.mod.length&&out.modifies(set.output);return out.changed()?out:pulse.StopPropagation}});vegaUtil.inherits(LegendEntries,vegaDataflow.Transform,{transform:function(_,pulse){if(null!=this.value&&!_.modified())return pulse.StopPropagation;var locale=pulse.dataflow.locale(),out=pulse.fork(pulse.NO_SOURCE|\npulse.NO_FIELDS),items=this.value,type=_.type||vegaScale.SymbolLegend,scale=_.scale,limit=+_.limit,count=vegaScale.tickCount(scale,null==_.count?5:_.count,_.minstep),lskip=!!_.values||type===vegaScale.SymbolLegend,format=_.format||vegaScale.labelFormat(locale,scale,count,type,_.formatSpecifier,_.formatType,lskip),values=_.values||vegaScale.labelValues(scale,count),size;items&&(out.rem=items);if(type===vegaScale.SymbolLegend){if(limit&&values.length>limit){pulse.dataflow.warn(\"Symbol legend count exceeds limit, filtering items.\");\nitems=values.slice(0,limit-1);var ellipsis=!0}else items=values;if(vegaUtil.isFunction(size=_.size)){_.values||0!==scale(items[0])||(items=items.slice(1));var offset=items.reduce(function(max,value){return Math.max(max,size(value,_))},0)}else size=vegaUtil.constant(offset=size||8);items=items.map(function(value,index){return vegaDataflow.ingest({index:index,label:format(value,index,items),value:value,offset:offset,size:size(value,_)})});ellipsis&&(ellipsis=values[items.length],items.push(vegaDataflow.ingest({index:items.length,\nlabel:\"â€¦\"+(values.length-items.length)+\" entries\",value:ellipsis,offset:offset,size:size(ellipsis,_)})))}else if(type===vegaScale.GradientLegend){pulse=scale.domain();var fraction=vegaScale.scaleFraction(scale,pulse[0],vegaUtil.peek(pulse));3>values.length&&!_.values&&pulse[0]!==vegaUtil.peek(pulse)&&(values=[pulse[0],vegaUtil.peek(pulse)]);items=values.map(function(value,index){return vegaDataflow.ingest({index:index,label:format(value,index,values),value:value,perc:fraction(value)})})}else size=\nvalues.length-1,fraction=vegaScale.labelFraction(scale),items=values.map(function(value,index){return vegaDataflow.ingest({index:index,label:format(value,index,values),value:value,perc:index?fraction(value):0,perc2:index===size?1:fraction(values[index+1])})});out.source=items;this.value=out.add=items;return out}});var sourceX=function(t){return t.source.x},sourceY=function(t){return t.source.y},targetX=function(t){return t.target.x},targetY=function(t){return t.target.y};LinkPath.Definition={type:\"LinkPath\",\nmetadata:{modifies:!0},params:[{name:\"sourceX\",type:\"field\",\"default\":\"source.x\"},{name:\"sourceY\",type:\"field\",\"default\":\"source.y\"},{name:\"targetX\",type:\"field\",\"default\":\"target.x\"},{name:\"targetY\",type:\"field\",\"default\":\"target.y\"},{name:\"orient\",type:\"enum\",\"default\":\"vertical\",values:[\"horizontal\",\"vertical\",\"radial\"]},{name:\"shape\",type:\"enum\",\"default\":\"line\",values:[\"line\",\"arc\",\"curve\",\"diagonal\",\"orthogonal\"]},{name:\"require\",type:\"signal\"},{name:\"as\",type:\"string\",\"default\":\"path\"}]};vegaUtil.inherits(LinkPath,\nvegaDataflow.Transform,{transform:function(_,pulse){var sx=_.sourceX||sourceX,sy=_.sourceY||sourceY,tx=_.targetX||targetX,ty=_.targetY||targetY,as=_.as||\"path\",shape=_.shape||\"line\",path=Paths.get(shape+\"-\"+(_.orient||\"vertical\"))||Paths.get(shape);path||vegaUtil.error(\"LinkPath unsupported type: \"+_.shape+(_.orient?\"-\"+_.orient:\"\"));pulse.visit(pulse.SOURCE,function(t){t[as]=path(sx(t),sy(t),tx(t),ty(t))});return pulse.reflow(_.modified()).modifies(as)}});var line=function(sx,sy,tx,ty){return\"M\"+\nsx+\",\"+sy+\"L\"+tx+\",\"+ty},arc=function(sx,sy,tx,ty){var dx=tx-sx,dy=ty-sy,rr=Math.sqrt(dx*dx+dy*dy)/2;return\"M\"+sx+\",\"+sy+\"A\"+rr+\",\"+rr+\" \"+180*Math.atan2(dy,dx)/Math.PI+\" 0 1 \"+tx+\",\"+ty},curve=function(sx,sy,tx,ty){var dx=tx-sx,dy=ty-sy,ix=.2*(dx+dy);dx=.2*(dy-dx);return\"M\"+sx+\",\"+sy+\"C\"+(sx+ix)+\",\"+(sy+dx)+\" \"+(tx+dx)+\",\"+(ty-ix)+\" \"+tx+\",\"+ty},Paths=vegaUtil.fastmap({line:line,\"line-radial\":function(sa,sr,ta,tr){return line(sr*Math.cos(sa),sr*Math.sin(sa),tr*Math.cos(ta),tr*Math.sin(ta))},arc:arc,\n\"arc-radial\":function(sa,sr,ta,tr){return arc(sr*Math.cos(sa),sr*Math.sin(sa),tr*Math.cos(ta),tr*Math.sin(ta))},curve:curve,\"curve-radial\":function(sa,sr,ta,tr){return curve(sr*Math.cos(sa),sr*Math.sin(sa),tr*Math.cos(ta),tr*Math.sin(ta))},\"orthogonal-horizontal\":function(sx,sy,tx,ty){return\"M\"+sx+\",\"+sy+\"V\"+ty+\"H\"+tx},\"orthogonal-vertical\":function(sx,sy,tx,ty){return\"M\"+sx+\",\"+sy+\"H\"+tx+\"V\"+ty},\"orthogonal-radial\":function(sa,sr,ta,tr){var tc=Math.cos(ta),ts=Math.sin(ta);return\"M\"+sr*Math.cos(sa)+\n\",\"+sr*Math.sin(sa)+\"A\"+sr+\",\"+sr+\" 0 0,\"+((Math.abs(ta-sa)>Math.PI?ta<=sa:ta>sa)?1:0)+\" \"+sr*tc+\",\"+sr*ts+\"L\"+tr*tc+\",\"+tr*ts},\"diagonal-horizontal\":function(sx,sy,tx,ty){var m=(sx+tx)/2;return\"M\"+sx+\",\"+sy+\"C\"+m+\",\"+sy+\" \"+m+\",\"+ty+\" \"+tx+\",\"+ty},\"diagonal-vertical\":function(sx,sy,tx,ty){var m=(sy+ty)/2;return\"M\"+sx+\",\"+sy+\"C\"+sx+\",\"+m+\" \"+tx+\",\"+m+\" \"+tx+\",\"+ty},\"diagonal-radial\":function(sa,sr,ta,tr){var sc=Math.cos(sa);sa=Math.sin(sa);var tc=Math.cos(ta);ta=Math.sin(ta);var mr=(sr+tr)/2;return\"M\"+\nsr*sc+\",\"+sr*sa+\"C\"+mr*sc+\",\"+mr*sa+\" \"+mr*tc+\",\"+mr*ta+\" \"+tr*tc+\",\"+tr*ta}});Pie.Definition={type:\"Pie\",metadata:{modifies:!0},params:[{name:\"field\",type:\"field\"},{name:\"startAngle\",type:\"number\",\"default\":0},{name:\"endAngle\",type:\"number\",\"default\":6.283185307179586},{name:\"sort\",type:\"boolean\",\"default\":!1},{name:\"as\",type:\"string\",array:!0,length:2,\"default\":[\"startAngle\",\"endAngle\"]}]};vegaUtil.inherits(Pie,vegaDataflow.Transform,{transform:function(_,pulse){var as=_.as||[\"startAngle\",\"endAngle\"],\nstartAngle=as[0],endAngle=as[1],start=_.startAngle||0,stop=null!=_.endAngle?_.endAngle:2*Math.PI,data=pulse.source,values=data.map(_.field||vegaUtil.one),n=values.length,a$jscomp$0=start;start=(stop-start)/d3Array.sum(values);stop=d3Array.range(n);var i;_.sort&&stop.sort(function(a,b){return values[a]-values[b]});for(i=0;i<n;++i){var v=values[stop[i]];var t=data[stop[i]];t[startAngle]=a$jscomp$0;t[endAngle]=a$jscomp$0+=v*start}this.value=values;return pulse.reflow(_.modified()).modifies(as)}});var SKIP=\nvegaUtil.toSet(\"set modified clear type scheme schemeExtent schemeCount domain domainMin domainMid domainMax domainRaw domainImplicit nice zero bins range rangeStep round reverse interpolate interpolateGamma\".split(\" \"));vegaUtil.inherits(Scale,vegaDataflow.Transform,{transform:function(_,pulse){var df=pulse.dataflow,scale=this.value;var key=_.type;var d=\"\";if(key===vegaScale.Sequential)key=vegaScale.Sequential+\"-\"+vegaScale.Linear;else{var t=_.type;vegaScale.isContinuous(t)&&t!==vegaScale.Time&&\nt!==vegaScale.UTC&&(_.scheme||_.range&&_.range.length&&_.range.every(vegaUtil.isString))&&(d=_.rawDomain?_.rawDomain.length:_.domain?_.domain.length+ +(null!=_.domainMid):0,d=2===d?vegaScale.Sequential+\"-\":3===d?vegaScale.Diverging+\"-\":\"\");key=(d+key||vegaScale.Linear).toLowerCase()}scale&&key===scale.type||(this.value=scale=vegaScale.scale(key)());for(key in _)SKIP[key]||\"padding\"===key&&includePad(scale.type)||(vegaUtil.isFunction(scale[key])?scale[key](_[key]):df.warn(\"Unsupported scale property: \"+\nkey));d=key=scale;(t=_.domainRaw)?(scale.domain(domainCheck(scale.type,t,df)),t=t.length):t=-1;if(-1<t)df=t;else{var domain=_.domain;t=scale.type;var JSCompiler_temp;!(JSCompiler_temp=_.zero)&&(JSCompiler_temp=void 0===_.zero)&&(JSCompiler_temp=scale.type,JSCompiler_temp=!scale.bins&&(JSCompiler_temp===vegaScale.Linear||JSCompiler_temp===vegaScale.Pow||JSCompiler_temp===vegaScale.Sqrt));if(domain){if(includePad(t)&&_.padding&&domain[0]!==vegaUtil.peek(domain)){var range=_.range,pad=_.padding;var n=\n_.exponent;var constant=_.constant;range=Math.abs(vegaUtil.peek(range)-range[0]);pad=range/(range-2*pad);n=t===vegaScale.Log?vegaUtil.zoomLog(domain,null,pad):t===vegaScale.Sqrt?vegaUtil.zoomPow(domain,null,pad,.5):t===vegaScale.Pow?vegaUtil.zoomPow(domain,null,pad,n||1):t===vegaScale.Symlog?vegaUtil.zoomSymlog(domain,null,pad,constant||1):vegaUtil.zoomLinear(domain,null,pad);domain=domain.slice();domain[0]=n[0];domain[domain.length-1]=n[1]}if(JSCompiler_temp||null!=_.domainMin||null!=_.domainMax||\nnull!=_.domainMid)n=(domain=domain.slice()).length-1||1,JSCompiler_temp&&(0<domain[0]&&(domain[0]=0),0>domain[n]&&(domain[n]=0)),null!=_.domainMin&&(domain[0]=_.domainMin),null!=_.domainMax&&(domain[n]=_.domainMax),null!=_.domainMid&&(JSCompiler_temp=_.domainMid,constant=JSCompiler_temp>domain[n]?n+1:JSCompiler_temp<domain[0]?0:n,constant!==n&&df.warn(\"Scale domainMid exceeds domain min or max.\",JSCompiler_temp),domain.splice(constant,0,JSCompiler_temp));scale.domain(domainCheck(t,domain,df));t===\nvegaScale.Ordinal&&scale.unknown(_.domainImplicit?vegaScale.scaleImplicit:void 0);_.nice&&scale.nice&&scale.nice(!0!==_.nice&&vegaScale.tickCount(scale,_.nice)||null);df=domain.length}else df=0}(t=_.bins)&&!vegaUtil.isArray(t)&&(JSCompiler_temp=d.domain(),scale=JSCompiler_temp[0],JSCompiler_temp=vegaUtil.peek(JSCompiler_temp),domain=t.step,n=null==t.start?scale:t.start,t=null==t.stop?JSCompiler_temp:t.stop,domain||vegaUtil.error(\"Scale bins parameter missing step property.\"),n<scale&&(n=domain*Math.ceil(scale/\ndomain)),t>JSCompiler_temp&&(t=domain*Math.floor(JSCompiler_temp/domain)),t=d3Array.range(n,t+domain/2,domain));t?d.bins=t:d.bins&&delete d.bins;d.type===vegaScale.BinOrdinal&&(t?_.domain||_.domainRaw||(d.domain(t),df=t.length):d.bins=d.domain());scale=df;a:{d=key.type;df=_.round||!1;t=_.range;if(null!=_.rangeStep)d!==vegaScale.Band&&d!==vegaScale.Point&&vegaUtil.error(\"Only band and point scales support rangeStep.\"),t=[0,_.rangeStep*vegaScale.bandSpace(scale,d===vegaScale.Point?1:(null!=_.paddingInner?\n_.paddingInner:_.padding)||0,(null!=_.paddingOuter?_.paddingOuter:_.padding)||0)];else if(_.scheme&&(t=_.schemeExtent,vegaUtil.isArray(_.scheme)?JSCompiler_temp=vegaScale.interpolateColors(_.scheme,_.interpolate,_.interpolateGamma):(JSCompiler_temp=_.scheme.toLowerCase(),(JSCompiler_temp=vegaScale.scheme(JSCompiler_temp))||vegaUtil.error(\"Unrecognized scheme name: \"+_.scheme)),scale=d===vegaScale.Threshold?scale+1:d===vegaScale.BinOrdinal?scale-1:d===vegaScale.Quantile||d===vegaScale.Quantize?+_.schemeCount||\n5:scale,t=vegaScale.isInterpolating(d)?adjustScheme(JSCompiler_temp,t,_.reverse):vegaUtil.isFunction(JSCompiler_temp)?vegaScale.quantizeInterpolator(adjustScheme(JSCompiler_temp,t),scale):d===vegaScale.Ordinal?JSCompiler_temp:JSCompiler_temp.slice(0,scale),vegaUtil.isFunction(t)))if(key.interpolator){key.interpolator(t);break a}else vegaUtil.error(\"Scale type \"+d+\" does not support interpolating color schemes.\");t&&vegaScale.isInterpolating(d)?key.interpolator(vegaScale.interpolateColors(flip(t,_.reverse),\n_.interpolate,_.interpolateGamma)):(t&&_.interpolate&&key.interpolate?key.interpolate(vegaScale.interpolate(_.interpolate,_.interpolateGamma)):vegaUtil.isFunction(key.round)?key.round(df):vegaUtil.isFunction(key.rangeRound)&&key.interpolate(df?d3Interpolate.interpolateRound:d3Interpolate.interpolate),t&&key.range(flip(t,_.reverse)))}return pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS)}});vegaUtil.inherits(SortItems,vegaDataflow.Transform,{transform:function(_,pulse){var mod=_.modified(\"sort\")||pulse.changed(pulse.ADD)||\npulse.modified(_.sort.fields)||pulse.modified(\"datum\");mod&&pulse.source.sort(vegaDataflow.stableCompare(_.sort));this.modified(mod);return pulse}});var DefOutput=[\"y0\",\"y1\"];Stack.Definition={type:\"Stack\",metadata:{modifies:!0},params:[{name:\"field\",type:\"field\"},{name:\"groupby\",type:\"field\",array:!0},{name:\"sort\",type:\"compare\"},{name:\"offset\",type:\"enum\",\"default\":\"zero\",values:[\"zero\",\"center\",\"normalize\"]},{name:\"as\",type:\"string\",array:!0,length:2,\"default\":DefOutput}]};vegaUtil.inherits(Stack,\nvegaDataflow.Transform,{transform:function(_,pulse){var as=_.as||DefOutput,y0=as[0],y1=as[1],sort=vegaDataflow.stableCompare(_.sort),field=_.field||vegaUtil.one,stack=\"center\"===_.offset?stackCenter:\"normalize\"===_.offset?stackNormalize:stackZero,max;sort=partition(pulse.source,_.groupby,sort,field);var i=0;var n=sort.length;for(max=sort.max;i<n;++i)stack(sort[i],max,field,y0,y1);return pulse.reflow(_.modified()).modifies(as)}});exports.axisticks=AxisTicks;exports.datajoin=DataJoin;exports.encode=\nEncode;exports.legendentries=LegendEntries;exports.linkpath=LinkPath;exports.pie=Pie;exports.scale=Scale;exports.sortitems=SortItems;exports.stack=Stack;Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_encode$build$vega_encode\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-dataflow'), require('vega-scale'), require('vega-util'), require('d3-array'), require('d3-interpolate')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-dataflow', 'vega-scale', 'vega-util', 'd3-array', 'd3-interpolate'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.vega, global.d3, global.d3));\n}(this, (function (exports, vegaDataflow, vegaScale, vegaUtil, d3Array, d3Interpolate) { 'use strict';\n\n  /**\n   * Generates axis ticks for visualizing a spatial scale.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Scale} params.scale - The scale to generate ticks for.\n   * @param {*} [params.count=10] - The approximate number of ticks, or\n   *   desired tick interval, to use.\n   * @param {Array<*>} [params.values] - The exact tick values to use.\n   *   These must be legal domain values for the provided scale.\n   *   If provided, the count argument is ignored.\n   * @param {function(*):string} [params.formatSpecifier] - A format specifier\n   *   to use in conjunction with scale.tickFormat. Legal values are\n   *   any valid d3 4.0 format specifier.\n   * @param {function(*):string} [params.format] - The format function to use.\n   *   If provided, the formatSpecifier argument is ignored.\n   */\n  function AxisTicks(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  vegaUtil.inherits(AxisTicks, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      if (this.value && !_.modified()) {\n        return pulse.StopPropagation;\n      }\n\n      var locale = pulse.dataflow.locale(),\n          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n          ticks = this.value,\n          scale = _.scale,\n          tally = _.count == null ? (_.values ? _.values.length : 10) : _.count,\n          count = vegaScale.tickCount(scale, tally, _.minstep),\n          format = _.format || vegaScale.tickFormat(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),\n          values = _.values ? vegaScale.validTicks(scale, _.values, count) : vegaScale.tickValues(scale, count);\n\n      if (ticks) out.rem = ticks;\n\n      ticks = values.map((value, i) =>\n        vegaDataflow.ingest({\n          index: i / (values.length - 1 || 1),\n          value: value,\n          label: format(value)\n        })\n      );\n\n      if (_.extra && ticks.length) {\n        // add an extra tick pegged to the initial domain value\n        // this is used to generate axes with 'binned' domains\n        ticks.push(vegaDataflow.ingest({\n          index: -1,\n          extra: {value: ticks[0].value},\n          label: ''\n        }));\n      }\n\n      out.source = ticks;\n      out.add = ticks;\n      this.value = ticks;\n\n      return out;\n    }\n  });\n\n  /**\n   * Joins a set of data elements against a set of visual items.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): object} [params.item] - An item generator function.\n   * @param {function(object): *} [params.key] - The key field associating data and visual items.\n   */\n  function DataJoin(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  function defaultItemCreate() {\n    return vegaDataflow.ingest({});\n  }\n\n  function newMap(key) {\n    const map = vegaUtil.fastmap().test(t => t.exit);\n    map.lookup = t => map.get(key(t));\n    return map;\n  }\n\n  vegaUtil.inherits(DataJoin, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      var df = pulse.dataflow,\n          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n          item = _.item || defaultItemCreate,\n          key = _.key || vegaDataflow.tupleid,\n          map = this.value;\n\n      // prevent transient (e.g., hover) requests from\n      // cascading across marks derived from marks\n      if (vegaUtil.isArray(out.encode)) {\n        out.encode = null;\n      }\n\n      if (map && (_.modified('key') || pulse.modified(key))) {\n        vegaUtil.error('DataJoin does not support modified key function or fields.');\n      }\n\n      if (!map) {\n        pulse = pulse.addAll();\n        this.value = map = newMap(key);\n      }\n\n      pulse.visit(pulse.ADD, t => {\n        const k = key(t);\n        let x = map.get(k);\n\n        if (x) {\n          if (x.exit) {\n            map.empty--;\n            out.add.push(x);\n          } else {\n            out.mod.push(x);\n          }\n        } else {\n          x = item(t);\n          map.set(k, x);\n          out.add.push(x);\n        }\n\n        x.datum = t;\n        x.exit = false;\n      });\n\n      pulse.visit(pulse.MOD, t => {\n        const k = key(t),\n              x = map.get(k);\n\n        if (x) {\n          x.datum = t;\n          out.mod.push(x);\n        }\n      });\n\n      pulse.visit(pulse.REM, t => {\n        const k = key(t),\n              x = map.get(k);\n\n        if (t === x.datum && !x.exit) {\n          out.rem.push(x);\n          x.exit = true;\n          ++map.empty;\n        }\n      });\n\n      if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');\n\n      if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {\n        df.runAfter(map.clean);\n      }\n\n      return out;\n    }\n  });\n\n  /**\n   * Invokes encoding functions for visual items.\n   * @constructor\n   * @param {object} params - The parameters to the encoding functions. This\n   *   parameter object will be passed through to all invoked encoding functions.\n   * @param {object} [params.mod=false] - Flag indicating if tuples in the input\n   *   mod set that are unmodified by encoders should be included in the output.\n   * @param {object} param.encoders - The encoding functions\n   * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set\n   * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set\n   * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set\n   */\n  function Encode(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  vegaUtil.inherits(Encode, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      var out = pulse.fork(pulse.ADD_REM),\n          fmod = _.mod || false,\n          encoders = _.encoders,\n          encode = pulse.encode;\n\n      // if an array, the encode directive includes additional sets\n      // that must be defined in order for the primary set to be invoked\n      // e.g., only run the update set if the hover set is defined\n      if (vegaUtil.isArray(encode)) {\n        if (out.changed() || encode.every(e => encoders[e])) {\n          encode = encode[0];\n          out.encode = null; // consume targeted encode directive\n        } else {\n          return pulse.StopPropagation;\n        }\n      }\n\n      // marshall encoder functions\n      var reenter = encode === 'enter',\n          update = encoders.update || vegaUtil.falsy,\n          enter = encoders.enter || vegaUtil.falsy,\n          exit = encoders.exit || vegaUtil.falsy,\n          set = (encode && !reenter ? encoders[encode] : update) || vegaUtil.falsy;\n\n      if (pulse.changed(pulse.ADD)) {\n        pulse.visit(pulse.ADD, t => { enter(t, _); update(t, _); });\n        out.modifies(enter.output);\n        out.modifies(update.output);\n        if (set !== vegaUtil.falsy && set !== update) {\n          pulse.visit(pulse.ADD, t => { set(t, _); });\n          out.modifies(set.output);\n        }\n      }\n\n      if (pulse.changed(pulse.REM) && exit !== vegaUtil.falsy) {\n        pulse.visit(pulse.REM, t => { exit(t, _); });\n        out.modifies(exit.output);\n      }\n\n      if (reenter || set !== vegaUtil.falsy) {\n        var flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);\n        if (reenter) {\n          pulse.visit(flag, t => {\n            var mod = enter(t, _) || fmod;\n            if (set(t, _) || mod) out.mod.push(t);\n          });\n          if (out.mod.length) out.modifies(enter.output);\n        } else {\n          pulse.visit(flag, t => {\n            if (set(t, _) || fmod) out.mod.push(t);\n          });\n        }\n        if (out.mod.length) out.modifies(set.output);\n      }\n\n      return out.changed() ? out : pulse.StopPropagation;\n    }\n  });\n\n  /**\n   * Generates legend entries for visualizing a scale.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Scale} params.scale - The scale to generate items for.\n   * @param {*} [params.count=5] - The approximate number of items, or\n   *   desired tick interval, to use.\n   * @param {*} [params.limit] - The maximum number of entries to\n   *   include in a symbol legend.\n   * @param {Array<*>} [params.values] - The exact tick values to use.\n   *   These must be legal domain values for the provided scale.\n   *   If provided, the count argument is ignored.\n   * @param {string} [params.formatSpecifier] - A format specifier\n   *   to use in conjunction with scale.tickFormat. Legal values are\n   *   any valid D3 format specifier string.\n   * @param {function(*):string} [params.format] - The format function to use.\n   *   If provided, the formatSpecifier argument is ignored.\n   */\n  function LegendEntries(params) {\n    vegaDataflow.Transform.call(this, [], params);\n  }\n\n  vegaUtil.inherits(LegendEntries, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      if (this.value != null && !_.modified()) {\n        return pulse.StopPropagation;\n      }\n\n      var locale = pulse.dataflow.locale(),\n          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n          items = this.value,\n          type  = _.type || vegaScale.SymbolLegend,\n          scale = _.scale,\n          limit = +_.limit,\n          count = vegaScale.tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\n          lskip = !!_.values || type === vegaScale.SymbolLegend,\n          format = _.format || vegaScale.labelFormat(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),\n          values = _.values || vegaScale.labelValues(scale, count),\n          domain, fraction, size, offset, ellipsis;\n\n      if (items) out.rem = items;\n\n      if (type === vegaScale.SymbolLegend) {\n        if (limit && values.length > limit) {\n          pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\n          items = values.slice(0, limit - 1);\n          ellipsis = true;\n        } else {\n          items = values;\n        }\n\n        if (vegaUtil.isFunction(size = _.size)) {\n          // if first value maps to size zero, remove from list (vega#717)\n          if (!_.values && scale(items[0]) === 0) {\n            items = items.slice(1);\n          }\n          // compute size offset for legend entries\n          offset = items.reduce((max, value) => Math.max(max, size(value, _)), 0);\n        } else {\n          size = vegaUtil.constant(offset = size || 8);\n        }\n\n        items = items.map((value, index) =>\n          vegaDataflow.ingest({\n            index:  index,\n            label:  format(value, index, items),\n            value:  value,\n            offset: offset,\n            size:   size(value, _)\n          })\n        );\n\n        if (ellipsis) {\n          ellipsis = values[items.length];\n          items.push(vegaDataflow.ingest({\n            index:    items.length,\n            label:    `\\u2026${values.length-items.length} entries`,\n            value:    ellipsis,\n            offset:   offset,\n            size:     size(ellipsis, _)\n          }));\n        }\n      }\n\n      else if (type === vegaScale.GradientLegend) {\n        domain = scale.domain(),\n        fraction = vegaScale.scaleFraction(scale, domain[0], vegaUtil.peek(domain));\n\n        // if automatic label generation produces 2 or fewer values,\n        // use the domain end points instead (fixes vega/vega#1364)\n        if (values.length < 3 && !_.values && domain[0] !== vegaUtil.peek(domain)) {\n          values = [domain[0], vegaUtil.peek(domain)];\n        }\n\n        items = values.map((value, index) =>\n          vegaDataflow.ingest({\n            index: index,\n            label: format(value, index, values),\n            value: value,\n            perc:  fraction(value)\n          })\n        );\n      }\n\n      else {\n        size = values.length - 1;\n        fraction = vegaScale.labelFraction(scale);\n\n        items = values.map((value, index) =>\n          vegaDataflow.ingest({\n            index: index,\n            label: format(value, index, values),\n            value: value,\n            perc:  index ? fraction(value) : 0,\n            perc2: index === size ? 1 : fraction(values[index+1])\n          })\n        );\n      }\n\n      out.source = items;\n      out.add = items;\n      this.value = items;\n\n      return out;\n    }\n  });\n\n  const sourceX = t => t.source.x;\n  const sourceY = t => t.source.y;\n  const targetX = t => t.target.x;\n  const targetY = t => t.target.y;\n\n   /**\n    * Layout paths linking source and target elements.\n    * @constructor\n    * @param {object} params - The parameters for this operator.\n    */\n  function LinkPath(params) {\n    vegaDataflow.Transform.call(this, {}, params);\n  }\n\n  LinkPath.Definition = {\n    'type': 'LinkPath',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'sourceX', 'type': 'field', 'default': 'source.x' },\n      { 'name': 'sourceY', 'type': 'field', 'default': 'source.y' },\n      { 'name': 'targetX', 'type': 'field', 'default': 'target.x' },\n      { 'name': 'targetY', 'type': 'field', 'default': 'target.y' },\n      { 'name': 'orient', 'type': 'enum', 'default': 'vertical',\n        'values': ['horizontal', 'vertical', 'radial'] },\n      { 'name': 'shape', 'type': 'enum', 'default': 'line',\n        'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal'] },\n      { 'name': 'require', 'type': 'signal' },\n      { 'name': 'as', 'type': 'string', 'default': 'path' }\n    ]\n  };\n\n  vegaUtil.inherits(LinkPath, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      var sx = _.sourceX || sourceX,\n          sy = _.sourceY || sourceY,\n          tx = _.targetX || targetX,\n          ty = _.targetY || targetY,\n          as = _.as || 'path',\n          orient = _.orient || 'vertical',\n          shape = _.shape || 'line',\n          path = Paths.get(shape + '-' + orient) || Paths.get(shape);\n\n      if (!path) {\n        vegaUtil.error('LinkPath unsupported type: ' + _.shape\n          + (_.orient ? '-' + _.orient : ''));\n      }\n\n      pulse.visit(pulse.SOURCE, t => {\n        t[as] = path(sx(t), sy(t), tx(t), ty(t));\n      });\n\n      return pulse.reflow(_.modified()).modifies(as);\n    }\n  });\n\n  const line = (sx, sy, tx, ty) =>\n    'M' + sx + ',' + sy +\n    'L' + tx + ',' + ty;\n\n  const lineR= (sa, sr, ta, tr) => line(\n    sr * Math.cos(sa), sr * Math.sin(sa),\n    tr * Math.cos(ta), tr * Math.sin(ta)\n  );\n\n  const arc = (sx, sy, tx, ty) => {\n    var dx = tx - sx,\n        dy = ty - sy,\n        rr = Math.sqrt(dx * dx + dy * dy) / 2,\n        ra = 180 * Math.atan2(dy, dx) / Math.PI;\n    return 'M' + sx + ',' + sy +\n           'A' + rr + ',' + rr +\n           ' ' + ra + ' 0 1' +\n           ' ' + tx + ',' + ty;\n  };\n\n  const arcR = (sa, sr, ta, tr) => arc(\n    sr * Math.cos(sa), sr * Math.sin(sa),\n    tr * Math.cos(ta), tr * Math.sin(ta)\n  );\n\n  const curve = (sx, sy, tx, ty) => {\n    const dx = tx - sx,\n          dy = ty - sy,\n          ix = 0.2 * (dx + dy),\n          iy = 0.2 * (dy - dx);\n    return 'M' + sx + ',' + sy +\n           'C' + (sx+ix) + ',' + (sy+iy) +\n           ' ' + (tx+iy) + ',' + (ty-ix) +\n           ' ' + tx + ',' + ty;\n  };\n\n  const curveR = (sa, sr, ta, tr) => curve(\n    sr * Math.cos(sa), sr * Math.sin(sa),\n    tr * Math.cos(ta), tr * Math.sin(ta)\n  );\n\n  const orthoX = (sx, sy, tx, ty) =>\n    'M' + sx + ',' + sy +\n    'V' + ty + 'H' + tx;\n\n  const orthoY = (sx, sy, tx, ty) =>\n    'M' + sx + ',' + sy +\n    'H' + tx + 'V' + ty;\n\n  const orthoR = (sa, sr, ta, tr) => {\n    const sc = Math.cos(sa),\n          ss = Math.sin(sa),\n          tc = Math.cos(ta),\n          ts = Math.sin(ta),\n          sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n    return 'M' + (sr*sc) + ',' + (sr*ss) +\n           'A' + sr + ',' + sr + ' 0 0,' + (sf?1:0) +\n           ' ' + (sr*tc) + ',' + (sr*ts) +\n           'L' + (tr*tc) + ',' + (tr*ts);\n  };\n\n  const diagonalX = (sx, sy, tx, ty) => {\n    const m = (sx + tx) / 2;\n    return 'M' + sx + ',' + sy +\n           'C' + m  + ',' + sy +\n           ' ' + m  + ',' + ty +\n           ' ' + tx + ',' + ty;\n  };\n\n  const diagonalY = (sx, sy, tx, ty) => {\n    const m = (sy + ty) / 2;\n    return 'M' + sx + ',' + sy +\n           'C' + sx + ',' + m +\n           ' ' + tx + ',' + m +\n           ' ' + tx + ',' + ty;\n  };\n\n  const diagonalR = (sa, sr, ta, tr) => {\n    const sc = Math.cos(sa),\n          ss = Math.sin(sa),\n          tc = Math.cos(ta),\n          ts = Math.sin(ta),\n          mr = (sr + tr) / 2;\n    return 'M' + (sr*sc) + ',' + (sr*ss) +\n           'C' + (mr*sc) + ',' + (mr*ss) +\n           ' ' + (mr*tc) + ',' + (mr*ts) +\n           ' ' + (tr*tc) + ',' + (tr*ts);\n  };\n\n  const Paths = vegaUtil.fastmap({\n    'line': line,\n    'line-radial': lineR,\n    'arc': arc,\n    'arc-radial': arcR,\n    'curve': curve,\n    'curve-radial': curveR,\n    'orthogonal-horizontal': orthoX,\n    'orthogonal-vertical': orthoY,\n    'orthogonal-radial': orthoR,\n    'diagonal-horizontal': diagonalX,\n    'diagonal-vertical': diagonalY,\n    'diagonal-radial': diagonalR\n  });\n\n  /**\n   * Pie and donut chart layout.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - The value field to size pie segments.\n   * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.\n   * @param {number} [params.endAngle=2Ï€] - The end angle (in radians) of the layout.\n   * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.\n   */\n  function Pie(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Pie.Definition = {\n    'type': 'Pie',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'field', 'type': 'field' },\n      { 'name': 'startAngle', 'type': 'number', 'default': 0 },\n      { 'name': 'endAngle', 'type': 'number', 'default': 6.283185307179586 },\n      { 'name': 'sort', 'type': 'boolean', 'default': false },\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['startAngle', 'endAngle'] }\n    ]\n  };\n\n  vegaUtil.inherits(Pie, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      var as = _.as || ['startAngle', 'endAngle'],\n          startAngle = as[0],\n          endAngle = as[1],\n          field = _.field || vegaUtil.one,\n          start = _.startAngle || 0,\n          stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,\n          data = pulse.source,\n          values = data.map(field),\n          n = values.length,\n          a = start,\n          k = (stop - start) / d3Array.sum(values),\n          index = d3Array.range(n),\n          i, t, v;\n\n      if (_.sort) {\n        index.sort((a, b) => values[a] - values[b]);\n      }\n\n      for (i=0; i<n; ++i) {\n        v = values[index[i]];\n        t = data[index[i]];\n        t[startAngle] = a;\n        t[endAngle] = (a += v * k);\n      }\n\n      this.value = values;\n      return pulse.reflow(_.modified()).modifies(as);\n    }\n  });\n\n  const DEFAULT_COUNT = 5;\n\n  function includeZero(scale) {\n    const type = scale.type;\n    return !scale.bins && (\n      type === vegaScale.Linear || type === vegaScale.Pow || type === vegaScale.Sqrt\n    );\n  }\n\n  function includePad(type) {\n    return vegaScale.isContinuous(type) && type !== vegaScale.Sequential;\n  }\n\n  const SKIP = vegaUtil.toSet([\n    'set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount',\n    'domain', 'domainMin', 'domainMid', 'domainMax',\n    'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins',\n    'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma'\n  ]);\n\n  /**\n   * Maintains a scale function mapping data values to visual channels.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   */\n  function Scale(params) {\n    vegaDataflow.Transform.call(this, null, params);\n    this.modified(true); // always treat as modified\n  }\n\n  vegaUtil.inherits(Scale, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      var df = pulse.dataflow,\n          scale = this.value,\n          key = scaleKey(_);\n\n      if (!scale || key !== scale.type) {\n        this.value = scale = vegaScale.scale(key)();\n      }\n\n      for (key in _) if (!SKIP[key]) {\n        // padding is a scale property for band/point but not others\n        if (key === 'padding' && includePad(scale.type)) continue;\n        // invoke scale property setter, raise warning if not found\n        vegaUtil.isFunction(scale[key])\n          ? scale[key](_[key])\n          : df.warn('Unsupported scale property: ' + key);\n      }\n\n      configureRange(scale, _,\n        configureBins(scale, _, configureDomain(scale, _, df))\n      );\n\n      return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n    }\n  });\n\n  function scaleKey(_) {\n    var t = _.type, d = '', n;\n\n    // backwards compatibility pre Vega 5.\n    if (t === vegaScale.Sequential) return vegaScale.Sequential + '-' + vegaScale.Linear;\n\n    if (isContinuousColor(_)) {\n      n = _.rawDomain ? _.rawDomain.length\n        : _.domain ? _.domain.length + +(_.domainMid != null)\n        : 0;\n      d = n === 2 ? vegaScale.Sequential + '-'\n        : n === 3 ? vegaScale.Diverging + '-'\n        : '';\n    }\n\n    return ((d + t) || vegaScale.Linear).toLowerCase();\n  }\n\n  function isContinuousColor(_) {\n    const t = _.type;\n    return vegaScale.isContinuous(t) && t !== vegaScale.Time && t !== vegaScale.UTC && (\n      _.scheme || _.range && _.range.length && _.range.every(vegaUtil.isString)\n    );\n  }\n\n  function configureDomain(scale, _, df) {\n    // check raw domain, if provided use that and exit early\n    var raw = rawDomain(scale, _.domainRaw, df);\n    if (raw > -1) return raw;\n\n    var domain = _.domain,\n        type = scale.type,\n        zero = _.zero || (_.zero === undefined && includeZero(scale)),\n        n, mid;\n\n    if (!domain) return 0;\n\n    // adjust continuous domain for minimum pixel padding\n    if (includePad(type) && _.padding && domain[0] !== vegaUtil.peek(domain)) {\n      domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);\n    }\n\n    // adjust domain based on zero, min, max settings\n    if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {\n      n = ((domain = domain.slice()).length - 1) || 1;\n      if (zero) {\n        if (domain[0] > 0) domain[0] = 0;\n        if (domain[n] < 0) domain[n] = 0;\n      }\n      if (_.domainMin != null) domain[0] = _.domainMin;\n      if (_.domainMax != null) domain[n] = _.domainMax;\n\n      if (_.domainMid != null) {\n        mid = _.domainMid;\n        const i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;\n        if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);\n        domain.splice(i, 0, mid);\n      }\n    }\n\n    // set the scale domain\n    scale.domain(domainCheck(type, domain, df));\n\n    // if ordinal scale domain is defined, prevent implicit\n    // domain construction as side-effect of scale lookup\n    if (type === vegaScale.Ordinal) {\n      scale.unknown(_.domainImplicit ? vegaScale.scaleImplicit : undefined);\n    }\n\n    // perform 'nice' adjustment as requested\n    if (_.nice && scale.nice) {\n      scale.nice((_.nice !== true && vegaScale.tickCount(scale, _.nice)) || null);\n    }\n\n    // return the cardinality of the domain\n    return domain.length;\n  }\n\n  function rawDomain(scale, raw, df) {\n    if (raw) {\n      scale.domain(domainCheck(scale.type, raw, df));\n      return raw.length;\n    } else {\n      return -1;\n    }\n  }\n\n  function padDomain(type, domain, range, pad, exponent, constant) {\n    var span = Math.abs(vegaUtil.peek(range) - range[0]),\n        frac = span / (span - 2 * pad),\n        d = type === vegaScale.Log    ? vegaUtil.zoomLog(domain, null, frac)\n          : type === vegaScale.Sqrt   ? vegaUtil.zoomPow(domain, null, frac, 0.5)\n          : type === vegaScale.Pow    ? vegaUtil.zoomPow(domain, null, frac, exponent || 1)\n          : type === vegaScale.Symlog ? vegaUtil.zoomSymlog(domain, null, frac, constant || 1)\n          : vegaUtil.zoomLinear(domain, null, frac);\n\n    domain = domain.slice();\n    domain[0] = d[0];\n    domain[domain.length-1] = d[1];\n    return domain;\n  }\n\n  function domainCheck(type, domain, df) {\n    if (vegaScale.isLogarithmic(type)) {\n      // sum signs of domain values\n      // if all pos or all neg, abs(sum) === domain.length\n      var s = Math.abs(domain.reduce((s, v) => s + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));\n\n      if (s !== domain.length) {\n        df.warn('Log scale domain includes zero: ' + vegaUtil.stringValue(domain));\n      }\n    }\n    return domain;\n  }\n\n  function configureBins(scale, _, count) {\n    let bins = _.bins;\n\n    if (bins && !vegaUtil.isArray(bins)) {\n      // generate bin boundary array\n      const domain = scale.domain(),\n            lo = domain[0],\n            hi = vegaUtil.peek(domain),\n            step = bins.step;\n\n      let start = bins.start == null ? lo : bins.start,\n          stop = bins.stop == null ? hi : bins.stop;\n\n      if (!step) vegaUtil.error('Scale bins parameter missing step property.');\n      if (start < lo) start = step * Math.ceil(lo / step);\n      if (stop > hi) stop = step * Math.floor(hi / step);\n      bins = d3Array.range(start, stop + step / 2, step);\n    }\n\n    if (bins) {\n      // assign bin boundaries to scale instance\n      scale.bins = bins;\n    } else if (scale.bins) {\n      // no current bins, remove bins if previously set\n      delete scale.bins;\n    }\n\n    // special handling for bin-ordinal scales\n    if (scale.type === vegaScale.BinOrdinal) {\n      if (!bins) {\n        // the domain specifies the bins\n        scale.bins = scale.domain();\n      } else if (!_.domain && !_.domainRaw) {\n        // the bins specify the domain\n        scale.domain(bins);\n        count = bins.length;\n      }\n    }\n\n    // return domain cardinality\n    return count;\n  }\n\n  function configureRange(scale, _, count) {\n    var type = scale.type,\n        round = _.round || false,\n        range = _.range;\n\n    // if range step specified, calculate full range extent\n    if (_.rangeStep != null) {\n      range = configureRangeStep(type, _, count);\n    }\n\n    // else if a range scheme is defined, use that\n    else if (_.scheme) {\n      range = configureScheme(type, _, count);\n      if (vegaUtil.isFunction(range)) {\n        if (scale.interpolator) {\n          return scale.interpolator(range);\n        } else {\n          vegaUtil.error(`Scale type ${type} does not support interpolating color schemes.`);\n        }\n      }\n    }\n\n    // given a range array for an interpolating scale, convert to interpolator\n    if (range && vegaScale.isInterpolating(type)) {\n      return scale.interpolator(\n        vegaScale.interpolateColors(flip(range, _.reverse), _.interpolate, _.interpolateGamma)\n      );\n    }\n\n    // configure rounding / interpolation\n    if (range && _.interpolate && scale.interpolate) {\n      scale.interpolate(vegaScale.interpolate(_.interpolate, _.interpolateGamma));\n    } else if (vegaUtil.isFunction(scale.round)) {\n      scale.round(round);\n    } else if (vegaUtil.isFunction(scale.rangeRound)) {\n      scale.interpolate(round ? d3Interpolate.interpolateRound : d3Interpolate.interpolate);\n    }\n\n    if (range) scale.range(flip(range, _.reverse));\n  }\n\n  function configureRangeStep(type, _, count) {\n    if (type !== vegaScale.Band && type !== vegaScale.Point) {\n      vegaUtil.error('Only band and point scales support rangeStep.');\n    }\n\n    // calculate full range based on requested step size and padding\n    var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,\n        inner = type === vegaScale.Point ? 1\n              : ((_.paddingInner != null ? _.paddingInner : _.padding) || 0);\n    return [0, _.rangeStep * vegaScale.bandSpace(count, inner, outer)];\n  }\n\n  function configureScheme(type, _, count) {\n    var extent = _.schemeExtent,\n        name, scheme;\n\n    if (vegaUtil.isArray(_.scheme)) {\n      scheme = vegaScale.interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);\n    } else {\n      name = _.scheme.toLowerCase();\n      scheme = vegaScale.scheme(name);\n      if (!scheme) vegaUtil.error(`Unrecognized scheme name: ${_.scheme}`);\n    }\n\n    // determine size for potential discrete range\n    count = (type === vegaScale.Threshold) ? count + 1\n      : (type === vegaScale.BinOrdinal) ? count - 1\n      : (type === vegaScale.Quantile || type === vegaScale.Quantize) ? (+_.schemeCount || DEFAULT_COUNT)\n      : count;\n\n    // adjust and/or quantize scheme as appropriate\n    return vegaScale.isInterpolating(type) ? adjustScheme(scheme, extent, _.reverse)\n      : vegaUtil.isFunction(scheme) ? vegaScale.quantizeInterpolator(adjustScheme(scheme, extent), count)\n      : type === vegaScale.Ordinal ? scheme : scheme.slice(0, count);\n  }\n\n  function adjustScheme(scheme, extent, reverse) {\n    return (vegaUtil.isFunction(scheme) && (extent || reverse))\n      ? vegaScale.interpolateRange(scheme, flip(extent || [0, 1], reverse))\n      : scheme;\n  }\n\n  function flip(array, reverse) {\n    return reverse ? array.slice().reverse() : array;\n  }\n\n  /**\n   * Sorts scenegraph items in the pulse source array.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(*,*): number} [params.sort] - A comparator\n   *   function for sorting tuples.\n   */\n  function SortItems(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  vegaUtil.inherits(SortItems, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const mod = _.modified('sort')\n            || pulse.changed(pulse.ADD)\n            || pulse.modified(_.sort.fields)\n            || pulse.modified('datum');\n\n      if (mod) pulse.source.sort(vegaDataflow.stableCompare(_.sort));\n\n      this.modified(mod);\n      return pulse;\n    }\n  });\n\n  const Zero = 'zero',\n        Center = 'center',\n        Normalize = 'normalize',\n        DefOutput = ['y0', 'y1'];\n\n  /**\n   * Stack layout for visualization elements.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - The value field to stack.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n   * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.\n   * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.\n   */\n  function Stack(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Stack.Definition = {\n    'type': 'Stack',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'field', 'type': 'field' },\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'sort', 'type': 'compare' },\n      { 'name': 'offset', 'type': 'enum', 'default': Zero, 'values': [Zero, Center, Normalize] },\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': DefOutput }\n    ]\n  };\n\n  vegaUtil.inherits(Stack, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      var as = _.as || DefOutput,\n          y0 = as[0],\n          y1 = as[1],\n          sort = vegaDataflow.stableCompare(_.sort),\n          field = _.field || vegaUtil.one,\n          stack = _.offset === Center ? stackCenter\n                : _.offset === Normalize ? stackNormalize\n                : stackZero,\n          groups, i, n, max;\n\n      // partition, sum, and sort the stack groups\n      groups = partition(pulse.source, _.groupby, sort, field);\n\n      // compute stack layouts per group\n      for (i=0, n=groups.length, max=groups.max; i<n; ++i) {\n        stack(groups[i], max, field, y0, y1);\n      }\n\n      return pulse.reflow(_.modified()).modifies(as);\n    }\n  });\n\n  function stackCenter(group, max, field, y0, y1) {\n    var last = (max - group.sum) / 2,\n        m = group.length,\n        j = 0, t;\n\n    for (; j<m; ++j) {\n      t = group[j];\n      t[y0] = last;\n      t[y1] = (last += Math.abs(field(t)));\n    }\n  }\n\n  function stackNormalize(group, max, field, y0, y1) {\n    var scale = 1 / group.sum,\n        last = 0,\n        m = group.length,\n        j = 0, v = 0, t;\n\n    for (; j<m; ++j) {\n      t = group[j];\n      t[y0] = last;\n      t[y1] = last = scale * (v += Math.abs(field(t)));\n    }\n  }\n\n  function stackZero(group, max, field, y0, y1) {\n    var lastPos = 0,\n        lastNeg = 0,\n        m = group.length,\n        j = 0, v, t;\n\n    for (; j<m; ++j) {\n      t = group[j];\n      v = +field(t);\n      if (v < 0) {\n        t[y0] = lastNeg;\n        t[y1] = (lastNeg += v);\n      } else {\n        t[y0] = lastPos;\n        t[y1] = (lastPos += v);\n      }\n    }\n  }\n\n  function partition(data, groupby, sort, field) {\n    var groups = [],\n        get = f => f(t),\n        map, i, n, m, t, k, g, s, max;\n\n    // partition data points into stack groups\n    if (groupby == null) {\n      groups.push(data.slice());\n    } else {\n      for (map={}, i=0, n=data.length; i<n; ++i) {\n        t = data[i];\n        k = groupby.map(get);\n        g = map[k];\n        if (!g) {\n          map[k] = (g = []);\n          groups.push(g);\n        }\n        g.push(t);\n      }\n    }\n\n    // compute sums of groups, sort groups as needed\n    for (k=0, max=0, m=groups.length; k<m; ++k) {\n      g = groups[k];\n      for (i=0, s=0, n=g.length; i<n; ++i) {\n        s += Math.abs(field(g[i]));\n      }\n      g.sum = s;\n      if (s > max) max = s;\n      if (sort) g.sort(sort);\n    }\n    groups.max = max;\n\n    return groups;\n  }\n\n  exports.axisticks = AxisTicks;\n  exports.datajoin = DataJoin;\n  exports.encode = Encode;\n  exports.legendentries = LegendEntries;\n  exports.linkpath = LinkPath;\n  exports.pie = Pie;\n  exports.scale = Scale;\n  exports.sortitems = SortItems;\n  exports.stack = Stack;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vega_dataflow$build$vega_dataflow","~$module$node_modules$vega_scale$build$vega_scale","~$shadow.js","~$module$node_modules$vega_util$build$vega_util","~$module$node_modules$d3_array$dist$d3_array","~$module$node_modules$d3_interpolate$dist$d3_interpolate"]],"~:properties",["^5",["datajoin","linkpath","index","offset","scale","sum","label","__esModule","max","datum","transform","lookup","vega","perc","axisticks","rem","legendentries","value","pie","source","Definition","transforms","exit","extra","add","bins","size","encode","perc2","stack","sortitems"]],"~:compiled-at",1600144479915,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_encode$build$vega_encode.js\",\n\"lineCount\":37,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-encode/build/vega-encode.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_encode$build$vega_encode\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-dataflow'), require('vega-scale'), require('vega-util'), require('d3-array'), require('d3-interpolate')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-dataflow', 'vega-scale', 'vega-util', 'd3-array', 'd3-interpolate'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.vega, global.d3, global.d3));\\n}(this, (function (exports, vegaDataflow, vegaScale, vegaUtil, d3Array, d3Interpolate) { 'use strict';\\n\\n  /**\\n   * Generates axis ticks for visualizing a spatial scale.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Scale} params.scale - The scale to generate ticks for.\\n   * @param {*} [params.count=10] - The approximate number of ticks, or\\n   *   desired tick interval, to use.\\n   * @param {Array<*>} [params.values] - The exact tick values to use.\\n   *   These must be legal domain values for the provided scale.\\n   *   If provided, the count argument is ignored.\\n   * @param {function(*):string} [params.formatSpecifier] - A format specifier\\n   *   to use in conjunction with scale.tickFormat. Legal values are\\n   *   any valid d3 4.0 format specifier.\\n   * @param {function(*):string} [params.format] - The format function to use.\\n   *   If provided, the formatSpecifier argument is ignored.\\n   */\\n  function AxisTicks(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  vegaUtil.inherits(AxisTicks, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      if (this.value && !_.modified()) {\\n        return pulse.StopPropagation;\\n      }\\n\\n      var locale = pulse.dataflow.locale(),\\n          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\\n          ticks = this.value,\\n          scale = _.scale,\\n          tally = _.count == null ? (_.values ? _.values.length : 10) : _.count,\\n          count = vegaScale.tickCount(scale, tally, _.minstep),\\n          format = _.format || vegaScale.tickFormat(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),\\n          values = _.values ? vegaScale.validTicks(scale, _.values, count) : vegaScale.tickValues(scale, count);\\n\\n      if (ticks) out.rem = ticks;\\n\\n      ticks = values.map((value, i) =>\\n        vegaDataflow.ingest({\\n          index: i / (values.length - 1 || 1),\\n          value: value,\\n          label: format(value)\\n        })\\n      );\\n\\n      if (_.extra && ticks.length) {\\n        // add an extra tick pegged to the initial domain value\\n        // this is used to generate axes with 'binned' domains\\n        ticks.push(vegaDataflow.ingest({\\n          index: -1,\\n          extra: {value: ticks[0].value},\\n          label: ''\\n        }));\\n      }\\n\\n      out.source = ticks;\\n      out.add = ticks;\\n      this.value = ticks;\\n\\n      return out;\\n    }\\n  });\\n\\n  /**\\n   * Joins a set of data elements against a set of visual items.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): object} [params.item] - An item generator function.\\n   * @param {function(object): *} [params.key] - The key field associating data and visual items.\\n   */\\n  function DataJoin(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  function defaultItemCreate() {\\n    return vegaDataflow.ingest({});\\n  }\\n\\n  function newMap(key) {\\n    const map = vegaUtil.fastmap().test(t => t.exit);\\n    map.lookup = t => map.get(key(t));\\n    return map;\\n  }\\n\\n  vegaUtil.inherits(DataJoin, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      var df = pulse.dataflow,\\n          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\\n          item = _.item || defaultItemCreate,\\n          key = _.key || vegaDataflow.tupleid,\\n          map = this.value;\\n\\n      // prevent transient (e.g., hover) requests from\\n      // cascading across marks derived from marks\\n      if (vegaUtil.isArray(out.encode)) {\\n        out.encode = null;\\n      }\\n\\n      if (map && (_.modified('key') || pulse.modified(key))) {\\n        vegaUtil.error('DataJoin does not support modified key function or fields.');\\n      }\\n\\n      if (!map) {\\n        pulse = pulse.addAll();\\n        this.value = map = newMap(key);\\n      }\\n\\n      pulse.visit(pulse.ADD, t => {\\n        const k = key(t);\\n        let x = map.get(k);\\n\\n        if (x) {\\n          if (x.exit) {\\n            map.empty--;\\n            out.add.push(x);\\n          } else {\\n            out.mod.push(x);\\n          }\\n        } else {\\n          x = item(t);\\n          map.set(k, x);\\n          out.add.push(x);\\n        }\\n\\n        x.datum = t;\\n        x.exit = false;\\n      });\\n\\n      pulse.visit(pulse.MOD, t => {\\n        const k = key(t),\\n              x = map.get(k);\\n\\n        if (x) {\\n          x.datum = t;\\n          out.mod.push(x);\\n        }\\n      });\\n\\n      pulse.visit(pulse.REM, t => {\\n        const k = key(t),\\n              x = map.get(k);\\n\\n        if (t === x.datum && !x.exit) {\\n          out.rem.push(x);\\n          x.exit = true;\\n          ++map.empty;\\n        }\\n      });\\n\\n      if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');\\n\\n      if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {\\n        df.runAfter(map.clean);\\n      }\\n\\n      return out;\\n    }\\n  });\\n\\n  /**\\n   * Invokes encoding functions for visual items.\\n   * @constructor\\n   * @param {object} params - The parameters to the encoding functions. This\\n   *   parameter object will be passed through to all invoked encoding functions.\\n   * @param {object} [params.mod=false] - Flag indicating if tuples in the input\\n   *   mod set that are unmodified by encoders should be included in the output.\\n   * @param {object} param.encoders - The encoding functions\\n   * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set\\n   * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set\\n   * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set\\n   */\\n  function Encode(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  vegaUtil.inherits(Encode, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      var out = pulse.fork(pulse.ADD_REM),\\n          fmod = _.mod || false,\\n          encoders = _.encoders,\\n          encode = pulse.encode;\\n\\n      // if an array, the encode directive includes additional sets\\n      // that must be defined in order for the primary set to be invoked\\n      // e.g., only run the update set if the hover set is defined\\n      if (vegaUtil.isArray(encode)) {\\n        if (out.changed() || encode.every(e => encoders[e])) {\\n          encode = encode[0];\\n          out.encode = null; // consume targeted encode directive\\n        } else {\\n          return pulse.StopPropagation;\\n        }\\n      }\\n\\n      // marshall encoder functions\\n      var reenter = encode === 'enter',\\n          update = encoders.update || vegaUtil.falsy,\\n          enter = encoders.enter || vegaUtil.falsy,\\n          exit = encoders.exit || vegaUtil.falsy,\\n          set = (encode && !reenter ? encoders[encode] : update) || vegaUtil.falsy;\\n\\n      if (pulse.changed(pulse.ADD)) {\\n        pulse.visit(pulse.ADD, t => { enter(t, _); update(t, _); });\\n        out.modifies(enter.output);\\n        out.modifies(update.output);\\n        if (set !== vegaUtil.falsy && set !== update) {\\n          pulse.visit(pulse.ADD, t => { set(t, _); });\\n          out.modifies(set.output);\\n        }\\n      }\\n\\n      if (pulse.changed(pulse.REM) && exit !== vegaUtil.falsy) {\\n        pulse.visit(pulse.REM, t => { exit(t, _); });\\n        out.modifies(exit.output);\\n      }\\n\\n      if (reenter || set !== vegaUtil.falsy) {\\n        var flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);\\n        if (reenter) {\\n          pulse.visit(flag, t => {\\n            var mod = enter(t, _) || fmod;\\n            if (set(t, _) || mod) out.mod.push(t);\\n          });\\n          if (out.mod.length) out.modifies(enter.output);\\n        } else {\\n          pulse.visit(flag, t => {\\n            if (set(t, _) || fmod) out.mod.push(t);\\n          });\\n        }\\n        if (out.mod.length) out.modifies(set.output);\\n      }\\n\\n      return out.changed() ? out : pulse.StopPropagation;\\n    }\\n  });\\n\\n  /**\\n   * Generates legend entries for visualizing a scale.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Scale} params.scale - The scale to generate items for.\\n   * @param {*} [params.count=5] - The approximate number of items, or\\n   *   desired tick interval, to use.\\n   * @param {*} [params.limit] - The maximum number of entries to\\n   *   include in a symbol legend.\\n   * @param {Array<*>} [params.values] - The exact tick values to use.\\n   *   These must be legal domain values for the provided scale.\\n   *   If provided, the count argument is ignored.\\n   * @param {string} [params.formatSpecifier] - A format specifier\\n   *   to use in conjunction with scale.tickFormat. Legal values are\\n   *   any valid D3 format specifier string.\\n   * @param {function(*):string} [params.format] - The format function to use.\\n   *   If provided, the formatSpecifier argument is ignored.\\n   */\\n  function LegendEntries(params) {\\n    vegaDataflow.Transform.call(this, [], params);\\n  }\\n\\n  vegaUtil.inherits(LegendEntries, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      if (this.value != null && !_.modified()) {\\n        return pulse.StopPropagation;\\n      }\\n\\n      var locale = pulse.dataflow.locale(),\\n          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\\n          items = this.value,\\n          type  = _.type || vegaScale.SymbolLegend,\\n          scale = _.scale,\\n          limit = +_.limit,\\n          count = vegaScale.tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\\n          lskip = !!_.values || type === vegaScale.SymbolLegend,\\n          format = _.format || vegaScale.labelFormat(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),\\n          values = _.values || vegaScale.labelValues(scale, count),\\n          domain, fraction, size, offset, ellipsis;\\n\\n      if (items) out.rem = items;\\n\\n      if (type === vegaScale.SymbolLegend) {\\n        if (limit && values.length > limit) {\\n          pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\\n          items = values.slice(0, limit - 1);\\n          ellipsis = true;\\n        } else {\\n          items = values;\\n        }\\n\\n        if (vegaUtil.isFunction(size = _.size)) {\\n          // if first value maps to size zero, remove from list (vega#717)\\n          if (!_.values && scale(items[0]) === 0) {\\n            items = items.slice(1);\\n          }\\n          // compute size offset for legend entries\\n          offset = items.reduce((max, value) => Math.max(max, size(value, _)), 0);\\n        } else {\\n          size = vegaUtil.constant(offset = size || 8);\\n        }\\n\\n        items = items.map((value, index) =>\\n          vegaDataflow.ingest({\\n            index:  index,\\n            label:  format(value, index, items),\\n            value:  value,\\n            offset: offset,\\n            size:   size(value, _)\\n          })\\n        );\\n\\n        if (ellipsis) {\\n          ellipsis = values[items.length];\\n          items.push(vegaDataflow.ingest({\\n            index:    items.length,\\n            label:    `\\\\u2026${values.length-items.length} entries`,\\n            value:    ellipsis,\\n            offset:   offset,\\n            size:     size(ellipsis, _)\\n          }));\\n        }\\n      }\\n\\n      else if (type === vegaScale.GradientLegend) {\\n        domain = scale.domain(),\\n        fraction = vegaScale.scaleFraction(scale, domain[0], vegaUtil.peek(domain));\\n\\n        // if automatic label generation produces 2 or fewer values,\\n        // use the domain end points instead (fixes vega/vega#1364)\\n        if (values.length < 3 && !_.values && domain[0] !== vegaUtil.peek(domain)) {\\n          values = [domain[0], vegaUtil.peek(domain)];\\n        }\\n\\n        items = values.map((value, index) =>\\n          vegaDataflow.ingest({\\n            index: index,\\n            label: format(value, index, values),\\n            value: value,\\n            perc:  fraction(value)\\n          })\\n        );\\n      }\\n\\n      else {\\n        size = values.length - 1;\\n        fraction = vegaScale.labelFraction(scale);\\n\\n        items = values.map((value, index) =>\\n          vegaDataflow.ingest({\\n            index: index,\\n            label: format(value, index, values),\\n            value: value,\\n            perc:  index ? fraction(value) : 0,\\n            perc2: index === size ? 1 : fraction(values[index+1])\\n          })\\n        );\\n      }\\n\\n      out.source = items;\\n      out.add = items;\\n      this.value = items;\\n\\n      return out;\\n    }\\n  });\\n\\n  const sourceX = t => t.source.x;\\n  const sourceY = t => t.source.y;\\n  const targetX = t => t.target.x;\\n  const targetY = t => t.target.y;\\n\\n   /**\\n    * Layout paths linking source and target elements.\\n    * @constructor\\n    * @param {object} params - The parameters for this operator.\\n    */\\n  function LinkPath(params) {\\n    vegaDataflow.Transform.call(this, {}, params);\\n  }\\n\\n  LinkPath.Definition = {\\n    'type': 'LinkPath',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'sourceX', 'type': 'field', 'default': 'source.x' },\\n      { 'name': 'sourceY', 'type': 'field', 'default': 'source.y' },\\n      { 'name': 'targetX', 'type': 'field', 'default': 'target.x' },\\n      { 'name': 'targetY', 'type': 'field', 'default': 'target.y' },\\n      { 'name': 'orient', 'type': 'enum', 'default': 'vertical',\\n        'values': ['horizontal', 'vertical', 'radial'] },\\n      { 'name': 'shape', 'type': 'enum', 'default': 'line',\\n        'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal'] },\\n      { 'name': 'require', 'type': 'signal' },\\n      { 'name': 'as', 'type': 'string', 'default': 'path' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(LinkPath, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      var sx = _.sourceX || sourceX,\\n          sy = _.sourceY || sourceY,\\n          tx = _.targetX || targetX,\\n          ty = _.targetY || targetY,\\n          as = _.as || 'path',\\n          orient = _.orient || 'vertical',\\n          shape = _.shape || 'line',\\n          path = Paths.get(shape + '-' + orient) || Paths.get(shape);\\n\\n      if (!path) {\\n        vegaUtil.error('LinkPath unsupported type: ' + _.shape\\n          + (_.orient ? '-' + _.orient : ''));\\n      }\\n\\n      pulse.visit(pulse.SOURCE, t => {\\n        t[as] = path(sx(t), sy(t), tx(t), ty(t));\\n      });\\n\\n      return pulse.reflow(_.modified()).modifies(as);\\n    }\\n  });\\n\\n  const line = (sx, sy, tx, ty) =>\\n    'M' + sx + ',' + sy +\\n    'L' + tx + ',' + ty;\\n\\n  const lineR= (sa, sr, ta, tr) => line(\\n    sr * Math.cos(sa), sr * Math.sin(sa),\\n    tr * Math.cos(ta), tr * Math.sin(ta)\\n  );\\n\\n  const arc = (sx, sy, tx, ty) => {\\n    var dx = tx - sx,\\n        dy = ty - sy,\\n        rr = Math.sqrt(dx * dx + dy * dy) / 2,\\n        ra = 180 * Math.atan2(dy, dx) / Math.PI;\\n    return 'M' + sx + ',' + sy +\\n           'A' + rr + ',' + rr +\\n           ' ' + ra + ' 0 1' +\\n           ' ' + tx + ',' + ty;\\n  };\\n\\n  const arcR = (sa, sr, ta, tr) => arc(\\n    sr * Math.cos(sa), sr * Math.sin(sa),\\n    tr * Math.cos(ta), tr * Math.sin(ta)\\n  );\\n\\n  const curve = (sx, sy, tx, ty) => {\\n    const dx = tx - sx,\\n          dy = ty - sy,\\n          ix = 0.2 * (dx + dy),\\n          iy = 0.2 * (dy - dx);\\n    return 'M' + sx + ',' + sy +\\n           'C' + (sx+ix) + ',' + (sy+iy) +\\n           ' ' + (tx+iy) + ',' + (ty-ix) +\\n           ' ' + tx + ',' + ty;\\n  };\\n\\n  const curveR = (sa, sr, ta, tr) => curve(\\n    sr * Math.cos(sa), sr * Math.sin(sa),\\n    tr * Math.cos(ta), tr * Math.sin(ta)\\n  );\\n\\n  const orthoX = (sx, sy, tx, ty) =>\\n    'M' + sx + ',' + sy +\\n    'V' + ty + 'H' + tx;\\n\\n  const orthoY = (sx, sy, tx, ty) =>\\n    'M' + sx + ',' + sy +\\n    'H' + tx + 'V' + ty;\\n\\n  const orthoR = (sa, sr, ta, tr) => {\\n    const sc = Math.cos(sa),\\n          ss = Math.sin(sa),\\n          tc = Math.cos(ta),\\n          ts = Math.sin(ta),\\n          sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\\n    return 'M' + (sr*sc) + ',' + (sr*ss) +\\n           'A' + sr + ',' + sr + ' 0 0,' + (sf?1:0) +\\n           ' ' + (sr*tc) + ',' + (sr*ts) +\\n           'L' + (tr*tc) + ',' + (tr*ts);\\n  };\\n\\n  const diagonalX = (sx, sy, tx, ty) => {\\n    const m = (sx + tx) / 2;\\n    return 'M' + sx + ',' + sy +\\n           'C' + m  + ',' + sy +\\n           ' ' + m  + ',' + ty +\\n           ' ' + tx + ',' + ty;\\n  };\\n\\n  const diagonalY = (sx, sy, tx, ty) => {\\n    const m = (sy + ty) / 2;\\n    return 'M' + sx + ',' + sy +\\n           'C' + sx + ',' + m +\\n           ' ' + tx + ',' + m +\\n           ' ' + tx + ',' + ty;\\n  };\\n\\n  const diagonalR = (sa, sr, ta, tr) => {\\n    const sc = Math.cos(sa),\\n          ss = Math.sin(sa),\\n          tc = Math.cos(ta),\\n          ts = Math.sin(ta),\\n          mr = (sr + tr) / 2;\\n    return 'M' + (sr*sc) + ',' + (sr*ss) +\\n           'C' + (mr*sc) + ',' + (mr*ss) +\\n           ' ' + (mr*tc) + ',' + (mr*ts) +\\n           ' ' + (tr*tc) + ',' + (tr*ts);\\n  };\\n\\n  const Paths = vegaUtil.fastmap({\\n    'line': line,\\n    'line-radial': lineR,\\n    'arc': arc,\\n    'arc-radial': arcR,\\n    'curve': curve,\\n    'curve-radial': curveR,\\n    'orthogonal-horizontal': orthoX,\\n    'orthogonal-vertical': orthoY,\\n    'orthogonal-radial': orthoR,\\n    'diagonal-horizontal': diagonalX,\\n    'diagonal-vertical': diagonalY,\\n    'diagonal-radial': diagonalR\\n  });\\n\\n  /**\\n   * Pie and donut chart layout.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - The value field to size pie segments.\\n   * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.\\n   * @param {number} [params.endAngle=2\\u03c0] - The end angle (in radians) of the layout.\\n   * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.\\n   */\\n  function Pie(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Pie.Definition = {\\n    'type': 'Pie',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field' },\\n      { 'name': 'startAngle', 'type': 'number', 'default': 0 },\\n      { 'name': 'endAngle', 'type': 'number', 'default': 6.283185307179586 },\\n      { 'name': 'sort', 'type': 'boolean', 'default': false },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['startAngle', 'endAngle'] }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Pie, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      var as = _.as || ['startAngle', 'endAngle'],\\n          startAngle = as[0],\\n          endAngle = as[1],\\n          field = _.field || vegaUtil.one,\\n          start = _.startAngle || 0,\\n          stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,\\n          data = pulse.source,\\n          values = data.map(field),\\n          n = values.length,\\n          a = start,\\n          k = (stop - start) / d3Array.sum(values),\\n          index = d3Array.range(n),\\n          i, t, v;\\n\\n      if (_.sort) {\\n        index.sort((a, b) => values[a] - values[b]);\\n      }\\n\\n      for (i=0; i<n; ++i) {\\n        v = values[index[i]];\\n        t = data[index[i]];\\n        t[startAngle] = a;\\n        t[endAngle] = (a += v * k);\\n      }\\n\\n      this.value = values;\\n      return pulse.reflow(_.modified()).modifies(as);\\n    }\\n  });\\n\\n  const DEFAULT_COUNT = 5;\\n\\n  function includeZero(scale) {\\n    const type = scale.type;\\n    return !scale.bins && (\\n      type === vegaScale.Linear || type === vegaScale.Pow || type === vegaScale.Sqrt\\n    );\\n  }\\n\\n  function includePad(type) {\\n    return vegaScale.isContinuous(type) && type !== vegaScale.Sequential;\\n  }\\n\\n  const SKIP = vegaUtil.toSet([\\n    'set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount',\\n    'domain', 'domainMin', 'domainMid', 'domainMax',\\n    'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins',\\n    'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma'\\n  ]);\\n\\n  /**\\n   * Maintains a scale function mapping data values to visual channels.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   */\\n  function Scale(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n    this.modified(true); // always treat as modified\\n  }\\n\\n  vegaUtil.inherits(Scale, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      var df = pulse.dataflow,\\n          scale = this.value,\\n          key = scaleKey(_);\\n\\n      if (!scale || key !== scale.type) {\\n        this.value = scale = vegaScale.scale(key)();\\n      }\\n\\n      for (key in _) if (!SKIP[key]) {\\n        // padding is a scale property for band/point but not others\\n        if (key === 'padding' && includePad(scale.type)) continue;\\n        // invoke scale property setter, raise warning if not found\\n        vegaUtil.isFunction(scale[key])\\n          ? scale[key](_[key])\\n          : df.warn('Unsupported scale property: ' + key);\\n      }\\n\\n      configureRange(scale, _,\\n        configureBins(scale, _, configureDomain(scale, _, df))\\n      );\\n\\n      return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\\n    }\\n  });\\n\\n  function scaleKey(_) {\\n    var t = _.type, d = '', n;\\n\\n    // backwards compatibility pre Vega 5.\\n    if (t === vegaScale.Sequential) return vegaScale.Sequential + '-' + vegaScale.Linear;\\n\\n    if (isContinuousColor(_)) {\\n      n = _.rawDomain ? _.rawDomain.length\\n        : _.domain ? _.domain.length + +(_.domainMid != null)\\n        : 0;\\n      d = n === 2 ? vegaScale.Sequential + '-'\\n        : n === 3 ? vegaScale.Diverging + '-'\\n        : '';\\n    }\\n\\n    return ((d + t) || vegaScale.Linear).toLowerCase();\\n  }\\n\\n  function isContinuousColor(_) {\\n    const t = _.type;\\n    return vegaScale.isContinuous(t) && t !== vegaScale.Time && t !== vegaScale.UTC && (\\n      _.scheme || _.range && _.range.length && _.range.every(vegaUtil.isString)\\n    );\\n  }\\n\\n  function configureDomain(scale, _, df) {\\n    // check raw domain, if provided use that and exit early\\n    var raw = rawDomain(scale, _.domainRaw, df);\\n    if (raw > -1) return raw;\\n\\n    var domain = _.domain,\\n        type = scale.type,\\n        zero = _.zero || (_.zero === undefined && includeZero(scale)),\\n        n, mid;\\n\\n    if (!domain) return 0;\\n\\n    // adjust continuous domain for minimum pixel padding\\n    if (includePad(type) && _.padding && domain[0] !== vegaUtil.peek(domain)) {\\n      domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);\\n    }\\n\\n    // adjust domain based on zero, min, max settings\\n    if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {\\n      n = ((domain = domain.slice()).length - 1) || 1;\\n      if (zero) {\\n        if (domain[0] > 0) domain[0] = 0;\\n        if (domain[n] < 0) domain[n] = 0;\\n      }\\n      if (_.domainMin != null) domain[0] = _.domainMin;\\n      if (_.domainMax != null) domain[n] = _.domainMax;\\n\\n      if (_.domainMid != null) {\\n        mid = _.domainMid;\\n        const i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;\\n        if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);\\n        domain.splice(i, 0, mid);\\n      }\\n    }\\n\\n    // set the scale domain\\n    scale.domain(domainCheck(type, domain, df));\\n\\n    // if ordinal scale domain is defined, prevent implicit\\n    // domain construction as side-effect of scale lookup\\n    if (type === vegaScale.Ordinal) {\\n      scale.unknown(_.domainImplicit ? vegaScale.scaleImplicit : undefined);\\n    }\\n\\n    // perform 'nice' adjustment as requested\\n    if (_.nice && scale.nice) {\\n      scale.nice((_.nice !== true && vegaScale.tickCount(scale, _.nice)) || null);\\n    }\\n\\n    // return the cardinality of the domain\\n    return domain.length;\\n  }\\n\\n  function rawDomain(scale, raw, df) {\\n    if (raw) {\\n      scale.domain(domainCheck(scale.type, raw, df));\\n      return raw.length;\\n    } else {\\n      return -1;\\n    }\\n  }\\n\\n  function padDomain(type, domain, range, pad, exponent, constant) {\\n    var span = Math.abs(vegaUtil.peek(range) - range[0]),\\n        frac = span / (span - 2 * pad),\\n        d = type === vegaScale.Log    ? vegaUtil.zoomLog(domain, null, frac)\\n          : type === vegaScale.Sqrt   ? vegaUtil.zoomPow(domain, null, frac, 0.5)\\n          : type === vegaScale.Pow    ? vegaUtil.zoomPow(domain, null, frac, exponent || 1)\\n          : type === vegaScale.Symlog ? vegaUtil.zoomSymlog(domain, null, frac, constant || 1)\\n          : vegaUtil.zoomLinear(domain, null, frac);\\n\\n    domain = domain.slice();\\n    domain[0] = d[0];\\n    domain[domain.length-1] = d[1];\\n    return domain;\\n  }\\n\\n  function domainCheck(type, domain, df) {\\n    if (vegaScale.isLogarithmic(type)) {\\n      // sum signs of domain values\\n      // if all pos or all neg, abs(sum) === domain.length\\n      var s = Math.abs(domain.reduce((s, v) => s + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));\\n\\n      if (s !== domain.length) {\\n        df.warn('Log scale domain includes zero: ' + vegaUtil.stringValue(domain));\\n      }\\n    }\\n    return domain;\\n  }\\n\\n  function configureBins(scale, _, count) {\\n    let bins = _.bins;\\n\\n    if (bins && !vegaUtil.isArray(bins)) {\\n      // generate bin boundary array\\n      const domain = scale.domain(),\\n            lo = domain[0],\\n            hi = vegaUtil.peek(domain),\\n            step = bins.step;\\n\\n      let start = bins.start == null ? lo : bins.start,\\n          stop = bins.stop == null ? hi : bins.stop;\\n\\n      if (!step) vegaUtil.error('Scale bins parameter missing step property.');\\n      if (start < lo) start = step * Math.ceil(lo / step);\\n      if (stop > hi) stop = step * Math.floor(hi / step);\\n      bins = d3Array.range(start, stop + step / 2, step);\\n    }\\n\\n    if (bins) {\\n      // assign bin boundaries to scale instance\\n      scale.bins = bins;\\n    } else if (scale.bins) {\\n      // no current bins, remove bins if previously set\\n      delete scale.bins;\\n    }\\n\\n    // special handling for bin-ordinal scales\\n    if (scale.type === vegaScale.BinOrdinal) {\\n      if (!bins) {\\n        // the domain specifies the bins\\n        scale.bins = scale.domain();\\n      } else if (!_.domain && !_.domainRaw) {\\n        // the bins specify the domain\\n        scale.domain(bins);\\n        count = bins.length;\\n      }\\n    }\\n\\n    // return domain cardinality\\n    return count;\\n  }\\n\\n  function configureRange(scale, _, count) {\\n    var type = scale.type,\\n        round = _.round || false,\\n        range = _.range;\\n\\n    // if range step specified, calculate full range extent\\n    if (_.rangeStep != null) {\\n      range = configureRangeStep(type, _, count);\\n    }\\n\\n    // else if a range scheme is defined, use that\\n    else if (_.scheme) {\\n      range = configureScheme(type, _, count);\\n      if (vegaUtil.isFunction(range)) {\\n        if (scale.interpolator) {\\n          return scale.interpolator(range);\\n        } else {\\n          vegaUtil.error(`Scale type ${type} does not support interpolating color schemes.`);\\n        }\\n      }\\n    }\\n\\n    // given a range array for an interpolating scale, convert to interpolator\\n    if (range && vegaScale.isInterpolating(type)) {\\n      return scale.interpolator(\\n        vegaScale.interpolateColors(flip(range, _.reverse), _.interpolate, _.interpolateGamma)\\n      );\\n    }\\n\\n    // configure rounding / interpolation\\n    if (range && _.interpolate && scale.interpolate) {\\n      scale.interpolate(vegaScale.interpolate(_.interpolate, _.interpolateGamma));\\n    } else if (vegaUtil.isFunction(scale.round)) {\\n      scale.round(round);\\n    } else if (vegaUtil.isFunction(scale.rangeRound)) {\\n      scale.interpolate(round ? d3Interpolate.interpolateRound : d3Interpolate.interpolate);\\n    }\\n\\n    if (range) scale.range(flip(range, _.reverse));\\n  }\\n\\n  function configureRangeStep(type, _, count) {\\n    if (type !== vegaScale.Band && type !== vegaScale.Point) {\\n      vegaUtil.error('Only band and point scales support rangeStep.');\\n    }\\n\\n    // calculate full range based on requested step size and padding\\n    var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,\\n        inner = type === vegaScale.Point ? 1\\n              : ((_.paddingInner != null ? _.paddingInner : _.padding) || 0);\\n    return [0, _.rangeStep * vegaScale.bandSpace(count, inner, outer)];\\n  }\\n\\n  function configureScheme(type, _, count) {\\n    var extent = _.schemeExtent,\\n        name, scheme;\\n\\n    if (vegaUtil.isArray(_.scheme)) {\\n      scheme = vegaScale.interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);\\n    } else {\\n      name = _.scheme.toLowerCase();\\n      scheme = vegaScale.scheme(name);\\n      if (!scheme) vegaUtil.error(`Unrecognized scheme name: ${_.scheme}`);\\n    }\\n\\n    // determine size for potential discrete range\\n    count = (type === vegaScale.Threshold) ? count + 1\\n      : (type === vegaScale.BinOrdinal) ? count - 1\\n      : (type === vegaScale.Quantile || type === vegaScale.Quantize) ? (+_.schemeCount || DEFAULT_COUNT)\\n      : count;\\n\\n    // adjust and/or quantize scheme as appropriate\\n    return vegaScale.isInterpolating(type) ? adjustScheme(scheme, extent, _.reverse)\\n      : vegaUtil.isFunction(scheme) ? vegaScale.quantizeInterpolator(adjustScheme(scheme, extent), count)\\n      : type === vegaScale.Ordinal ? scheme : scheme.slice(0, count);\\n  }\\n\\n  function adjustScheme(scheme, extent, reverse) {\\n    return (vegaUtil.isFunction(scheme) && (extent || reverse))\\n      ? vegaScale.interpolateRange(scheme, flip(extent || [0, 1], reverse))\\n      : scheme;\\n  }\\n\\n  function flip(array, reverse) {\\n    return reverse ? array.slice().reverse() : array;\\n  }\\n\\n  /**\\n   * Sorts scenegraph items in the pulse source array.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(*,*): number} [params.sort] - A comparator\\n   *   function for sorting tuples.\\n   */\\n  function SortItems(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  vegaUtil.inherits(SortItems, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const mod = _.modified('sort')\\n            || pulse.changed(pulse.ADD)\\n            || pulse.modified(_.sort.fields)\\n            || pulse.modified('datum');\\n\\n      if (mod) pulse.source.sort(vegaDataflow.stableCompare(_.sort));\\n\\n      this.modified(mod);\\n      return pulse;\\n    }\\n  });\\n\\n  const Zero = 'zero',\\n        Center = 'center',\\n        Normalize = 'normalize',\\n        DefOutput = ['y0', 'y1'];\\n\\n  /**\\n   * Stack layout for visualization elements.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - The value field to stack.\\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\\n   * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.\\n   * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.\\n   */\\n  function Stack(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Stack.Definition = {\\n    'type': 'Stack',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field' },\\n      { 'name': 'groupby', 'type': 'field', 'array': true },\\n      { 'name': 'sort', 'type': 'compare' },\\n      { 'name': 'offset', 'type': 'enum', 'default': Zero, 'values': [Zero, Center, Normalize] },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': DefOutput }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Stack, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      var as = _.as || DefOutput,\\n          y0 = as[0],\\n          y1 = as[1],\\n          sort = vegaDataflow.stableCompare(_.sort),\\n          field = _.field || vegaUtil.one,\\n          stack = _.offset === Center ? stackCenter\\n                : _.offset === Normalize ? stackNormalize\\n                : stackZero,\\n          groups, i, n, max;\\n\\n      // partition, sum, and sort the stack groups\\n      groups = partition(pulse.source, _.groupby, sort, field);\\n\\n      // compute stack layouts per group\\n      for (i=0, n=groups.length, max=groups.max; i<n; ++i) {\\n        stack(groups[i], max, field, y0, y1);\\n      }\\n\\n      return pulse.reflow(_.modified()).modifies(as);\\n    }\\n  });\\n\\n  function stackCenter(group, max, field, y0, y1) {\\n    var last = (max - group.sum) / 2,\\n        m = group.length,\\n        j = 0, t;\\n\\n    for (; j<m; ++j) {\\n      t = group[j];\\n      t[y0] = last;\\n      t[y1] = (last += Math.abs(field(t)));\\n    }\\n  }\\n\\n  function stackNormalize(group, max, field, y0, y1) {\\n    var scale = 1 / group.sum,\\n        last = 0,\\n        m = group.length,\\n        j = 0, v = 0, t;\\n\\n    for (; j<m; ++j) {\\n      t = group[j];\\n      t[y0] = last;\\n      t[y1] = last = scale * (v += Math.abs(field(t)));\\n    }\\n  }\\n\\n  function stackZero(group, max, field, y0, y1) {\\n    var lastPos = 0,\\n        lastNeg = 0,\\n        m = group.length,\\n        j = 0, v, t;\\n\\n    for (; j<m; ++j) {\\n      t = group[j];\\n      v = +field(t);\\n      if (v < 0) {\\n        t[y0] = lastNeg;\\n        t[y1] = (lastNeg += v);\\n      } else {\\n        t[y0] = lastPos;\\n        t[y1] = (lastPos += v);\\n      }\\n    }\\n  }\\n\\n  function partition(data, groupby, sort, field) {\\n    var groups = [],\\n        get = f => f(t),\\n        map, i, n, m, t, k, g, s, max;\\n\\n    // partition data points into stack groups\\n    if (groupby == null) {\\n      groups.push(data.slice());\\n    } else {\\n      for (map={}, i=0, n=data.length; i<n; ++i) {\\n        t = data[i];\\n        k = groupby.map(get);\\n        g = map[k];\\n        if (!g) {\\n          map[k] = (g = []);\\n          groups.push(g);\\n        }\\n        g.push(t);\\n      }\\n    }\\n\\n    // compute sums of groups, sort groups as needed\\n    for (k=0, max=0, m=groups.length; k<m; ++k) {\\n      g = groups[k];\\n      for (i=0, s=0, n=g.length; i<n; ++i) {\\n        s += Math.abs(field(g[i]));\\n      }\\n      g.sum = s;\\n      if (s > max) max = s;\\n      if (sort) g.sort(sort);\\n    }\\n    groups.max = max;\\n\\n    return groups;\\n  }\\n\\n  exports.axisticks = AxisTicks;\\n  exports.datajoin = DataJoin;\\n  exports.encode = Encode;\\n  exports.legendentries = LegendEntries;\\n  exports.linkpath = LinkPath;\\n  exports.pie = Pie;\\n  exports.scale = Scale;\\n  exports.sortitems = SortItems;\\n  exports.stack = Stack;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"transforms\",\"d3\",\"vegaDataflow\",\"vegaScale\",\"vegaUtil\",\"d3Array\",\"d3Interpolate\",\"AxisTicks\",\"params\",\"Transform\",\"call\",\"DataJoin\",\"defaultItemCreate\",\"ingest\",\"newMap\",\"key\",\"map\",\"fastmap\",\"test\",\"t\",\"exit\",\"lookup\",\"map.lookup\",\"get\",\"Encode\",\"LegendEntries\",\"LinkPath\",\"Pie\",\"includePad\",\"type\",\"isContinuous\",\"Sequential\",\"Scale\",\"modified\",\"domainCheck\",\"domain\",\"df\",\"isLogarithmic\",\"Math\",\"s\",\"abs\",\"reduce\",\"v\",\"length\",\"warn\",\"stringValue\",\"adjustScheme\",\"scheme\",\"extent\",\"reverse\",\"isFunction\",\"interpolateRange\",\"flip\",\"array\",\"slice\",\"SortItems\",\"Stack\",\"stackCenter\",\"group\",\"max\",\"field\",\"y0\",\"y1\",\"last\",\"sum\",\"m\",\"j\",\"stackNormalize\",\"scale\",\"stackZero\",\"lastNeg\",\"lastPos\",\"partition\",\"data\",\"groupby\",\"sort\",\"groups\",\"f\",\"n\",\"push\",\"i\",\"k\",\"g\",\"inherits\",\"transform\",\"_\",\"pulse\",\"value\",\"StopPropagation\",\"locale\",\"dataflow\",\"out\",\"fork\",\"NO_SOURCE\",\"NO_FIELDS\",\"ticks\",\"count\",\"tickCount\",\"tally\",\"values\",\"minstep\",\"format\",\"tickFormat\",\"formatSpecifier\",\"formatType\",\"validTicks\",\"tickValues\",\"rem\",\"index\",\"label\",\"extra\",\"source\",\"add\",\"item\",\"tupleid\",\"isArray\",\"encode\",\"error\",\"addAll\",\"visit\",\"ADD\",\"x\",\"empty\",\"mod\",\"set\",\"datum\",\"MOD\",\"REM\",\"changed\",\"ADD_MOD\",\"modifies\",\"clean\",\"cleanThreshold\",\"runAfter\",\"ADD_REM\",\"fmod\",\"encoders\",\"every\",\"e\",\"reenter\",\"update\",\"falsy\",\"enter\",\"output\",\"flag\",\"REFLOW\",\"items\",\"SymbolLegend\",\"limit\",\"lskip\",\"labelFormat\",\"labelValues\",\"size\",\"ellipsis\",\"offset\",\"constant\",\"GradientLegend\",\"fraction\",\"scaleFraction\",\"peek\",\"perc\",\"labelFraction\",\"perc2\",\"sourceX\",\"sourceY\",\"y\",\"targetX\",\"targetY\",\"Definition\",\"sx\",\"sy\",\"tx\",\"ty\",\"as\",\"shape\",\"path\",\"Paths\",\"orient\",\"SOURCE\",\"reflow\",\"line\",\"arc\",\"dx\",\"dy\",\"rr\",\"sqrt\",\"atan2\",\"PI\",\"curve\",\"ix\",\"iy\",\"lineR\",\"sa\",\"sr\",\"ta\",\"tr\",\"cos\",\"sin\",\"arcR\",\"curveR\",\"orthoX\",\"orthoY\",\"orthoR\",\"tc\",\"ts\",\"sc\",\"ss\",\"sf\",\"diagonalX\",\"diagonalY\",\"diagonalR\",\"mr\",\"startAngle\",\"endAngle\",\"start\",\"stop\",\"one\",\"a\",\"range\",\"b\",\"SKIP\",\"toSet\",\"d\",\"Linear\",\"Time\",\"UTC\",\"isString\",\"rawDomain\",\"domainMid\",\"Diverging\",\"toLowerCase\",\"domainRaw\",\"raw\",\"zero\",\"bins\",\"Pow\",\"Sqrt\",\"padding\",\"exponent\",\"span\",\"frac\",\"pad\",\"Log\",\"zoomLog\",\"zoomPow\",\"Symlog\",\"zoomSymlog\",\"zoomLinear\",\"domainMin\",\"domainMax\",\"mid\",\"splice\",\"Ordinal\",\"unknown\",\"domainImplicit\",\"scaleImplicit\",\"undefined\",\"nice\",\"lo\",\"hi\",\"step\",\"ceil\",\"floor\",\"BinOrdinal\",\"round\",\"rangeStep\",\"Band\",\"Point\",\"bandSpace\",\"inner\",\"paddingInner\",\"paddingOuter\",\"schemeExtent\",\"interpolateColors\",\"interpolate\",\"interpolateGamma\",\"name\",\"Threshold\",\"Quantile\",\"Quantize\",\"schemeCount\",\"DEFAULT_COUNT\",\"isInterpolating\",\"quantizeInterpolator\",\"interpolator\",\"rangeRound\",\"interpolateRound\",\"fields\",\"stableCompare\",\"DefOutput\",\"Zero\",\"Center\",\"Normalize\",\"stack\",\"axisticks\",\"datajoin\",\"legendentries\",\"linkpath\",\"pie\",\"sortitems\",\"Object\",\"defineProperty\"]\n}\n"]