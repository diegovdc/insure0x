["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-geo/build/vega-geo.js"],"~:js","shadow$provide.module$node_modules$vega_geo$build$vega_geo=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_dataflow$build$vega_dataflow\"),require(\"module$node_modules$vega_util$build$vega_util\"),require(\"module$node_modules$d3_array$dist$d3_array\"),require(\"module$node_modules$vega_statistics$build$vega_statistics\"),require(\"module$node_modules$vega_projection$build$vega_projection\"),\nrequire(\"module$node_modules$d3_geo$dist$d3_geo\"),require(\"module$node_modules$d3_color$dist$d3_color\"),require(\"module$node_modules$vega_canvas$build$vega_canvas\")):\"function\"===typeof define&&define.amd?define(\"exports vega-dataflow vega-util d3-array vega-statistics vega-projection d3-geo d3-color vega-canvas\".split(\" \"),factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory((global.vega=global.vega||{},global.vega.transforms={}),global.vega,global.vega,global.d3,global.vega,\nglobal.vega,global.d3,global.d3,global.vega))})(this,function(exports,vegaDataflow,vegaUtil,d3Array,vegaStatistics,vegaProjection,d3Geo,d3Color,vegaCanvas){function noop(){}function contours(){function contours(values,tz){return tz.map(function(value){return contour(values,value)})}function contour(values,value){var polygons=[],holes=[];isorings(values,value,function(ring){smooth(ring,values,value);for(var i=0,n=ring.length,area=ring[n-1][1]*ring[0][0]-ring[n-1][0]*ring[0][1];++i<n;)area+=ring[i-\n1][1]*ring[i][0]-ring[i-1][0]*ring[i][1];0<area?polygons.push([ring]):holes.push(ring)});holes.forEach(function(hole$jscomp$0){for(var i=0,n=polygons.length,polygon;i<n;++i){a:{var JSCompiler_inline_result=(polygon=polygons[i])[0];for(var hole=hole$jscomp$0,i$jscomp$0=-1,n$jscomp$0=hole.length;++i$jscomp$0<n$jscomp$0;){b:{var c=JSCompiler_inline_result;for(var point=hole[i$jscomp$0],x=point[0],y=point[1],contains=-1,i$jscomp$1=0,n$jscomp$1=c.length,j=n$jscomp$1-1;i$jscomp$1<n$jscomp$1;j=i$jscomp$1++){var pi=\nc[i$jscomp$1],xi=pi[0],yi=pi[1],pj=c[j];j=pj[0];var yj=pj[1],i$jscomp$2,a=pi;pi=pj;pj=point;if(i$jscomp$2=(pi[0]-a[0])*(pj[1]-a[1])===(pj[0]-a[0])*(pi[1]-a[1]))a=a[i$jscomp$2=+(a[0]===pi[0])],pj=pj[i$jscomp$2],pi=pi[i$jscomp$2],i$jscomp$2=a<=pj&&pj<=pi||pi<=pj&&pj<=a;if(i$jscomp$2){c=0;break b}yi>y!==yj>y&&x<(j-xi)*(y-yi)/(yj-yi)+xi&&(contains=-contains)}c=contains}if(c){JSCompiler_inline_result=c;break a}}JSCompiler_inline_result=0}if(-1!==JSCompiler_inline_result){polygon.push(hole$jscomp$0);break}}});\nreturn{type:\"MultiPolygon\",value:value,coordinates:polygons}}function isorings(values,value,callback){function stitch(line){var start=[line[0][0]+x,line[0][1]+y];line=[line[1][0]+x,line[1][1]+y];var startIndex=2*start[0]+start[1]*(dx+1)*4,endIndex=2*line[0]+line[1]*(dx+1)*4,f,g;(f=fragmentByEnd[startIndex])?(g=fragmentByStart[endIndex])?(delete fragmentByEnd[f.end],delete fragmentByStart[g.start],f===g?(f.ring.push(line),callback(f.ring)):fragmentByStart[f.start]=fragmentByEnd[g.end]={start:f.start,\nend:g.end,ring:f.ring.concat(g.ring)}):(delete fragmentByEnd[f.end],f.ring.push(line),fragmentByEnd[f.end=endIndex]=f):(f=fragmentByStart[endIndex])?(g=fragmentByEnd[startIndex])?(delete fragmentByStart[f.start],delete fragmentByEnd[g.end],f===g?(f.ring.push(line),callback(f.ring)):fragmentByStart[g.start]=fragmentByEnd[f.end]={start:g.start,end:f.end,ring:g.ring.concat(f.ring)}):(delete fragmentByStart[f.start],f.ring.unshift(start),fragmentByStart[f.start=startIndex]=f):fragmentByStart[startIndex]=\nfragmentByEnd[endIndex]={start:startIndex,end:endIndex,ring:[start,line]}}var fragmentByStart=[],fragmentByEnd=[],y;var x=y=-1;var t1=values[0]>=value;for(cases[t1<<1].forEach(stitch);++x<dx-1;){var t0=t1;t1=values[x+1]>=value;cases[t0|t1<<1].forEach(stitch)}for(cases[t1<<0].forEach(stitch);++y<dy-1;){x=-1;t1=values[y*dx+dx]>=value;var t2=values[y*dx]>=value;for(cases[t1<<1|t2<<2].forEach(stitch);++x<dx-1;){t0=t1;t1=values[y*dx+dx+x+1]>=value;var t3=t2;t2=values[y*dx+x+1]>=value;cases[t0|t1<<1|t2<<\n2|t3<<3].forEach(stitch)}cases[t1|t2<<3].forEach(stitch)}x=-1;t2=values[y*dx]>=value;for(cases[t2<<2].forEach(stitch);++x<dx-1;)t3=t2,t2=values[y*dx+x+1]>=value,cases[t2<<2|t3<<3].forEach(stitch);cases[t2<<3].forEach(stitch)}function smoothLinear(ring,values,value){ring.forEach(function(point){var x=point[0],y=point[1],xt=x|0,yt=y|0,v1=values[yt*dx+xt];if(0<x&&x<dx&&xt===x){var v0=values[yt*dx+xt-1];point[0]=x+(value-v0)/(v1-v0)-.5}0<y&&y<dy&&yt===y&&(v0=values[(yt-1)*dx+xt],point[1]=y+(value-v0)/\n(v1-v0)-.5)})}var dx=1,dy=1,smooth=smoothLinear;contours.contour=contour;contours.size=function(_){if(!arguments.length)return[dx,dy];var _0=Math.floor(_[0]),_1=Math.floor(_[1]);0<=_0&&0<=_1||vegaUtil.error(\"invalid size\");return dx=_0,dy=_1,contours};contours.smooth=function(_){return arguments.length?(smooth=_?smoothLinear:noop,contours):smooth===smoothLinear};return contours}function quantize(k,nice,zero){return function(values){var ex=vegaUtil.extent(values);values=zero?Math.min(ex[0],0):ex[0];\nex=ex[1];var span=ex-values;values=nice?d3Array.tickStep(values,ex,k):span/(k+1);return d3Array.range(values,ex,values)}}function Isocontour(params){vegaDataflow.Transform.call(this,null,params)}function levels(values,f,_){var q=quantize(_.levels||10,_.nice,!1!==_.zero);return\"shared\"!==_.resolve?q:q(values.map(function(t){return d3Array.max(f(t).values)}))}function transformPaths(paths,grid,datum,_){var s=_.scale||grid.scale,t=_.translate||grid.translate;vegaUtil.isFunction(s)&&(s=s(datum,_));vegaUtil.isFunction(t)&&\n(t=t(datum,_));if(1!==s&&null!=s||t)datum=(vegaUtil.isNumber(s)?s:s[0])||1,s=(vegaUtil.isNumber(s)?s:s[1])||1,paths.forEach(transform(grid,datum,s,t&&t[0]||0,t&&t[1]||0))}function transform(grid,sx,sy,tx,ty){function transformPolygon(coordinates){coordinates.forEach(transformRing)}function transformRing(coordinates){flip&&coordinates.reverse();coordinates.forEach(transformPoint)}function transformPoint(coordinates){coordinates[0]=(coordinates[0]-x1)*sx+tx;coordinates[1]=(coordinates[1]-y1)*sy+ty}\nvar x1=grid.x1||0,y1=grid.y1||0,flip=0>sx*sy;return function(geometry){geometry.coordinates.forEach(transformPolygon);return geometry}}function radius(bw,data,f){bw=0<=bw?bw:vegaStatistics.bandwidthNRD(data,f);return Math.round((Math.sqrt(4*bw*bw+1)-1)/2)}function number(_){return vegaUtil.isFunction(_)?_:vegaUtil.constant(+_)}function density2D(){function density(data,counts){var rx=radius(bandwidth[0],data,x)>>k,ry=radius(bandwidth[1],data,y)>>k,ox=rx?rx+2:0,oy=ry?ry+2:0,n=2*ox+(dx>>k),m=2*oy+(dy>>\nk),values0=new Float32Array(n*m),values1=new Float32Array(n*m),values=values0;data.forEach(function(d){var xi=ox+(+x(d)>>k),yi=oy+(+y(d)>>k);0<=xi&&xi<n&&0<=yi&&yi<m&&(values0[xi+yi*n]+=+weight(d))});0<rx&&0<ry?(blurX(n,m,values0,values1,rx),blurY(n,m,values1,values0,ry),blurX(n,m,values0,values1,rx),blurY(n,m,values1,values0,ry),blurX(n,m,values0,values1,rx),blurY(n,m,values1,values0,ry)):0<rx?(blurX(n,m,values0,values1,rx),blurX(n,m,values1,values0,rx),blurX(n,m,values0,values1,rx),values=values1):\n0<ry&&(blurY(n,m,values0,values1,ry),blurY(n,m,values1,values0,ry),blurY(n,m,values0,values1,ry),values=values1);data=counts?Math.pow(2,-2*k):1/d3Array.sum(values);counts=0;for(rx=n*m;counts<rx;++counts)values[counts]*=data;return{values:values,scale:1<<k,width:n,height:m,x1:ox,y1:oy,x2:ox+(dx>>k),y2:oy+(dy>>k)}}var x=function(d){return d[0]},y=function(d){return d[1]},weight=vegaUtil.one,bandwidth=[-1,-1],dx=960,dy=500,k=2;density.x=function(_){return arguments.length?(x=number(_),density):x};density.y=\nfunction(_){return arguments.length?(y=number(_),density):y};density.weight=function(_){return arguments.length?(weight=number(_),density):weight};density.size=function(_){if(!arguments.length)return[dx,dy];var _0=+_[0],_1=+_[1];0<=_0&&0<=_1||vegaUtil.error(\"invalid size\");return dx=_0,dy=_1,density};density.cellSize=function(_){if(!arguments.length)return 1<<k;1<=(_=+_)||vegaUtil.error(\"invalid cell size\");k=Math.floor(Math.log(_)/Math.LN2);return density};density.bandwidth=function(_){if(!arguments.length)return bandwidth;\n_=vegaUtil.array(_);1===_.length&&(_=[+_[0],+_[0]]);2!==_.length&&vegaUtil.error(\"invalid bandwidth\");return bandwidth=_,density};return density}function blurX(n,m,source,target,r){for(var w=(r<<1)+1,j=0;j<m;++j)for(var i=0,sr=0;i<n+r;++i)i<n&&(sr+=source[i+j*n]),i>=r&&(i>=w&&(sr-=source[i-w+j*n]),target[i-r+j*n]=sr/Math.min(i+1,n-1+w-i,w))}function blurY(n,m,source,target,r){for(var w=(r<<1)+1,i=0;i<n;++i)for(var j=0,sr=0;j<m+r;++j)j<m&&(sr+=source[i+j*n]),j>=r&&(j>=w&&(sr-=source[i+(j-w)*n]),target[i+\n(j-r)*n]=sr/Math.min(j+1,m-1+w-j,w))}function KDE2D(params){vegaDataflow.Transform.call(this,null,params)}function params$jscomp$0(obj,_){PARAMS.forEach(function(param){return null!=_[param]?obj[param](_[param]):0});return obj}function partition(data,groupby){var groups=[],get=function(f){return f(t)},n;if(null==groupby)groups.push(data);else{var map={};var i=0;for(n=data.length;i<n;++i){var t=data[i];var k=groupby.map(get);var g=map[k];g||(map[k]=g=[],g.dims=k,groups.push(g));g.push(t)}}return groups}\nfunction Contour(params){vegaDataflow.Transform.call(this,null,params)}function GeoJSON(params){vegaDataflow.Transform.call(this,null,params)}function GeoPath(params){vegaDataflow.Transform.call(this,null,params)}function initPath(path,pointRadius){var prev=path.pointRadius();path.context(null);null!=pointRadius&&path.pointRadius(pointRadius);return prev}function GeoPoint(params){vegaDataflow.Transform.call(this,null,params)}function GeoShape(params){vegaDataflow.Transform.call(this,null,params)}\nfunction shapeGenerator(path,field,pointRadius){var shape=null==pointRadius?function(_){return path(field(_))}:function(_){var prev=path.pointRadius();_=path.pointRadius(pointRadius)(field(_));path.pointRadius(prev);return _};shape.context=function(_){path.context(_);return shape};return shape}function Graticule(params){vegaDataflow.Transform.call(this,[],params);this.generator=d3Geo.geoGraticule()}function Heatmap(params){vegaDataflow.Transform.call(this,null,params)}function color_(color,_){if(vegaUtil.isFunction(color)){var f=\nfunction(obj){return d3Color.rgb(color(obj,_))};f.dep=dependency(color)}else f=vegaUtil.constant(d3Color.rgb(color||\"#888\"));return f}function opacity_(opacity,_){if(vegaUtil.isFunction(opacity)){var f=function(obj){return opacity(obj,_)};f.dep=dependency(opacity)}else opacity?f=vegaUtil.constant(opacity):(f=function(obj){return obj.$value/obj.$max||0},f.dep=!0);return f}function dependency(f){if(!vegaUtil.isFunction(f))return!1;f=vegaUtil.toSet(vegaUtil.accessorFields(f));return f.$x||f.$y||f.$value||\nf.$max}function toCanvas(grid,obj,color,opacity){var n=grid.width,m=grid.height,x1=grid.x1||0,y1=grid.y1||0,x2=grid.x2||n;m=grid.y2||m;var val=grid.values;grid=val?function(i){return val[i]}:vegaUtil.zero;for(var can=vegaCanvas.canvas(x2-x1,m-y1),ctx=can.getContext(\"2d\"),img=ctx.getImageData(0,0,x2-x1,m-y1),pix=img.data,j=y1,k=0;j<m;++j){obj.$y=j-y1;for(var i$jscomp$0=x1,r=j*n;i$jscomp$0<x2;++i$jscomp$0,k+=4){obj.$x=i$jscomp$0-x1;obj.$value=grid(i$jscomp$0+r);var v=color(obj);pix[k+0]=v.r;pix[k+1]=\nv.g;pix[k+2]=v.b;pix[k+3]=~~(255*opacity(obj))}}ctx.putImageData(img,0,0);return can}function Projection(params){vegaDataflow.Transform.call(this,null,params);this.modified(!0)}function fit(proj,_){var data=collectGeoJSON(_.fit);_.extent?proj.fitExtent(_.extent,data):_.size?proj.fitSize(_.size,data):0}function create(type){var constructor=vegaProjection.projection((type||\"mercator\").toLowerCase());constructor||vegaUtil.error(\"Unrecognized projection type: \"+type);return constructor()}function collectGeoJSON(data){data=\nvegaUtil.array(data);return 1===data.length?data[0]:{type:\"FeatureCollection\",features:data.reduce(function(a,f){return a.concat(featurize(f))},[])}}function featurize(f){return\"FeatureCollection\"===f.type?f.features:vegaUtil.array(f).filter(function(d){return null!=d}).map(function(d){return\"Feature\"===d.type?d:{type:\"Feature\",geometry:d}})}var cases=[[],[[[1,1.5],[.5,1]]],[[[1.5,1],[1,1.5]]],[[[1.5,1],[.5,1]]],[[[1,.5],[1.5,1]]],[[[1,1.5],[.5,1]],[[1,.5],[1.5,1]]],[[[1,.5],[1,1.5]]],[[[1,.5],[.5,\n1]]],[[[.5,1],[1,.5]]],[[[1,1.5],[1,.5]]],[[[.5,1],[1,.5]],[[1.5,1],[1,1.5]]],[[[1.5,1],[1,.5]]],[[[.5,1],[1.5,1]]],[[[1,1.5],[1.5,1]]],[[[.5,1],[1,1.5]]],[]];Isocontour.Definition={type:\"Isocontour\",metadata:{generates:!0},params:[{name:\"field\",type:\"field\"},{name:\"thresholds\",type:\"number\",array:!0},{name:\"levels\",type:\"number\"},{name:\"nice\",type:\"boolean\",\"default\":!1},{name:\"resolve\",type:\"enum\",values:[\"shared\",\"independent\"],\"default\":\"independent\"},{name:\"zero\",type:\"boolean\",\"default\":!0},\n{name:\"smooth\",type:\"boolean\",\"default\":!0},{name:\"scale\",type:\"number\",expr:!0},{name:\"translate\",type:\"number\",array:!0,expr:!0},{name:\"as\",type:\"string\",\"null\":!0,\"default\":\"contour\"}]};vegaUtil.inherits(Isocontour,vegaDataflow.Transform,{transform:function(_,pulse){if(this.value&&!pulse.changed()&&!_.modified())return pulse.StopPropagation;var out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);pulse=pulse.materialize(pulse.SOURCE).source;var field=_.field||vegaUtil.identity,contour=contours().smooth(!1!==\n_.smooth),tz=_.thresholds||levels(pulse,field,_),as=null===_.as?null:_.as||\"contour\",values=[];pulse.forEach(function(t){var grid=field(t),paths=contour.size([grid.width,grid.height])(grid.values,vegaUtil.isArray(tz)?tz:tz(grid.values));transformPaths(paths,grid,t,_);paths.forEach(function(p){var $jscomp$compprop11={};values.push(vegaDataflow.rederive(t,vegaDataflow.ingest(null!=as?($jscomp$compprop11[as]=p,$jscomp$compprop11):p)))})});this.value&&(out.rem=this.value);this.value=out.source=out.add=\nvalues;return out}});KDE2D.Definition={type:\"KDE2D\",metadata:{generates:!0},params:[{name:\"size\",type:\"number\",array:!0,length:2,required:!0},{name:\"x\",type:\"field\",required:!0},{name:\"y\",type:\"field\",required:!0},{name:\"weight\",type:\"field\"},{name:\"groupby\",type:\"field\",array:!0},{name:\"cellSize\",type:\"number\"},{name:\"bandwidth\",type:\"number\",array:!0,length:2},{name:\"counts\",type:\"boolean\",\"default\":!1},{name:\"as\",type:\"string\",\"default\":\"grid\"}]};var PARAMS=\"x y weight size cellSize bandwidth\".split(\" \");\nvegaUtil.inherits(KDE2D,vegaDataflow.Transform,{transform:function(_,pulse){function set(t,vals){for(var i=0;i<names.length;++i)t[names[i]]=vals[i];return t}if(this.value&&!pulse.changed()&&!_.modified())return pulse.StopPropagation;var out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);pulse=pulse.materialize(pulse.SOURCE).source;pulse=partition(pulse,_.groupby);var names=(_.groupby||[]).map(vegaUtil.accessorName),kde=params$jscomp$0(density2D(),_),as=_.as||\"grid\",values=[];values=pulse.map(function(g){var $jscomp$compprop12=\n{};return vegaDataflow.ingest(set(($jscomp$compprop12[as]=kde(g,_.counts),$jscomp$compprop12),g.dims))});this.value&&(out.rem=this.value);this.value=out.source=out.add=values;return out}});Contour.Definition={type:\"Contour\",metadata:{generates:!0},params:[{name:\"size\",type:\"number\",array:!0,length:2,required:!0},{name:\"values\",type:\"number\",array:!0},{name:\"x\",type:\"field\"},{name:\"y\",type:\"field\"},{name:\"weight\",type:\"field\"},{name:\"cellSize\",type:\"number\"},{name:\"bandwidth\",type:\"number\"},{name:\"count\",\ntype:\"number\"},{name:\"nice\",type:\"boolean\",\"default\":!1},{name:\"thresholds\",type:\"number\",array:!0},{name:\"smooth\",type:\"boolean\",\"default\":!0}]};vegaUtil.inherits(Contour,vegaDataflow.Transform,{transform:function(_,pulse){if(this.value&&!pulse.changed()&&!_.modified())return pulse.StopPropagation;var out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),contour=contours().smooth(!1!==_.smooth),values=_.values,thresh=_.thresholds||quantize(_.count||10,_.nice,!!values),size=_.size;if(!values){values=pulse.materialize(pulse.SOURCE).source;\n_=params$jscomp$0(density2D(),_)(values,!0);var post=transform(_,_.scale||1,_.scale||1,0,0);size=[_.width,_.height];values=_.values}thresh=vegaUtil.isArray(thresh)?thresh:thresh(values);values=contour.size(size)(values,thresh);post&&values.forEach(post);this.value&&(out.rem=this.value);this.value=out.source=out.add=(values||[]).map(vegaDataflow.ingest);return out}});GeoJSON.Definition={type:\"GeoJSON\",metadata:{},params:[{name:\"fields\",type:\"field\",array:!0,length:2},{name:\"geojson\",type:\"field\"}]};\nvegaUtil.inherits(GeoJSON,vegaDataflow.Transform,{transform:function(_,pulse){var features=this._features,points=this._points,fields=_.fields,lon=fields&&fields[0],lat=fields&&fields[1],geojson=_.geojson||!fields&&vegaUtil.identity;fields=pulse.ADD;_=_.modified()||pulse.changed(pulse.REM)||pulse.modified(vegaUtil.accessorFields(geojson))||lon&&pulse.modified(vegaUtil.accessorFields(lon))||lat&&pulse.modified(vegaUtil.accessorFields(lat));if(!this.value||_)fields=pulse.SOURCE,this._features=features=\n[],this._points=points=[];geojson&&pulse.visit(fields,function(t){return features.push(geojson(t))});lon&&lat&&(pulse.visit(fields,function(t){var x=lon(t);t=lat(t);null!=x&&null!=t&&(x=+x)===x&&(t=+t)===t&&points.push([x,t])}),features=features.concat({type:\"Feature\",geometry:{type:\"MultiPoint\",coordinates:points}}));this.value={type:\"FeatureCollection\",features:features}}});GeoPath.Definition={type:\"GeoPath\",metadata:{modifies:!0},params:[{name:\"projection\",type:\"projection\"},{name:\"field\",type:\"field\"},\n{name:\"pointRadius\",type:\"number\",expr:!0},{name:\"as\",type:\"string\",\"default\":\"path\"}]};vegaUtil.inherits(GeoPath,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.ALL),path=this.value,field=_.field||vegaUtil.identity,as=_.as||\"path\",flag=out.SOURCE;!path||_.modified()?(this.value=path=vegaProjection.getProjectionPath(_.projection),out.materialize().reflow()):flag=field===vegaUtil.identity||pulse.modified(field.fields)?out.ADD_MOD:out.ADD;_=initPath(path,_.pointRadius);\nout.visit(flag,function(t){return t[as]=path(field(t))});path.pointRadius(_);return out.modifies(as)}});GeoPoint.Definition={type:\"GeoPoint\",metadata:{modifies:!0},params:[{name:\"projection\",type:\"projection\",required:!0},{name:\"fields\",type:\"field\",array:!0,required:!0,length:2},{name:\"as\",type:\"string\",array:!0,length:2,\"default\":[\"x\",\"y\"]}]};vegaUtil.inherits(GeoPoint,vegaDataflow.Transform,{transform:function(_,pulse){function set(t){var xy=proj([lon(t),lat(t)]);xy?(t[x]=xy[0],t[y]=xy[1]):(t[x]=\nvoid 0,t[y]=void 0)}var proj=_.projection,lon=_.fields[0],lat=_.fields[1],as=_.as||[\"x\",\"y\"],x=as[0],y=as[1];_.modified()?pulse=pulse.materialize().reflow(!0).visit(pulse.SOURCE,set):(_=pulse.modified(lon.fields)||pulse.modified(lat.fields),pulse.visit(_?pulse.ADD_MOD:pulse.ADD,set));return pulse.modifies(as)}});GeoShape.Definition={type:\"GeoShape\",metadata:{modifies:!0,nomod:!0},params:[{name:\"projection\",type:\"projection\"},{name:\"field\",type:\"field\",\"default\":\"datum\"},{name:\"pointRadius\",type:\"number\",\nexpr:!0},{name:\"as\",type:\"string\",\"default\":\"shape\"}]};vegaUtil.inherits(GeoShape,vegaDataflow.Transform,{transform:function(_,pulse){pulse=pulse.fork(pulse.ALL);var shape=this.value,as=_.as||\"shape\",flag=pulse.ADD;if(!shape||_.modified())this.value=shape=shapeGenerator(vegaProjection.getProjectionPath(_.projection),_.field||vegaUtil.field(\"datum\"),_.pointRadius),pulse.materialize().reflow(),flag=pulse.SOURCE;pulse.visit(flag,function(t){return t[as]=shape});return pulse.modifies(as)}});Graticule.Definition=\n{type:\"Graticule\",metadata:{changes:!0,generates:!0},params:[{name:\"extent\",type:\"array\",array:!0,length:2,content:{type:\"number\",array:!0,length:2}},{name:\"extentMajor\",type:\"array\",array:!0,length:2,content:{type:\"number\",array:!0,length:2}},{name:\"extentMinor\",type:\"array\",array:!0,length:2,content:{type:\"number\",array:!0,length:2}},{name:\"step\",type:\"number\",array:!0,length:2},{name:\"stepMajor\",type:\"number\",array:!0,length:2,\"default\":[90,360]},{name:\"stepMinor\",type:\"number\",array:!0,length:2,\n\"default\":[10,10]},{name:\"precision\",type:\"number\",\"default\":2.5}]};vegaUtil.inherits(Graticule,vegaDataflow.Transform,{transform:function(_,pulse){var src=this.value,gen=this.generator;if(!src.length||_.modified())for(var prop in _)if(vegaUtil.isFunction(gen[prop]))gen[prop](_[prop]);_=gen();src.length?pulse.mod.push(vegaDataflow.replace(src[0],_)):pulse.add.push(vegaDataflow.ingest(_));src[0]=_;return pulse}});Heatmap.Definition={type:\"heatmap\",metadata:{modifies:!0},params:[{name:\"field\",type:\"field\"},\n{name:\"color\",type:\"string\",expr:!0},{name:\"opacity\",type:\"number\",expr:!0},{name:\"resolve\",type:\"enum\",values:[\"shared\",\"independent\"],\"default\":\"independent\"},{name:\"as\",type:\"string\",\"default\":\"image\"}]};vegaUtil.inherits(Heatmap,vegaDataflow.Transform,{transform:function(_,pulse){if(!pulse.changed()&&!_.modified())return pulse.StopPropagation;var source=pulse.materialize(pulse.SOURCE).source,shared=\"shared\"===_.resolve,field=_.field||vegaUtil.identity,opacity=opacity_(_.opacity,_),color=color_(_.color,\n_),as=_.as||\"image\",obj={$x:0,$y:0,$value:0,$max:shared?d3Array.max(source.map(function(t){return d3Array.max(field(t).values)})):0};source.forEach(function(t){var v=field(t),o=vegaUtil.extend({},t,obj);shared||(o.$max=d3Array.max(v.values||[]));t[as]=toCanvas(v,o,color.dep?color:vegaUtil.constant(color(o)),opacity.dep?opacity:vegaUtil.constant(opacity(o)))});return pulse.reflow(!0).modifies(as)}});vegaUtil.inherits(Projection,vegaDataflow.Transform,{transform:function(_,pulse){var proj$jscomp$0=\nthis.value;!proj$jscomp$0||_.modified(\"type\")?(this.value=proj$jscomp$0=create(_.type),vegaProjection.projectionProperties.forEach(function(prop){if(null!=_[prop]){var proj=proj$jscomp$0,value=_[prop];if(vegaUtil.isFunction(proj[prop]))proj[prop](value)}})):vegaProjection.projectionProperties.forEach(function(prop){if(_.modified(prop)){var proj=proj$jscomp$0,value=_[prop];if(vegaUtil.isFunction(proj[prop]))proj[prop](value)}});null!=_.pointRadius&&proj$jscomp$0.path.pointRadius(_.pointRadius);_.fit&&\nfit(proj$jscomp$0,_);return pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS)}});exports.contour=Contour;exports.geojson=GeoJSON;exports.geopath=GeoPath;exports.geopoint=GeoPoint;exports.geoshape=GeoShape;exports.graticule=Graticule;exports.heatmap=Heatmap;exports.isocontour=Isocontour;exports.kde2d=KDE2D;exports.projection=Projection;Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_geo$build$vega_geo\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-dataflow'), require('vega-util'), require('d3-array'), require('vega-statistics'), require('vega-projection'), require('d3-geo'), require('d3-color'), require('vega-canvas')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-dataflow', 'vega-util', 'd3-array', 'vega-statistics', 'vega-projection', 'd3-geo', 'd3-color', 'vega-canvas'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.d3, global.vega, global.vega, global.d3, global.d3, global.vega));\n}(this, (function (exports, vegaDataflow, vegaUtil, d3Array, vegaStatistics, vegaProjection, d3Geo, d3Color, vegaCanvas) { 'use strict';\n\n  function noop() {}\n\n  const cases = [\n    [],\n    [[[1.0, 1.5], [0.5, 1.0]]],\n    [[[1.5, 1.0], [1.0, 1.5]]],\n    [[[1.5, 1.0], [0.5, 1.0]]],\n    [[[1.0, 0.5], [1.5, 1.0]]],\n    [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],\n    [[[1.0, 0.5], [1.0, 1.5]]],\n    [[[1.0, 0.5], [0.5, 1.0]]],\n    [[[0.5, 1.0], [1.0, 0.5]]],\n    [[[1.0, 1.5], [1.0, 0.5]]],\n    [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],\n    [[[1.5, 1.0], [1.0, 0.5]]],\n    [[[0.5, 1.0], [1.5, 1.0]]],\n    [[[1.0, 1.5], [1.5, 1.0]]],\n    [[[0.5, 1.0], [1.0, 1.5]]],\n    []\n  ];\n\n  // Implementation adapted from d3/d3-contour. Thanks!\n  function contours() {\n    var dx = 1,\n        dy = 1,\n        smooth = smoothLinear;\n\n    function contours(values, tz) {\n      return tz.map(value => contour(values, value));\n    }\n\n    // Accumulate, smooth contour rings, assign holes to exterior rings.\n    // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n    function contour(values, value) {\n      var polygons = [],\n          holes = [];\n\n      isorings(values, value, ring => {\n        smooth(ring, values, value);\n        if (area(ring) > 0) polygons.push([ring]);\n        else holes.push(ring);\n      });\n\n      holes.forEach(hole => {\n        for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n          if (contains((polygon = polygons[i])[0], hole) !== -1) {\n            polygon.push(hole);\n            return;\n          }\n        }\n      });\n\n      return {\n        type: 'MultiPolygon',\n        value: value,\n        coordinates: polygons\n      };\n    }\n\n    // Marching squares with isolines stitched into rings.\n    // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n    function isorings(values, value, callback) {\n      var fragmentByStart = new Array,\n          fragmentByEnd = new Array,\n          x, y, t0, t1, t2, t3;\n\n      // Special case for the first row (y = -1, t2 = t3 = 0).\n      x = y = -1;\n      t1 = values[0] >= value;\n      cases[t1 << 1].forEach(stitch);\n      while (++x < dx - 1) {\n        t0 = t1, t1 = values[x + 1] >= value;\n        cases[t0 | t1 << 1].forEach(stitch);\n      }\n      cases[t1 << 0].forEach(stitch);\n\n      // General case for the intermediate rows.\n      while (++y < dy - 1) {\n        x = -1;\n        t1 = values[y * dx + dx] >= value;\n        t2 = values[y * dx] >= value;\n        cases[t1 << 1 | t2 << 2].forEach(stitch);\n        while (++x < dx - 1) {\n          t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;\n          t3 = t2, t2 = values[y * dx + x + 1] >= value;\n          cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n        }\n        cases[t1 | t2 << 3].forEach(stitch);\n      }\n\n      // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n      x = -1;\n      t2 = values[y * dx] >= value;\n      cases[t2 << 2].forEach(stitch);\n      while (++x < dx - 1) {\n        t3 = t2, t2 = values[y * dx + x + 1] >= value;\n        cases[t2 << 2 | t3 << 3].forEach(stitch);\n      }\n      cases[t2 << 3].forEach(stitch);\n\n      function stitch(line) {\n        var start = [line[0][0] + x, line[0][1] + y],\n            end = [line[1][0] + x, line[1][1] + y],\n            startIndex = index(start),\n            endIndex = index(end),\n            f, g;\n        if (f = fragmentByEnd[startIndex]) {\n          if (g = fragmentByStart[endIndex]) {\n            delete fragmentByEnd[f.end];\n            delete fragmentByStart[g.start];\n            if (f === g) {\n              f.ring.push(end);\n              callback(f.ring);\n            } else {\n              fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};\n            }\n          } else {\n            delete fragmentByEnd[f.end];\n            f.ring.push(end);\n            fragmentByEnd[f.end = endIndex] = f;\n          }\n        } else if (f = fragmentByStart[endIndex]) {\n          if (g = fragmentByEnd[startIndex]) {\n            delete fragmentByStart[f.start];\n            delete fragmentByEnd[g.end];\n            if (f === g) {\n              f.ring.push(end);\n              callback(f.ring);\n            } else {\n              fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};\n            }\n          } else {\n            delete fragmentByStart[f.start];\n            f.ring.unshift(start);\n            fragmentByStart[f.start = startIndex] = f;\n          }\n        } else {\n          fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};\n        }\n      }\n    }\n\n    function index(point) {\n      return point[0] * 2 + point[1] * (dx + 1) * 4;\n    }\n\n    function smoothLinear(ring, values, value) {\n      ring.forEach(point => {\n        var x = point[0],\n            y = point[1],\n            xt = x | 0,\n            yt = y | 0,\n            v0,\n            v1 = values[yt * dx + xt];\n        if (x > 0 && x < dx && xt === x) {\n          v0 = values[yt * dx + xt - 1];\n          point[0] = x + (value - v0) / (v1 - v0) - 0.5;\n        }\n        if (y > 0 && y < dy && yt === y) {\n          v0 = values[(yt - 1) * dx + xt];\n          point[1] = y + (value - v0) / (v1 - v0) - 0.5;\n        }\n      });\n    }\n\n    contours.contour = contour;\n\n    contours.size = function(_) {\n      if (!arguments.length) return [dx, dy];\n      var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);\n      if (!(_0 >= 0 && _1 >= 0)) vegaUtil.error('invalid size');\n      return dx = _0, dy = _1, contours;\n    };\n\n    contours.smooth = function(_) {\n      return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n    };\n\n    return contours;\n  }\n\n  function area(ring) {\n    var i = 0,\n        n = ring.length,\n        area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n    while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n    return area;\n  }\n\n  function contains(ring, hole) {\n    var i = -1, n = hole.length, c;\n    while (++i < n) if (c = ringContains(ring, hole[i])) return c;\n    return 0;\n  }\n\n  function ringContains(ring, point) {\n    var x = point[0], y = point[1], contains = -1;\n    for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n      var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];\n      if (segmentContains(pi, pj, point)) return 0;\n      if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;\n    }\n    return contains;\n  }\n\n  function segmentContains(a, b, c) {\n    var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);\n  }\n\n  function collinear(a, b, c) {\n    return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);\n  }\n\n  function within(p, q, r) {\n    return p <= q && q <= r || r <= q && q <= p;\n  }\n\n  function quantize(k, nice, zero) {\n    return function(values) {\n      var ex = vegaUtil.extent(values),\n          start = zero ? Math.min(ex[0], 0) : ex[0],\n          stop = ex[1],\n          span = stop - start,\n          step = nice ? d3Array.tickStep(start, stop, k) : (span / (k + 1));\n      return d3Array.range(step, stop, step);\n    };\n  }\n\n  /**\n   * Generate isocontours (level sets) based on input raster grid data.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} [params.field] - The field with raster grid\n   *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n   * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n   *   specified, the levels, nice, resolve, and zero parameters are ignored.\n   * @param {number} [params.levels] - The desired number of contour levels.\n   * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n   *   threshold values should be automatically aligned to \"nice\"\n   *   human-friendly values. Setting this flag may cause the number of\n   *   thresholds to deviate from the specified levels.\n   * @param {string} [params.resolve] - The method for resolving thresholds\n   *   across multiple input grids. If 'independent' (the default), threshold\n   *   calculation will be performed separately for each grid. If 'shared', a\n   *   single set of threshold values will be used for all input grids.\n   * @param {boolean} [params.zero] - Boolean flag indicating if the contour\n   *   threshold values should include zero.\n   * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n   *   polygons should be smoothed using linear interpolation. The default is\n   *   true. The parameter is ignored when using density estimation.\n   * @param {boolean} [params.scale] - Optional numerical value by which to\n   *   scale the output isocontour coordinates. This parameter can be useful\n   *   to scale the contours to match a desired output resolution.\n   * @param {string} [params.as='contour'] - The output field in which to store\n   *   the generated isocontour data (default 'contour').\n   */\n  function Isocontour(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Isocontour.Definition = {\n    'type': 'Isocontour',\n    'metadata': {'generates': true},\n    'params': [\n      { 'name': 'field', 'type': 'field' },\n      { 'name': 'thresholds', 'type': 'number', 'array': true },\n      { 'name': 'levels', 'type': 'number' },\n      { 'name': 'nice', 'type': 'boolean', 'default': false },\n      { 'name': 'resolve', 'type': 'enum', 'values': ['shared', 'independent'], 'default': 'independent' },\n      { 'name': 'zero', 'type': 'boolean', 'default': true },\n      { 'name': 'smooth', 'type': 'boolean', 'default': true },\n      { 'name': 'scale', 'type': 'number', 'expr': true },\n      { 'name': 'translate', 'type': 'number', 'array': true, 'expr': true },\n      { 'name': 'as', 'type': 'string', 'null': true, 'default': 'contour' }\n    ]\n  };\n\n  vegaUtil.inherits(Isocontour, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      if (this.value && !pulse.changed() && !_.modified()) {\n        return pulse.StopPropagation;\n      }\n\n      var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n          source = pulse.materialize(pulse.SOURCE).source,\n          field = _.field || vegaUtil.identity,\n          contour = contours().smooth(_.smooth !== false),\n          tz = _.thresholds || levels(source, field, _),\n          as = _.as === null ? null : _.as || 'contour',\n          values = [];\n\n      source.forEach(t => {\n        const grid = field(t);\n\n        // generate contour paths in GeoJSON format\n        const paths = contour.size([grid.width, grid.height])(\n          grid.values, vegaUtil.isArray(tz) ? tz : tz(grid.values)\n        );\n\n        // adjust contour path coordinates as needed\n        transformPaths(paths, grid, t, _);\n\n        // ingest; copy source data properties to output\n        paths.forEach(p => {\n          values.push(vegaDataflow.rederive(t, vegaDataflow.ingest(as != null ? {[as]: p} : p)));\n        });\n      });\n\n      if (this.value) out.rem = this.value;\n      this.value = out.source = out.add = values;\n\n      return out;\n    }\n  });\n\n  function levels(values, f, _) {\n    const q = quantize(_.levels || 10, _.nice, _.zero !== false);\n    return _.resolve !== 'shared'\n      ? q\n      : q(values.map(t => d3Array.max(f(t).values)));\n  }\n\n  function transformPaths(paths, grid, datum, _) {\n    let s = _.scale || grid.scale,\n        t = _.translate || grid.translate;\n    if (vegaUtil.isFunction(s)) s = s(datum, _);\n    if (vegaUtil.isFunction(t)) t = t(datum, _);\n    if ((s === 1 || s == null) && !t) return;\n\n    const sx = (vegaUtil.isNumber(s) ? s : s[0]) || 1,\n          sy = (vegaUtil.isNumber(s) ? s : s[1]) || 1,\n          tx = t && t[0] || 0,\n          ty = t && t[1] || 0;\n\n    paths.forEach(transform(grid, sx, sy, tx, ty));\n  }\n\n  function transform(grid, sx, sy, tx, ty) {\n    const x1 = grid.x1 || 0,\n          y1 = grid.y1 || 0,\n          flip = sx * sy < 0;\n\n    function transformPolygon(coordinates) {\n      coordinates.forEach(transformRing);\n    }\n\n    function transformRing(coordinates) {\n      if (flip) coordinates.reverse(); // maintain winding order\n      coordinates.forEach(transformPoint);\n    }\n\n    function transformPoint(coordinates) {\n      coordinates[0] = (coordinates[0] - x1) * sx + tx;\n      coordinates[1] = (coordinates[1] - y1) * sy + ty;\n    }\n\n    return function(geometry) {\n      geometry.coordinates.forEach(transformPolygon);\n      return geometry;\n    };\n  }\n\n  function radius(bw, data, f) {\n    const v = bw >= 0 ? bw : vegaStatistics.bandwidthNRD(data, f);\n    return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);\n  }\n\n  function number(_) {\n    return vegaUtil.isFunction(_) ? _ : vegaUtil.constant(+_);\n  }\n\n  // Implementation adapted from d3/d3-contour. Thanks!\n  function density2D() {\n    var x = d => d[0],\n        y = d => d[1],\n        weight = vegaUtil.one,\n        bandwidth = [-1, -1],\n        dx = 960,\n        dy = 500,\n        k = 2; // log2(cellSize)\n\n    function density(data, counts) {\n      const rx = radius(bandwidth[0], data, x) >> k, // blur x-radius\n            ry = radius(bandwidth[1], data, y) >> k, // blur y-radius\n            ox = rx ? rx + 2 : 0, // x-offset padding for blur\n            oy = ry ? ry + 2 : 0, // y-offset padding for blur\n            n = 2 * ox + (dx >> k), // grid width\n            m = 2 * oy + (dy >> k), // grid height\n            values0 = new Float32Array(n * m),\n            values1 = new Float32Array(n * m);\n\n      let values = values0;\n\n      data.forEach(d => {\n        const xi = ox + (+x(d) >> k),\n              yi = oy + (+y(d) >> k);\n\n        if (xi >= 0 && xi < n && yi >= 0 && yi < m) {\n          values0[xi + yi * n] += +weight(d);\n        }\n      });\n\n      if (rx > 0 && ry > 0) {\n        blurX(n, m, values0, values1, rx);\n        blurY(n, m, values1, values0, ry);\n        blurX(n, m, values0, values1, rx);\n        blurY(n, m, values1, values0, ry);\n        blurX(n, m, values0, values1, rx);\n        blurY(n, m, values1, values0, ry);\n      } else if (rx > 0) {\n        blurX(n, m, values0, values1, rx);\n        blurX(n, m, values1, values0, rx);\n        blurX(n, m, values0, values1, rx);\n        values = values1;\n      } else if (ry > 0) {\n        blurY(n, m, values0, values1, ry);\n        blurY(n, m, values1, values0, ry);\n        blurY(n, m, values0, values1, ry);\n        values = values1;\n      }\n\n      // scale density estimates\n      // density in points per square pixel or probability density\n      const s = counts ? Math.pow(2, -2 * k) : 1 / d3Array.sum(values);\n      for (let i=0, sz=n*m; i<sz; ++i) values[i] *= s;\n\n      return {\n        values: values,\n        scale: 1 << k,\n        width: n,\n        height: m,\n        x1: ox,\n        y1: oy,\n        x2: ox + (dx >> k),\n        y2: oy + (dy >> k)\n      };\n    }\n\n    density.x = function(_) {\n      return arguments.length ? (x = number(_), density) : x;\n    };\n\n    density.y = function(_) {\n      return arguments.length ? (y = number(_), density) : y;\n    };\n\n    density.weight = function(_) {\n      return arguments.length ? (weight = number(_), density) : weight;\n    };\n\n    density.size = function(_) {\n      if (!arguments.length) return [dx, dy];\n      var _0 = +_[0], _1 = +_[1];\n      if (!(_0 >= 0 && _1 >= 0)) vegaUtil.error('invalid size');\n      return dx = _0, dy = _1, density;\n    };\n\n    density.cellSize = function(_) {\n      if (!arguments.length) return 1 << k;\n      if (!((_ = +_) >= 1)) vegaUtil.error('invalid cell size');\n      k = Math.floor(Math.log(_) / Math.LN2);\n      return density;\n    };\n\n    density.bandwidth = function(_) {\n      if (!arguments.length) return bandwidth;\n      _ = vegaUtil.array(_);\n      if (_.length === 1) _ = [+_[0], +_[0]];\n      if (_.length !== 2) vegaUtil.error('invalid bandwidth');\n      return bandwidth = _, density;\n    };\n\n    return density;\n  }\n\n  function blurX(n, m, source, target, r) {\n    const w = (r << 1) + 1;\n    for (let j = 0; j < m; ++j) {\n      for (let i = 0, sr = 0; i < n + r; ++i) {\n        if (i < n) {\n          sr += source[i + j * n];\n        }\n        if (i >= r) {\n          if (i >= w) {\n            sr -= source[i - w + j * n];\n          }\n          target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);\n        }\n      }\n    }\n  }\n\n  function blurY(n, m, source, target, r) {\n    const w = (r << 1) + 1;\n    for (let i = 0; i < n; ++i) {\n      for (let j = 0, sr = 0; j < m + r; ++j) {\n        if (j < m) {\n          sr += source[i + j * n];\n        }\n        if (j >= r) {\n          if (j >= w) {\n            sr -= source[i + (j - w) * n];\n          }\n          target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);\n        }\n      }\n    }\n  }\n\n  /**\n   * Perform 2D kernel-density estimation of point data.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<number>} params.size - The [width, height] extent (in\n   *   units of input pixels) over which to perform density estimation.\n   * @param {function(object): number} params.x - The x-coordinate accessor.\n   * @param {function(object): number} params.y - The y-coordinate accessor.\n   * @param {function(object): number} [params.weight] - The weight accessor.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n   *   to groupby.\n   * @param {number} [params.cellSize] - Contour density calculation cell size.\n   *   This parameter determines the level of spatial approximation. For example,\n   *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.\n   *   A value of 1 will result in an output raster grid whose dimensions exactly\n   *   matches the size parameter.\n   * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,\n   *   in pixels. The input can be a two-element array specifying separate\n   *   x and y bandwidths, or a single-element array specifying both. If the\n   *   bandwidth is unspecified or less than zero, the bandwidth will be\n   *   automatically determined.\n   * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n   *   output values should be probability estimates (false, default) or\n   *   smoothed counts (true).\n   * @param {string} [params.as='grid'] - The output field in which to store\n   *   the generated raster grid (default 'grid').\n   */\n  function KDE2D(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  KDE2D.Definition = {\n    'type': 'KDE2D',\n    'metadata': {'generates': true},\n    'params': [\n      { 'name': 'size', 'type': 'number', 'array': true, 'length': 2, 'required': true },\n      { 'name': 'x', 'type': 'field', 'required': true },\n      { 'name': 'y', 'type': 'field', 'required': true },\n      { 'name': 'weight', 'type': 'field' },\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'cellSize', 'type': 'number' },\n      { 'name': 'bandwidth', 'type': 'number', 'array': true, 'length': 2 },\n      { 'name': 'counts', 'type': 'boolean', 'default': false },\n      { 'name': 'as', 'type': 'string', 'default': 'grid'}\n    ]\n  };\n\n  const PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];\n\n  function params(obj, _) {\n    PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);\n    return obj;\n  }\n\n  vegaUtil.inherits(KDE2D, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      if (this.value && !pulse.changed() && !_.modified())\n        return pulse.StopPropagation;\n\n      var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n          source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition(source, _.groupby),\n          names = (_.groupby || []).map(vegaUtil.accessorName),\n          kde = params(density2D(), _),\n          as = _.as || 'grid',\n          values = [];\n\n      function set(t, vals) {\n        for (let i=0; i<names.length; ++i) t[names[i]] = vals[i];\n        return t;\n      }\n\n      // generate density raster grids\n      values = groups.map(g => vegaDataflow.ingest(\n        set({[as]: kde(g, _.counts)}, g.dims)\n      ));\n\n      if (this.value) out.rem = this.value;\n      this.value = out.source = out.add = values;\n\n      return out;\n    }\n  });\n\n  function partition(data, groupby) {\n    var groups = [],\n        get = f => f(t),\n        map, i, n, t, k, g;\n\n    // partition data points into groups\n    if (groupby == null) {\n      groups.push(data);\n    } else {\n      for (map={}, i=0, n=data.length; i<n; ++i) {\n        t = data[i];\n        k = groupby.map(get);\n        g = map[k];\n        if (!g) {\n          map[k] = (g = []);\n          g.dims = k;\n          groups.push(g);\n        }\n        g.push(t);\n      }\n    }\n\n    return groups;\n  }\n\n  /**\n   * Generate contours based on kernel-density estimation of point data.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.\n   *  If the values parameter is provided, this must be the dimensions of the input data.\n   *  If density estimation is performed, this is the output view dimensions in pixels.\n   * @param {Array<number>} [params.values] - An array of numeric values representing an\n   *  width x height grid of values over which to compute contours. If unspecified, this\n   *  transform will instead attempt to compute contours for the kernel density estimate\n   *  using values drawn from data tuples in the input pulse.\n   * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.\n   * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.\n   * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.\n   * @param {number} [params.cellSize] - Contour density calculation cell size.\n   * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.\n   * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n   *   this parameter is set, the count and nice parameters will be ignored.\n   * @param {number} [params.count] - The desired number of contours.\n   * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n   *   threshold values should be automatically aligned to \"nice\"\n   *   human-friendly values. Setting this flag may cause the number of\n   *   thresholds to deviate from the specified count.\n   * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n   *   polygons should be smoothed using linear interpolation. The default is\n   *   true. The parameter is ignored when using density estimation.\n   */\n  function Contour(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Contour.Definition = {\n    'type': 'Contour',\n    'metadata': {'generates': true},\n    'params': [\n      { 'name': 'size', 'type': 'number', 'array': true, 'length': 2, 'required': true },\n      { 'name': 'values', 'type': 'number', 'array': true },\n      { 'name': 'x', 'type': 'field' },\n      { 'name': 'y', 'type': 'field' },\n      { 'name': 'weight', 'type': 'field' },\n      { 'name': 'cellSize', 'type': 'number' },\n      { 'name': 'bandwidth', 'type': 'number' },\n      { 'name': 'count', 'type': 'number' },\n      { 'name': 'nice', 'type': 'boolean', 'default': false },\n      { 'name': 'thresholds', 'type': 'number', 'array': true },\n      { 'name': 'smooth', 'type': 'boolean', 'default': true }\n    ]\n  };\n\n  vegaUtil.inherits(Contour, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      if (this.value && !pulse.changed() && !_.modified()) {\n        return pulse.StopPropagation;\n      }\n\n      var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n          contour = contours().smooth(_.smooth !== false),\n          values = _.values,\n          thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),\n          size = _.size, grid, post;\n\n      if (!values) {\n        values = pulse.materialize(pulse.SOURCE).source;\n        grid = params(density2D(), _)(values, true);\n        post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);\n        size = [grid.width, grid.height];\n        values = grid.values;\n      }\n\n      thresh = vegaUtil.isArray(thresh) ? thresh : thresh(values);\n      values = contour.size(size)(values, thresh);\n      if (post) values.forEach(post);\n\n      if (this.value) out.rem = this.value;\n      this.value = out.source = out.add = (values || []).map(vegaDataflow.ingest);\n\n      return out;\n    }\n  });\n\n  var Feature = 'Feature';\n  var FeatureCollection = 'FeatureCollection';\n  var MultiPoint = 'MultiPoint';\n\n  /**\n   * Consolidate an array of [longitude, latitude] points or GeoJSON features\n   * into a combined GeoJSON object. This transform is particularly useful for\n   * combining geo data for a Projection's fit argument. The resulting GeoJSON\n   * data is available as this transform's value. Input pulses are unchanged.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<function(object): *>} [params.fields] - A two-element array\n   *   of field accessors for the longitude and latitude values.\n   * @param {function(object): *} params.geojson - A field accessor for\n   *   retrieving GeoJSON feature data.\n   */\n  function GeoJSON(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  GeoJSON.Definition = {\n    'type': 'GeoJSON',\n    'metadata': {},\n    'params': [\n      { 'name': 'fields', 'type': 'field', 'array': true, 'length': 2 },\n      { 'name': 'geojson', 'type': 'field' }\n    ]\n  };\n\n  vegaUtil.inherits(GeoJSON, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      var features = this._features,\n          points = this._points,\n          fields = _.fields,\n          lon = fields && fields[0],\n          lat = fields && fields[1],\n          geojson = _.geojson || (!fields && vegaUtil.identity),\n          flag = pulse.ADD,\n          mod;\n\n      mod = _.modified()\n        || pulse.changed(pulse.REM)\n        || pulse.modified(vegaUtil.accessorFields(geojson))\n        || (lon && (pulse.modified(vegaUtil.accessorFields(lon))))\n        || (lat && (pulse.modified(vegaUtil.accessorFields(lat))));\n\n      if (!this.value || mod) {\n        flag = pulse.SOURCE;\n        this._features = (features = []);\n        this._points = (points = []);\n      }\n\n      if (geojson) {\n        pulse.visit(flag, t => features.push(geojson(t)));\n      }\n\n      if (lon && lat) {\n        pulse.visit(flag, t => {\n          var x = lon(t),\n              y = lat(t);\n          if (x != null && y != null && (x = +x) === x && (y = +y) === y) {\n            points.push([x, y]);\n          }\n        });\n        features = features.concat({\n          type: Feature,\n          geometry: {\n            type: MultiPoint,\n            coordinates: points\n          }\n        });\n      }\n\n      this.value = {\n        type: FeatureCollection,\n        features: features\n      };\n    }\n  });\n\n  /**\n   * Map GeoJSON data to an SVG path string.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(number, number): *} params.projection - The cartographic\n   *   projection to apply.\n   * @param {function(object): *} [params.field] - The field with GeoJSON data,\n   *   or null if the tuple itself is a GeoJSON feature.\n   * @param {string} [params.as='path'] - The output field in which to store\n   *   the generated path data (default 'path').\n   */\n  function GeoPath(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  GeoPath.Definition = {\n    'type': 'GeoPath',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'projection', 'type': 'projection' },\n      { 'name': 'field', 'type': 'field' },\n      { 'name': 'pointRadius', 'type': 'number', 'expr': true },\n      { 'name': 'as', 'type': 'string', 'default': 'path' }\n    ]\n  };\n\n  vegaUtil.inherits(GeoPath, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      var out = pulse.fork(pulse.ALL),\n          path = this.value,\n          field = _.field || vegaUtil.identity,\n          as = _.as || 'path',\n          flag = out.SOURCE;\n\n      if (!path || _.modified()) {\n        // parameters updated, reset and reflow\n        this.value = path = vegaProjection.getProjectionPath(_.projection);\n        out.materialize().reflow();\n      } else {\n        flag = field === vegaUtil.identity || pulse.modified(field.fields)\n          ? out.ADD_MOD\n          : out.ADD;\n      }\n\n      var prev = initPath(path, _.pointRadius);\n      out.visit(flag, t => t[as] = path(field(t)));\n      path.pointRadius(prev);\n\n      return out.modifies(as);\n    }\n  });\n\n  function initPath(path, pointRadius) {\n    var prev = path.pointRadius();\n    path.context(null);\n    if (pointRadius != null) {\n      path.pointRadius(pointRadius);\n    }\n    return prev;\n  }\n\n  /**\n   * Geo-code a longitude/latitude point to an x/y coordinate.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(number, number): *} params.projection - The cartographic\n   *   projection to apply.\n   * @param {Array<function(object): *>} params.fields - A two-element array of\n   *   field accessors for the longitude and latitude values.\n   * @param {Array<string>} [params.as] - A two-element array of field names\n   *   under which to store the result. Defaults to ['x','y'].\n   */\n  function GeoPoint(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  GeoPoint.Definition = {\n    'type': 'GeoPoint',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'projection', 'type': 'projection', 'required': true },\n      { 'name': 'fields', 'type': 'field', 'array': true, 'required': true, 'length': 2 },\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['x', 'y'] }\n    ]\n  };\n\n  vegaUtil.inherits(GeoPoint, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      var proj = _.projection,\n          lon = _.fields[0],\n          lat = _.fields[1],\n          as = _.as || ['x', 'y'],\n          x = as[0],\n          y = as[1],\n          mod;\n\n      function set(t) {\n        var xy = proj([lon(t), lat(t)]);\n        if (xy) {\n          t[x] = xy[0];\n          t[y] = xy[1];\n        } else {\n          t[x] = undefined;\n          t[y] = undefined;\n        }\n      }\n\n      if (_.modified()) {\n        // parameters updated, reflow\n        pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);\n      } else {\n        mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);\n        pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);\n      }\n\n      return pulse.modifies(as);\n    }\n  });\n\n  /**\n   * Annotate items with a geopath shape generator.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(number, number): *} params.projection - The cartographic\n   *   projection to apply.\n   * @param {function(object): *} [params.field] - The field with GeoJSON data,\n   *   or null if the tuple itself is a GeoJSON feature.\n   * @param {string} [params.as='shape'] - The output field in which to store\n   *   the generated path data (default 'shape').\n   */\n  function GeoShape(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  GeoShape.Definition = {\n    'type': 'GeoShape',\n    'metadata': {'modifies': true, 'nomod': true},\n    'params': [\n      { 'name': 'projection', 'type': 'projection' },\n      { 'name': 'field', 'type': 'field', 'default': 'datum' },\n      { 'name': 'pointRadius', 'type': 'number', 'expr': true },\n      { 'name': 'as', 'type': 'string', 'default': 'shape' }\n    ]\n  };\n\n  vegaUtil.inherits(GeoShape, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      var out = pulse.fork(pulse.ALL),\n          shape = this.value,\n          as = _.as || 'shape',\n          flag = out.ADD;\n\n      if (!shape || _.modified()) {\n        // parameters updated, reset and reflow\n        this.value = shape = shapeGenerator(\n          vegaProjection.getProjectionPath(_.projection),\n          _.field || vegaUtil.field('datum'),\n          _.pointRadius\n        );\n        out.materialize().reflow();\n        flag = out.SOURCE;\n      }\n\n      out.visit(flag, t => t[as] = shape);\n\n      return out.modifies(as);\n    }\n  });\n\n  function shapeGenerator(path, field, pointRadius) {\n    var shape = pointRadius == null\n      ? _ => path(field(_))\n      : _ => {\n        var prev = path.pointRadius(),\n            value = path.pointRadius(pointRadius)(field(_));\n        path.pointRadius(prev);\n        return value;\n      };\n    shape.context = _ => {\n      path.context(_);\n      return shape;\n    };\n\n    return shape;\n  }\n\n  /**\n   * GeoJSON feature generator for creating graticules.\n   * @constructor\n   */\n  function Graticule(params) {\n    vegaDataflow.Transform.call(this, [], params);\n    this.generator = d3Geo.geoGraticule();\n  }\n\n  Graticule.Definition = {\n    'type': 'Graticule',\n    'metadata': {'changes': true, 'generates': true},\n    'params': [\n      { 'name': 'extent', 'type': 'array', 'array': true, 'length': 2,\n        'content': {'type': 'number', 'array': true, 'length': 2} },\n      { 'name': 'extentMajor', 'type': 'array', 'array': true, 'length': 2,\n        'content': {'type': 'number', 'array': true, 'length': 2} },\n      { 'name': 'extentMinor', 'type': 'array', 'array': true, 'length': 2,\n        'content': {'type': 'number', 'array': true, 'length': 2} },\n      { 'name': 'step', 'type': 'number', 'array': true, 'length': 2 },\n      { 'name': 'stepMajor', 'type': 'number', 'array': true, 'length': 2, 'default': [90, 360] },\n      { 'name': 'stepMinor', 'type': 'number', 'array': true, 'length': 2, 'default': [10, 10] },\n      { 'name': 'precision', 'type': 'number', 'default': 2.5 }\n    ]\n  };\n\n  vegaUtil.inherits(Graticule, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      var src = this.value,\n          gen = this.generator, t;\n\n      if (!src.length || _.modified()) {\n        for (var prop in _) {\n          if (vegaUtil.isFunction(gen[prop])) {\n            gen[prop](_[prop]);\n          }\n        }\n      }\n\n      t = gen();\n      if (src.length) {\n        pulse.mod.push(vegaDataflow.replace(src[0], t));\n      } else {\n        pulse.add.push(vegaDataflow.ingest(t));\n      }\n      src[0] = t;\n\n      return pulse;\n    }\n  });\n\n  /**\n   * Render a heatmap image for input raster grid data.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} [params.field] - The field with raster grid\n   *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n   * @param {string} [params.color] - A constant color value or function for\n   *   individual pixel color. If a function, it will be invoked with an input\n   *   object that includes $x, $y, $value, and $max fields for the grid.\n   * @param {number} [params.opacity] - A constant opacity value or function for\n   *   individual pixel opacity. If a function, it will be invoked with an input\n   *   object that includes $x, $y, $value, and $max fields for the grid.\n   * @param {string} [params.resolve] - The method for resolving maximum values\n   *   across multiple input grids. If 'independent' (the default), maximum\n   *   calculation will be performed separately for each grid. If 'shared',\n   *   a single global maximum will be used for all input grids.\n   * @param {string} [params.as='image'] - The output field in which to store\n   *   the generated bitmap canvas images (default 'image').\n   */\n  function Heatmap(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Heatmap.Definition = {\n    'type': 'heatmap',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'field', 'type': 'field' },\n      { 'name': 'color', 'type': 'string', 'expr': true},\n      { 'name': 'opacity', 'type': 'number', 'expr': true},\n      { 'name': 'resolve', 'type': 'enum', 'values': ['shared', 'independent'], 'default': 'independent' },\n      { 'name': 'as', 'type': 'string', 'default': 'image' }\n    ]\n  };\n\n  vegaUtil.inherits(Heatmap, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      if (!pulse.changed() && !_.modified()) {\n        return pulse.StopPropagation;\n      }\n\n      var source = pulse.materialize(pulse.SOURCE).source,\n          shared = _.resolve === 'shared',\n          field = _.field || vegaUtil.identity,\n          opacity = opacity_(_.opacity, _),\n          color = color_(_.color, _),\n          as = _.as || 'image',\n          obj = {\n            $x: 0, $y: 0, $value: 0,\n            $max: shared ? d3Array.max(source.map(t => d3Array.max(field(t).values))) : 0\n          };\n\n      source.forEach(t => {\n        const v = field(t);\n\n        // build proxy data object\n        const o = vegaUtil.extend({}, t, obj);\n        // set maximum value if not globally shared\n        if (!shared) o.$max = d3Array.max(v.values || []);\n\n        // generate canvas image\n        // optimize color/opacity if not pixel-dependent\n        t[as] = toCanvas(v, o,\n          color.dep ? color : vegaUtil.constant(color(o)),\n          opacity.dep ? opacity : vegaUtil.constant(opacity(o))\n        );\n      });\n\n      return pulse.reflow(true).modifies(as);\n    }\n  });\n\n  // get image color function\n  function color_(color, _) {\n    let f;\n    if (vegaUtil.isFunction(color)) {\n      f = obj => d3Color.rgb(color(obj, _));\n      f.dep = dependency(color);\n    } else {\n      // default to mid-grey\n      f = vegaUtil.constant(d3Color.rgb(color || '#888'));\n    }\n    return f;\n  }\n\n  // get image opacity function\n  function opacity_(opacity, _) {\n    let f;\n    if (vegaUtil.isFunction(opacity)) {\n      f = obj => opacity(obj, _);\n      f.dep = dependency(opacity);\n    } else if (opacity) {\n      f = vegaUtil.constant(opacity);\n    } else {\n      // default to [0, max] opacity gradient\n      f = obj => (obj.$value / obj.$max) || 0;\n      f.dep = true;\n    }\n    return f;\n  }\n\n  // check if function depends on individual pixel data\n  function dependency(f) {\n    if (!vegaUtil.isFunction(f)) return false;\n    const set = vegaUtil.toSet(vegaUtil.accessorFields(f));\n    return set.$x || set.$y || set.$value || set.$max;\n  }\n\n  // render raster grid to canvas\n  function toCanvas(grid, obj, color, opacity) {\n    const n = grid.width,\n          m = grid.height,\n          x1 = grid.x1 || 0,\n          y1 = grid.y1 || 0,\n          x2 = grid.x2 || n,\n          y2 = grid.y2 || m,\n          val = grid.values,\n          value = val ? i => val[i] : vegaUtil.zero,\n          can = vegaCanvas.canvas(x2 - x1, y2 - y1),\n          ctx = can.getContext('2d'),\n          img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),\n          pix = img.data;\n\n    for (let j=y1, k=0; j<y2; ++j) {\n      obj.$y = j - y1;\n      for (let i=x1, r=j*n; i<x2; ++i, k+=4) {\n        obj.$x = i - x1;\n        obj.$value = value(i + r);\n\n        const v = color(obj);\n        pix[k+0] = v.r;\n        pix[k+1] = v.g;\n        pix[k+2] = v.b;\n        pix[k+3] = ~~(255 * opacity(obj));\n      }\n    }\n\n    ctx.putImageData(img, 0, 0);\n    return can;\n  }\n\n  /**\n   * Maintains a cartographic projection.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   */\n  function Projection(params) {\n    vegaDataflow.Transform.call(this, null, params);\n    this.modified(true); // always treat as modified\n  }\n\n  vegaUtil.inherits(Projection, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      let proj = this.value;\n\n      if (!proj || _.modified('type')) {\n        this.value = (proj = create(_.type));\n        vegaProjection.projectionProperties.forEach(prop => {\n          if (_[prop] != null) set(proj, prop, _[prop]);\n        });\n      } else {\n        vegaProjection.projectionProperties.forEach(prop => {\n          if (_.modified(prop)) set(proj, prop, _[prop]);\n        });\n      }\n\n      if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);\n      if (_.fit) fit(proj, _);\n\n      return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n    }\n  });\n\n  function fit(proj, _) {\n    var data = collectGeoJSON(_.fit);\n    _.extent ? proj.fitExtent(_.extent, data)\n      : _.size ? proj.fitSize(_.size, data) : 0;\n  }\n\n  function create(type) {\n    var constructor = vegaProjection.projection((type || 'mercator').toLowerCase());\n    if (!constructor) vegaUtil.error('Unrecognized projection type: ' + type);\n    return constructor();\n  }\n\n  function set(proj, key, value) {\n     if (vegaUtil.isFunction(proj[key])) proj[key](value);\n  }\n\n  function collectGeoJSON(data) {\n    data = vegaUtil.array(data);\n    return data.length === 1 ? data[0]\n      : {\n          type: FeatureCollection,\n          features: data.reduce((a, f) => a.concat(featurize(f)), [])\n        };\n  }\n\n  function featurize(f) {\n    return f.type === FeatureCollection\n      ? f.features\n      : vegaUtil.array(f).filter(d => d != null).map(\n          d => d.type === Feature ? d : {type: Feature, geometry: d}\n        );\n  }\n\n  exports.contour = Contour;\n  exports.geojson = GeoJSON;\n  exports.geopath = GeoPath;\n  exports.geopoint = GeoPoint;\n  exports.geoshape = GeoShape;\n  exports.graticule = Graticule;\n  exports.heatmap = Heatmap;\n  exports.isocontour = Isocontour;\n  exports.kde2d = KDE2D;\n  exports.projection = Projection;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vega_dataflow$build$vega_dataflow","~$module$node_modules$d3_color$dist$d3_color","~$shadow.js","~$module$node_modules$vega_projection$build$vega_projection","~$module$node_modules$vega_statistics$build$vega_statistics","~$module$node_modules$d3_geo$dist$d3_geo","~$module$node_modules$vega_util$build$vega_util","~$module$node_modules$vega_canvas$build$vega_canvas","~$module$node_modules$d3_array$dist$d3_array"]],"~:properties",["^5",["geopath","y1","ring","dims","geoshape","values","$value","_points","width","$y","x1","height","scale","smooth","bandwidth","$max","dep","geopoint","x","__esModule","isocontour","transform","vega","_features","coordinates","rem","heatmap","value","geometry","context","$x","start","cellSize","contour","source","type","projection","y","Definition","x2","kde2d","transforms","y2","add","generator","size","geojson","graticule","features","end","weight"]],"~:compiled-at",1600144479964,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_geo$build$vega_geo.js\",\n\"lineCount\":44,\n\"mappings\":\"AAAAA,cAAA,CAAe,2CAAf,CAAgE,QAAQ,CAACC,eAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,gBAAvB,CAAgC,CACvG,SAAS,CAACH,MAAD,CAASI,OAAT,CAAkB,CACP,QAAnB,GAAA,MAAOD,iBAAP,EAAiD,WAAjD,GAA+B,MAAOD,OAAtC,CAA+DE,OAAA,CAAQD,gBAAR,CAAiBF,OAAA,CAAQ,uDAAR,CAAjB,CAA2CA,OAAA,CAAQ,+CAAR,CAA3C,CAAiEA,OAAA,CAAQ,4CAAR,CAAjE,CAAsFA,OAAA,CAAQ,2DAAR,CAAtF,CAAkHA,OAAA,CAAQ,2DAAR,CAAlH;AAA8IA,OAAA,CAAQ,wCAAR,CAA9I,CAAiKA,OAAA,CAAQ,4CAAR,CAAjK,CAAsLA,OAAA,CAAQ,mDAAR,CAAtL,CAA/D,CACkB,UAAlB,GAAA,MAAOI,OAAP,EAAgCA,MAAhC,CAAuCC,GAAvC,CAA6CD,MAAA,CAAO,sGAAA,CAAA,KAAA,CAAA,GAAA,CAAP,CAAyID,OAAzI,CAA7C,EACCJ,MAAA,CAA+B,WAAtB,GAAA,MAAOO,WAAP,CAAoCA,UAApC,CAAiDP,MAAjD,EAA2DQ,IAApE,CAA0EJ,OAAA,EAASJ,MAAA,CAAOS,IAAP,CAAcT,MAAd,CAAqBS,IAArB,EAA6B,EAA7B,CAAiCT,MAAjC,CAAwCS,IAAxC,CAA6CC,UAA7C,CAA0D,EAAnE,EAAwEV,MAAxE,CAA+ES,IAA/E,CAAqFT,MAArF,CAA4FS,IAA5F,CAAkGT,MAAlG,CAAyGW,EAAzG,CAA6GX,MAA7G,CAAoHS,IAApH;AAA0HT,MAA1H,CAAiIS,IAAjI,CAAuIT,MAAvI,CAA8IW,EAA9I,CAAkJX,MAAlJ,CAAyJW,EAAzJ,CAA6JX,MAA7J,CAAoKS,IAApK,CAD3E,CAF0B,CAA3B,CAAA,CAIC,IAJD,CAIQ,QAAS,CAACN,OAAD,CAAUS,YAAV,CAAwBC,QAAxB,CAAkCC,OAAlC,CAA2CC,cAA3C,CAA2DC,cAA3D,CAA2EC,KAA3E,CAAkFC,OAAlF,CAA2FC,UAA3F,CAAuG,CAEvHC,QAASA,KAAI,EAAG,EAsBhBC,QAASA,SAAQ,EAAG,CAKlBA,QAASA,SAAQ,CAACC,MAAD,CAASC,EAAT,CAAa,CAC5B,MAAOA,GAAA,CAAGC,GAAH,CAAO,QAAA,CAAAC,KAAA,CAAS,CAAA,MAAAC,QAAA,CAAQJ,MAAR,CAAgBG,KAAhB,CAAA,CAAhB,CADqB,CAM9BC,QAASA,QAAO,CAACJ,MAAD,CAASG,KAAT,CAAgB,CAAA,IAC1BE,SAAW,EADe,CAE1BC,MAAQ,EAEZC,SAAA,CAASP,MAAT,CAAiBG,KAAjB,CAAwB,QAAA,CAAAK,IAAA,CAAQ,CAC9BC,MAAA,CAAOD,IAAP,CAAaR,MAAb,CAAqBG,KAArB,CAmJJ,KAJkB,IACdO,EAAI,CADU,CAEdC,EAhJSH,IAgJTG,CAASC,MAFK,CAGdC,KAjJSL,IAiJF,CAAKG,CAAL,CAAS,CAAT,CAAA,CAAY,CAAZ,CAAPE,CAjJSL,IAiJe,CAAK,CAAL,CAAA,CAAQ,CAAR,CAAxBK,CAjJSL,IAiJ4B,CAAKG,CAAL,CAAS,CAAT,CAAA,CAAY,CAAZ,CAArCE,CAjJSL,IAiJ6C,CAAK,CAAL,CAAA,CAAQ,CAAR,CAC1D,CAAO,EAAEE,CAAT,CAAaC,CAAb,CAAA,CAAgBE,IAAA,EAlJHL,IAkJW,CAAKE,CAAL;AAAS,CAAT,CAAA,CAAY,CAAZ,CAAR,CAlJHF,IAkJ4B,CAAKE,CAAL,CAAA,CAAQ,CAAR,CAAzB,CAlJHF,IAkJyC,CAAKE,CAAL,CAAS,CAAT,CAAA,CAAY,CAAZ,CAAtC,CAlJHF,IAkJ0D,CAAKE,CAAL,CAAA,CAAQ,CAAR,CAlJlD,EAAjB,CAmJGG,IAnJH,CAAoBR,QAAA,CAASS,IAAT,CAAc,CAACN,IAAD,CAAd,CAApB,CACKF,KAAA,CAAMQ,IAAN,CAAWN,IAAX,CAHyB,CAAhC,CAMAF,MAAA,CAAMS,OAAN,CAAc,QAAA,CAAAC,aAAA,CAAQ,CACpB,IADoB,IACXN,EAAI,CADO,CACJC,EAAIN,QAAJM,CAAaC,MADT,CACiBK,OAArC,CAA8CP,CAA9C,CAAkDC,CAAlD,CAAqD,EAAED,CAAvD,CAA0D,CAiJlC,CAAA,CAAA,CAhJT,IAAA,yBAAA,CAACO,OAAD,CAAWZ,QAAA,CAASK,CAAT,CAAX,EAAwB,CAAxB,CAkJnB,KAlJ+CM,IAAAA,KAAAA,aAAAA,CAiJ3CN,WAAI,EAjJuCM,CAiJnCL,WAAIK,IAAJL,CAASC,MACrB,CAAO,EAAEF,UAAT,CAAaC,UAAb,CAAA,CAAgB,CAIiB,CAAA,CAAA,CAJIH,IAAAA,EAAAA,wBAMrC,KAN2C,IAAA,MAAAQ,IAAA,CAAKN,UAAL,CAAA,CAKvCQ,EAAIC,KAAA,CAAM,CAAN,CALmC,CAKzBC,EAAID,KAAA,CAAM,CAAN,CALqB,CAKXE,SAAW,EALA,CAMlCX,WAAI,CAN8B,CAM3BC,WAAIH,CAAJG,CAASC,MANkB,CAMVU,EAAIX,UAAJW,CAAQ,CAAzC,CAA4CZ,UAA5C,CAAgDC,UAAhD,CAAmDW,CAAnD,CAAuDZ,UAAA,EAAvD,CAA4D,CAAA,IACtDa;AAAKf,CAAA,CAAKE,UAAL,CADiD,CACxCc,GAAKD,EAAA,CAAG,CAAH,CADmC,CAC5BE,GAAKF,EAAA,CAAG,CAAH,CADuB,CAChBG,GAAKlB,CAAA,CAAKc,CAAL,CAASK,EAAAA,CAAKD,EAAA,CAAG,CAAH,CAA7D,KAAoEE,GAAKF,EAAA,CAAG,CAAH,CAAzE,CAQEhB,UARF,CACoBa,EAAAA,EAAIG,GAAAA,CAAAA,EAAIP,GAAAA,CAAAA,KAOhB,IAAA,UAAA,EAAAU,EAIN,CAAE,CAAF,CAJM,CAAAC,CAIC,CAAE,CAAF,CAJD,GAAAC,EAIU,CAAE,CAAF,CAJV,CAAAD,CAIiB,CAAE,CAAF,CAJjB,KAAAC,EAI4B,CAAE,CAAF,CAJ5B,CAAAD,CAImC,CAAE,CAAF,CAJnC,GAAAD,EAI4C,CAAE,CAAF,CAJ5C,CAAAC,CAImD,CAAE,CAAF,CAJnD,EAAsB,CAQpC,CARoC,CAAA,CAAA,UAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,GAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAQpC,CARoC,EAQpC,CARoC,EAAA,CAAA,UAAA,CAQpC,CARoC,EAQpC,CARoC,EAAA,CAAA,UAAA,CAQpC,CAAA,UAAA,CAAOE,CAAP,EAAYC,EAAZ,EAAiBA,EAAjB,EAAsBC,EAAtB,EAA2BA,EAA3B,EAAgCD,EAAhC,EAAqCA,EAArC,EAA0CD,CAfxC,IAOY,UAPZ,CAAoC,CAAA,CAAA,CAAO,CAAP,OAAA,CAAA,CAC9BP,EAAN,CAAWL,CAAX,GAAmBQ,EAAnB,CAAwBR,CAAxB,EAAiCF,CAAjC,EAAsCS,CAAtC,CAA2CH,EAA3C,GAAkDJ,CAAlD,CAAsDK,EAAtD,GAA6DG,EAA7D,CAAkEH,EAAlE,EAAwED,EAAxE,GAA8EH,QAA9E,CAAyF,CAACA,QAA1F,CAH0D,CAK5D,CAAA,CAAOA,QAP0B,CAJjB,GAAQ,CAAR,CAAqC,CAAA,wBAAA,CAAOU,CAAP,OAAA,CAAA,CAArC,CAChB,wBAAA,CAAO,CAHqB,CAhJtB,GAAmD,EAAnD,GAAI,wBAAJ,CAAuD,CACrDd,OAAA,CAAQH,IAAR,CAAaE,aAAb,CACA,MAFqD,CADC,CADtC,CAAtB,CASA;MAAO,CACLmB,KAAM,cADD,CAELhC,MAAOA,KAFF,CAGLiC,YAAa/B,QAHR,CAnBuB,CA4BhCE,QAASA,SAAQ,CAACP,MAAD,CAASG,KAAT,CAAgBkC,QAAhB,CAA0B,CAuCzCC,QAASA,OAAM,CAACC,IAAD,CAAO,CAAA,IAChBC,MAAQ,CAACD,IAAA,CAAK,CAAL,CAAA,CAAQ,CAAR,CAAD,CAAcrB,CAAd,CAAiBqB,IAAA,CAAK,CAAL,CAAA,CAAQ,CAAR,CAAjB,CAA8BnB,CAA9B,CACRqB,KAAAA,CAAM,CAACF,IAAA,CAAK,CAAL,CAAA,CAAQ,CAAR,CAAD,CAAcrB,CAAd,CAAiBqB,IAAA,CAAK,CAAL,CAAA,CAAQ,CAAR,CAAjB,CAA8BnB,CAA9B,CAFU,KAGhBsB,WAwCY,CAxCZA,CAAmBF,KAwClB,CAAM,CAAN,CAxCDE,CAAmBF,KAwCH,CAAM,CAAN,CAxChBE,EAwC4BC,EAxC5BD,CAwCiC,CAxCjCA,EAwCsC,CA3CtB,CAIhBE,SAuCY,CAvCZA,CAAiBH,IAuChB,CAAM,CAAN,CAvCDG,CAAiBH,IAuCD,CAAM,CAAN,CAvChBG,EAuC4BD,EAvC5BC,CAuCiC,CAvCjCA,EAuCsC,CA3CtB,CAKhBC,CALgB,CAKbC,CACP,EAAID,CAAJ,CAAQE,aAAA,CAAcL,UAAd,CAAR,EACE,CAAII,CAAJ,CAAQE,eAAA,CAAgBJ,QAAhB,CAAR,GACE,OAAOG,aAAA,CAAcF,CAAd,CAAgBJ,GAAhB,CAEP,CADA,OAAOO,eAAA,CAAgBF,CAAhB,CAAkBN,KAAlB,CACP,CAAIK,CAAJ,GAAUC,CAAV,EACED,CAAA,CAAErC,IAAF,CAAOM,IAAP,CAAY2B,IAAZ,CACA,CAAAJ,QAAA,CAASQ,CAAT,CAAWrC,IAAX,CAFF,EAIEwC,eAAA,CAAgBH,CAAhB,CAAkBL,KAAlB,CAJF,CAI6BO,aAAA,CAAcD,CAAd,CAAgBL,GAAhB,CAJ7B,CAIoD,CAACD,MAAOK,CAAPL,CAASA,KAAV;AAAiBC,IAAKK,CAALL,CAAOA,GAAxB,CAA6BjC,KAAMqC,CAAA,CAAErC,IAAF,CAAOyC,MAAP,CAAcH,CAAd,CAAgBtC,IAAhB,CAAnC,CAPtD,GAUE,OAAOuC,aAAA,CAAcF,CAAd,CAAgBJ,GAAhB,CAEP,CADAI,CAAA,CAAErC,IAAF,CAAOM,IAAP,CAAY2B,IAAZ,CACA,CAAAM,aAAA,CAAcF,CAAd,CAAgBJ,GAAhB,CAAsBG,QAAtB,CAAA,CAAkCC,CAZpC,CADF,CAeO,CAAIA,CAAJ,CAAQG,eAAA,CAAgBJ,QAAhB,CAAR,EACL,CAAIE,CAAJ,CAAQC,aAAA,CAAcL,UAAd,CAAR,GACE,OAAOM,eAAA,CAAgBH,CAAhB,CAAkBL,KAAlB,CAEP,CADA,OAAOO,aAAA,CAAcD,CAAd,CAAgBL,GAAhB,CACP,CAAII,CAAJ,GAAUC,CAAV,EACED,CAAA,CAAErC,IAAF,CAAOM,IAAP,CAAY2B,IAAZ,CACA,CAAAJ,QAAA,CAASQ,CAAT,CAAWrC,IAAX,CAFF,EAIEwC,eAAA,CAAgBF,CAAhB,CAAkBN,KAAlB,CAJF,CAI6BO,aAAA,CAAcF,CAAd,CAAgBJ,GAAhB,CAJ7B,CAIoD,CAACD,MAAOM,CAAPN,CAASA,KAAV,CAAiBC,IAAKI,CAALJ,CAAOA,GAAxB,CAA6BjC,KAAMsC,CAAA,CAAEtC,IAAF,CAAOyC,MAAP,CAAcJ,CAAd,CAAgBrC,IAAhB,CAAnC,CAPtD,GAUE,OAAOwC,eAAA,CAAgBH,CAAhB,CAAkBL,KAAlB,CAEP,CADAK,CAAA,CAAErC,IAAF,CAAO0C,OAAP,CAAeV,KAAf,CACA,CAAAQ,eAAA,CAAgBH,CAAhB,CAAkBL,KAAlB,CAA0BE,UAA1B,CAAA,CAAwCG,CAZ1C,CADK,CAgBLG,eAAA,CAAgBN,UAAhB,CAhBK;AAgByBK,aAAA,CAAcH,QAAd,CAhBzB,CAgBmD,CAACJ,MAAOE,UAAR,CAAoBD,IAAKG,QAAzB,CAAmCpC,KAAM,CAACgC,KAAD,CAAQC,IAAR,CAAzC,CArCtC,CAvCmB,IACrCO,gBAAkB,EADmB,CAErCD,cAAgB,EAFqB,CAGlC3B,CAGP,KAAAF,EAAIE,CAAJF,CAAQ,EACR,KAAAiC,GAAKnD,MAAA,CAAO,CAAP,CAALmD,EAAkBhD,KAElB,KADAiD,KAAA,CAAMD,EAAN,EAAY,CAAZ,CAAA,CAAepC,OAAf,CAAuBuB,MAAvB,CACA,CAAO,EAAEpB,CAAT,CAAayB,EAAb,CAAkB,CAAlB,CAAA,CAAqB,CACnB,IAAAU,GAAKF,EAAIA,GAAT,CAAcnD,MAAA,CAAOkB,CAAP,CAAW,CAAX,CAAd,EAA+Bf,KAC/BiD,MAAA,CAAMC,EAAN,CAAWF,EAAX,EAAiB,CAAjB,CAAA,CAAoBpC,OAApB,CAA4BuB,MAA5B,CAFmB,CAOrB,IAHAc,KAAA,CAAMD,EAAN,EAAY,CAAZ,CAAA,CAAepC,OAAf,CAAuBuB,MAAvB,CAGA,CAAO,EAAElB,CAAT,CAAakC,EAAb,CAAkB,CAAlB,CAAA,CAAqB,CACnBpC,CAAA,CAAI,EACJiC,GAAA,CAAKnD,MAAA,CAAOoB,CAAP,CAAWuB,EAAX,CAAgBA,EAAhB,CAAL,EAA4BxC,KAC5B,KAAAoD,GAAKvD,MAAA,CAAOoB,CAAP,CAAWuB,EAAX,CAALY,EAAuBpD,KAEvB,KADAiD,KAAA,CAAMD,EAAN,EAAY,CAAZ,CAAgBI,EAAhB,EAAsB,CAAtB,CAAA,CAAyBxC,OAAzB,CAAiCuB,MAAjC,CACA,CAAO,EAAEpB,CAAT,CAAayB,EAAb,CAAkB,CAAlB,CAAA,CAAqB,CACnBU,EAAA,CAAKF,EAAIA,GAAT,CAAcnD,MAAA,CAAOoB,CAAP,CAAWuB,EAAX,CAAgBA,EAAhB,CAAqBzB,CAArB,CAAyB,CAAzB,CAAd,EAA6Cf,KAC7C,KAAAqD,GAAKD,EAAIA,GAAT,CAAcvD,MAAA,CAAOoB,CAAP,CAAWuB,EAAX,CAAgBzB,CAAhB,CAAoB,CAApB,CAAd,EAAwCf,KACxCiD,MAAA,CAAMC,EAAN,CAAWF,EAAX,EAAiB,CAAjB,CAAqBI,EAArB;AAA2B,CAA3B,CAA+BC,EAA/B,EAAqC,CAArC,CAAA,CAAwCzC,OAAxC,CAAgDuB,MAAhD,CAHmB,CAKrBc,KAAA,CAAMD,EAAN,CAAWI,EAAX,EAAiB,CAAjB,CAAA,CAAoBxC,OAApB,CAA4BuB,MAA5B,CAVmB,CAcrBpB,CAAA,CAAI,EACJqC,GAAA,CAAKvD,MAAA,CAAOoB,CAAP,CAAWuB,EAAX,CAAL,EAAuBxC,KAEvB,KADAiD,KAAA,CAAMG,EAAN,EAAY,CAAZ,CAAA,CAAexC,OAAf,CAAuBuB,MAAvB,CACA,CAAO,EAAEpB,CAAT,CAAayB,EAAb,CAAkB,CAAlB,CAAA,CACEa,EACA,CADKD,EACL,CADSA,EACT,CADcvD,MAAA,CAAOoB,CAAP,CAAWuB,EAAX,CAAgBzB,CAAhB,CAAoB,CAApB,CACd,EADwCf,KACxC,CAAAiD,KAAA,CAAMG,EAAN,EAAY,CAAZ,CAAgBC,EAAhB,EAAsB,CAAtB,CAAA,CAAyBzC,OAAzB,CAAiCuB,MAAjC,CAEFc,MAAA,CAAMG,EAAN,EAAY,CAAZ,CAAA,CAAexC,OAAf,CAAuBuB,MAAvB,CArCyC,CAqF3CmB,QAASA,aAAY,CAACjD,IAAD,CAAOR,MAAP,CAAeG,KAAf,CAAsB,CACzCK,IAAA,CAAKO,OAAL,CAAa,QAAA,CAAAI,KAAA,CAAS,CAAA,IAChBD,EAAIC,KAAA,CAAM,CAAN,CADY,CAEhBC,EAAID,KAAA,CAAM,CAAN,CAFY,CAGhBuC,GAAKxC,CAALwC,CAAS,CAHO,CAIhBC,GAAKvC,CAALuC,CAAS,CAJO,CAMhBC,GAAK5D,MAAA,CAAO2D,EAAP,CAAYhB,EAAZ,CAAiBe,EAAjB,CACT,IAAQ,CAAR,CAAIxC,CAAJ,EAAaA,CAAb,CAAiByB,EAAjB,EAAuBe,EAAvB,GAA8BxC,CAA9B,CAAiC,CAC/B,IAAA2C,GAAK7D,MAAA,CAAO2D,EAAP,CAAYhB,EAAZ,CAAiBe,EAAjB,CAAsB,CAAtB,CACLvC,MAAA,CAAM,CAAN,CAAA,CAAWD,CAAX,EAAgBf,KAAhB,CAAwB0D,EAAxB,GAA+BD,EAA/B,CAAoCC,EAApC,EAA0C,EAFX,CAIzB,CAAR,CAAIzC,CAAJ,EAAaA,CAAb,CAAiBkC,EAAjB,EAAuBK,EAAvB,GAA8BvC,CAA9B,GACEyC,EACA,CADK7D,MAAA,EAAQ2D,EAAR,CAAa,CAAb,EAAkBhB,EAAlB,CAAuBe,EAAvB,CACL,CAAAvC,KAAA,CAAM,CAAN,CAAA,CAAWC,CAAX,EAAgBjB,KAAhB,CAAwB0D,EAAxB;CAA+BD,EAA/B,CAAoCC,EAApC,EAA0C,EAF5C,CAXoB,CAAtB,CADyC,CA5HzB,IACdlB,GAAK,CADS,CAEdW,GAAK,CAFS,CAGd7C,OAASgD,YA4Ib1D,SAAA,CAASK,OAAT,CAAmBA,OAEnBL,SAAA,CAAS+D,IAAT,CAAgBC,QAAQ,CAACC,CAAD,CAAI,CAC1B,GAAI,CAACC,SAAD,CAAWrD,MAAf,CAAuB,MAAO,CAAC+B,EAAD,CAAKW,EAAL,CADJ,KAEtBY,GAAKC,IAAA,CAAKC,KAAL,CAAWJ,CAAA,CAAE,CAAF,CAAX,CAFiB,CAECK,GAAKF,IAAA,CAAKC,KAAL,CAAWJ,CAAA,CAAE,CAAF,CAAX,CACpB,EAAZ,EAAME,EAAN,EAAuB,CAAvB,EAAiBG,EAAjB,EAA2B9E,QAAA,CAAS+E,KAAT,CAAe,cAAf,CAC3B,OAAO3B,GAAA,CAAKuB,EAAL,CAASZ,EAAT,CAAce,EAAd,CAAkBtE,QAJC,CAO5BA,SAAA,CAASU,MAAT,CAAkB8D,QAAQ,CAACP,CAAD,CAAI,CAC5B,MAAOC,UAAA,CAAUrD,MAAV,EAAoBH,MAAA,CAASuD,CAAA,CAAIP,YAAJ,CAAmB3D,IAA5B,CAAkCC,QAAtD,EAAkEU,MAAlE,GAA6EgD,YADxD,CAI9B,OAAO1D,SA5JW,CAmMpByE,QAASA,SAAQ,CAACC,CAAD,CAAIC,IAAJ,CAAUC,IAAV,CAAgB,CAC/B,MAAO,SAAQ,CAAC3E,MAAD,CAAS,CAAA,IAClB4E,GAAKrF,QAAA,CAASsF,MAAT,CAAgB7E,MAAhB,CACLwC,OAAAA,CAAQmC,IAAA,CAAOR,IAAA,CAAKW,GAAL,CAASF,EAAA,CAAG,CAAH,CAAT,CAAgB,CAAhB,CAAP,CAA4BA,EAAA,CAAG,CAAH,CACpCG;EAAAA,CAAOH,EAAA,CAAG,CAAH,CAHW,KAIlBI,KAAOD,EAAPC,CAAcxC,MACdyC,OAAAA,CAAOP,IAAA,CAAOlF,OAAA,CAAQ0F,QAAR,CAAiB1C,MAAjB,CAAwBuC,EAAxB,CAA8BN,CAA9B,CAAP,CAA2CO,IAA3C,EAAmDP,CAAnD,CAAuD,CAAvD,CACX,OAAOjF,QAAA,CAAQ2F,KAAR,CAAcF,MAAd,CAAoBF,EAApB,CAA0BE,MAA1B,CANe,CADO,CAuCjCG,QAASA,WAAU,CAACC,MAAD,CAAS,CAC1B/F,YAAA,CAAagG,SAAb,CAAuBC,IAAvB,CAA4B,IAA5B,CAAkC,IAAlC,CAAwCF,MAAxC,CAD0B,CA2D5BG,QAASA,OAAM,CAACxF,MAAD,CAAS6C,CAAT,CAAYmB,CAAZ,CAAe,CAC5B,IAAM/B,EAAIuC,QAAA,CAASR,CAAT,CAAWwB,MAAX,EAAqB,EAArB,CAAyBxB,CAAzB,CAA2BU,IAA3B,CAA4C,CAAA,CAA5C,GAAiCV,CAAjC,CAAmCW,IAAnC,CACV,OAAqB,QAAd,GAAAX,CAAA,CAAEyB,OAAF,CACHxD,CADG,CAEHA,CAAA,CAAEjC,MAAA,CAAOE,GAAP,CAAW,QAAA,CAAAwF,CAAA,CAAK,CAAA,MAAAlG,QAAA,CAAQmG,GAAR,CAAY9C,CAAA,CAAE6C,CAAF,CAAZ,CAAiB1F,MAAjB,CAAA,CAAhB,CAAF,CAJwB,CAO9B4F,QAASA,eAAc,CAACC,KAAD,CAAQC,IAAR,CAAcC,KAAd,CAAqB/B,CAArB,CAAwB,CAAA,IACzCgC,EAAIhC,CAAJgC,CAAMC,KAAND,EAAeF,IAAfE,CAAoBC,KADqB,CAEzCP,EAAI1B,CAAJ0B,CAAMQ,SAANR,EAAmBI,IAAnBJ,CAAwBQ,SACxB3G,SAAA,CAAS4G,UAAT,CAAoBH,CAApB,CAAJ,GAA4BA,CAA5B,CAAgCA,CAAA,CAAED,KAAF,CAAS/B,CAAT,CAAhC,CACIzE,SAAA,CAAS4G,UAAT,CAAoBT,CAApB,CAAJ;CAA4BA,CAA5B,CAAgCA,CAAA,CAAEK,KAAF,CAAS/B,CAAT,CAAhC,CACA,IAAW,CAAX,GAAKgC,CAAL,EAAqB,IAArB,EAAgBA,CAAhB,EAA+BN,CAA/B,CAEMU,KAKN,EALY7G,QAAA,CAAS8G,QAAT,CAAkBL,CAAlB,CAAA,CAAuBA,CAAvB,CAA2BA,CAAA,CAAE,CAAF,CAKvC,GALgD,CAKhD,CAJMM,CAIN,EAJY/G,QAAA,CAAS8G,QAAT,CAAkBL,CAAlB,CAAA,CAAuBA,CAAvB,CAA2BA,CAAA,CAAE,CAAF,CAIvC,GAJgD,CAIhD,CAAAH,KAAA,CAAM9E,OAAN,CAAcwF,SAAA,CAAUT,IAAV,CAAgBM,KAAhB,CAAoBE,CAApB,CAHHZ,CAGG,EAHEA,CAAA,CAAE,CAAF,CAGF,EAHU,CAGV,CAFHA,CAEG,EAFEA,CAAA,CAAE,CAAF,CAEF,EAFU,CAEV,CAAd,CAZ6C,CAe/Ca,QAASA,UAAS,CAACT,IAAD,CAAOM,EAAP,CAAWE,EAAX,CAAeE,EAAf,CAAmBC,EAAnB,CAAuB,CAKvCC,QAASA,iBAAgB,CAACtE,WAAD,CAAc,CACrCA,WAAA,CAAYrB,OAAZ,CAAoB4F,aAApB,CADqC,CAIvCA,QAASA,cAAa,CAACvE,WAAD,CAAc,CAC9BwE,IAAJ,EAAUxE,WAAA,CAAYyE,OAAZ,EACVzE,YAAA,CAAYrB,OAAZ,CAAoB+F,cAApB,CAFkC,CAKpCA,QAASA,eAAc,CAAC1E,WAAD,CAAc,CACnCA,WAAA,CAAY,CAAZ,CAAA,EAAkBA,WAAA,CAAY,CAAZ,CAAlB,CAAmC2E,EAAnC,EAAyCX,EAAzC,CAA8CI,EAC9CpE,YAAA,CAAY,CAAZ,CAAA,EAAkBA,WAAA,CAAY,CAAZ,CAAlB,CAAmC4E,EAAnC,EAAyCV,EAAzC,CAA8CG,EAFX;AAbrC,IAAMM,GAAKjB,IAALiB,CAAUA,EAAVA,EAAgB,CAAtB,CACMC,GAAKlB,IAALkB,CAAUA,EAAVA,EAAgB,CADtB,CAEMJ,KAAiB,CAAjBA,CAAOR,EAAPQ,CAAYN,EAgBlB,OAAO,SAAQ,CAACW,QAAD,CAAW,CACxBA,QAAA,CAAS7E,WAAT,CAAqBrB,OAArB,CAA6B2F,gBAA7B,CACA,OAAOO,SAFiB,CAnBa,CAyBzCC,QAASA,OAAM,CAACC,EAAD,CAAKC,IAAL,CAAWvE,CAAX,CAAc,CACrBwE,EAAAA,CAAU,CAAN,EAAAF,EAAA,CAAUA,EAAV,CAAe1H,cAAA,CAAe6H,YAAf,CAA4BF,IAA5B,CAAkCvE,CAAlC,CACzB,OAAOsB,KAAA,CAAKoD,KAAL,EAAYpD,IAAA,CAAKqD,IAAL,CAAU,CAAV,CAAcH,EAAd,CAAkBA,EAAlB,CAAsB,CAAtB,CAAZ,CAAuC,CAAvC,EAA4C,CAA5C,CAFoB,CAK7BI,QAASA,OAAM,CAACzD,CAAD,CAAI,CACjB,MAAOzE,SAAA,CAAS4G,UAAT,CAAoBnC,CAApB,CAAA,CAAyBA,CAAzB,CAA6BzE,QAAA,CAASmI,QAAT,CAAkB,CAAC1D,CAAnB,CADnB,CAKnB2D,QAASA,UAAS,EAAG,CASnBC,QAASA,QAAO,CAACR,IAAD,CAAOS,MAAP,CAAe,CAC7B,IAAMC,GAAKZ,MAAA,CAAOa,SAAA,CAAU,CAAV,CAAP,CAAqBX,IAArB,CAA2BlG,CAA3B,CAAL4G,EAAsCrD,CAA5C,CACMuD,GAAKd,MAAA,CAAOa,SAAA,CAAU,CAAV,CAAP,CAAqBX,IAArB,CAA2BhG,CAA3B,CAAL4G,EAAsCvD,CAD5C,CAEMwD,GAAKH,EAAA,CAAKA,EAAL,CAAU,CAAV,CAAc,CAFzB,CAGMI,GAAKF,EAAA,CAAKA,EAAL,CAAU,CAAV,CAAc,CAHzB,CAIMrH,EAAI,CAAJA,CAAQsH,EAARtH,EAAcgC,EAAdhC,EAAoB8D,CAApB9D,CAJN,CAKMwH,EAAI,CAAJA,CAAQD,EAARC,EAAc7E,EAAd6E;AAAoB1D,CAApB0D,CALN,CAMMC,QAAU,IAAIC,YAAJ,CAAiB1H,CAAjB,CAAqBwH,CAArB,CANhB,CAOMG,QAAU,IAAID,YAAJ,CAAiB1H,CAAjB,CAAqBwH,CAArB,CAPhB,CASInI,OAASoI,OAEbhB,KAAA,CAAKrG,OAAL,CAAa,QAAA,CAAAwH,CAAA,CAAK,CAChB,IAAM/G,GAAKyG,EAALzG,EAAW,CAACN,CAAA,CAAEqH,CAAF,CAAZ/G,EAAoBiD,CAApBjD,CAAN,CACMC,GAAKyG,EAALzG,EAAW,CAACL,CAAA,CAAEmH,CAAF,CAAZ9G,EAAoBgD,CAApBhD,CAEI,EAAV,EAAID,EAAJ,EAAeA,EAAf,CAAoBb,CAApB,EAA+B,CAA/B,EAAyBc,EAAzB,EAAoCA,EAApC,CAAyC0G,CAAzC,GACEC,OAAA,CAAQ5G,EAAR,CAAaC,EAAb,CAAkBd,CAAlB,CADF,EAC0B,CAAC6H,MAAA,CAAOD,CAAP,CAD3B,CAJgB,CAAlB,CASS,EAAT,CAAIT,EAAJ,EAAmB,CAAnB,CAAcE,EAAd,EACES,KAAA,CAAM9H,CAAN,CAASwH,CAAT,CAAYC,OAAZ,CAAqBE,OAArB,CAA8BR,EAA9B,CAKA,CAJAY,KAAA,CAAM/H,CAAN,CAASwH,CAAT,CAAYG,OAAZ,CAAqBF,OAArB,CAA8BJ,EAA9B,CAIA,CAHAS,KAAA,CAAM9H,CAAN,CAASwH,CAAT,CAAYC,OAAZ,CAAqBE,OAArB,CAA8BR,EAA9B,CAGA,CAFAY,KAAA,CAAM/H,CAAN,CAASwH,CAAT,CAAYG,OAAZ,CAAqBF,OAArB,CAA8BJ,EAA9B,CAEA,CADAS,KAAA,CAAM9H,CAAN,CAASwH,CAAT,CAAYC,OAAZ,CAAqBE,OAArB,CAA8BR,EAA9B,CACA,CAAAY,KAAA,CAAM/H,CAAN,CAASwH,CAAT,CAAYG,OAAZ,CAAqBF,OAArB,CAA8BJ,EAA9B,CANF,EAOgB,CAAT,CAAIF,EAAJ,EACLW,KAAA,CAAM9H,CAAN,CAASwH,CAAT,CAAYC,OAAZ,CAAqBE,OAArB,CAA8BR,EAA9B,CAGA,CAFAW,KAAA,CAAM9H,CAAN,CAASwH,CAAT,CAAYG,OAAZ,CAAqBF,OAArB,CAA8BN,EAA9B,CAEA,CADAW,KAAA,CAAM9H,CAAN,CAASwH,CAAT,CAAYC,OAAZ,CAAqBE,OAArB,CAA8BR,EAA9B,CACA,CAAA9H,MAAA,CAASsI,OAJJ;AAKS,CALT,CAKIN,EALJ,GAMLU,KAAA,CAAM/H,CAAN,CAASwH,CAAT,CAAYC,OAAZ,CAAqBE,OAArB,CAA8BN,EAA9B,CAGA,CAFAU,KAAA,CAAM/H,CAAN,CAASwH,CAAT,CAAYG,OAAZ,CAAqBF,OAArB,CAA8BJ,EAA9B,CAEA,CADAU,KAAA,CAAM/H,CAAN,CAASwH,CAAT,CAAYC,OAAZ,CAAqBE,OAArB,CAA8BN,EAA9B,CACA,CAAAhI,MAAA,CAASsI,OATJ,CAcDtC,KAAAA,CAAI6B,MAAA,CAAS1D,IAAA,CAAKwE,GAAL,CAAS,CAAT,CAAY,EAAZ,CAAiBlE,CAAjB,CAAT,CAA+B,CAA/B,CAAmCjF,OAAA,CAAQoJ,GAAR,CAAY5I,MAAZ,CACpCU,OAAAA,CAAE,CAAX,KAAcmI,EAAd,CAAiBlI,CAAjB,CAAmBwH,CAAnB,CAAsBzH,MAAtB,CAAwBmI,EAAxB,CAA4B,EAAEnI,MAA9B,CAAiCV,MAAA,CAAOU,MAAP,CAAA,EAAasF,IAE9C,OAAO,CACLhG,OAAQA,MADH,CAELiG,MAAO,CAAPA,EAAYxB,CAFP,CAGLqE,MAAOnI,CAHF,CAILoI,OAAQZ,CAJH,CAKLpB,GAAIkB,EALC,CAMLjB,GAAIkB,EANC,CAOLc,GAAIf,EAAJe,EAAUrG,EAAVqG,EAAgBvE,CAAhBuE,CAPK,CAQLC,GAAIf,EAAJe,EAAU3F,EAAV2F,EAAgBxE,CAAhBwE,CARK,CA7CsB,CATZ,IACf/H,EAAIA,QAAA,CAAAqH,CAAA,CAAK,CAAA,MAAAA,EAAA,CAAE,CAAF,CAAA,CADM,CAEfnH,EAAIA,QAAA,CAAAmH,CAAA,CAAK,CAAA,MAAAA,EAAA,CAAE,CAAF,CAAA,CAFM,CAGfC,OAASjJ,QAATiJ,CAAkBU,GAHH,CAIfnB,UAAY,CAAC,EAAD,CAAK,EAAL,CAJG,CAKfpF,GAAK,GALU,CAMfW,GAAK,GANU,CAOfmB,EAAI,CA2DRmD,QAAA,CAAQ1G,CAAR,CAAYiI,QAAQ,CAACnF,CAAD,CAAI,CACtB,MAAOC,UAAA,CAAUrD,MAAV,EAAoBM,CAAA,CAAIuG,MAAA,CAAOzD,CAAP,CAAJ,CAAe4D,OAAnC,EAA8C1G,CAD/B,CAIxB0G,QAAA,CAAQxG,CAAR;AAAYgI,QAAQ,CAACpF,CAAD,CAAI,CACtB,MAAOC,UAAA,CAAUrD,MAAV,EAAoBQ,CAAA,CAAIqG,MAAA,CAAOzD,CAAP,CAAJ,CAAe4D,OAAnC,EAA8CxG,CAD/B,CAIxBwG,QAAA,CAAQY,MAAR,CAAiBa,QAAQ,CAACrF,CAAD,CAAI,CAC3B,MAAOC,UAAA,CAAUrD,MAAV,EAAoB4H,MAAA,CAASf,MAAA,CAAOzD,CAAP,CAAT,CAAoB4D,OAAxC,EAAmDY,MAD/B,CAI7BZ,QAAA,CAAQ9D,IAAR,CAAewF,QAAQ,CAACtF,CAAD,CAAI,CACzB,GAAI,CAACC,SAAD,CAAWrD,MAAf,CAAuB,MAAO,CAAC+B,EAAD,CAAKW,EAAL,CADL,KAErBY,GAAK,CAACF,CAAA,CAAE,CAAF,CAFe,CAETK,GAAK,CAACL,CAAA,CAAE,CAAF,CACV,EAAZ,EAAME,EAAN,EAAuB,CAAvB,EAAiBG,EAAjB,EAA2B9E,QAAA,CAAS+E,KAAT,CAAe,cAAf,CAC3B,OAAO3B,GAAA,CAAKuB,EAAL,CAASZ,EAAT,CAAce,EAAd,CAAkBuD,OAJA,CAO3BA,QAAA,CAAQ2B,QAAR,CAAmBC,QAAQ,CAACxF,CAAD,CAAI,CAC7B,GAAI,CAACC,SAAD,CAAWrD,MAAf,CAAuB,MAAO,EAAP,EAAY6D,CACjB,EAAlB,GAAOT,CAAP,CAAW,CAACA,CAAZ,GAAsBzE,QAAA,CAAS+E,KAAT,CAAe,mBAAf,CACtBG,EAAA,CAAIN,IAAA,CAAKC,KAAL,CAAWD,IAAA,CAAKsF,GAAL,CAASzF,CAAT,CAAX,CAAyBG,IAAzB,CAA8BuF,GAA9B,CACJ,OAAO9B,QAJsB,CAO/BA,QAAA,CAAQG,SAAR,CAAoB4B,QAAQ,CAAC3F,CAAD,CAAI,CAC9B,GAAI,CAACC,SAAD,CAAWrD,MAAf,CAAuB,MAAOmH,UAC9B/D;CAAA,CAAIzE,QAAA,CAASqK,KAAT,CAAe5F,CAAf,CACa,EAAjB,GAAIA,CAAJ,CAAMpD,MAAN,GAAoBoD,CAApB,CAAwB,CAAC,CAACA,CAAA,CAAE,CAAF,CAAF,CAAQ,CAACA,CAAA,CAAE,CAAF,CAAT,CAAxB,CACiB,EAAjB,GAAIA,CAAJ,CAAMpD,MAAN,EAAoBrB,QAAA,CAAS+E,KAAT,CAAe,mBAAf,CACpB,OAAOyD,UAAA,CAAY/D,CAAZ,CAAe4D,OALQ,CAQhC,OAAOA,QApGY,CAuGrBa,QAASA,MAAK,CAAC9H,CAAD,CAAIwH,CAAJ,CAAO0B,MAAP,CAAeC,MAAf,CAAuB5H,CAAvB,CAA0B,CAEtC,IADA,IAAM6H,GAAK7H,CAAL6H,EAAU,CAAVA,EAAe,CAArB,CACSzI,EAAI,CAAb,CAAgBA,CAAhB,CAAoB6G,CAApB,CAAuB,EAAE7G,CAAzB,CACE,IAD0B,IACjBZ,EAAI,CADa,CACVsJ,GAAK,CAArB,CAAwBtJ,CAAxB,CAA4BC,CAA5B,CAAgCuB,CAAhC,CAAmC,EAAExB,CAArC,CACMA,CAGJ,CAHQC,CAGR,GAFEqJ,EAEF,EAFQH,MAAA,CAAOnJ,CAAP,CAAWY,CAAX,CAAeX,CAAf,CAER,EAAID,CAAJ,EAASwB,CAAT,GACMxB,CAGJ,EAHSqJ,CAGT,GAFEC,EAEF,EAFQH,MAAA,CAAOnJ,CAAP,CAAWqJ,CAAX,CAAezI,CAAf,CAAmBX,CAAnB,CAER,EAAAmJ,MAAA,CAAOpJ,CAAP,CAAWwB,CAAX,CAAeZ,CAAf,CAAmBX,CAAnB,CAAA,CAAwBqJ,EAAxB,CAA6B7F,IAAA,CAAKW,GAAL,CAASpE,CAAT,CAAa,CAAb,CAAgBC,CAAhB,CAAoB,CAApB,CAAwBoJ,CAAxB,CAA4BrJ,CAA5B,CAA+BqJ,CAA/B,CAJ/B,CAPkC,CAiBxCrB,QAASA,MAAK,CAAC/H,CAAD,CAAIwH,CAAJ,CAAO0B,MAAP,CAAeC,MAAf,CAAuB5H,CAAvB,CAA0B,CAEtC,IADA,IAAM6H,GAAK7H,CAAL6H,EAAU,CAAVA,EAAe,CAArB,CACSrJ,EAAI,CAAb,CAAgBA,CAAhB,CAAoBC,CAApB,CAAuB,EAAED,CAAzB,CACE,IAD0B,IACjBY,EAAI,CADa,CACV0I,GAAK,CAArB,CAAwB1I,CAAxB,CAA4B6G,CAA5B,CAAgCjG,CAAhC,CAAmC,EAAEZ,CAArC,CACMA,CAGJ,CAHQ6G,CAGR,GAFE6B,EAEF,EAFQH,MAAA,CAAOnJ,CAAP,CAAWY,CAAX,CAAeX,CAAf,CAER,EAAIW,CAAJ,EAASY,CAAT,GACMZ,CAGJ,EAHSyI,CAGT,GAFEC,EAEF,EAFQH,MAAA,CAAOnJ,CAAP,EAAYY,CAAZ,CAAgByI,CAAhB,EAAqBpJ,CAArB,CAER,EAAAmJ,MAAA,CAAOpJ,CAAP;CAAYY,CAAZ,CAAgBY,CAAhB,EAAqBvB,CAArB,CAAA,CAA0BqJ,EAA1B,CAA+B7F,IAAA,CAAKW,GAAL,CAASxD,CAAT,CAAa,CAAb,CAAgB6G,CAAhB,CAAoB,CAApB,CAAwB4B,CAAxB,CAA4BzI,CAA5B,CAA+ByI,CAA/B,CAJjC,CAPkC,CA4CxCE,QAASA,MAAK,CAAC5E,MAAD,CAAS,CACrB/F,YAAA,CAAagG,SAAb,CAAuBC,IAAvB,CAA4B,IAA5B,CAAkC,IAAlC,CAAwCF,MAAxC,CADqB,CAsBvBA,QAASA,gBAAM,CAAC6E,GAAD,CAAMlG,CAAN,CAAS,CACtBmG,MAAA,CAAOpJ,OAAP,CAAe,QAAA,CAAAqJ,KAAA,CAAS,CAAA,MAAY,KAAZ,EAAApG,CAAA,CAAEoG,KAAF,CAAA,CAAmBF,GAAA,CAAIE,KAAJ,CAAA,CAAWpG,CAAA,CAAEoG,KAAF,CAAX,CAAnB,CAA0C,CAA1C,CAAxB,CACA,OAAOF,IAFe,CAmCxBG,QAASA,UAAS,CAACjD,IAAD,CAAOkD,OAAP,CAAgB,CAAA,IAC5BC,OAAS,EADmB,CAE5BC,IAAMA,QAAA,CAAA3H,CAAA,CAAK,CAAA,MAAAA,EAAA,CAAE6C,CAAF,CAAA,CAFiB,CAGpB/E,CAGZ,IAAe,IAAf,EAAI2J,OAAJ,CACEC,MAAA,CAAOzJ,IAAP,CAAYsG,IAAZ,CADF,KAEO,CACA,IAAAlH,IAAI,EAAJ,KAAQQ,EAAE,CAAf,KAAkBC,CAAlB,CAAoByG,IAApB,CAAyBxG,MAAzB,CAAiCF,CAAjC,CAAmCC,CAAnC,CAAsC,EAAED,CAAxC,CAA2C,CACzC,IAAAgF,EAAI0B,IAAA,CAAK1G,CAAL,CACJ,KAAA+D,EAAI6F,OAAA,CAAQpK,GAAR,CAAYsK,GAAZ,CACJ,KAAA1H,EAAI5C,GAAA,CAAIuE,CAAJ,CACC3B,EAAL,GACE5C,GAAA,CAAIuE,CAAJ,CAEA,CAFU3B,CAEV,CAFc,EAEd,CADAA,CACA,CADE2H,IACF,CADShG,CACT,CAAA8F,MAAA,CAAOzJ,IAAP,CAAYgC,CAAZ,CAHF,CAKAA,EAAA,CAAEhC,IAAF,CAAO4E,CAAP,CATyC,CADtC,CAcP,MAAO6E,OAtByB;AAoDlCG,QAASA,QAAO,CAACrF,MAAD,CAAS,CACvB/F,YAAA,CAAagG,SAAb,CAAuBC,IAAvB,CAA4B,IAA5B,CAAkC,IAAlC,CAAwCF,MAAxC,CADuB,CAqEzBsF,QAASA,QAAO,CAACtF,MAAD,CAAS,CACvB/F,YAAA,CAAagG,SAAb,CAAuBC,IAAvB,CAA4B,IAA5B,CAAkC,IAAlC,CAAwCF,MAAxC,CADuB,CA2EzBuF,QAASA,QAAO,CAACvF,MAAD,CAAS,CACvB/F,YAAA,CAAagG,SAAb,CAAuBC,IAAvB,CAA4B,IAA5B,CAAkC,IAAlC,CAAwCF,MAAxC,CADuB,CAyCzBwF,QAASA,SAAQ,CAACC,IAAD,CAAOC,WAAP,CAAoB,CACnC,IAAIC,KAAOF,IAAA,CAAKC,WAAL,EACXD,KAAA,CAAKG,OAAL,CAAa,IAAb,CACmB,KAAnB,EAAIF,WAAJ,EACED,IAAA,CAAKC,WAAL,CAAiBA,WAAjB,CAEF,OAAOC,KAN4B,CAoBrCE,QAASA,SAAQ,CAAC7F,MAAD,CAAS,CACxB/F,YAAA,CAAagG,SAAb,CAAuBC,IAAvB,CAA4B,IAA5B,CAAkC,IAAlC,CAAwCF,MAAxC,CADwB,CA0D1B8F,QAASA,SAAQ,CAAC9F,MAAD,CAAS,CACxB/F,YAAA,CAAagG,SAAb,CAAuBC,IAAvB,CAA4B,IAA5B,CAAkC,IAAlC,CAAwCF,MAAxC,CADwB;AAuC1B+F,QAASA,eAAc,CAACN,IAAD,CAAOO,KAAP,CAAcN,WAAd,CAA2B,CAChD,IAAIO,MAAuB,IAAf,EAAAP,WAAA,CACR,QAAA,CAAA/G,CAAA,CAAK,CAAA,MAAA8G,KAAA,CAAKO,KAAA,CAAMrH,CAAN,CAAL,CAAA,CADG,CAER,QAAA,CAAAA,CAAA,CAAK,CAAA,IACDgH,KAAOF,IAAA,CAAKC,WAAL,EACP5K,EAAAA,CAAQ2K,IAAA,CAAKC,WAAL,CAAiBA,WAAjB,CAAA,CAA8BM,KAAA,CAAMrH,CAAN,CAA9B,CACZ8G,KAAA,CAAKC,WAAL,CAAiBC,IAAjB,CACA,OAAO7K,EAJF,CAMTmL,MAAA,CAAML,OAAN,CAAgBM,QAAA,CAAAvH,CAAA,CAAK,CACnB8G,IAAA,CAAKG,OAAL,CAAajH,CAAb,CACA,OAAOsH,MAFY,CAKrB,OAAOA,MAdyC,CAqBlDE,QAASA,UAAS,CAACnG,MAAD,CAAS,CACzB/F,YAAA,CAAagG,SAAb,CAAuBC,IAAvB,CAA4B,IAA5B,CAAkC,EAAlC,CAAsCF,MAAtC,CACA,KAAA,CAAKoG,SAAL,CAAiB9L,KAAA,CAAM+L,YAAN,EAFQ,CAkE3BC,QAASA,QAAO,CAACtG,MAAD,CAAS,CACvB/F,YAAA,CAAagG,SAAb,CAAuBC,IAAvB,CAA4B,IAA5B,CAAkC,IAAlC,CAAwCF,MAAxC,CADuB,CAsDzBuG,QAASA,OAAM,CAACC,KAAD,CAAQ7H,CAAR,CAAW,CAExB,GAAIzE,QAAA,CAAS4G,UAAT,CAAoB0F,KAApB,CAAJ,CAAgC,CAC9B,IAAAhJ;AAAIA,QAAA,CAAAqH,GAAA,CAAO,CAAA,MAAAtK,QAAA,CAAQkM,GAAR,CAAYD,KAAA,CAAM3B,GAAN,CAAWlG,CAAX,CAAZ,CAAA,CACXnB,EAAA,CAAEkJ,GAAF,CAAQC,UAAA,CAAWH,KAAX,CAFsB,CAAhC,IAKEhJ,EAAA,CAAItD,QAAA,CAASmI,QAAT,CAAkB9H,OAAA,CAAQkM,GAAR,CAAYD,KAAZ,EAAqB,MAArB,CAAlB,CAEN,OAAOhJ,EATiB,CAa1BoJ,QAASA,SAAQ,CAACC,OAAD,CAAUlI,CAAV,CAAa,CAE5B,GAAIzE,QAAA,CAAS4G,UAAT,CAAoB+F,OAApB,CAAJ,CAAkC,CAChC,IAAArJ,EAAIA,QAAA,CAAAqH,GAAA,CAAO,CAAA,MAAAgC,QAAA,CAAQhC,GAAR,CAAalG,CAAb,CAAA,CACXnB,EAAA,CAAEkJ,GAAF,CAAQC,UAAA,CAAWE,OAAX,CAFwB,CAAlC,IAGWA,QAAJ,CACLrJ,CADK,CACDtD,QAAA,CAASmI,QAAT,CAAkBwE,OAAlB,CADC,EAILrJ,CACA,CADIA,QAAA,CAAAqH,GAAA,CAAO,CAAA,MAACA,IAAD,CAAKiC,MAAL,CAAcjC,GAAd,CAAkBkC,IAAlB,EAA2B,CAA3B,CACX,CAAAvJ,CAAA,CAAEkJ,GAAF,CAAQ,CAAA,CALH,CAOP,OAAOlJ,EAZqB,CAgB9BmJ,QAASA,WAAU,CAACnJ,CAAD,CAAI,CACrB,GAAI,CAACtD,QAAA,CAAS4G,UAAT,CAAoBtD,CAApB,CAAL,CAA6B,MAAO,CAAA,CAC9BwJ,EAAAA,CAAM9M,QAAA,CAAS+M,KAAT,CAAe/M,QAAA,CAASgN,cAAT,CAAwB1J,CAAxB,CAAf,CACZ,OAAOwJ,EAAP,CAAWG,EAAX,EAAiBH,CAAjB,CAAqBI,EAArB,EAA2BJ,CAA3B,CAA+BF,MAA/B;AAAyCE,CAAzC,CAA6CD,IAHxB,CAOvBM,QAASA,SAAQ,CAAC5G,IAAD,CAAOoE,GAAP,CAAY2B,KAAZ,CAAmBK,OAAnB,CAA4B,CAC3C,IAAMvL,EAAImF,IAAJnF,CAASmI,KAAf,CACMX,EAAIrC,IAAJqC,CAASY,MADf,CAEMhC,GAAKjB,IAALiB,CAAUA,EAAVA,EAAgB,CAFtB,CAGMC,GAAKlB,IAALkB,CAAUA,EAAVA,EAAgB,CAHtB,CAIMgC,GAAKlD,IAALkD,CAAUA,EAAVA,EAAgBrI,CAChBsI,EAAAA,CAAKnD,IAALmD,CAAUA,EAAVA,EAAgBd,CALtB,KAMMwE,IAAM7G,IAAN6G,CAAW3M,MACXG,KAAAA,CAAQwM,GAAA,CAAM,QAAA,CAAAjM,CAAA,CAAK,CAAA,MAAAiM,IAAA,CAAIjM,CAAJ,CAAA,CAAX,CAAoBnB,QAApB,CAA6BoF,IAM3C,KAbA,IAQMiI,IAAM/M,UAAA,CAAWgN,MAAX,CAAkB7D,EAAlB,CAAuBjC,EAAvB,CAA2BkC,CAA3B,CAAgCjC,EAAhC,CARZ,CASM8F,IAAMF,GAAA,CAAIG,UAAJ,CAAe,IAAf,CATZ,CAUMC,IAAMF,GAAA,CAAIG,YAAJ,CAAiB,CAAjB,CAAoB,CAApB,CAAuBjE,EAAvB,CAA4BjC,EAA5B,CAAgCkC,CAAhC,CAAqCjC,EAArC,CAVZ,CAWMkG,IAAMF,GAANE,CAAU9F,IAXhB,CAaS9F,EAAE0F,EAbX,CAaevC,EAAE,CAAjB,CAAoBnD,CAApB,CAAsB2H,CAAtB,CAA0B,EAAE3H,CAA5B,CAA+B,CAC7B4I,GAAA,CAAIuC,EAAJ,CAASnL,CAAT,CAAa0F,EACb,KAF6B,IAEpBtG,WAAEqG,EAFkB,CAEd7E,EAAEZ,CAAFY,CAAIvB,CAAnB,CAAsBD,UAAtB,CAAwBsI,EAAxB,CAA4B,EAAEtI,UAAF,CAAK+D,CAAL,EAAQ,CAApC,CAAuC,CACrCyF,GAAA,CAAIsC,EAAJ,CAAS9L,UAAT,CAAaqG,EACbmD,IAAA,CAAIiC,MAAJ,CAAahM,IAAA,CAAMO,UAAN,CAAUwB,CAAV,CAEb,KAAMmF,EAAIwE,KAAA,CAAM3B,GAAN,CACVgD,IAAA,CAAIzI,CAAJ,CAAM,CAAN,CAAA,CAAW4C,CAAX,CAAanF,CACbgL,IAAA,CAAIzI,CAAJ,CAAM,CAAN,CAAA;AAAW4C,CAAX,CAAavE,CACboK,IAAA,CAAIzI,CAAJ,CAAM,CAAN,CAAA,CAAW4C,CAAX,CAAaxF,CACbqL,IAAA,CAAIzI,CAAJ,CAAM,CAAN,CAAA,CAAW,CAAC,EAAE,GAAF,CAAQyH,OAAA,CAAQhC,GAAR,CAAR,CARyB,CAFV,CAc/B4C,GAAA,CAAIK,YAAJ,CAAiBH,GAAjB,CAAsB,CAAtB,CAAyB,CAAzB,CACA,OAAOJ,IA7BoC,CAqC7CQ,QAASA,WAAU,CAAC/H,MAAD,CAAS,CAC1B/F,YAAA,CAAagG,SAAb,CAAuBC,IAAvB,CAA4B,IAA5B,CAAkC,IAAlC,CAAwCF,MAAxC,CACA,KAAA,CAAKgI,QAAL,CAAc,CAAA,CAAd,CAF0B,CA2B5BC,QAASA,IAAG,CAACC,IAAD,CAAOvJ,CAAP,CAAU,CACpB,IAAIoD,KAAOoG,cAAA,CAAexJ,CAAf,CAAiBsJ,GAAjB,CACXtJ,EAAA,CAAEa,MAAF,CAAW0I,IAAA,CAAKE,SAAL,CAAezJ,CAAf,CAAiBa,MAAjB,CAAyBuC,IAAzB,CAAX,CACIpD,CAAA,CAAEF,IAAF,CAASyJ,IAAA,CAAKG,OAAL,CAAa1J,CAAb,CAAeF,IAAf,CAAqBsD,IAArB,CAAT,CAAsC,CAHtB,CAMtBuG,QAASA,OAAM,CAACxL,IAAD,CAAO,CACpB,IAAIyL,YAAclO,cAAA,CAAemO,UAAf,CAA0B,CAAC1L,IAAD,EAAS,UAAT,EAAqB2L,WAArB,EAA1B,CACbF,YAAL,EAAkBrO,QAAA,CAAS+E,KAAT,CAAe,gCAAf,CAAkDnC,IAAlD,CAClB,OAAOyL,YAAA,EAHa,CAUtBJ,QAASA,eAAc,CAACpG,IAAD,CAAO,CAC5BA,IAAA;AAAO7H,QAAA,CAASqK,KAAT,CAAexC,IAAf,CACP,OAAuB,EAAhB,GAAAA,IAAA,CAAKxG,MAAL,CAAoBwG,IAAA,CAAK,CAAL,CAApB,CACH,CACEjF,KA7fgB4L,mBA4flB,CAEEC,SAAU5G,IAAA,CAAK6G,MAAL,CAAY,QAAA,CAACnM,CAAD,CAAIe,CAAJ,CAAU,CAAA,MAAAf,EAAA,CAAEmB,MAAF,CAASiL,SAAA,CAAUrL,CAAV,CAAT,CAAA,CAAtB,CAA8C,EAA9C,CAFZ,CAHwB,CAS9BqL,QAASA,UAAS,CAACrL,CAAD,CAAI,CACpB,MAngBsBkL,mBAmgBf,GAAAlL,CAAA,CAAEV,IAAF,CACHU,CADG,CACDmL,QADC,CAEHzO,QAAA,CAASqK,KAAT,CAAe/G,CAAf,CAAA,CAAkBsL,MAAlB,CAAyB,QAAA,CAAA5F,CAAA,CAAK,CAAA,MAAK,KAAL,EAAAA,CAAA,CAA9B,CAAA,CAAyCrI,GAAzC,CACE,QAAA,CAAAqI,CAAA,CAAK,CAAA,MAvgBC6F,SAugBD,GAAA7F,CAAA,CAAEpG,IAAF,CAAqBoG,CAArB,CAAyB,CAACpG,KAvgBzBiM,SAugBwB,CAAgBnH,SAAUsB,CAA1B,CAAzB,CADP,CAHgB,CA3rCtB,IAAMnF,MAAQ,CACZ,EADY,CAEZ,CAAC,CAAC,CAAC,CAAD,CAAM,GAAN,CAAD,CAAa,CAAC,EAAD,CAAM,CAAN,CAAb,CAAD,CAFY,CAGZ,CAAC,CAAC,CAAC,GAAD,CAAM,CAAN,CAAD,CAAa,CAAC,CAAD,CAAM,GAAN,CAAb,CAAD,CAHY,CAIZ,CAAC,CAAC,CAAC,GAAD,CAAM,CAAN,CAAD,CAAa,CAAC,EAAD,CAAM,CAAN,CAAb,CAAD,CAJY,CAKZ,CAAC,CAAC,CAAC,CAAD,CAAM,EAAN,CAAD,CAAa,CAAC,GAAD,CAAM,CAAN,CAAb,CAAD,CALY,CAMZ,CAAC,CAAC,CAAC,CAAD,CAAM,GAAN,CAAD,CAAa,CAAC,EAAD,CAAM,CAAN,CAAb,CAAD,CAA2B,CAAC,CAAC,CAAD,CAAM,EAAN,CAAD,CAAa,CAAC,GAAD,CAAM,CAAN,CAAb,CAA3B,CANY,CAOZ,CAAC,CAAC,CAAC,CAAD,CAAM,EAAN,CAAD,CAAa,CAAC,CAAD,CAAM,GAAN,CAAb,CAAD,CAPY,CAQZ,CAAC,CAAC,CAAC,CAAD,CAAM,EAAN,CAAD,CAAa,CAAC,EAAD;AAAM,CAAN,CAAb,CAAD,CARY,CASZ,CAAC,CAAC,CAAC,EAAD,CAAM,CAAN,CAAD,CAAa,CAAC,CAAD,CAAM,EAAN,CAAb,CAAD,CATY,CAUZ,CAAC,CAAC,CAAC,CAAD,CAAM,GAAN,CAAD,CAAa,CAAC,CAAD,CAAM,EAAN,CAAb,CAAD,CAVY,CAWZ,CAAC,CAAC,CAAC,EAAD,CAAM,CAAN,CAAD,CAAa,CAAC,CAAD,CAAM,EAAN,CAAb,CAAD,CAA2B,CAAC,CAAC,GAAD,CAAM,CAAN,CAAD,CAAa,CAAC,CAAD,CAAM,GAAN,CAAb,CAA3B,CAXY,CAYZ,CAAC,CAAC,CAAC,GAAD,CAAM,CAAN,CAAD,CAAa,CAAC,CAAD,CAAM,EAAN,CAAb,CAAD,CAZY,CAaZ,CAAC,CAAC,CAAC,EAAD,CAAM,CAAN,CAAD,CAAa,CAAC,GAAD,CAAM,CAAN,CAAb,CAAD,CAbY,CAcZ,CAAC,CAAC,CAAC,CAAD,CAAM,GAAN,CAAD,CAAa,CAAC,GAAD,CAAM,CAAN,CAAb,CAAD,CAdY,CAeZ,CAAC,CAAC,CAAC,EAAD,CAAM,CAAN,CAAD,CAAa,CAAC,CAAD,CAAM,GAAN,CAAb,CAAD,CAfY,CAgBZ,EAhBY,CAkQdgC,WAAA,CAAWiJ,UAAX,CAAwB,CACtB,KAAQ,YADc,CAEtB,SAAY,CAAC,UAAa,CAAA,CAAd,CAFU,CAGtB,OAAU,CACR,CAAE,KAAQ,OAAV,CAAmB,KAAQ,OAA3B,CADQ,CAER,CAAE,KAAQ,YAAV,CAAwB,KAAQ,QAAhC,CAA0C,MAAS,CAAA,CAAnD,CAFQ,CAGR,CAAE,KAAQ,QAAV,CAAoB,KAAQ,QAA5B,CAHQ,CAIR,CAAE,KAAQ,MAAV,CAAkB,KAAQ,SAA1B,CAAqC,UAAW,CAAA,CAAhD,CAJQ,CAKR,CAAE,KAAQ,SAAV,CAAqB,KAAQ,MAA7B,CAAqC,OAAU,CAAC,QAAD,CAAW,aAAX,CAA/C,CAA0E,UAAW,aAArF,CALQ,CAMR,CAAE,KAAQ,MAAV,CAAkB,KAAQ,SAA1B,CAAqC,UAAW,CAAA,CAAhD,CANQ;AAOR,CAAE,KAAQ,QAAV,CAAoB,KAAQ,SAA5B,CAAuC,UAAW,CAAA,CAAlD,CAPQ,CAQR,CAAE,KAAQ,OAAV,CAAmB,KAAQ,QAA3B,CAAqC,KAAQ,CAAA,CAA7C,CARQ,CASR,CAAE,KAAQ,WAAV,CAAuB,KAAQ,QAA/B,CAAyC,MAAS,CAAA,CAAlD,CAAwD,KAAQ,CAAA,CAAhE,CATQ,CAUR,CAAE,KAAQ,IAAV,CAAgB,KAAQ,QAAxB,CAAkC,OAAQ,CAAA,CAA1C,CAAgD,UAAW,SAA3D,CAVQ,CAHY,CAiBxB9O,SAAA,CAAS+O,QAAT,CAAkBlJ,UAAlB,CAA8B9F,YAA9B,CAA2CgG,SAA3C,CAAsD,CACpD,UAAAiB,QAAS,CAACvC,CAAD,CAAIuK,KAAJ,CAAW,CAClB,GAAI,IAAJ,CAASpO,KAAT,EAAkB,CAACoO,KAAA,CAAMC,OAAN,EAAnB,EAAsC,CAACxK,CAAA,CAAEqJ,QAAF,EAAvC,CACE,MAAOkB,MAAP,CAAaE,eAFG,KAKdC,IAAMH,KAAA,CAAMI,IAAN,CAAWJ,KAAX,CAAiBK,SAAjB,CAA6BL,KAA7B,CAAmCM,SAAnC,CACNhF,MAAAA,CAAS0E,KAAA,CAAMO,WAAN,CAAkBP,KAAlB,CAAwBQ,MAAxB,CAATlF,CAAyCA,MAN3B,KAOdwB,MAAQrH,CAARqH,CAAUA,KAAVA,EAAmB9L,QAAnB8L,CAA4B2D,QAPd,CAQd5O,QAAUL,QAAA,EAAA,CAAWU,MAAX,CAA+B,CAAA,CAA/B;AAAkBuD,CAAlB,CAAoBvD,MAApB,CARI,CASdR,GAAK+D,CAAL/D,CAAOgP,UAAPhP,EAAqBuF,MAAA,CAAOqE,KAAP,CAAewB,KAAf,CAAsBrH,CAAtB,CATP,CAUdkL,GAAc,IAAT,GAAAlL,CAAA,CAAEkL,EAAF,CAAgB,IAAhB,CAAuBlL,CAAvB,CAAyBkL,EAAzB,EAA+B,SAVtB,CAWdlP,OAAS,EAEb6J,MAAA,CAAO9I,OAAP,CAAe,QAAA,CAAA2E,CAAA,CAAK,CAClB,IAAMI,KAAOuF,KAAA,CAAM3F,CAAN,CAAb,CAGMG,MAAQzF,OAAA,CAAQ0D,IAAR,CAAa,CAACgC,IAAD,CAAMgD,KAAN,CAAahD,IAAb,CAAkBiD,MAAlB,CAAb,CAAA,CACZjD,IADY,CACP9F,MADO,CACCT,QAAA,CAAS4P,OAAT,CAAiBlP,EAAjB,CAAA,CAAuBA,EAAvB,CAA4BA,EAAA,CAAG6F,IAAH,CAAQ9F,MAAR,CAD7B,CAKd4F,eAAA,CAAeC,KAAf,CAAsBC,IAAtB,CAA4BJ,CAA5B,CAA+B1B,CAA/B,CAGA6B,MAAA,CAAM9E,OAAN,CAAc,QAAA,CAAAiB,CAAA,CAAK,CACjB,IAAA,mBAAsE,EAAtEhC,OAAA,CAAOc,IAAP,CAAYxB,YAAA,CAAa8P,QAAb,CAAsB1J,CAAtB,CAAyBpG,YAAA,CAAa+P,MAAb,CAA0B,IAAN,EAAAH,EAAA,EAAa,kBAAA,CAAEA,EAAF,CAAA,CAAOlN,CAAP,CAAA,kBAAb,EAAyBA,CAA7C,CAAzB,CAAZ,CADiB,CAAnB,CAZkB,CAApB,CAiBI,KAAJ,CAAS7B,KAAT,GAAgBuO,GAAhB,CAAoBY,GAApB,CAA0B,IAA1B,CAA+BnP,KAA/B,CACA,KAAA,CAAKA,KAAL,CAAauO,GAAb,CAAiB7E,MAAjB,CAA0B6E,GAA1B,CAA8Ba,GAA9B;AAAoCvP,MAEpC,OAAO0O,IAjCW,CADgC,CAAtD,CAuQAzE,MAAA,CAAMoE,UAAN,CAAmB,CACjB,KAAQ,OADS,CAEjB,SAAY,CAAC,UAAa,CAAA,CAAd,CAFK,CAGjB,OAAU,CACR,CAAE,KAAQ,MAAV,CAAkB,KAAQ,QAA1B,CAAoC,MAAS,CAAA,CAA7C,CAAmD,OAAU,CAA7D,CAAgE,SAAY,CAAA,CAA5E,CADQ,CAER,CAAE,KAAQ,GAAV,CAAe,KAAQ,OAAvB,CAAgC,SAAY,CAAA,CAA5C,CAFQ,CAGR,CAAE,KAAQ,GAAV,CAAe,KAAQ,OAAvB,CAAgC,SAAY,CAAA,CAA5C,CAHQ,CAIR,CAAE,KAAQ,QAAV,CAAoB,KAAQ,OAA5B,CAJQ,CAKR,CAAE,KAAQ,SAAV,CAAqB,KAAQ,OAA7B,CAAsC,MAAS,CAAA,CAA/C,CALQ,CAMR,CAAE,KAAQ,UAAV,CAAsB,KAAQ,QAA9B,CANQ,CAOR,CAAE,KAAQ,WAAV,CAAuB,KAAQ,QAA/B,CAAyC,MAAS,CAAA,CAAlD,CAAwD,OAAU,CAAlE,CAPQ,CAQR,CAAE,KAAQ,QAAV,CAAoB,KAAQ,SAA5B,CAAuC,UAAW,CAAA,CAAlD,CARQ,CASR,CAAE,KAAQ,IAAV,CAAgB,KAAQ,QAAxB,CAAkC,UAAW,MAA7C,CATQ,CAHO,CAgBnB,KAAMlE,OAAS,oCAAA,CAAA,KAAA,CAAA,GAAA,CAOf5K;QAAA,CAAS+O,QAAT,CAAkBrE,KAAlB,CAAyB3K,YAAzB,CAAsCgG,SAAtC,CAAiD,CAC/C,UAAAiB,QAAS,CAACvC,CAAD,CAAIuK,KAAJ,CAAW,CAYlBlC,QAASA,IAAG,CAAC3G,CAAD,CAAI8J,IAAJ,CAAU,CACpB,IAAK,IAAI9O,EAAE,CAAX,CAAcA,CAAd,CAAgB+O,KAAhB,CAAsB7O,MAAtB,CAA8B,EAAEF,CAAhC,CAAmCgF,CAAA,CAAE+J,KAAA,CAAM/O,CAAN,CAAF,CAAA,CAAc8O,IAAA,CAAK9O,CAAL,CACjD,OAAOgF,EAFa,CAXtB,GAAI,IAAJ,CAASvF,KAAT,EAAkB,CAACoO,KAAA,CAAMC,OAAN,EAAnB,EAAsC,CAACxK,CAAA,CAAEqJ,QAAF,EAAvC,CACE,MAAOkB,MAAP,CAAaE,eAFG,KAIdC,IAAMH,KAAA,CAAMI,IAAN,CAAWJ,KAAX,CAAiBK,SAAjB,CAA6BL,KAA7B,CAAmCM,SAAnC,CACNhF,MAAAA,CAAS0E,KAAA,CAAMO,WAAN,CAAkBP,KAAlB,CAAwBQ,MAAxB,CAATlF,CAAyCA,MACzCU,MAAAA,CAASF,SAAA,CAAUR,KAAV,CAAkB7F,CAAlB,CAAoBsG,OAApB,CANK,KAOdmF,MAAQ,CAACzL,CAAD,CAAGsG,OAAH,EAAc,EAAd,EAAkBpK,GAAlB,CAAsBX,QAAtB,CAA+BmQ,YAA/B,CAPM,CAQdC,IAAMtK,eAAA,CAAOsC,SAAA,EAAP,CAAoB3D,CAApB,CARQ,CASdkL,GAAKlL,CAALkL,CAAOA,EAAPA,EAAa,MATC,CAUdlP,OAAS,EAQbA,OAAA,CAASuK,KAAA,CAAOrK,GAAP,CAAW,QAAA,CAAA4C,CAAA,CAAK,CAAA,IAAA;AACnB,EADmB,OAAAxD,aAAA,CAAa+P,MAAb,CACvBhD,GAAA,EAAI,kBAAA,CAAE6C,EAAF,CAAA,CAAOS,GAAA,CAAI7M,CAAJ,CAAOkB,CAAP,CAAS6D,MAAT,CAAP,CAAA,kBAAJ,EAA8B/E,CAA9B,CAAgC2H,IAAhC,CADuB,CAAA,CAAhB,CAIL,KAAJ,CAAStK,KAAT,GAAgBuO,GAAhB,CAAoBY,GAApB,CAA0B,IAA1B,CAA+BnP,KAA/B,CACA,KAAA,CAAKA,KAAL,CAAauO,GAAb,CAAiB7E,MAAjB,CAA0B6E,GAA1B,CAA8Ba,GAA9B,CAAoCvP,MAEpC,OAAO0O,IAzBW,CAD2B,CAAjD,CAsFAhE,QAAA,CAAQ2D,UAAR,CAAqB,CACnB,KAAQ,SADW,CAEnB,SAAY,CAAC,UAAa,CAAA,CAAd,CAFO,CAGnB,OAAU,CACR,CAAE,KAAQ,MAAV,CAAkB,KAAQ,QAA1B,CAAoC,MAAS,CAAA,CAA7C,CAAmD,OAAU,CAA7D,CAAgE,SAAY,CAAA,CAA5E,CADQ,CAER,CAAE,KAAQ,QAAV,CAAoB,KAAQ,QAA5B,CAAsC,MAAS,CAAA,CAA/C,CAFQ,CAGR,CAAE,KAAQ,GAAV,CAAe,KAAQ,OAAvB,CAHQ,CAIR,CAAE,KAAQ,GAAV,CAAe,KAAQ,OAAvB,CAJQ,CAKR,CAAE,KAAQ,QAAV,CAAoB,KAAQ,OAA5B,CALQ,CAMR,CAAE,KAAQ,UAAV,CAAsB,KAAQ,QAA9B,CANQ,CAOR,CAAE,KAAQ,WAAV,CAAuB,KAAQ,QAA/B,CAPQ,CAQR,CAAE,KAAQ,OAAV;AAAmB,KAAQ,QAA3B,CARQ,CASR,CAAE,KAAQ,MAAV,CAAkB,KAAQ,SAA1B,CAAqC,UAAW,CAAA,CAAhD,CATQ,CAUR,CAAE,KAAQ,YAAV,CAAwB,KAAQ,QAAhC,CAA0C,MAAS,CAAA,CAAnD,CAVQ,CAWR,CAAE,KAAQ,QAAV,CAAoB,KAAQ,SAA5B,CAAuC,UAAW,CAAA,CAAlD,CAXQ,CAHS,CAkBrB9O,SAAA,CAAS+O,QAAT,CAAkB5D,OAAlB,CAA2BpL,YAA3B,CAAwCgG,SAAxC,CAAmD,CACjD,UAAAiB,QAAS,CAACvC,CAAD,CAAIuK,KAAJ,CAAW,CAClB,GAAI,IAAJ,CAASpO,KAAT,EAAkB,CAACoO,KAAA,CAAMC,OAAN,EAAnB,EAAsC,CAACxK,CAAA,CAAEqJ,QAAF,EAAvC,CACE,MAAOkB,MAAP,CAAaE,eAFG,KAKdC,IAAMH,KAAA,CAAMI,IAAN,CAAWJ,KAAX,CAAiBK,SAAjB,CAA6BL,KAA7B,CAAmCM,SAAnC,CALQ,CAMdzO,QAAUL,QAAA,EAAA,CAAWU,MAAX,CAA+B,CAAA,CAA/B,GAAkBuD,CAAlB,CAAoBvD,MAApB,CANI,CAOdT,OAASgE,CAAThE,CAAWA,MAPG,CAQd4P,OAAS5L,CAAT4L,CAAWX,UAAXW,EAAyBpL,QAAA,CAASR,CAAT,CAAW6L,KAAX,EAAoB,EAApB,CAAwB7L,CAAxB,CAA0BU,IAA1B,CAAgC,CAAC,CAAC1E,MAAlC,CARX,CASd8D,KAAOE,CAAPF,CAASA,IAEb,IAAI,CAAC9D,MAAL,CAAa,CACXA,MAAA,CAASuO,KAAA,CAAMO,WAAN,CAAkBP,KAAlB,CAAwBQ,MAAxB,CAAT,CAAyClF,MACzC/D;CAAA,CAAOT,eAAA,CAAOsC,SAAA,EAAP,CAAoB3D,CAApB,CAAA,CAAuBhE,MAAvB,CAA+B,CAAA,CAA/B,CACP,KAAA8P,KAAOvJ,SAAA,CAAUT,CAAV,CAAgBA,CAAhB,CAAqBG,KAArB,EAA8B,CAA9B,CAAiCH,CAAjC,CAAsCG,KAAtC,EAA+C,CAA/C,CAAkD,CAAlD,CAAqD,CAArD,CACPnC,KAAA,CAAO,CAACgC,CAAD,CAAMgD,KAAN,CAAahD,CAAb,CAAkBiD,MAAlB,CACP/I,OAAA,CAAS8F,CAAT,CAAc9F,MALH,CAQb4P,MAAA,CAASrQ,QAAA,CAAS4P,OAAT,CAAiBS,MAAjB,CAAA,CAA2BA,MAA3B,CAAoCA,MAAA,CAAO5P,MAAP,CAC7CA,OAAA,CAASI,OAAA,CAAQ0D,IAAR,CAAaA,IAAb,CAAA,CAAmB9D,MAAnB,CAA2B4P,MAA3B,CACLE,KAAJ,EAAU9P,MAAA,CAAOe,OAAP,CAAe+O,IAAf,CAEN,KAAJ,CAAS3P,KAAT,GAAgBuO,GAAhB,CAAoBY,GAApB,CAA0B,IAA1B,CAA+BnP,KAA/B,CACA,KAAA,CAAKA,KAAL,CAAauO,GAAb,CAAiB7E,MAAjB,CAA0B6E,GAA1B,CAA8Ba,GAA9B,CAAoC,CAACvP,MAAD,EAAW,EAAX,EAAeE,GAAf,CAAmBZ,YAAnB,CAAgC+P,MAAhC,CAEpC,OAAOX,IA1BW,CAD6B,CAAnD,CAmDA/D,QAAA,CAAQ0D,UAAR,CAAqB,CACnB,KAAQ,SADW,CAEnB,SAAY,EAFO,CAGnB,OAAU,CACR,CAAE,KAAQ,QAAV,CAAoB,KAAQ,OAA5B,CAAqC,MAAS,CAAA,CAA9C,CAAoD,OAAU,CAA9D,CADQ,CAER,CAAE,KAAQ,SAAV,CAAqB,KAAQ,OAA7B,CAFQ,CAHS,CASrB9O;QAAA,CAAS+O,QAAT,CAAkB3D,OAAlB,CAA2BrL,YAA3B,CAAwCgG,SAAxC,CAAmD,CACjD,UAAAiB,QAAS,CAACvC,CAAD,CAAIuK,KAAJ,CAAW,CAAA,IACdP,SAAW,IAAXA,CAAgB+B,SADF,CAEdC,OAAS,IAATA,CAAcC,OAFA,CAGdC,OAASlM,CAATkM,CAAWA,MAHG,CAIdC,IAAMD,MAANC,EAAgBD,MAAA,CAAO,CAAP,CAJF,CAKdE,IAAMF,MAANE,EAAgBF,MAAA,CAAO,CAAP,CALF,CAMdG,QAAUrM,CAAVqM,CAAYA,OAAZA,EAAwB,CAACH,MAAzBG,EAAmC9Q,QAAnC8Q,CAA4CrB,QAC5CsB,OAAAA,CAAO/B,KAAP+B,CAAaC,GAGjBC,EAAA,CAAMxM,CAAA,CAAEqJ,QAAF,EAAN,EACKkB,KAAA,CAAMC,OAAN,CAAcD,KAAd,CAAoBkC,GAApB,CADL,EAEKlC,KAAA,CAAMlB,QAAN,CAAe9N,QAAA,CAASgN,cAAT,CAAwB8D,OAAxB,CAAf,CAFL,EAGMF,GAHN,EAGc5B,KAAA,CAAMlB,QAAN,CAAe9N,QAAA,CAASgN,cAAT,CAAwB4D,GAAxB,CAAf,CAHd,EAIMC,GAJN,EAIc7B,KAAA,CAAMlB,QAAN,CAAe9N,QAAA,CAASgN,cAAT,CAAwB6D,GAAxB,CAAf,CAEd,IAAI,CAAC,IAAD,CAAMjQ,KAAV,EAAmBqQ,CAAnB,CACEF,MAEA,CAFO/B,KAEP,CAFaQ,MAEb,CADA,IACA,CADKgB,SACL,CADkB/B,QAClB;AAD6B,EAC7B,CAAA,IAAA,CAAKiC,OAAL,CAAgBD,MAAhB,CAAyB,EAGvBK,QAAJ,EACE9B,KAAA,CAAMmC,KAAN,CAAYJ,MAAZ,CAAkB,QAAA,CAAA5K,CAAA,CAAK,CAAA,MAAAsI,SAAA,CAASlN,IAAT,CAAcuP,OAAA,CAAQ3K,CAAR,CAAd,CAAA,CAAvB,CAGEyK,IAAJ,EAAWC,GAAX,GACE7B,KAAA,CAAMmC,KAAN,CAAYJ,MAAZ,CAAkB,QAAA,CAAA5K,CAAA,CAAK,CAAA,IACjBxE,EAAIiP,GAAA,CAAIzK,CAAJ,CACJtE,EAAAA,CAAIgP,GAAA,CAAI1K,CAAJ,CACC,KAAT,EAAIxE,CAAJ,EAAsB,IAAtB,EAAiBE,CAAjB,GAA+BF,CAA/B,CAAmC,CAACA,CAApC,IAA2CA,CAA3C,GAAiDE,CAAjD,CAAqD,CAACA,CAAtD,IAA6DA,CAA7D,EACE4O,MAAA,CAAOlP,IAAP,CAAY,CAACI,CAAD,CAAIE,CAAJ,CAAZ,CAJmB,CAAvB,CAOA,CAAA4M,QAAA,CAAWA,QAAA,CAAS/K,MAAT,CAAgB,CACzBd,KAjEMiM,SAgEmB,CAEzBnH,SAAU,CACR9E,KAjEOwO,YAgEC,CAERvO,YAAa4N,MAFL,CAFe,CAAhB,CARb,CAiBA,KAAA,CAAK7P,KAAL,CAAa,CACXgC,KAzEkB4L,mBAwEP,CAEXC,SAAUA,QAFC,CA3CK,CAD6B,CAAnD,CAkEApD,QAAA,CAAQyD,UAAR,CAAqB,CACnB,KAAQ,SADW,CAEnB,SAAY,CAAC,SAAY,CAAA,CAAb,CAFO,CAGnB,OAAU,CACR,CAAE,KAAQ,YAAV,CAAwB,KAAQ,YAAhC,CADQ,CAER,CAAE,KAAQ,OAAV,CAAmB,KAAQ,OAA3B,CAFQ;AAGR,CAAE,KAAQ,aAAV,CAAyB,KAAQ,QAAjC,CAA2C,KAAQ,CAAA,CAAnD,CAHQ,CAIR,CAAE,KAAQ,IAAV,CAAgB,KAAQ,QAAxB,CAAkC,UAAW,MAA7C,CAJQ,CAHS,CAWrB9O,SAAA,CAAS+O,QAAT,CAAkB1D,OAAlB,CAA2BtL,YAA3B,CAAwCgG,SAAxC,CAAmD,CACjD,UAAAiB,QAAS,CAACvC,CAAD,CAAIuK,KAAJ,CAAW,CAAA,IACdG,IAAMH,KAAA,CAAMI,IAAN,CAAWJ,KAAX,CAAiBqC,GAAjB,CADQ,CAEd9F,KAAO,IAAPA,CAAY3K,KAFE,CAGdkL,MAAQrH,CAARqH,CAAUA,KAAVA,EAAmB9L,QAAnB8L,CAA4B2D,QAHd,CAIdE,GAAKlL,CAALkL,CAAOA,EAAPA,EAAa,MAJC,CAKdoB,KAAO5B,GAAP4B,CAAWvB,MAEX,EAACjE,IAAL,EAAa9G,CAAA,CAAEqJ,QAAF,EAAb,EAEE,IACA,CADKlN,KACL,CADa2K,IACb,CADoBpL,cAAA,CAAemR,iBAAf,CAAiC7M,CAAjC,CAAmC6J,UAAnC,CACpB,CAAAa,GAAA,CAAII,WAAJ,EAAA,CAAkBgC,MAAlB,EAHF,EAKER,IALF,CAKSjF,KAAA,GAAU9L,QAAV,CAAmByP,QAAnB,EAA+BT,KAAA,CAAMlB,QAAN,CAAehC,KAAf,CAAqB6E,MAArB,CAA/B,CACHxB,GADG,CACCqC,OADD,CAEHrC,GAFG,CAEC6B,GAGNvF,EAAAA,CAAOH,QAAA,CAASC,IAAT,CAAe9G,CAAf,CAAiB+G,WAAjB,CACX2D;GAAA,CAAIgC,KAAJ,CAAUJ,IAAV,CAAgB,QAAA,CAAA5K,CAAA,CAAK,CAAA,MAAAA,EAAA,CAAEwJ,EAAF,CAAA,CAAQpE,IAAA,CAAKO,KAAA,CAAM3F,CAAN,CAAL,CAAR,CAArB,CACAoF,KAAA,CAAKC,WAAL,CAAiBC,CAAjB,CAEA,OAAO0D,IAAA,CAAIsC,QAAJ,CAAa9B,EAAb,CArBW,CAD6B,CAAnD,CAkDAhE,SAAA,CAASmD,UAAT,CAAsB,CACpB,KAAQ,UADY,CAEpB,SAAY,CAAC,SAAY,CAAA,CAAb,CAFQ,CAGpB,OAAU,CACR,CAAE,KAAQ,YAAV,CAAwB,KAAQ,YAAhC,CAA8C,SAAY,CAAA,CAA1D,CADQ,CAER,CAAE,KAAQ,QAAV,CAAoB,KAAQ,OAA5B,CAAqC,MAAS,CAAA,CAA9C,CAAoD,SAAY,CAAA,CAAhE,CAAsE,OAAU,CAAhF,CAFQ,CAGR,CAAE,KAAQ,IAAV,CAAgB,KAAQ,QAAxB,CAAkC,MAAS,CAAA,CAA3C,CAAiD,OAAU,CAA3D,CAA8D,UAAW,CAAC,GAAD,CAAM,GAAN,CAAzE,CAHQ,CAHU,CAUtB9O,SAAA,CAAS+O,QAAT,CAAkBpD,QAAlB,CAA4B5L,YAA5B,CAAyCgG,SAAzC,CAAoD,CAClD,UAAAiB,QAAS,CAACvC,CAAD,CAAIuK,KAAJ,CAAW,CASlBlC,QAASA,IAAG,CAAC3G,CAAD,CAAI,CACd,IAAIuL,GAAK1D,IAAA,CAAK,CAAC4C,GAAA,CAAIzK,CAAJ,CAAD,CAAS0K,GAAA,CAAI1K,CAAJ,CAAT,CAAL,CACLuL,GAAJ,EACEvL,CAAA,CAAExE,CAAF,CACA,CADO+P,EAAA,CAAG,CAAH,CACP,CAAAvL,CAAA,CAAEtE,CAAF,CAAA,CAAO6P,EAAA,CAAG,CAAH,CAFT,GAIEvL,CAAA,CAAExE,CAAF,CACA;AADOgQ,IAAAA,EACP,CAAAxL,CAAA,CAAEtE,CAAF,CAAA,CAAO8P,IAAAA,EALT,CAFc,CATE,IACd3D,KAAOvJ,CAAPuJ,CAASM,UADK,CAEdsC,IAAMnM,CAAA,CAAEkM,MAAF,CAAS,CAAT,CAFQ,CAGdE,IAAMpM,CAAA,CAAEkM,MAAF,CAAS,CAAT,CAHQ,CAIdhB,GAAKlL,CAALkL,CAAOA,EAAPA,EAAa,CAAC,GAAD,CAAM,GAAN,CAJC,CAKdhO,EAAIgO,EAAA,CAAG,CAAH,CALU,CAMd9N,EAAI8N,EAAA,CAAG,CAAH,CAcJlL,EAAA,CAAEqJ,QAAF,EAAJ,CAEEkB,KAFF,CAEUA,KAAA,CAAMO,WAAN,EAAA,CAAoBgC,MAApB,CAA2B,CAAA,CAA3B,CAAA,CAAiCJ,KAAjC,CAAuCnC,KAAvC,CAA6CQ,MAA7C,CAAqD1C,GAArD,CAFV,EAIEmE,CACA,CADMjC,KAAA,CAAMlB,QAAN,CAAe8C,GAAf,CAAmBD,MAAnB,CACN,EADoC3B,KAAA,CAAMlB,QAAN,CAAe+C,GAAf,CAAmBF,MAAnB,CACpC,CAAA3B,KAAA,CAAMmC,KAAN,CAAYF,CAAA,CAAMjC,KAAN,CAAYwC,OAAZ,CAAsBxC,KAAtB,CAA4BgC,GAAxC,CAA6ClE,GAA7C,CALF,CAQA,OAAOkC,MAAA,CAAMyC,QAAN,CAAe9B,EAAf,CA5BW,CAD8B,CAApD,CAgDA/D,SAAA,CAASkD,UAAT,CAAsB,CACpB,KAAQ,UADY,CAEpB,SAAY,CAAC,SAAY,CAAA,CAAb,CAAmB,MAAS,CAAA,CAA5B,CAFQ,CAGpB,OAAU,CACR,CAAE,KAAQ,YAAV,CAAwB,KAAQ,YAAhC,CADQ,CAER,CAAE,KAAQ,OAAV,CAAmB,KAAQ,OAA3B,CAAoC,UAAW,OAA/C,CAFQ,CAGR,CAAE,KAAQ,aAAV,CAAyB,KAAQ,QAAjC;AAA2C,KAAQ,CAAA,CAAnD,CAHQ,CAIR,CAAE,KAAQ,IAAV,CAAgB,KAAQ,QAAxB,CAAkC,UAAW,OAA7C,CAJQ,CAHU,CAWtB9O,SAAA,CAAS+O,QAAT,CAAkBnD,QAAlB,CAA4B7L,YAA5B,CAAyCgG,SAAzC,CAAoD,CAClD,UAAAiB,QAAS,CAACvC,CAAD,CAAIuK,KAAJ,CAAW,CACdG,KAAAA,CAAMH,KAAA,CAAMI,IAAN,CAAWJ,KAAX,CAAiBqC,GAAjB,CADQ,KAEdtF,MAAQ,IAARA,CAAanL,KAFC,CAGd+O,GAAKlL,CAALkL,CAAOA,EAAPA,EAAa,OAHC,CAIdoB,KAAO5B,KAAP4B,CAAWC,GAEf,IAAI,CAACjF,KAAL,EAActH,CAAA,CAAEqJ,QAAF,EAAd,CAEE,IAMA,CANKlN,KAML,CANamL,KAMb,CANqBF,cAAA,CACnB1L,cAAA,CAAemR,iBAAf,CAAiC7M,CAAjC,CAAmC6J,UAAnC,CADmB,CAEnB7J,CAFmB,CAEjBqH,KAFiB,EAER9L,QAAA,CAAS8L,KAAT,CAAe,OAAf,CAFQ,CAGnBrH,CAHmB,CAGjB+G,WAHiB,CAMrB,CADA2D,KAAA,CAAII,WAAJ,EAAA,CAAkBgC,MAAlB,EACA,CAAAR,IAAA,CAAO5B,KAAP,CAAWK,MAGbL,MAAA,CAAIgC,KAAJ,CAAUJ,IAAV,CAAgB,QAAA,CAAA5K,CAAA,CAAK,CAAA,MAAAA,EAAA,CAAEwJ,EAAF,CAAA,CAAQ5D,KAAR,CAArB,CAEA,OAAOoD,MAAA,CAAIsC,QAAJ,CAAa9B,EAAb,CAnBW,CAD8B,CAApD,CAkDA1D,UAAA,CAAU6C,UAAV;AAAuB,CACrB,KAAQ,WADa,CAErB,SAAY,CAAC,QAAW,CAAA,CAAZ,CAAkB,UAAa,CAAA,CAA/B,CAFS,CAGrB,OAAU,CACR,CAAE,KAAQ,QAAV,CAAoB,KAAQ,OAA5B,CAAqC,MAAS,CAAA,CAA9C,CAAoD,OAAU,CAA9D,CACE,QAAW,CAAC,KAAQ,QAAT,CAAmB,MAAS,CAAA,CAA5B,CAAkC,OAAU,CAA5C,CADb,CADQ,CAGR,CAAE,KAAQ,aAAV,CAAyB,KAAQ,OAAjC,CAA0C,MAAS,CAAA,CAAnD,CAAyD,OAAU,CAAnE,CACE,QAAW,CAAC,KAAQ,QAAT,CAAmB,MAAS,CAAA,CAA5B,CAAkC,OAAU,CAA5C,CADb,CAHQ,CAKR,CAAE,KAAQ,aAAV,CAAyB,KAAQ,OAAjC,CAA0C,MAAS,CAAA,CAAnD,CAAyD,OAAU,CAAnE,CACE,QAAW,CAAC,KAAQ,QAAT,CAAmB,MAAS,CAAA,CAA5B,CAAkC,OAAU,CAA5C,CADb,CALQ,CAOR,CAAE,KAAQ,MAAV,CAAkB,KAAQ,QAA1B,CAAoC,MAAS,CAAA,CAA7C,CAAmD,OAAU,CAA7D,CAPQ,CAQR,CAAE,KAAQ,WAAV,CAAuB,KAAQ,QAA/B,CAAyC,MAAS,CAAA,CAAlD,CAAwD,OAAU,CAAlE,CAAqE,UAAW,CAAC,EAAD,CAAK,GAAL,CAAhF,CARQ,CASR,CAAE,KAAQ,WAAV,CAAuB,KAAQ,QAA/B,CAAyC,MAAS,CAAA,CAAlD,CAAwD,OAAU,CAAlE;AAAqE,UAAW,CAAC,EAAD,CAAK,EAAL,CAAhF,CATQ,CAUR,CAAE,KAAQ,WAAV,CAAuB,KAAQ,QAA/B,CAAyC,UAAW,GAApD,CAVQ,CAHW,CAiBvB9O,SAAA,CAAS+O,QAAT,CAAkB9C,SAAlB,CAA6BlM,YAA7B,CAA0CgG,SAA1C,CAAqD,CACnD,UAAAiB,QAAS,CAACvC,CAAD,CAAIuK,KAAJ,CAAW,CAAA,IACd4C,IAAM,IAANA,CAAWhR,KADG,CAEdiR,IAAM,IAANA,CAAW3F,SAEf,IAAI,CAAC0F,GAAD,CAAKvQ,MAAT,EAAmBoD,CAAA,CAAEqJ,QAAF,EAAnB,CACE,IAAKgE,IAAIA,IAAT,GAAiBrN,EAAjB,CACE,GAAIzE,QAAA,CAAS4G,UAAT,CAAoBiL,GAAA,CAAIC,IAAJ,CAApB,CAAJ,CACED,GAAA,CAAIC,IAAJ,CAAA,CAAUrN,CAAA,CAAEqN,IAAF,CAAV,CAKN3L,EAAA,CAAI0L,GAAA,EACAD,IAAJ,CAAQvQ,MAAR,CACE2N,KAAA,CAAMiC,GAAN,CAAU1P,IAAV,CAAexB,YAAA,CAAagS,OAAb,CAAqBH,GAAA,CAAI,CAAJ,CAArB,CAA6BzL,CAA7B,CAAf,CADF,CAGE6I,KAAA,CAAMgB,GAAN,CAAUzO,IAAV,CAAexB,YAAA,CAAa+P,MAAb,CAAoB3J,CAApB,CAAf,CAEFyL,IAAA,CAAI,CAAJ,CAAA,CAASzL,CAET,OAAO6I,MApBW,CAD+B,CAArD,CAgDA5C,QAAA,CAAQ0C,UAAR,CAAqB,CACnB,KAAQ,SADW,CAEnB,SAAY,CAAC,SAAY,CAAA,CAAb,CAFO,CAGnB,OAAU,CACR,CAAE,KAAQ,OAAV,CAAmB,KAAQ,OAA3B,CADQ;AAER,CAAE,KAAQ,OAAV,CAAmB,KAAQ,QAA3B,CAAqC,KAAQ,CAAA,CAA7C,CAFQ,CAGR,CAAE,KAAQ,SAAV,CAAqB,KAAQ,QAA7B,CAAuC,KAAQ,CAAA,CAA/C,CAHQ,CAIR,CAAE,KAAQ,SAAV,CAAqB,KAAQ,MAA7B,CAAqC,OAAU,CAAC,QAAD,CAAW,aAAX,CAA/C,CAA0E,UAAW,aAArF,CAJQ,CAKR,CAAE,KAAQ,IAAV,CAAgB,KAAQ,QAAxB,CAAkC,UAAW,OAA7C,CALQ,CAHS,CAYrB9O,SAAA,CAAS+O,QAAT,CAAkB3C,OAAlB,CAA2BrM,YAA3B,CAAwCgG,SAAxC,CAAmD,CACjD,UAAAiB,QAAS,CAACvC,CAAD,CAAIuK,KAAJ,CAAW,CAClB,GAAI,CAACA,KAAA,CAAMC,OAAN,EAAL,EAAwB,CAACxK,CAAA,CAAEqJ,QAAF,EAAzB,CACE,MAAOkB,MAAP,CAAaE,eAFG,KAKd5E,OAAS0E,KAAA,CAAMO,WAAN,CAAkBP,KAAlB,CAAwBQ,MAAxB,CAATlF,CAAyCA,MAL3B,CAMd0H,OAAuB,QAAvBA,GAASvN,CAATuN,CAAW9L,OANG,CAOd4F,MAAQrH,CAARqH,CAAUA,KAAVA,EAAmB9L,QAAnB8L,CAA4B2D,QAPd,CAQd9C,QAAUD,QAAA,CAASjI,CAAT,CAAWkI,OAAX,CAAoBlI,CAApB,CARI,CASd6H,MAAQD,MAAA,CAAO5H,CAAP,CAAS6H,KAAT;AAAgB7H,CAAhB,CATM,CAUdkL,GAAKlL,CAALkL,CAAOA,EAAPA,EAAa,OAVC,CAWdhF,IAAM,CACJsC,GAAI,CADA,CACGC,GAAI,CADP,CACUN,OAAQ,CADlB,CAEJC,KAAMmF,MAAA,CAAS/R,OAAA,CAAQmG,GAAR,CAAYkE,MAAA,CAAO3J,GAAP,CAAW,QAAA,CAAAwF,CAAA,CAAK,CAAA,MAAAlG,QAAA,CAAQmG,GAAR,CAAY0F,KAAA,CAAM3F,CAAN,CAAZ,CAAqB1F,MAArB,CAAA,CAAhB,CAAZ,CAAT,CAAsE,CAFxE,CAKV6J,OAAA,CAAO9I,OAAP,CAAe,QAAA,CAAA2E,CAAA,CAAK,CAClB,IAAM2B,EAAIgE,KAAA,CAAM3F,CAAN,CAAV,CAGM8L,EAAIjS,QAAA,CAASkS,MAAT,CAAgB,EAAhB,CAAoB/L,CAApB,CAAuBwE,GAAvB,CAELqH,OAAL,GAAaC,CAAb,CAAepF,IAAf,CAAsB5M,OAAA,CAAQmG,GAAR,CAAY0B,CAAZ,CAAcrH,MAAd,EAAwB,EAAxB,CAAtB,CAIA0F,EAAA,CAAEwJ,EAAF,CAAA,CAAQxC,QAAA,CAASrF,CAAT,CAAYmK,CAAZ,CACN3F,KAAA,CAAME,GAAN,CAAYF,KAAZ,CAAoBtM,QAAA,CAASmI,QAAT,CAAkBmE,KAAA,CAAM2F,CAAN,CAAlB,CADd,CAENtF,OAAA,CAAQH,GAAR,CAAcG,OAAd,CAAwB3M,QAAA,CAASmI,QAAT,CAAkBwE,OAAA,CAAQsF,CAAR,CAAlB,CAFlB,CAVU,CAApB,CAgBA,OAAOjD,MAAA,CAAMuC,MAAN,CAAa,CAAA,CAAb,CAAA,CAAmBE,QAAnB,CAA4B9B,EAA5B,CAhCW,CAD6B,CAAnD,CAoHA3P,SAAA,CAAS+O,QAAT,CAAkBlB,UAAlB,CAA8B9N,YAA9B,CAA2CgG,SAA3C,CAAsD,CACpD,UAAAiB,QAAS,CAACvC,CAAD,CAAIuK,KAAJ,CAAW,CAClB,IAAIhB;AAAO,IAAPA,CAAYpN,KAEZ,EAACoN,aAAL,EAAavJ,CAAA,CAAEqJ,QAAF,CAAW,MAAX,CAAb,EACE,IACA,CADKlN,KACL,CADcoN,aACd,CADqBI,MAAA,CAAO3J,CAAP,CAAS7B,IAAT,CACrB,CAAAzC,cAAA,CAAegS,oBAAf,CAAoC3Q,OAApC,CAA4C,QAAA,CAAAsQ,IAAA,CAAQ,CAClD,GAAe,IAAf,EAAIrN,CAAA,CAAEqN,IAAF,CAAJ,CAAqB,CAAI9D,IAAAA,KAAAA,aAAAA,CAAY,MAAAvJ,CAAA,CAAEqN,IAAF,CA4B1C,IAAI9R,QAAA,CAAS4G,UAAT,CAAoBoH,IAAA,CA5BY8D,IA4BZ,CAApB,CAAJ,CAAoC9D,IAAA,CA5BA8D,IA4BA,CAAA,CAAUlR,KAAV,CA5BV,CAD6B,CAApD,CAFF,EAMET,cAAA,CAAegS,oBAAf,CAAoC3Q,OAApC,CAA4C,QAAA,CAAAsQ,IAAA,CAAQ,CAClD,GAAIrN,CAAA,CAAEqJ,QAAF,CAAWgE,IAAX,CAAJ,CAAsB,CAAI9D,IAAAA,KAAAA,aAAAA,CAAY,MAAAvJ,CAAA,CAAEqN,IAAF,CAwB3C,IAAI9R,QAAA,CAAS4G,UAAT,CAAoBoH,IAAA,CAxBa8D,IAwBb,CAApB,CAAJ,CAAoC9D,IAAA,CAxBC8D,IAwBD,CAAA,CAAUlR,KAAV,CAxBT,CAD4B,CAApD,CAKmB,KAArB,EAAI6D,CAAJ,CAAM+G,WAAN,EAA2BwC,aAAA,CAAKzC,IAAL,CAAUC,WAAV,CAAsB/G,CAAtB,CAAwB+G,WAAxB,CACvB/G,EAAJ,CAAMsJ,GAAN;AAAWA,GAAA,CAAIC,aAAJ,CAAUvJ,CAAV,CAEX,OAAOuK,MAAA,CAAMI,IAAN,CAAWJ,KAAX,CAAiBK,SAAjB,CAA6BL,KAA7B,CAAmCM,SAAnC,CAjBW,CADgC,CAAtD,CAuDAhQ,QAAA,CAAQuB,OAAR,CAAkBsK,OAClB7L,QAAA,CAAQwR,OAAR,CAAkB1F,OAClB9L,QAAA,CAAQ8S,OAAR,CAAkB/G,OAClB/L,QAAA,CAAQ+S,QAAR,CAAmB1G,QACnBrM,QAAA,CAAQgT,QAAR,CAAmB1G,QACnBtM,QAAA,CAAQiT,SAAR,CAAoBtG,SACpB3M,QAAA,CAAQkT,OAAR,CAAkBpG,OAClB9M,QAAA,CAAQmT,UAAR,CAAqB5M,UACrBvG,QAAA,CAAQoT,KAAR,CAAgBhI,KAChBpL,QAAA,CAAQgP,UAAR,CAAqBT,UAErB8E,OAAA,CAAOC,cAAP,CAAsBtT,OAAtB,CAA+B,YAA/B,CAA6C,CAAEsB,MAAO,CAAA,CAAT,CAA7C,CAltCuH,CAJxH,CADuG;\",\n\"sources\":[\"node_modules/vega-geo/build/vega-geo.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_geo$build$vega_geo\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-dataflow'), require('vega-util'), require('d3-array'), require('vega-statistics'), require('vega-projection'), require('d3-geo'), require('d3-color'), require('vega-canvas')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-dataflow', 'vega-util', 'd3-array', 'vega-statistics', 'vega-projection', 'd3-geo', 'd3-color', 'vega-canvas'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.d3, global.vega, global.vega, global.d3, global.d3, global.vega));\\n}(this, (function (exports, vegaDataflow, vegaUtil, d3Array, vegaStatistics, vegaProjection, d3Geo, d3Color, vegaCanvas) { 'use strict';\\n\\n  function noop() {}\\n\\n  const cases = [\\n    [],\\n    [[[1.0, 1.5], [0.5, 1.0]]],\\n    [[[1.5, 1.0], [1.0, 1.5]]],\\n    [[[1.5, 1.0], [0.5, 1.0]]],\\n    [[[1.0, 0.5], [1.5, 1.0]]],\\n    [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],\\n    [[[1.0, 0.5], [1.0, 1.5]]],\\n    [[[1.0, 0.5], [0.5, 1.0]]],\\n    [[[0.5, 1.0], [1.0, 0.5]]],\\n    [[[1.0, 1.5], [1.0, 0.5]]],\\n    [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],\\n    [[[1.5, 1.0], [1.0, 0.5]]],\\n    [[[0.5, 1.0], [1.5, 1.0]]],\\n    [[[1.0, 1.5], [1.5, 1.0]]],\\n    [[[0.5, 1.0], [1.0, 1.5]]],\\n    []\\n  ];\\n\\n  // Implementation adapted from d3/d3-contour. Thanks!\\n  function contours() {\\n    var dx = 1,\\n        dy = 1,\\n        smooth = smoothLinear;\\n\\n    function contours(values, tz) {\\n      return tz.map(value => contour(values, value));\\n    }\\n\\n    // Accumulate, smooth contour rings, assign holes to exterior rings.\\n    // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\\n    function contour(values, value) {\\n      var polygons = [],\\n          holes = [];\\n\\n      isorings(values, value, ring => {\\n        smooth(ring, values, value);\\n        if (area(ring) > 0) polygons.push([ring]);\\n        else holes.push(ring);\\n      });\\n\\n      holes.forEach(hole => {\\n        for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\\n          if (contains((polygon = polygons[i])[0], hole) !== -1) {\\n            polygon.push(hole);\\n            return;\\n          }\\n        }\\n      });\\n\\n      return {\\n        type: 'MultiPolygon',\\n        value: value,\\n        coordinates: polygons\\n      };\\n    }\\n\\n    // Marching squares with isolines stitched into rings.\\n    // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\\n    function isorings(values, value, callback) {\\n      var fragmentByStart = new Array,\\n          fragmentByEnd = new Array,\\n          x, y, t0, t1, t2, t3;\\n\\n      // Special case for the first row (y = -1, t2 = t3 = 0).\\n      x = y = -1;\\n      t1 = values[0] >= value;\\n      cases[t1 << 1].forEach(stitch);\\n      while (++x < dx - 1) {\\n        t0 = t1, t1 = values[x + 1] >= value;\\n        cases[t0 | t1 << 1].forEach(stitch);\\n      }\\n      cases[t1 << 0].forEach(stitch);\\n\\n      // General case for the intermediate rows.\\n      while (++y < dy - 1) {\\n        x = -1;\\n        t1 = values[y * dx + dx] >= value;\\n        t2 = values[y * dx] >= value;\\n        cases[t1 << 1 | t2 << 2].forEach(stitch);\\n        while (++x < dx - 1) {\\n          t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;\\n          t3 = t2, t2 = values[y * dx + x + 1] >= value;\\n          cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\\n        }\\n        cases[t1 | t2 << 3].forEach(stitch);\\n      }\\n\\n      // Special case for the last row (y = dy - 1, t0 = t1 = 0).\\n      x = -1;\\n      t2 = values[y * dx] >= value;\\n      cases[t2 << 2].forEach(stitch);\\n      while (++x < dx - 1) {\\n        t3 = t2, t2 = values[y * dx + x + 1] >= value;\\n        cases[t2 << 2 | t3 << 3].forEach(stitch);\\n      }\\n      cases[t2 << 3].forEach(stitch);\\n\\n      function stitch(line) {\\n        var start = [line[0][0] + x, line[0][1] + y],\\n            end = [line[1][0] + x, line[1][1] + y],\\n            startIndex = index(start),\\n            endIndex = index(end),\\n            f, g;\\n        if (f = fragmentByEnd[startIndex]) {\\n          if (g = fragmentByStart[endIndex]) {\\n            delete fragmentByEnd[f.end];\\n            delete fragmentByStart[g.start];\\n            if (f === g) {\\n              f.ring.push(end);\\n              callback(f.ring);\\n            } else {\\n              fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};\\n            }\\n          } else {\\n            delete fragmentByEnd[f.end];\\n            f.ring.push(end);\\n            fragmentByEnd[f.end = endIndex] = f;\\n          }\\n        } else if (f = fragmentByStart[endIndex]) {\\n          if (g = fragmentByEnd[startIndex]) {\\n            delete fragmentByStart[f.start];\\n            delete fragmentByEnd[g.end];\\n            if (f === g) {\\n              f.ring.push(end);\\n              callback(f.ring);\\n            } else {\\n              fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};\\n            }\\n          } else {\\n            delete fragmentByStart[f.start];\\n            f.ring.unshift(start);\\n            fragmentByStart[f.start = startIndex] = f;\\n          }\\n        } else {\\n          fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};\\n        }\\n      }\\n    }\\n\\n    function index(point) {\\n      return point[0] * 2 + point[1] * (dx + 1) * 4;\\n    }\\n\\n    function smoothLinear(ring, values, value) {\\n      ring.forEach(point => {\\n        var x = point[0],\\n            y = point[1],\\n            xt = x | 0,\\n            yt = y | 0,\\n            v0,\\n            v1 = values[yt * dx + xt];\\n        if (x > 0 && x < dx && xt === x) {\\n          v0 = values[yt * dx + xt - 1];\\n          point[0] = x + (value - v0) / (v1 - v0) - 0.5;\\n        }\\n        if (y > 0 && y < dy && yt === y) {\\n          v0 = values[(yt - 1) * dx + xt];\\n          point[1] = y + (value - v0) / (v1 - v0) - 0.5;\\n        }\\n      });\\n    }\\n\\n    contours.contour = contour;\\n\\n    contours.size = function(_) {\\n      if (!arguments.length) return [dx, dy];\\n      var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);\\n      if (!(_0 >= 0 && _1 >= 0)) vegaUtil.error('invalid size');\\n      return dx = _0, dy = _1, contours;\\n    };\\n\\n    contours.smooth = function(_) {\\n      return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\\n    };\\n\\n    return contours;\\n  }\\n\\n  function area(ring) {\\n    var i = 0,\\n        n = ring.length,\\n        area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\\n    while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\\n    return area;\\n  }\\n\\n  function contains(ring, hole) {\\n    var i = -1, n = hole.length, c;\\n    while (++i < n) if (c = ringContains(ring, hole[i])) return c;\\n    return 0;\\n  }\\n\\n  function ringContains(ring, point) {\\n    var x = point[0], y = point[1], contains = -1;\\n    for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\\n      var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];\\n      if (segmentContains(pi, pj, point)) return 0;\\n      if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;\\n    }\\n    return contains;\\n  }\\n\\n  function segmentContains(a, b, c) {\\n    var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);\\n  }\\n\\n  function collinear(a, b, c) {\\n    return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);\\n  }\\n\\n  function within(p, q, r) {\\n    return p <= q && q <= r || r <= q && q <= p;\\n  }\\n\\n  function quantize(k, nice, zero) {\\n    return function(values) {\\n      var ex = vegaUtil.extent(values),\\n          start = zero ? Math.min(ex[0], 0) : ex[0],\\n          stop = ex[1],\\n          span = stop - start,\\n          step = nice ? d3Array.tickStep(start, stop, k) : (span / (k + 1));\\n      return d3Array.range(step, stop, step);\\n    };\\n  }\\n\\n  /**\\n   * Generate isocontours (level sets) based on input raster grid data.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} [params.field] - The field with raster grid\\n   *   data. If unspecified, the tuple itself is interpreted as a raster grid.\\n   * @param {Array<number>} [params.thresholds] - Contour threshold array. If\\n   *   specified, the levels, nice, resolve, and zero parameters are ignored.\\n   * @param {number} [params.levels] - The desired number of contour levels.\\n   * @param {boolean} [params.nice] - Boolean flag indicating if the contour\\n   *   threshold values should be automatically aligned to \\\"nice\\\"\\n   *   human-friendly values. Setting this flag may cause the number of\\n   *   thresholds to deviate from the specified levels.\\n   * @param {string} [params.resolve] - The method for resolving thresholds\\n   *   across multiple input grids. If 'independent' (the default), threshold\\n   *   calculation will be performed separately for each grid. If 'shared', a\\n   *   single set of threshold values will be used for all input grids.\\n   * @param {boolean} [params.zero] - Boolean flag indicating if the contour\\n   *   threshold values should include zero.\\n   * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\\n   *   polygons should be smoothed using linear interpolation. The default is\\n   *   true. The parameter is ignored when using density estimation.\\n   * @param {boolean} [params.scale] - Optional numerical value by which to\\n   *   scale the output isocontour coordinates. This parameter can be useful\\n   *   to scale the contours to match a desired output resolution.\\n   * @param {string} [params.as='contour'] - The output field in which to store\\n   *   the generated isocontour data (default 'contour').\\n   */\\n  function Isocontour(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Isocontour.Definition = {\\n    'type': 'Isocontour',\\n    'metadata': {'generates': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field' },\\n      { 'name': 'thresholds', 'type': 'number', 'array': true },\\n      { 'name': 'levels', 'type': 'number' },\\n      { 'name': 'nice', 'type': 'boolean', 'default': false },\\n      { 'name': 'resolve', 'type': 'enum', 'values': ['shared', 'independent'], 'default': 'independent' },\\n      { 'name': 'zero', 'type': 'boolean', 'default': true },\\n      { 'name': 'smooth', 'type': 'boolean', 'default': true },\\n      { 'name': 'scale', 'type': 'number', 'expr': true },\\n      { 'name': 'translate', 'type': 'number', 'array': true, 'expr': true },\\n      { 'name': 'as', 'type': 'string', 'null': true, 'default': 'contour' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Isocontour, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      if (this.value && !pulse.changed() && !_.modified()) {\\n        return pulse.StopPropagation;\\n      }\\n\\n      var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\\n          source = pulse.materialize(pulse.SOURCE).source,\\n          field = _.field || vegaUtil.identity,\\n          contour = contours().smooth(_.smooth !== false),\\n          tz = _.thresholds || levels(source, field, _),\\n          as = _.as === null ? null : _.as || 'contour',\\n          values = [];\\n\\n      source.forEach(t => {\\n        const grid = field(t);\\n\\n        // generate contour paths in GeoJSON format\\n        const paths = contour.size([grid.width, grid.height])(\\n          grid.values, vegaUtil.isArray(tz) ? tz : tz(grid.values)\\n        );\\n\\n        // adjust contour path coordinates as needed\\n        transformPaths(paths, grid, t, _);\\n\\n        // ingest; copy source data properties to output\\n        paths.forEach(p => {\\n          values.push(vegaDataflow.rederive(t, vegaDataflow.ingest(as != null ? {[as]: p} : p)));\\n        });\\n      });\\n\\n      if (this.value) out.rem = this.value;\\n      this.value = out.source = out.add = values;\\n\\n      return out;\\n    }\\n  });\\n\\n  function levels(values, f, _) {\\n    const q = quantize(_.levels || 10, _.nice, _.zero !== false);\\n    return _.resolve !== 'shared'\\n      ? q\\n      : q(values.map(t => d3Array.max(f(t).values)));\\n  }\\n\\n  function transformPaths(paths, grid, datum, _) {\\n    let s = _.scale || grid.scale,\\n        t = _.translate || grid.translate;\\n    if (vegaUtil.isFunction(s)) s = s(datum, _);\\n    if (vegaUtil.isFunction(t)) t = t(datum, _);\\n    if ((s === 1 || s == null) && !t) return;\\n\\n    const sx = (vegaUtil.isNumber(s) ? s : s[0]) || 1,\\n          sy = (vegaUtil.isNumber(s) ? s : s[1]) || 1,\\n          tx = t && t[0] || 0,\\n          ty = t && t[1] || 0;\\n\\n    paths.forEach(transform(grid, sx, sy, tx, ty));\\n  }\\n\\n  function transform(grid, sx, sy, tx, ty) {\\n    const x1 = grid.x1 || 0,\\n          y1 = grid.y1 || 0,\\n          flip = sx * sy < 0;\\n\\n    function transformPolygon(coordinates) {\\n      coordinates.forEach(transformRing);\\n    }\\n\\n    function transformRing(coordinates) {\\n      if (flip) coordinates.reverse(); // maintain winding order\\n      coordinates.forEach(transformPoint);\\n    }\\n\\n    function transformPoint(coordinates) {\\n      coordinates[0] = (coordinates[0] - x1) * sx + tx;\\n      coordinates[1] = (coordinates[1] - y1) * sy + ty;\\n    }\\n\\n    return function(geometry) {\\n      geometry.coordinates.forEach(transformPolygon);\\n      return geometry;\\n    };\\n  }\\n\\n  function radius(bw, data, f) {\\n    const v = bw >= 0 ? bw : vegaStatistics.bandwidthNRD(data, f);\\n    return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);\\n  }\\n\\n  function number(_) {\\n    return vegaUtil.isFunction(_) ? _ : vegaUtil.constant(+_);\\n  }\\n\\n  // Implementation adapted from d3/d3-contour. Thanks!\\n  function density2D() {\\n    var x = d => d[0],\\n        y = d => d[1],\\n        weight = vegaUtil.one,\\n        bandwidth = [-1, -1],\\n        dx = 960,\\n        dy = 500,\\n        k = 2; // log2(cellSize)\\n\\n    function density(data, counts) {\\n      const rx = radius(bandwidth[0], data, x) >> k, // blur x-radius\\n            ry = radius(bandwidth[1], data, y) >> k, // blur y-radius\\n            ox = rx ? rx + 2 : 0, // x-offset padding for blur\\n            oy = ry ? ry + 2 : 0, // y-offset padding for blur\\n            n = 2 * ox + (dx >> k), // grid width\\n            m = 2 * oy + (dy >> k), // grid height\\n            values0 = new Float32Array(n * m),\\n            values1 = new Float32Array(n * m);\\n\\n      let values = values0;\\n\\n      data.forEach(d => {\\n        const xi = ox + (+x(d) >> k),\\n              yi = oy + (+y(d) >> k);\\n\\n        if (xi >= 0 && xi < n && yi >= 0 && yi < m) {\\n          values0[xi + yi * n] += +weight(d);\\n        }\\n      });\\n\\n      if (rx > 0 && ry > 0) {\\n        blurX(n, m, values0, values1, rx);\\n        blurY(n, m, values1, values0, ry);\\n        blurX(n, m, values0, values1, rx);\\n        blurY(n, m, values1, values0, ry);\\n        blurX(n, m, values0, values1, rx);\\n        blurY(n, m, values1, values0, ry);\\n      } else if (rx > 0) {\\n        blurX(n, m, values0, values1, rx);\\n        blurX(n, m, values1, values0, rx);\\n        blurX(n, m, values0, values1, rx);\\n        values = values1;\\n      } else if (ry > 0) {\\n        blurY(n, m, values0, values1, ry);\\n        blurY(n, m, values1, values0, ry);\\n        blurY(n, m, values0, values1, ry);\\n        values = values1;\\n      }\\n\\n      // scale density estimates\\n      // density in points per square pixel or probability density\\n      const s = counts ? Math.pow(2, -2 * k) : 1 / d3Array.sum(values);\\n      for (let i=0, sz=n*m; i<sz; ++i) values[i] *= s;\\n\\n      return {\\n        values: values,\\n        scale: 1 << k,\\n        width: n,\\n        height: m,\\n        x1: ox,\\n        y1: oy,\\n        x2: ox + (dx >> k),\\n        y2: oy + (dy >> k)\\n      };\\n    }\\n\\n    density.x = function(_) {\\n      return arguments.length ? (x = number(_), density) : x;\\n    };\\n\\n    density.y = function(_) {\\n      return arguments.length ? (y = number(_), density) : y;\\n    };\\n\\n    density.weight = function(_) {\\n      return arguments.length ? (weight = number(_), density) : weight;\\n    };\\n\\n    density.size = function(_) {\\n      if (!arguments.length) return [dx, dy];\\n      var _0 = +_[0], _1 = +_[1];\\n      if (!(_0 >= 0 && _1 >= 0)) vegaUtil.error('invalid size');\\n      return dx = _0, dy = _1, density;\\n    };\\n\\n    density.cellSize = function(_) {\\n      if (!arguments.length) return 1 << k;\\n      if (!((_ = +_) >= 1)) vegaUtil.error('invalid cell size');\\n      k = Math.floor(Math.log(_) / Math.LN2);\\n      return density;\\n    };\\n\\n    density.bandwidth = function(_) {\\n      if (!arguments.length) return bandwidth;\\n      _ = vegaUtil.array(_);\\n      if (_.length === 1) _ = [+_[0], +_[0]];\\n      if (_.length !== 2) vegaUtil.error('invalid bandwidth');\\n      return bandwidth = _, density;\\n    };\\n\\n    return density;\\n  }\\n\\n  function blurX(n, m, source, target, r) {\\n    const w = (r << 1) + 1;\\n    for (let j = 0; j < m; ++j) {\\n      for (let i = 0, sr = 0; i < n + r; ++i) {\\n        if (i < n) {\\n          sr += source[i + j * n];\\n        }\\n        if (i >= r) {\\n          if (i >= w) {\\n            sr -= source[i - w + j * n];\\n          }\\n          target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);\\n        }\\n      }\\n    }\\n  }\\n\\n  function blurY(n, m, source, target, r) {\\n    const w = (r << 1) + 1;\\n    for (let i = 0; i < n; ++i) {\\n      for (let j = 0, sr = 0; j < m + r; ++j) {\\n        if (j < m) {\\n          sr += source[i + j * n];\\n        }\\n        if (j >= r) {\\n          if (j >= w) {\\n            sr -= source[i + (j - w) * n];\\n          }\\n          target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Perform 2D kernel-density estimation of point data.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<number>} params.size - The [width, height] extent (in\\n   *   units of input pixels) over which to perform density estimation.\\n   * @param {function(object): number} params.x - The x-coordinate accessor.\\n   * @param {function(object): number} params.y - The y-coordinate accessor.\\n   * @param {function(object): number} [params.weight] - The weight accessor.\\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors\\n   *   to groupby.\\n   * @param {number} [params.cellSize] - Contour density calculation cell size.\\n   *   This parameter determines the level of spatial approximation. For example,\\n   *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.\\n   *   A value of 1 will result in an output raster grid whose dimensions exactly\\n   *   matches the size parameter.\\n   * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,\\n   *   in pixels. The input can be a two-element array specifying separate\\n   *   x and y bandwidths, or a single-element array specifying both. If the\\n   *   bandwidth is unspecified or less than zero, the bandwidth will be\\n   *   automatically determined.\\n   * @param {boolean} [params.counts=false] - A boolean flag indicating if the\\n   *   output values should be probability estimates (false, default) or\\n   *   smoothed counts (true).\\n   * @param {string} [params.as='grid'] - The output field in which to store\\n   *   the generated raster grid (default 'grid').\\n   */\\n  function KDE2D(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  KDE2D.Definition = {\\n    'type': 'KDE2D',\\n    'metadata': {'generates': true},\\n    'params': [\\n      { 'name': 'size', 'type': 'number', 'array': true, 'length': 2, 'required': true },\\n      { 'name': 'x', 'type': 'field', 'required': true },\\n      { 'name': 'y', 'type': 'field', 'required': true },\\n      { 'name': 'weight', 'type': 'field' },\\n      { 'name': 'groupby', 'type': 'field', 'array': true },\\n      { 'name': 'cellSize', 'type': 'number' },\\n      { 'name': 'bandwidth', 'type': 'number', 'array': true, 'length': 2 },\\n      { 'name': 'counts', 'type': 'boolean', 'default': false },\\n      { 'name': 'as', 'type': 'string', 'default': 'grid'}\\n    ]\\n  };\\n\\n  const PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];\\n\\n  function params(obj, _) {\\n    PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);\\n    return obj;\\n  }\\n\\n  vegaUtil.inherits(KDE2D, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      if (this.value && !pulse.changed() && !_.modified())\\n        return pulse.StopPropagation;\\n\\n      var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\\n          source = pulse.materialize(pulse.SOURCE).source,\\n          groups = partition(source, _.groupby),\\n          names = (_.groupby || []).map(vegaUtil.accessorName),\\n          kde = params(density2D(), _),\\n          as = _.as || 'grid',\\n          values = [];\\n\\n      function set(t, vals) {\\n        for (let i=0; i<names.length; ++i) t[names[i]] = vals[i];\\n        return t;\\n      }\\n\\n      // generate density raster grids\\n      values = groups.map(g => vegaDataflow.ingest(\\n        set({[as]: kde(g, _.counts)}, g.dims)\\n      ));\\n\\n      if (this.value) out.rem = this.value;\\n      this.value = out.source = out.add = values;\\n\\n      return out;\\n    }\\n  });\\n\\n  function partition(data, groupby) {\\n    var groups = [],\\n        get = f => f(t),\\n        map, i, n, t, k, g;\\n\\n    // partition data points into groups\\n    if (groupby == null) {\\n      groups.push(data);\\n    } else {\\n      for (map={}, i=0, n=data.length; i<n; ++i) {\\n        t = data[i];\\n        k = groupby.map(get);\\n        g = map[k];\\n        if (!g) {\\n          map[k] = (g = []);\\n          g.dims = k;\\n          groups.push(g);\\n        }\\n        g.push(t);\\n      }\\n    }\\n\\n    return groups;\\n  }\\n\\n  /**\\n   * Generate contours based on kernel-density estimation of point data.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.\\n   *  If the values parameter is provided, this must be the dimensions of the input data.\\n   *  If density estimation is performed, this is the output view dimensions in pixels.\\n   * @param {Array<number>} [params.values] - An array of numeric values representing an\\n   *  width x height grid of values over which to compute contours. If unspecified, this\\n   *  transform will instead attempt to compute contours for the kernel density estimate\\n   *  using values drawn from data tuples in the input pulse.\\n   * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.\\n   * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.\\n   * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.\\n   * @param {number} [params.cellSize] - Contour density calculation cell size.\\n   * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.\\n   * @param {Array<number>} [params.thresholds] - Contour threshold array. If\\n   *   this parameter is set, the count and nice parameters will be ignored.\\n   * @param {number} [params.count] - The desired number of contours.\\n   * @param {boolean} [params.nice] - Boolean flag indicating if the contour\\n   *   threshold values should be automatically aligned to \\\"nice\\\"\\n   *   human-friendly values. Setting this flag may cause the number of\\n   *   thresholds to deviate from the specified count.\\n   * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\\n   *   polygons should be smoothed using linear interpolation. The default is\\n   *   true. The parameter is ignored when using density estimation.\\n   */\\n  function Contour(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Contour.Definition = {\\n    'type': 'Contour',\\n    'metadata': {'generates': true},\\n    'params': [\\n      { 'name': 'size', 'type': 'number', 'array': true, 'length': 2, 'required': true },\\n      { 'name': 'values', 'type': 'number', 'array': true },\\n      { 'name': 'x', 'type': 'field' },\\n      { 'name': 'y', 'type': 'field' },\\n      { 'name': 'weight', 'type': 'field' },\\n      { 'name': 'cellSize', 'type': 'number' },\\n      { 'name': 'bandwidth', 'type': 'number' },\\n      { 'name': 'count', 'type': 'number' },\\n      { 'name': 'nice', 'type': 'boolean', 'default': false },\\n      { 'name': 'thresholds', 'type': 'number', 'array': true },\\n      { 'name': 'smooth', 'type': 'boolean', 'default': true }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Contour, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      if (this.value && !pulse.changed() && !_.modified()) {\\n        return pulse.StopPropagation;\\n      }\\n\\n      var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\\n          contour = contours().smooth(_.smooth !== false),\\n          values = _.values,\\n          thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),\\n          size = _.size, grid, post;\\n\\n      if (!values) {\\n        values = pulse.materialize(pulse.SOURCE).source;\\n        grid = params(density2D(), _)(values, true);\\n        post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);\\n        size = [grid.width, grid.height];\\n        values = grid.values;\\n      }\\n\\n      thresh = vegaUtil.isArray(thresh) ? thresh : thresh(values);\\n      values = contour.size(size)(values, thresh);\\n      if (post) values.forEach(post);\\n\\n      if (this.value) out.rem = this.value;\\n      this.value = out.source = out.add = (values || []).map(vegaDataflow.ingest);\\n\\n      return out;\\n    }\\n  });\\n\\n  var Feature = 'Feature';\\n  var FeatureCollection = 'FeatureCollection';\\n  var MultiPoint = 'MultiPoint';\\n\\n  /**\\n   * Consolidate an array of [longitude, latitude] points or GeoJSON features\\n   * into a combined GeoJSON object. This transform is particularly useful for\\n   * combining geo data for a Projection's fit argument. The resulting GeoJSON\\n   * data is available as this transform's value. Input pulses are unchanged.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<function(object): *>} [params.fields] - A two-element array\\n   *   of field accessors for the longitude and latitude values.\\n   * @param {function(object): *} params.geojson - A field accessor for\\n   *   retrieving GeoJSON feature data.\\n   */\\n  function GeoJSON(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  GeoJSON.Definition = {\\n    'type': 'GeoJSON',\\n    'metadata': {},\\n    'params': [\\n      { 'name': 'fields', 'type': 'field', 'array': true, 'length': 2 },\\n      { 'name': 'geojson', 'type': 'field' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(GeoJSON, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      var features = this._features,\\n          points = this._points,\\n          fields = _.fields,\\n          lon = fields && fields[0],\\n          lat = fields && fields[1],\\n          geojson = _.geojson || (!fields && vegaUtil.identity),\\n          flag = pulse.ADD,\\n          mod;\\n\\n      mod = _.modified()\\n        || pulse.changed(pulse.REM)\\n        || pulse.modified(vegaUtil.accessorFields(geojson))\\n        || (lon && (pulse.modified(vegaUtil.accessorFields(lon))))\\n        || (lat && (pulse.modified(vegaUtil.accessorFields(lat))));\\n\\n      if (!this.value || mod) {\\n        flag = pulse.SOURCE;\\n        this._features = (features = []);\\n        this._points = (points = []);\\n      }\\n\\n      if (geojson) {\\n        pulse.visit(flag, t => features.push(geojson(t)));\\n      }\\n\\n      if (lon && lat) {\\n        pulse.visit(flag, t => {\\n          var x = lon(t),\\n              y = lat(t);\\n          if (x != null && y != null && (x = +x) === x && (y = +y) === y) {\\n            points.push([x, y]);\\n          }\\n        });\\n        features = features.concat({\\n          type: Feature,\\n          geometry: {\\n            type: MultiPoint,\\n            coordinates: points\\n          }\\n        });\\n      }\\n\\n      this.value = {\\n        type: FeatureCollection,\\n        features: features\\n      };\\n    }\\n  });\\n\\n  /**\\n   * Map GeoJSON data to an SVG path string.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(number, number): *} params.projection - The cartographic\\n   *   projection to apply.\\n   * @param {function(object): *} [params.field] - The field with GeoJSON data,\\n   *   or null if the tuple itself is a GeoJSON feature.\\n   * @param {string} [params.as='path'] - The output field in which to store\\n   *   the generated path data (default 'path').\\n   */\\n  function GeoPath(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  GeoPath.Definition = {\\n    'type': 'GeoPath',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'projection', 'type': 'projection' },\\n      { 'name': 'field', 'type': 'field' },\\n      { 'name': 'pointRadius', 'type': 'number', 'expr': true },\\n      { 'name': 'as', 'type': 'string', 'default': 'path' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(GeoPath, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      var out = pulse.fork(pulse.ALL),\\n          path = this.value,\\n          field = _.field || vegaUtil.identity,\\n          as = _.as || 'path',\\n          flag = out.SOURCE;\\n\\n      if (!path || _.modified()) {\\n        // parameters updated, reset and reflow\\n        this.value = path = vegaProjection.getProjectionPath(_.projection);\\n        out.materialize().reflow();\\n      } else {\\n        flag = field === vegaUtil.identity || pulse.modified(field.fields)\\n          ? out.ADD_MOD\\n          : out.ADD;\\n      }\\n\\n      var prev = initPath(path, _.pointRadius);\\n      out.visit(flag, t => t[as] = path(field(t)));\\n      path.pointRadius(prev);\\n\\n      return out.modifies(as);\\n    }\\n  });\\n\\n  function initPath(path, pointRadius) {\\n    var prev = path.pointRadius();\\n    path.context(null);\\n    if (pointRadius != null) {\\n      path.pointRadius(pointRadius);\\n    }\\n    return prev;\\n  }\\n\\n  /**\\n   * Geo-code a longitude/latitude point to an x/y coordinate.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(number, number): *} params.projection - The cartographic\\n   *   projection to apply.\\n   * @param {Array<function(object): *>} params.fields - A two-element array of\\n   *   field accessors for the longitude and latitude values.\\n   * @param {Array<string>} [params.as] - A two-element array of field names\\n   *   under which to store the result. Defaults to ['x','y'].\\n   */\\n  function GeoPoint(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  GeoPoint.Definition = {\\n    'type': 'GeoPoint',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'projection', 'type': 'projection', 'required': true },\\n      { 'name': 'fields', 'type': 'field', 'array': true, 'required': true, 'length': 2 },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['x', 'y'] }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(GeoPoint, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      var proj = _.projection,\\n          lon = _.fields[0],\\n          lat = _.fields[1],\\n          as = _.as || ['x', 'y'],\\n          x = as[0],\\n          y = as[1],\\n          mod;\\n\\n      function set(t) {\\n        var xy = proj([lon(t), lat(t)]);\\n        if (xy) {\\n          t[x] = xy[0];\\n          t[y] = xy[1];\\n        } else {\\n          t[x] = undefined;\\n          t[y] = undefined;\\n        }\\n      }\\n\\n      if (_.modified()) {\\n        // parameters updated, reflow\\n        pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);\\n      } else {\\n        mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);\\n        pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);\\n      }\\n\\n      return pulse.modifies(as);\\n    }\\n  });\\n\\n  /**\\n   * Annotate items with a geopath shape generator.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(number, number): *} params.projection - The cartographic\\n   *   projection to apply.\\n   * @param {function(object): *} [params.field] - The field with GeoJSON data,\\n   *   or null if the tuple itself is a GeoJSON feature.\\n   * @param {string} [params.as='shape'] - The output field in which to store\\n   *   the generated path data (default 'shape').\\n   */\\n  function GeoShape(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  GeoShape.Definition = {\\n    'type': 'GeoShape',\\n    'metadata': {'modifies': true, 'nomod': true},\\n    'params': [\\n      { 'name': 'projection', 'type': 'projection' },\\n      { 'name': 'field', 'type': 'field', 'default': 'datum' },\\n      { 'name': 'pointRadius', 'type': 'number', 'expr': true },\\n      { 'name': 'as', 'type': 'string', 'default': 'shape' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(GeoShape, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      var out = pulse.fork(pulse.ALL),\\n          shape = this.value,\\n          as = _.as || 'shape',\\n          flag = out.ADD;\\n\\n      if (!shape || _.modified()) {\\n        // parameters updated, reset and reflow\\n        this.value = shape = shapeGenerator(\\n          vegaProjection.getProjectionPath(_.projection),\\n          _.field || vegaUtil.field('datum'),\\n          _.pointRadius\\n        );\\n        out.materialize().reflow();\\n        flag = out.SOURCE;\\n      }\\n\\n      out.visit(flag, t => t[as] = shape);\\n\\n      return out.modifies(as);\\n    }\\n  });\\n\\n  function shapeGenerator(path, field, pointRadius) {\\n    var shape = pointRadius == null\\n      ? _ => path(field(_))\\n      : _ => {\\n        var prev = path.pointRadius(),\\n            value = path.pointRadius(pointRadius)(field(_));\\n        path.pointRadius(prev);\\n        return value;\\n      };\\n    shape.context = _ => {\\n      path.context(_);\\n      return shape;\\n    };\\n\\n    return shape;\\n  }\\n\\n  /**\\n   * GeoJSON feature generator for creating graticules.\\n   * @constructor\\n   */\\n  function Graticule(params) {\\n    vegaDataflow.Transform.call(this, [], params);\\n    this.generator = d3Geo.geoGraticule();\\n  }\\n\\n  Graticule.Definition = {\\n    'type': 'Graticule',\\n    'metadata': {'changes': true, 'generates': true},\\n    'params': [\\n      { 'name': 'extent', 'type': 'array', 'array': true, 'length': 2,\\n        'content': {'type': 'number', 'array': true, 'length': 2} },\\n      { 'name': 'extentMajor', 'type': 'array', 'array': true, 'length': 2,\\n        'content': {'type': 'number', 'array': true, 'length': 2} },\\n      { 'name': 'extentMinor', 'type': 'array', 'array': true, 'length': 2,\\n        'content': {'type': 'number', 'array': true, 'length': 2} },\\n      { 'name': 'step', 'type': 'number', 'array': true, 'length': 2 },\\n      { 'name': 'stepMajor', 'type': 'number', 'array': true, 'length': 2, 'default': [90, 360] },\\n      { 'name': 'stepMinor', 'type': 'number', 'array': true, 'length': 2, 'default': [10, 10] },\\n      { 'name': 'precision', 'type': 'number', 'default': 2.5 }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Graticule, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      var src = this.value,\\n          gen = this.generator, t;\\n\\n      if (!src.length || _.modified()) {\\n        for (var prop in _) {\\n          if (vegaUtil.isFunction(gen[prop])) {\\n            gen[prop](_[prop]);\\n          }\\n        }\\n      }\\n\\n      t = gen();\\n      if (src.length) {\\n        pulse.mod.push(vegaDataflow.replace(src[0], t));\\n      } else {\\n        pulse.add.push(vegaDataflow.ingest(t));\\n      }\\n      src[0] = t;\\n\\n      return pulse;\\n    }\\n  });\\n\\n  /**\\n   * Render a heatmap image for input raster grid data.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} [params.field] - The field with raster grid\\n   *   data. If unspecified, the tuple itself is interpreted as a raster grid.\\n   * @param {string} [params.color] - A constant color value or function for\\n   *   individual pixel color. If a function, it will be invoked with an input\\n   *   object that includes $x, $y, $value, and $max fields for the grid.\\n   * @param {number} [params.opacity] - A constant opacity value or function for\\n   *   individual pixel opacity. If a function, it will be invoked with an input\\n   *   object that includes $x, $y, $value, and $max fields for the grid.\\n   * @param {string} [params.resolve] - The method for resolving maximum values\\n   *   across multiple input grids. If 'independent' (the default), maximum\\n   *   calculation will be performed separately for each grid. If 'shared',\\n   *   a single global maximum will be used for all input grids.\\n   * @param {string} [params.as='image'] - The output field in which to store\\n   *   the generated bitmap canvas images (default 'image').\\n   */\\n  function Heatmap(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Heatmap.Definition = {\\n    'type': 'heatmap',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field' },\\n      { 'name': 'color', 'type': 'string', 'expr': true},\\n      { 'name': 'opacity', 'type': 'number', 'expr': true},\\n      { 'name': 'resolve', 'type': 'enum', 'values': ['shared', 'independent'], 'default': 'independent' },\\n      { 'name': 'as', 'type': 'string', 'default': 'image' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Heatmap, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      if (!pulse.changed() && !_.modified()) {\\n        return pulse.StopPropagation;\\n      }\\n\\n      var source = pulse.materialize(pulse.SOURCE).source,\\n          shared = _.resolve === 'shared',\\n          field = _.field || vegaUtil.identity,\\n          opacity = opacity_(_.opacity, _),\\n          color = color_(_.color, _),\\n          as = _.as || 'image',\\n          obj = {\\n            $x: 0, $y: 0, $value: 0,\\n            $max: shared ? d3Array.max(source.map(t => d3Array.max(field(t).values))) : 0\\n          };\\n\\n      source.forEach(t => {\\n        const v = field(t);\\n\\n        // build proxy data object\\n        const o = vegaUtil.extend({}, t, obj);\\n        // set maximum value if not globally shared\\n        if (!shared) o.$max = d3Array.max(v.values || []);\\n\\n        // generate canvas image\\n        // optimize color/opacity if not pixel-dependent\\n        t[as] = toCanvas(v, o,\\n          color.dep ? color : vegaUtil.constant(color(o)),\\n          opacity.dep ? opacity : vegaUtil.constant(opacity(o))\\n        );\\n      });\\n\\n      return pulse.reflow(true).modifies(as);\\n    }\\n  });\\n\\n  // get image color function\\n  function color_(color, _) {\\n    let f;\\n    if (vegaUtil.isFunction(color)) {\\n      f = obj => d3Color.rgb(color(obj, _));\\n      f.dep = dependency(color);\\n    } else {\\n      // default to mid-grey\\n      f = vegaUtil.constant(d3Color.rgb(color || '#888'));\\n    }\\n    return f;\\n  }\\n\\n  // get image opacity function\\n  function opacity_(opacity, _) {\\n    let f;\\n    if (vegaUtil.isFunction(opacity)) {\\n      f = obj => opacity(obj, _);\\n      f.dep = dependency(opacity);\\n    } else if (opacity) {\\n      f = vegaUtil.constant(opacity);\\n    } else {\\n      // default to [0, max] opacity gradient\\n      f = obj => (obj.$value / obj.$max) || 0;\\n      f.dep = true;\\n    }\\n    return f;\\n  }\\n\\n  // check if function depends on individual pixel data\\n  function dependency(f) {\\n    if (!vegaUtil.isFunction(f)) return false;\\n    const set = vegaUtil.toSet(vegaUtil.accessorFields(f));\\n    return set.$x || set.$y || set.$value || set.$max;\\n  }\\n\\n  // render raster grid to canvas\\n  function toCanvas(grid, obj, color, opacity) {\\n    const n = grid.width,\\n          m = grid.height,\\n          x1 = grid.x1 || 0,\\n          y1 = grid.y1 || 0,\\n          x2 = grid.x2 || n,\\n          y2 = grid.y2 || m,\\n          val = grid.values,\\n          value = val ? i => val[i] : vegaUtil.zero,\\n          can = vegaCanvas.canvas(x2 - x1, y2 - y1),\\n          ctx = can.getContext('2d'),\\n          img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),\\n          pix = img.data;\\n\\n    for (let j=y1, k=0; j<y2; ++j) {\\n      obj.$y = j - y1;\\n      for (let i=x1, r=j*n; i<x2; ++i, k+=4) {\\n        obj.$x = i - x1;\\n        obj.$value = value(i + r);\\n\\n        const v = color(obj);\\n        pix[k+0] = v.r;\\n        pix[k+1] = v.g;\\n        pix[k+2] = v.b;\\n        pix[k+3] = ~~(255 * opacity(obj));\\n      }\\n    }\\n\\n    ctx.putImageData(img, 0, 0);\\n    return can;\\n  }\\n\\n  /**\\n   * Maintains a cartographic projection.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   */\\n  function Projection(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n    this.modified(true); // always treat as modified\\n  }\\n\\n  vegaUtil.inherits(Projection, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      let proj = this.value;\\n\\n      if (!proj || _.modified('type')) {\\n        this.value = (proj = create(_.type));\\n        vegaProjection.projectionProperties.forEach(prop => {\\n          if (_[prop] != null) set(proj, prop, _[prop]);\\n        });\\n      } else {\\n        vegaProjection.projectionProperties.forEach(prop => {\\n          if (_.modified(prop)) set(proj, prop, _[prop]);\\n        });\\n      }\\n\\n      if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);\\n      if (_.fit) fit(proj, _);\\n\\n      return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\\n    }\\n  });\\n\\n  function fit(proj, _) {\\n    var data = collectGeoJSON(_.fit);\\n    _.extent ? proj.fitExtent(_.extent, data)\\n      : _.size ? proj.fitSize(_.size, data) : 0;\\n  }\\n\\n  function create(type) {\\n    var constructor = vegaProjection.projection((type || 'mercator').toLowerCase());\\n    if (!constructor) vegaUtil.error('Unrecognized projection type: ' + type);\\n    return constructor();\\n  }\\n\\n  function set(proj, key, value) {\\n     if (vegaUtil.isFunction(proj[key])) proj[key](value);\\n  }\\n\\n  function collectGeoJSON(data) {\\n    data = vegaUtil.array(data);\\n    return data.length === 1 ? data[0]\\n      : {\\n          type: FeatureCollection,\\n          features: data.reduce((a, f) => a.concat(featurize(f)), [])\\n        };\\n  }\\n\\n  function featurize(f) {\\n    return f.type === FeatureCollection\\n      ? f.features\\n      : vegaUtil.array(f).filter(d => d != null).map(\\n          d => d.type === Feature ? d : {type: Feature, geometry: d}\\n        );\\n  }\\n\\n  exports.contour = Contour;\\n  exports.geojson = GeoJSON;\\n  exports.geopath = GeoPath;\\n  exports.geopoint = GeoPoint;\\n  exports.geoshape = GeoShape;\\n  exports.graticule = Graticule;\\n  exports.heatmap = Heatmap;\\n  exports.isocontour = Isocontour;\\n  exports.kde2d = KDE2D;\\n  exports.projection = Projection;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"transforms\",\"d3\",\"vegaDataflow\",\"vegaUtil\",\"d3Array\",\"vegaStatistics\",\"vegaProjection\",\"d3Geo\",\"d3Color\",\"vegaCanvas\",\"noop\",\"contours\",\"values\",\"tz\",\"map\",\"value\",\"contour\",\"polygons\",\"holes\",\"isorings\",\"ring\",\"smooth\",\"i\",\"n\",\"length\",\"area\",\"push\",\"forEach\",\"hole\",\"polygon\",\"x\",\"point\",\"y\",\"contains\",\"j\",\"pi\",\"xi\",\"yi\",\"pj\",\"xj\",\"yj\",\"b\",\"a\",\"c\",\"p\",\"q\",\"r\",\"type\",\"coordinates\",\"callback\",\"stitch\",\"line\",\"start\",\"end\",\"startIndex\",\"dx\",\"endIndex\",\"f\",\"g\",\"fragmentByEnd\",\"fragmentByStart\",\"concat\",\"unshift\",\"t1\",\"cases\",\"t0\",\"dy\",\"t2\",\"t3\",\"smoothLinear\",\"xt\",\"yt\",\"v1\",\"v0\",\"size\",\"contours.size\",\"_\",\"arguments\",\"_0\",\"Math\",\"floor\",\"_1\",\"error\",\"contours.smooth\",\"quantize\",\"k\",\"nice\",\"zero\",\"ex\",\"extent\",\"min\",\"stop\",\"span\",\"step\",\"tickStep\",\"range\",\"Isocontour\",\"params\",\"Transform\",\"call\",\"levels\",\"resolve\",\"t\",\"max\",\"transformPaths\",\"paths\",\"grid\",\"datum\",\"s\",\"scale\",\"translate\",\"isFunction\",\"sx\",\"isNumber\",\"sy\",\"transform\",\"tx\",\"ty\",\"transformPolygon\",\"transformRing\",\"flip\",\"reverse\",\"transformPoint\",\"x1\",\"y1\",\"geometry\",\"radius\",\"bw\",\"data\",\"v\",\"bandwidthNRD\",\"round\",\"sqrt\",\"number\",\"constant\",\"density2D\",\"density\",\"counts\",\"rx\",\"bandwidth\",\"ry\",\"ox\",\"oy\",\"m\",\"values0\",\"Float32Array\",\"values1\",\"d\",\"weight\",\"blurX\",\"blurY\",\"pow\",\"sum\",\"sz\",\"width\",\"height\",\"x2\",\"y2\",\"one\",\"density.x\",\"density.y\",\"density.weight\",\"density.size\",\"cellSize\",\"density.cellSize\",\"log\",\"LN2\",\"density.bandwidth\",\"array\",\"source\",\"target\",\"w\",\"sr\",\"KDE2D\",\"obj\",\"PARAMS\",\"param\",\"partition\",\"groupby\",\"groups\",\"get\",\"dims\",\"Contour\",\"GeoJSON\",\"GeoPath\",\"initPath\",\"path\",\"pointRadius\",\"prev\",\"context\",\"GeoPoint\",\"GeoShape\",\"shapeGenerator\",\"field\",\"shape\",\"shape.context\",\"Graticule\",\"generator\",\"geoGraticule\",\"Heatmap\",\"color_\",\"color\",\"rgb\",\"dep\",\"dependency\",\"opacity_\",\"opacity\",\"$value\",\"$max\",\"set\",\"toSet\",\"accessorFields\",\"$x\",\"$y\",\"toCanvas\",\"val\",\"can\",\"canvas\",\"ctx\",\"getContext\",\"img\",\"getImageData\",\"pix\",\"putImageData\",\"Projection\",\"modified\",\"fit\",\"proj\",\"collectGeoJSON\",\"fitExtent\",\"fitSize\",\"create\",\"constructor\",\"projection\",\"toLowerCase\",\"FeatureCollection\",\"features\",\"reduce\",\"featurize\",\"filter\",\"Feature\",\"Definition\",\"inherits\",\"pulse\",\"changed\",\"StopPropagation\",\"out\",\"fork\",\"NO_SOURCE\",\"NO_FIELDS\",\"materialize\",\"SOURCE\",\"identity\",\"thresholds\",\"as\",\"isArray\",\"rederive\",\"ingest\",\"rem\",\"add\",\"vals\",\"names\",\"accessorName\",\"kde\",\"thresh\",\"count\",\"post\",\"_features\",\"points\",\"_points\",\"fields\",\"lon\",\"lat\",\"geojson\",\"flag\",\"ADD\",\"mod\",\"REM\",\"visit\",\"MultiPoint\",\"ALL\",\"getProjectionPath\",\"reflow\",\"ADD_MOD\",\"modifies\",\"xy\",\"undefined\",\"src\",\"gen\",\"prop\",\"replace\",\"shared\",\"o\",\"extend\",\"projectionProperties\",\"geopath\",\"geopoint\",\"geoshape\",\"graticule\",\"heatmap\",\"isocontour\",\"kde2d\",\"Object\",\"defineProperty\"]\n}\n"]