["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-transforms/build/vega-transforms.js"],"~:js","shadow$provide.module$node_modules$vega_transforms$build$vega_transforms=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_util$build$vega_util\"),require(\"module$node_modules$vega_dataflow$build$vega_dataflow\"),require(\"module$node_modules$vega_statistics$build$vega_statistics\"),require(\"module$node_modules$d3_array$dist$d3_array\"),require(\"module$node_modules$vega_time$build$vega_time\")):\n\"function\"===typeof define&&define.amd?define(\"exports vega-util vega-dataflow vega-statistics d3-array vega-time\".split(\" \"),factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory((global.vega=global.vega||{},global.vega.transforms={}),global.vega,global.vega,global.vega,global.d3,global.vega))})(this,function(exports,vegaUtil,vegaDataflow,vegaStatistics,d3Array,vegaTime){function multikey(f){return function(x){for(var n=f.length,i=1,k=String(f[0](x));i<n;++i)k+=\"|\"+f[i](x);\nreturn k}}function groupkey(fields){return fields&&fields.length?1===fields.length?fields[0]:multikey(fields):function(){return\"\"}}function measure(key,value){return function(out){return vegaUtil.extend({name:key,out:out||key},base_op,value)}}function compareIndex(a,b){return a.idx-b.idx}function resolve(agg){var map={};agg.forEach(function(a){return map[a.name]=a});var getreqs=function(a){a.req&&a.req.forEach(function(key){map[key]||getreqs(map[key]=AggregateOps[key]())})};agg.forEach(getreqs);return Object.values(map).sort(compareIndex)}\nfunction init$jscomp$0(){var $jscomp$this=this;this.missing=this.valid=0;this._ops.forEach(function(op){return op.init($jscomp$this)})}function add$jscomp$0(v,t){var $jscomp$this=this;null==v||\"\"===v?++this.missing:v===v&&(++this.valid,this._ops.forEach(function(op){return op.add($jscomp$this,v,t)}))}function rem$jscomp$0(v,t){var $jscomp$this=this;null==v||\"\"===v?--this.missing:v===v&&(--this.valid,this._ops.forEach(function(op){return op.rem($jscomp$this,v,t)}))}function set$jscomp$0(t){var $jscomp$this=\nthis;this._out.forEach(function(op){return t[op.out]=op.value($jscomp$this)});return t}function compileMeasures(agg,field){function ctr(cell){this._ops=ops;this._out=out;this.cell=cell;this.init()}field=field||vegaUtil.identity;var ops=resolve(agg),out=agg.slice().sort(compareIndex);ctr.prototype.init=init$jscomp$0;ctr.prototype.add=add$jscomp$0;ctr.prototype.rem=rem$jscomp$0;ctr.prototype.set=set$jscomp$0;ctr.prototype.get=field;ctr.fields=agg.map(function(op){return op.out});return ctr}function TupleStore(key){this._key=\nkey?vegaUtil.field(key):vegaDataflow.tupleid;this.reset()}function Aggregate(params){vegaDataflow.Transform.call(this,null,params);this._adds=[];this._mods=[];this._mlen=this._alen=0;this._drop=!0;this._cross=!1;this._dims=[];this._dnames=[];this._measures=[];this._countOnly=!1;this._outputs=this._inputs=this._prev=this._counts=null}function Bin(params){vegaDataflow.Transform.call(this,null,params)}function SortedList(idFunc,source,input){var data=source||[],add=input||[],rem={},cnt=0;return{add:function(t){return add.push(t)},\nremove:function(t){return rem[idFunc(t)]=++cnt},size:function(){return data.length},data:function(compare,resort){cnt&&(data=data.filter(function(t){return!rem[idFunc(t)]}),rem={},cnt=0);resort&&compare&&data.sort(compare);add.length&&(data=compare?vegaUtil.merge(compare,data,add.sort(compare)):data.concat(add),add=[]);return data}}}function Collect(params){vegaDataflow.Transform.call(this,[],params)}function Compare(params){vegaDataflow.Operator.call(this,null,update$jscomp$0,params)}function update$jscomp$0(_){return this.value&&\n!_.modified()?this.value:vegaUtil.compare(_.fields,_.orders)}function CountPattern(params){vegaDataflow.Transform.call(this,null,params)}function Cross(params){vegaDataflow.Transform.call(this,null,params)}function parse(def,data){var func=def[\"function\"];vegaUtil.hasOwnProperty(Distributions,func)||vegaUtil.error(\"Unknown distribution function: \"+func);func=Distributions[func]();for(var name in def)if(\"field\"===name)func.data((def.from||data()).map(def[name]));else if(\"distributions\"===name)func[name](def[name].map(function(_){return parse(_,\ndata)}));else if(\"function\"===typeof func[name])func[name](def[name]);return func}function Density(params){vegaDataflow.Transform.call(this,null,params)}function source$jscomp$0(pulse){return function(){return pulse.materialize(pulse.SOURCE).source}}function fieldNames(fields,as){return fields?fields.map(function(f,i){return as[i]||vegaUtil.accessorName(f)}):null}function partition(data,groupby,field){var groups=[],get=function(f){return f(t)},n;if(null==groupby)groups.push(data.map(field));else{var map=\n{};var i=0;for(n=data.length;i<n;++i){var t=data[i];var k=groupby.map(get);var g=map[k];g||(map[k]=g=[],g.dims=k,groups.push(g));g.push(field(t))}}return groups}function DotBin(params){vegaDataflow.Transform.call(this,null,params)}function Expression(params){vegaDataflow.Operator.call(this,null,update$1,params);this.modified(!0)}function update$1(_){var expr=_.expr;return this.value&&!_.modified(\"expr\")?this.value:vegaUtil.accessor(function(datum){return expr(datum,_)},vegaUtil.accessorFields(expr),\nvegaUtil.accessorName(expr))}function Extent(params){vegaDataflow.Transform.call(this,[void 0,void 0],params)}function Subflow(pulse,parent){vegaDataflow.Operator.call(this,pulse);this.parent=parent;this.count=0}function Facet(params){vegaDataflow.Transform.call(this,{},params);this._keys=vegaUtil.fastmap();var a=this._targets=[];a.active=0;a.forEach=function(f){for(var i=0,n=a.active;i<n;++i)f(a[i],i,a)}}function Field(params){vegaDataflow.Operator.call(this,null,update$2,params)}function update$2(_){return this.value&&\n!_.modified()?this.value:vegaUtil.isArray(_.name)?vegaUtil.array(_.name).map(function(f){return vegaUtil.field(f)}):vegaUtil.field(_.name,_.as)}function Filter(params){vegaDataflow.Transform.call(this,vegaUtil.fastmap(),params)}function Flatten(params){vegaDataflow.Transform.call(this,[],params)}function Fold(params){vegaDataflow.Transform.call(this,[],params)}function Formula(params){vegaDataflow.Transform.call(this,null,params)}function Generate(params){vegaDataflow.Transform.call(this,[],params)}\nfunction Impute(params){vegaDataflow.Transform.call(this,[],params)}function getValue(_){var m=_.method||Methods.value;if(null==Methods[m])vegaUtil.error(\"Unrecognized imputation method: \"+m);else{if(m===Methods.value){var v=void 0!==_.value?_.value:0;return function(){return v}}return Methods[m]}}function getField(_){var f=_.field;return function(t){return t?f(t):NaN}}function partition$1(data,groupby,key,keyvals){var get=function(f){return f(t)},groups=[];keyvals=keyvals?keyvals.slice():[];var kMap=\n{},gMap={},group,n;keyvals.forEach(function(k,i){return kMap[k]=i+1});var i$jscomp$0=0;for(n=data.length;i$jscomp$0<n;++i$jscomp$0){var t=data[i$jscomp$0];var gVals=key(t);var j=kMap[gVals]||(kMap[gVals]=keyvals.push(gVals));var gKey=(gVals=groupby?groupby.map(get):Empty)+\"\";(group=gMap[gKey])||(group=gMap[gKey]=[],groups.push(group),group.values=gVals);group[j-1]=t}groups.domain=keyvals;return groups}function JoinAggregate(params){Aggregate.call(this,params)}function KDE(params){vegaDataflow.Transform.call(this,\nnull,params)}function Key(params){vegaDataflow.Operator.call(this,null,update$3,params)}function update$3(_){return this.value&&!_.modified()?this.value:vegaUtil.key(_.fields,_.flat)}function Load(params){vegaDataflow.Transform.call(this,[],params);this._pending=null}function stop$jscomp$0(_){return _.modified(\"async\")&&!(_.modified(\"values\")||_.modified(\"url\")||_.modified(\"format\"))}function output$jscomp$0(op,pulse,data){data.forEach(vegaDataflow.ingest);pulse=pulse.fork(pulse.NO_FIELDS&pulse.NO_SOURCE);\npulse.rem=op.value;op.value=pulse.source=pulse.add=data;op._pending=null;pulse.rem.length&&pulse.clean(!0);return pulse}function Lookup(params){vegaDataflow.Transform.call(this,{},params)}function MultiExtent(params){vegaDataflow.Operator.call(this,null,update$4,params)}function update$4(_){if(this.value&&!_.modified())return this.value;_=_.extents;var n=_.length,min=Infinity,max=-Infinity,i;for(i=0;i<n;++i){var e=_[i];e[0]<min&&(min=e[0]);e[1]>max&&(max=e[1])}return[min,max]}function MultiValues(params){vegaDataflow.Operator.call(this,\nnull,update$5,params)}function update$5(_$jscomp$0){return this.value&&!_$jscomp$0.modified()?this.value:_$jscomp$0.values.reduce(function(data,_){return data.concat(_)},[])}function Params(params){vegaDataflow.Transform.call(this,null,params)}function Pivot(params){Aggregate.call(this,params)}function aggregateParams(_,pulse){var key=_.field,value=_.value,op=(\"count\"===_.op?\"__count__\":_.op)||\"sum\",fields=vegaUtil.accessorFields(key).concat(vegaUtil.accessorFields(value)),keys=pivotKeys(key,_.limit||\n0,pulse);pulse.changed()&&_.set(\"__pivot__\",null,null,!0);return{key:_.key,groupby:_.groupby,ops:keys.map(function(){return op}),fields:keys.map(function(k){return get$jscomp$0(k,key,value,fields)}),as:keys.map(function(k){return k+\"\"}),modified:_.modified.bind(_)}}function get$jscomp$0(k,key,value,fields){return vegaUtil.accessor(function(d){return key(d)===k?value(d):NaN},fields,k+\"\")}function pivotKeys(key,limit,pulse){var map={},list=[];pulse.visit(pulse.SOURCE,function(t){t=key(t);map[t]||(map[t]=\n1,list.push(t))});list.sort(vegaUtil.ascending);return limit?list.slice(0,limit):list}function PreFacet(params){Facet.call(this,params)}function Project(params){vegaDataflow.Transform.call(this,null,params)}function Proxy(params){vegaDataflow.Transform.call(this,null,params)}function Quantile(params){vegaDataflow.Transform.call(this,null,params)}function Relay(params){vegaDataflow.Transform.call(this,null,params)}function Sample(params){vegaDataflow.Transform.call(this,[],params);this.count=0}function Sequence(params){vegaDataflow.Transform.call(this,\nnull,params)}function Sieve(params){vegaDataflow.Transform.call(this,null,params);this.modified(!0)}function TimeUnit(params){vegaDataflow.Transform.call(this,null,params)}function TupleIndex(params){vegaDataflow.Transform.call(this,vegaUtil.fastmap(),params)}function Values(params){vegaDataflow.Transform.call(this,null,params)}function WindowOp(op,field,param,as){var fn=WindowOps[op](field,param);return{init:fn.init||vegaUtil.zero,update:function(w,t){t[as]=fn.next(w)}}}function WindowState(_$jscomp$0){function visitInputs(f){vegaUtil.array(vegaUtil.accessorFields(f)).forEach(function(_){return inputs[_]=\n1})}var ops=vegaUtil.array(_$jscomp$0.ops),fields=vegaUtil.array(_$jscomp$0.fields),params=vegaUtil.array(_$jscomp$0.params),as=vegaUtil.array(_$jscomp$0.as),outputs=this.outputs=[],windows=this.windows=[],inputs={},map={},counts=[],measures=[],countOnly=!0;visitInputs(_$jscomp$0.sort);ops.forEach(function(op,i){var field=fields[i],mname=vegaUtil.accessorName(field),name=as[i]||op+(mname?\"_\"+mname:\"\");visitInputs(field);outputs.push(name);vegaUtil.hasOwnProperty(WindowOps,op)?windows.push(WindowOp(op,\nfields[i],params[i],name)):(null==field&&\"count\"!==op&&vegaUtil.error(\"Null aggregate field specified.\"),\"count\"===op?counts.push(name):(countOnly=!1,i=map[mname],i||(i=map[mname]=[],i.field=field,measures.push(i)),i.push(AggregateOps[op](name))))});if(counts.length||measures.length)this.cell=cell(measures,counts,countOnly);this.inputs=Object.keys(inputs)}function cell(measures,counts,countOnly){measures=measures.map(function(m){return compileMeasures(m,m.field)});var cell={num:0,agg:null,store:!1,\ncount:counts};if(!countOnly)for(var n$jscomp$0=measures.length,a=cell.agg=Array(n$jscomp$0),i$jscomp$0=0;i$jscomp$0<n$jscomp$0;++i$jscomp$0)a[i$jscomp$0]=new measures[i$jscomp$0](cell);if(cell.store)var store=cell.data=new TupleStore;cell.add=function(t){cell.num+=1;if(!countOnly){store&&store.add(t);for(var i$324=0;i$324<n$jscomp$0;++i$324)a[i$324].add(a[i$324].get(t),t)}};cell.rem=function(t){--cell.num;if(!countOnly){store&&store.rem(t);for(var i$325=0;i$325<n$jscomp$0;++i$325)a[i$325].rem(a[i$325].get(t),\nt)}};cell.set=function(t){var n;store&&store.values();var i=0;for(n=counts.length;i<n;++i)t[counts[i]]=cell.num;if(!countOnly)for(i=0,n=a.length;i<n;++i)a[i].set(t)};cell.init=function(){cell.num=0;store&&store.reset();for(var i$326=0;i$326<n$jscomp$0;++i$326)a[i$326].init()};return cell}function Window(params){vegaDataflow.Transform.call(this,{},params);this._mlen=0;this._mods=[]}function processPartition(list,state,cmp,_){var sort=_.sort,range=sort&&!_.ignorePeers;_=_.frame||[null,0];list=list.data(cmp);\ncmp=list.length;var b=range?d3Array.bisector(sort):null;sort={i0:0,i1:0,p0:0,p1:0,index:0,data:list,compare:sort||vegaUtil.constant(-1)};state.init();for(var i=0;i<cmp;++i){var i$jscomp$0=i;sort.p0=sort.i0;sort.p1=sort.i1;sort.i0=null==_[0]?0:Math.max(0,i$jscomp$0-Math.abs(_[0]));sort.i1=null==_[1]?cmp:Math.min(cmp,i$jscomp$0+Math.abs(_[1])+1);sort.index=i$jscomp$0;if(range){i$jscomp$0=sort.i0;var r1=sort.i1-1,c=sort.compare,d=sort.data,n=d.length-1;0<i$jscomp$0&&!c(d[i$jscomp$0],d[i$jscomp$0-1])&&\n(sort.i0=b.left(d,d[i$jscomp$0]));r1<n&&!c(d[r1],d[r1+1])&&(sort.i1=b.right(d,d[r1]))}state.update(sort,list[i])}}var noop=function(){},base_op={init:noop,add:noop,rem:noop,idx:0},AggregateOps={values:{init:function(m){return m.cell.store=!0},value:function(m){return m.cell.data.values()},idx:-1},count:{value:function(m){return m.cell.num}},__count__:{value:function(m){return m.missing+m.valid}},missing:{value:function(m){return m.missing}},valid:{value:function(m){return m.valid}},sum:{init:function(m){return m.sum=\n0},value:function(m){return m.sum},add:function(m,v){return m.sum+=+v},rem:function(m,v){return m.sum-=v}},product:{init:function(m){return m.product=1},value:function(m){return m.valid?m.product:void 0},add:function(m,v){return m.product*=v},rem:function(m,v){return m.product/=v}},mean:{init:function(m){return m.mean=0},value:function(m){return m.valid?m.mean:void 0},add:function(m,v){return m.mean_d=v-m.mean,m.mean+=m.mean_d/m.valid},rem:function(m,v){return m.mean_d=v-m.mean,m.mean-=m.valid?m.mean_d/\nm.valid:m.mean}},average:{value:function(m){return m.valid?m.mean:void 0},req:[\"mean\"],idx:1},variance:{init:function(m){return m.dev=0},value:function(m){return 1<m.valid?m.dev/(m.valid-1):void 0},add:function(m,v){return m.dev+=m.mean_d*(v-m.mean)},rem:function(m,v){return m.dev-=m.mean_d*(v-m.mean)},req:[\"mean\"],idx:1},variancep:{value:function(m){return 1<m.valid?m.dev/m.valid:void 0},req:[\"variance\"],idx:2},stdev:{value:function(m){return 1<m.valid?Math.sqrt(m.dev/(m.valid-1)):void 0},req:[\"variance\"],\nidx:2},stdevp:{value:function(m){return 1<m.valid?Math.sqrt(m.dev/m.valid):void 0},req:[\"variance\"],idx:2},stderr:{value:function(m){return 1<m.valid?Math.sqrt(m.dev/(m.valid*(m.valid-1))):void 0},req:[\"variance\"],idx:2},distinct:{value:function(m){return m.cell.data.distinct(m.get)},req:[\"values\"],idx:3},ci0:{value:function(m){return m.cell.data.ci0(m.get)},req:[\"values\"],idx:3},ci1:{value:function(m){return m.cell.data.ci1(m.get)},req:[\"values\"],idx:3},median:{value:function(m){return m.cell.data.q2(m.get)},\nreq:[\"values\"],idx:3},q1:{value:function(m){return m.cell.data.q1(m.get)},req:[\"values\"],idx:3},q3:{value:function(m){return m.cell.data.q3(m.get)},req:[\"values\"],idx:3},min:{init:function(m){return m.min=void 0},value:function(m){return m.min=Number.isNaN(m.min)?m.cell.data.min(m.get):m.min},add:function(m,v){if(v<m.min||void 0===m.min)m.min=v},rem:function(m,v){v<=m.min&&(m.min=NaN)},req:[\"values\"],idx:4},max:{init:function(m){return m.max=void 0},value:function(m){return m.max=Number.isNaN(m.max)?\nm.cell.data.max(m.get):m.max},add:function(m,v){if(v>m.max||void 0===m.max)m.max=v},rem:function(m,v){v>=m.max&&(m.max=NaN)},req:[\"values\"],idx:4},argmin:{init:function(m){return m.argmin=void 0},value:function(m){return m.argmin||m.cell.data.argmin(m.get)},add:function(m,v,t){v<m.min&&(m.argmin=t)},rem:function(m,v){v<=m.min&&(m.argmin=void 0)},req:[\"min\",\"values\"],idx:3},argmax:{init:function(m){return m.argmax=void 0},value:function(m){return m.argmax||m.cell.data.argmax(m.get)},add:function(m,\nv,t){v>m.max&&(m.argmax=t)},rem:function(m,v){v>=m.max&&(m.argmax=void 0)},req:[\"max\",\"values\"],idx:3}};noop=Object.keys(AggregateOps);noop.forEach(function(key){AggregateOps[key]=measure(key,AggregateOps[key])});var prototype=TupleStore.prototype;prototype.reset=function(){this._add=[];this._rem=[];this._q=this._get=this._ext=null};prototype.add=function(v){this._add.push(v)};prototype.rem=function(v){this._rem.push(v)};prototype.values=function(){this._get=null;if(0===this._rem.length)return this._add;\nvar a=this._add,r=this._rem,k=this._key,n=a.length,m=r.length,x=Array(n-m),map={},i,v;for(i=0;i<m;++i)map[k(r[i])]=1;for(r=i=0;i<n;++i)map[k(v=a[i])]?map[k(v)]=0:x[r++]=v;this._rem=[];return this._add=x};prototype.distinct=function(get){for(var v=this.values(),map={},n=v.length,count=0,s;0<=--n;)s=get(v[n])+\"\",vegaUtil.hasOwnProperty(map,s)||(map[s]=1,++count);return count};prototype.extent=function(get){if(this._get!==get||!this._ext){var v=this.values(),i=vegaUtil.extentIndex(v,get);this._ext=[v[i[0]],\nv[i[1]]];this._get=get}return this._ext};prototype.argmin=function(get){return this.extent(get)[0]||{}};prototype.argmax=function(get){return this.extent(get)[1]||{}};prototype.min=function(get){var m=this.extent(get)[0];return null!=m?get(m):void 0};prototype.max=function(get){var m=this.extent(get)[1];return null!=m?get(m):void 0};prototype.quartile=function(get){this._get===get&&this._q||(this._q=vegaStatistics.quartiles(this.values(),get),this._get=get);return this._q};prototype.q1=function(get){return this.quartile(get)[0]};\nprototype.q2=function(get){return this.quartile(get)[1]};prototype.q3=function(get){return this.quartile(get)[2]};prototype.ci=function(get){this._get===get&&this._ci||(this._ci=vegaStatistics.bootstrapCI(this.values(),1E3,.05,get),this._get=get);return this._ci};prototype.ci0=function(get){return this.ci(get)[0]};prototype.ci1=function(get){return this.ci(get)[1]};Aggregate.Definition={type:\"Aggregate\",metadata:{generates:!0,changes:!0},params:[{name:\"groupby\",type:\"field\",array:!0},{name:\"ops\",\ntype:\"enum\",array:!0,values:noop},{name:\"fields\",type:\"field\",\"null\":!0,array:!0},{name:\"as\",type:\"string\",\"null\":!0,array:!0},{name:\"drop\",type:\"boolean\",\"default\":!0},{name:\"cross\",type:\"boolean\",\"default\":!1},{name:\"key\",type:\"field\"}]};vegaUtil.inherits(Aggregate,vegaDataflow.Transform,{transform:function(_,pulse){var $jscomp$this=this,aggr=this,out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),mod=_.modified();aggr.stamp=out.stamp;aggr.value&&(mod||pulse.modified(aggr._inputs,!0))?(aggr._prev=\naggr.value,aggr.value=mod?aggr.init(_):{},pulse.visit(pulse.SOURCE,function(t){return aggr.add(t)})):(aggr.value=aggr.value||aggr.init(_),pulse.visit(pulse.REM,function(t){return aggr.rem(t)}),pulse.visit(pulse.ADD,function(t){return aggr.add(t)}));out.modifies(aggr._outputs);aggr._drop=!1!==_.drop;_.cross&&1<aggr._dims.length&&(aggr._drop=!1,aggr.cross());pulse.clean()&&aggr._drop&&out.clean(!0).runAfter(function(){return $jscomp$this.clean()});return aggr.changes(out)},cross:function(){function collect(cells){var key,\ni,v;for(key in cells){var t=cells[key].tuple;for(i=0;i<n;++i)vals[i][v=t[dims[i]]]=v}}function generate(base,tuple,index){var name=dims[index],v=vals[index++],k;for(k in v){var key=base?base+\"|\"+k:k;tuple[name]=v[k];index<n?generate(key,tuple,index):curr[key]||aggr.cell(key,tuple)}}var aggr=this,curr=aggr.value,dims=aggr._dnames,vals=dims.map(function(){return{}}),n=dims.length;collect(aggr._prev);collect(curr);generate(\"\",{},0)},init:function(_){function inputVisit(get){get=vegaUtil.array(vegaUtil.accessorFields(get));\nfor(var n=get.length,i=0,f;i<n;++i)inputMap[f=get[i]]||(inputMap[f]=1,inputs.push(f))}var inputs=this._inputs=[],outputs=this._outputs=[],inputMap={};this._dims=vegaUtil.array(_.groupby);this._dnames=this._dims.map(function(d){var dname=vegaUtil.accessorName(d);inputVisit(d);outputs.push(dname);return dname});this.cellkey=_.key?_.key:groupkey(this._dims);this._countOnly=!0;this._counts=[];this._measures=[];var fields=_.fields||[null],ops=_.ops||[\"count\"];_=_.as||[];var n$jscomp$0=fields.length,map=\n{},i$jscomp$0;n$jscomp$0!==ops.length&&vegaUtil.error(\"Unmatched number of fields and aggregate ops.\");for(i$jscomp$0=0;i$jscomp$0<n$jscomp$0;++i$jscomp$0){var field=fields[i$jscomp$0];var op=ops[i$jscomp$0];null==field&&\"count\"!==op&&vegaUtil.error(\"Null aggregate field specified.\");var mname=vegaUtil.accessorName(field);var outname=_[i$jscomp$0]||op+(mname?\"_\"+mname:\"\");outputs.push(outname);if(\"count\"===op)this._counts.push(outname);else{var m$jscomp$0=map[mname];m$jscomp$0||(inputVisit(field),\nm$jscomp$0=map[mname]=[],m$jscomp$0.field=field,this._measures.push(m$jscomp$0));\"count\"!==op&&(this._countOnly=!1);m$jscomp$0.push(AggregateOps[op](outname))}}this._measures=this._measures.map(function(m){return compileMeasures(m,m.field)});return{}},cellkey:groupkey(),cell:function(key,t){var cell=this.value[key];cell?0===cell.num&&this._drop&&cell.stamp<this.stamp?(cell.stamp=this.stamp,this._adds[this._alen++]=cell):cell.stamp<this.stamp&&(cell.stamp=this.stamp,this._mods[this._mlen++]=cell):\n(cell=this.value[key]=this.newcell(key,t),this._adds[this._alen++]=cell);return cell},newcell:function(key,t){key={key:key,num:0,agg:null,tuple:this.newtuple(t,this._prev&&this._prev[key]),stamp:this.stamp,store:!1};if(!this._countOnly){t=this._measures;var n=t.length;key.agg=Array(n);for(var i=0;i<n;++i)key.agg[i]=new t[i](key)}key.store&&(key.data=new TupleStore);return key},newtuple:function(t,p){for(var names=this._dnames,dims=this._dims,n=dims.length,x={},i=0;i<n;++i)x[names[i]]=dims[i](t);return p?\nvegaDataflow.replace(p.tuple,x):vegaDataflow.ingest(x)},clean:function(){var cells=this.value,key;for(key in cells)0===cells[key].num&&delete cells[key]},add:function(t){var key=this.cellkey(t);key=this.cell(key,t);key.num+=1;if(!this._countOnly){key.store&&key.data.add(t);key=key.agg;for(var i=0,n=key.length;i<n;++i)key[i].add(key[i].get(t),t)}},rem:function(t){var key=this.cellkey(t);key=this.cell(key,t);--key.num;if(!this._countOnly){key.store&&key.data.rem(t);key=key.agg;for(var i=0,n=key.length;i<\nn;++i)key[i].rem(key[i].get(t),t)}},celltuple:function(cell){var tuple=cell.tuple,counts=this._counts;cell.store&&cell.data.values();for(var i=0,n=counts.length;i<n;++i)tuple[counts[i]]=cell.num;if(!this._countOnly)for(cell=cell.agg,counts=0,i=cell.length;counts<i;++counts)cell[counts].set(tuple);return tuple},changes:function(out){var adds=this._adds,mods=this._mods,prev=this._prev,drop=this._drop,add=out.add,rem=out.rem,mod=out.mod,key;if(prev)for(key in prev){var cell=prev[key];drop&&!cell.num||\nrem.push(cell.tuple)}prev=0;for(key=this._alen;prev<key;++prev)add.push(this.celltuple(adds[prev])),adds[prev]=null;prev=0;for(key=this._mlen;prev<key;++prev)cell=mods[prev],(0===cell.num&&drop?rem:mod).push(this.celltuple(cell)),mods[prev]=null;this._alen=this._mlen=0;this._prev=null;return out}});Bin.Definition={type:\"Bin\",metadata:{modifies:!0},params:[{name:\"field\",type:\"field\",required:!0},{name:\"interval\",type:\"boolean\",\"default\":!0},{name:\"anchor\",type:\"number\"},{name:\"maxbins\",type:\"number\",\n\"default\":20},{name:\"base\",type:\"number\",\"default\":10},{name:\"divide\",type:\"number\",array:!0,\"default\":[5,2]},{name:\"extent\",type:\"number\",array:!0,length:2,required:!0},{name:\"span\",type:\"number\"},{name:\"step\",type:\"number\"},{name:\"steps\",type:\"number\",array:!0},{name:\"minstep\",type:\"number\",\"default\":0},{name:\"nice\",type:\"boolean\",\"default\":!0},{name:\"name\",type:\"string\"},{name:\"as\",type:\"string\",array:!0,length:2,\"default\":[\"bin0\",\"bin1\"]}]};vegaUtil.inherits(Bin,vegaDataflow.Transform,{transform:function(_,\npulse){var band=!1!==_.interval,bins=this._bins(_),start=bins.start,step=bins.step,as=_.as||[\"bin0\",\"bin1\"],b0=as[0],b1=as[1];_.modified()?(pulse=pulse.reflow(!0),_=pulse.SOURCE):_=pulse.modified(vegaUtil.accessorFields(_.field))?pulse.ADD_MOD:pulse.ADD;pulse.visit(_,band?function(t){var v=bins(t);t[b0]=v;t[b1]=null==v?null:start+step*(1+(v-start)/step)}:function(t){return t[b0]=bins(t)});return pulse.modifies(band?as:b0)},_bins:function(_){if(this.value&&!_.modified())return this.value;var field=\n_.field,bins=vegaStatistics.bin(_),step=bins.step,start=bins.start,stop=start+Math.ceil((bins.stop-start)/step)*step,a;null!=(a=_.anchor)&&(a-=start+step*Math.floor((a-start)/step),start+=a,stop+=a);a=function(t){t=vegaUtil.toNumber(field(t));return null==t?null:t<start?-Infinity:t>stop?Infinity:(t=Math.max(start,Math.min(t,stop-step)),start+step*Math.floor(1E-14+(t-start)/step))};a.start=start;a.stop=bins.stop;a.step=step;return this.value=vegaUtil.accessor(a,vegaUtil.accessorFields(field),_.name||\n\"bin_\"+vegaUtil.accessorName(field))}});Collect.Definition={type:\"Collect\",metadata:{source:!0},params:[{name:\"sort\",type:\"compare\"}]};vegaUtil.inherits(Collect,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.ALL),list=SortedList(vegaDataflow.tupleid,this.value,out.materialize(out.ADD).add),sort=_.sort;_=pulse.changed()||sort&&(_.modified(\"sort\")||pulse.modified(sort.fields));out.visit(out.REM,list.remove);this.modified(_);this.value=out.source=list.data(vegaDataflow.stableCompare(sort),\n_);pulse.source&&pulse.source.root&&(this.value.root=pulse.source.root);return out}});vegaUtil.inherits(Compare,vegaDataflow.Operator);CountPattern.Definition={type:\"CountPattern\",metadata:{generates:!0,changes:!0},params:[{name:\"field\",type:\"field\",required:!0},{name:\"case\",type:\"enum\",values:[\"upper\",\"lower\",\"mixed\"],\"default\":\"mixed\"},{name:\"pattern\",type:\"string\",\"default\":'[\\\\w\"]+'},{name:\"stopwords\",type:\"string\",\"default\":\"\"},{name:\"as\",type:\"string\",array:!0,length:2,\"default\":[\"text\",\"count\"]}]};\nvegaUtil.inherits(CountPattern,vegaDataflow.Transform,{transform:function(_,pulse){var process=function(update){return function(tuple){tuple=get(tuple);switch(_.case){case \"upper\":tuple=tuple.toUpperCase();break;case \"lower\":tuple=tuple.toLowerCase()}tuple=tuple.match(match)||[];for(var t,i=0,n=tuple.length;i<n;++i)stop.test(t=tuple[i])||update(t)}},init=this._parameterCheck(_,pulse),counts=this._counts,match=this._match,stop=this._stop,get=_.field,as=_.as||[\"text\",\"count\"],add=process(function(t){return counts[t]=\n1+(counts[t]||0)});process=process(function(t){return--counts[t]});init?pulse.visit(pulse.SOURCE,add):(pulse.visit(pulse.ADD,add),pulse.visit(pulse.REM,process));return this._finish(pulse,as)},_parameterCheck:function(_,pulse){var init=!1;if(_.modified(\"stopwords\")||!this._stop)this._stop=new RegExp(\"^\"+(_.stopwords||\"\")+\"$\",\"i\"),init=!0;if(_.modified(\"pattern\")||!this._match)this._match=new RegExp(_.pattern||\"[\\\\w']+\",\"g\"),init=!0;if(_.modified(\"field\")||pulse.modified(_.field.fields))init=!0;init&&\n(this._counts={});return init},_finish:function(pulse,as){var counts=this._counts,tuples=this._tuples||(this._tuples={}),text=as[0],count=as[1];pulse=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);var w;for(w in counts){var t=tuples[w];var c=counts[w]||0;!t&&c?(tuples[w]=t=vegaDataflow.ingest({}),t[text]=w,t[count]=c,pulse.add.push(t)):0===c?(t&&pulse.rem.push(t),counts[w]=null,tuples[w]=null):t[count]!==c&&(t[count]=c,pulse.mod.push(t))}return pulse.modifies(as)}});Cross.Definition={type:\"Cross\",metadata:{generates:!0},\nparams:[{name:\"filter\",type:\"expr\"},{name:\"as\",type:\"string\",array:!0,length:2,\"default\":[\"a\",\"b\"]}]};vegaUtil.inherits(Cross,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.NO_SOURCE),as=_.as||[\"a\",\"b\"],a=as[0],b=as[1],reset=!this.value||pulse.changed(pulse.ADD_REM)||_.modified(\"as\")||_.modified(\"filter\"),data=this.value;if(reset){data&&(out.rem=data);pulse=data=pulse.materialize(pulse.SOURCE).source;_=_.filter||vegaUtil.truthy;reset=[];data={};for(var n=pulse.length,\ni=0,j,left;i<n;++i)for(data[a]=left=pulse[i],j=0;j<n;++j)data[b]=pulse[j],_(data)&&(reset.push(vegaDataflow.ingest(data)),data={},data[a]=left);out.add=this.value=reset}else out.mod=data;out.source=this.value;return out.modifies(as)}});var Distributions={kde:vegaStatistics.randomKDE,mixture:vegaStatistics.randomMixture,normal:vegaStatistics.randomNormal,lognormal:vegaStatistics.randomLogNormal,uniform:vegaStatistics.randomUniform};prototype=[{key:{\"function\":\"normal\"},params:[{name:\"mean\",type:\"number\",\n\"default\":0},{name:\"stdev\",type:\"number\",\"default\":1}]},{key:{\"function\":\"lognormal\"},params:[{name:\"mean\",type:\"number\",\"default\":0},{name:\"stdev\",type:\"number\",\"default\":1}]},{key:{\"function\":\"uniform\"},params:[{name:\"min\",type:\"number\",\"default\":0},{name:\"max\",type:\"number\",\"default\":1}]},{key:{\"function\":\"kde\"},params:[{name:\"field\",type:\"field\",required:!0},{name:\"from\",type:\"data\"},{name:\"bandwidth\",type:\"number\",\"default\":0}]}];Density.Definition={type:\"Density\",metadata:{generates:!0},params:[{name:\"extent\",\ntype:\"number\",array:!0,length:2},{name:\"steps\",type:\"number\"},{name:\"minsteps\",type:\"number\",\"default\":25},{name:\"maxsteps\",type:\"number\",\"default\":200},{name:\"method\",type:\"string\",\"default\":\"pdf\",values:[\"pdf\",\"cdf\"]},{name:\"distribution\",type:\"param\",params:prototype.concat({key:{\"function\":\"mixture\"},params:[{name:\"distributions\",type:\"param\",array:!0,params:prototype},{name:\"weights\",type:\"number\",array:!0}]})},{name:\"as\",type:\"string\",array:!0,\"default\":[\"value\",\"density\"]}]};vegaUtil.inherits(Density,\nvegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);if(!this.value||pulse.changed()||_.modified()){var dist=parse(_.distribution,source$jscomp$0(pulse));pulse=_.steps||_.minsteps||25;var maxsteps=_.steps||_.maxsteps||200,method=_.method||\"pdf\";\"pdf\"!==method&&\"cdf\"!==method&&vegaUtil.error(\"Invalid density method: \"+method);_.extent||dist.data||vegaUtil.error(\"Missing density extent parameter.\");method=dist[method];var as=_.as||[\"value\",\"density\"];\n_=_.extent||vegaUtil.extent(dist.data());_=vegaStatistics.sampleCurve(method,_,pulse,maxsteps).map(function(v){var tuple={};tuple[as[0]]=v[0];tuple[as[1]]=v[1];return vegaDataflow.ingest(tuple)});this.value&&(out.rem=this.value);this.value=out.add=out.source=_}return out}});DotBin.Definition={type:\"DotBin\",metadata:{modifies:!0},params:[{name:\"field\",type:\"field\",required:!0},{name:\"groupby\",type:\"field\",array:!0},{name:\"step\",type:\"number\"},{name:\"smooth\",type:\"boolean\",\"default\":!1},{name:\"as\",\ntype:\"string\",\"default\":\"bin\"}]};vegaUtil.inherits(DotBin,vegaDataflow.Transform,{transform:function(_,pulse){if(this.value&&!_.modified()&&!pulse.changed())return pulse;var source=pulse.materialize(pulse.SOURCE).source,groups=partition(pulse.source,_.groupby,vegaUtil.identity),smooth=_.smooth||!1,field=_.field;source=_.step||vegaUtil.span(vegaUtil.extent(source,field))/30;var sort=vegaDataflow.stableCompare(function(a,b){return field(a)-field(b)});_=_.as||\"bin\";for(var n=groups.length,min=Infinity,\nmax=-Infinity,i=0,j;i<n;++i){var g=groups[i].sort(sort);j=-1;for(var $jscomp$iter$88=$jscomp.makeIterator(vegaStatistics.dotbin(g,source,smooth,field)),$jscomp$key$v=$jscomp$iter$88.next();!$jscomp$key$v.done;$jscomp$key$v=$jscomp$iter$88.next())$jscomp$key$v=$jscomp$key$v.value,$jscomp$key$v<min&&(min=$jscomp$key$v),$jscomp$key$v>max&&(max=$jscomp$key$v),g[++j][_]=$jscomp$key$v}this.value={start:min,stop:max,step:source};return pulse.reflow(!0).modifies(_)}});vegaUtil.inherits(Expression,vegaDataflow.Operator);\nExtent.Definition={type:\"Extent\",metadata:{},params:[{name:\"field\",type:\"field\",required:!0}]};vegaUtil.inherits(Extent,vegaDataflow.Transform,{transform:function(_,pulse){var extent=this.value,field=_.field;_=pulse.changed()||pulse.modified(field.fields)||_.modified(\"field\");var min=extent[0],max=extent[1];if(_||null==min)min=Infinity,max=-Infinity;pulse.visit(_?pulse.SOURCE:pulse.ADD,function(t){t=vegaUtil.toNumber(field(t));null!=t&&(t<min&&(min=t),t>max&&(max=t))});Number.isFinite(min)&&Number.isFinite(max)||\n((extent=vegaUtil.accessorName(field))&&(extent=' for field \"'+extent+'\"'),pulse.dataflow.warn(\"Infinite extent\"+extent+\": [\"+min+\", \"+max+\"]\"),min=max=void 0);this.value=[min,max]}});vegaUtil.inherits(Subflow,vegaDataflow.Operator,{connect:function(target){this.detachSubflow=target.detachSubflow;this.targets().add(target);return target.source=this},add:function(t){this.count+=1;this.value.add.push(t)},rem:function(t){--this.count;this.value.rem.push(t)},mod:function(t){this.value.mod.push(t)},init:function(pulse){this.value.init(pulse,\npulse.NO_SOURCE)},evaluate:function(){return this.value}});vegaUtil.inherits(Facet,vegaDataflow.Transform,{activate:function(flow){this._targets[this._targets.active++]=flow},subflow:function(key,flow,pulse,parent){var flows=this.value,sf=vegaUtil.hasOwnProperty(flows,key)&&flows[key];if(sf)sf.value.stamp<pulse.stamp&&(sf.init(pulse),this.activate(sf));else{var p=parent||(p=this._group[key])&&p.tuple;parent=pulse.dataflow;sf=new Subflow(pulse.fork(pulse.NO_SOURCE),this);parent.add(sf).connect(flow(parent,\nkey,p));flows[key]=sf;this.activate(sf)}return sf},clean:function(){var flows=this.value,key;for(key in flows)if(0===flows[key].count){var detach=flows[key].detachSubflow;detach&&detach();delete flows[key]}},initTargets:function(){for(var a=this._targets,n=a.length,i=0;i<n&&null!=a[i];++i)a[i]=null;a.active=0},transform:function(_,pulse){var $jscomp$this=this,df=pulse.dataflow,key$jscomp$0=_.key,flow=_.subflow,cache=this._keys,rekey=_.modified(\"key\"),subflow=function(key){return $jscomp$this.subflow(key,\nflow,pulse)};this._group=_.group||{};this.initTargets();pulse.visit(pulse.REM,function(t){var id=vegaDataflow.tupleid(t),k=cache.get(id);void 0!==k&&(cache.delete(id),subflow(k).rem(t))});pulse.visit(pulse.ADD,function(t){var k=key$jscomp$0(t);cache.set(vegaDataflow.tupleid(t),k);subflow(k).add(t)});rekey||pulse.modified(key$jscomp$0.fields)?pulse.visit(pulse.MOD,function(t){var id=vegaDataflow.tupleid(t),k0=cache.get(id),k1=key$jscomp$0(t);k0===k1?subflow(k1).mod(t):(cache.set(id,k1),subflow(k0).rem(t),\nsubflow(k1).add(t))}):pulse.changed(pulse.MOD)&&pulse.visit(pulse.MOD,function(t){subflow(cache.get(vegaDataflow.tupleid(t))).mod(t)});rekey&&pulse.visit(pulse.REFLOW,function(t){var id=vegaDataflow.tupleid(t),k0=cache.get(id),k1=key$jscomp$0(t);k0!==k1&&(cache.set(id,k1),subflow(k0).rem(t),subflow(k1).add(t))});pulse.clean()?df.runAfter(function(){$jscomp$this.clean();cache.clean()}):cache.empty>df.cleanThreshold&&df.runAfter(cache.clean);return pulse}});vegaUtil.inherits(Field,vegaDataflow.Operator);\nFilter.Definition={type:\"Filter\",metadata:{changes:!0},params:[{name:\"expr\",type:\"expr\",required:!0}]};vegaUtil.inherits(Filter,vegaDataflow.Transform,{transform:function(_,pulse){function revisit(t){var id=vegaDataflow.tupleid(t),b=test(t,_),s=cache.get(id);b&&s?(cache.delete(id),add.push(t)):b||s?isMod&&b&&!s&&mod.push(t):(cache.set(id,1),rem.push(t))}var df=pulse.dataflow,cache=this.value,output=pulse.fork(),add=output.add,rem=output.rem,mod=output.mod,test=_.expr,isMod=!0;pulse.visit(pulse.REM,\nfunction(t){var id=vegaDataflow.tupleid(t);cache.has(id)?cache.delete(id):rem.push(t)});pulse.visit(pulse.ADD,function(t){test(t,_)?add.push(t):cache.set(vegaDataflow.tupleid(t),1)});pulse.visit(pulse.MOD,revisit);_.modified()&&(isMod=!1,pulse.visit(pulse.REFLOW,revisit));cache.empty>df.cleanThreshold&&df.runAfter(cache.clean);return output}});Flatten.Definition={type:\"Flatten\",metadata:{generates:!0},params:[{name:\"fields\",type:\"field\",array:!0,required:!0},{name:\"index\",type:\"string\"},{name:\"as\",\ntype:\"string\",array:!0}]};vegaUtil.inherits(Flatten,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.NO_SOURCE),fields=_.fields,as=fieldNames(fields,_.as||[]),index=_.index||null,m=as.length;out.rem=this.value;pulse.visit(pulse.SOURCE,function(t){for(var arrays=fields.map(function(f){return f(t)}),maxlen=arrays.reduce(function(l,a){return Math.max(l,a.length)},0),i=0,j,d,v;i<maxlen;++i){d=vegaDataflow.derive(t);for(j=0;j<m;++j)d[as[j]]=null==(v=arrays[j][i])?null:v;index&&\n(d[index]=i);out.add.push(d)}});this.value=out.source=out.add;index&&out.modifies(index);return out.modifies(as)}});Fold.Definition={type:\"Fold\",metadata:{generates:!0},params:[{name:\"fields\",type:\"field\",array:!0,required:!0},{name:\"as\",type:\"string\",array:!0,length:2,\"default\":[\"key\",\"value\"]}]};vegaUtil.inherits(Fold,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.NO_SOURCE),fields=_.fields,fnames=fields.map(vegaUtil.accessorName);_=_.as||[\"key\",\"value\"];var k=_[0],\nv=_[1],n=fields.length;out.rem=this.value;pulse.visit(pulse.SOURCE,function(t){for(var i=0,d;i<n;++i)d=vegaDataflow.derive(t),d[k]=fnames[i],d[v]=fields[i](t),out.add.push(d)});this.value=out.source=out.add;return out.modifies(_)}});Formula.Definition={type:\"Formula\",metadata:{modifies:!0},params:[{name:\"expr\",type:\"expr\",required:!0},{name:\"as\",type:\"string\",required:!0},{name:\"initonly\",type:\"boolean\"}]};vegaUtil.inherits(Formula,vegaDataflow.Transform,{transform:function(_,pulse){var func=_.expr,\nas=_.as,mod=_.modified(),flag=_.initonly?pulse.ADD:mod?pulse.SOURCE:pulse.modified(func.fields)||pulse.modified(as)?pulse.ADD_MOD:pulse.ADD;mod&&(pulse=pulse.materialize().reflow(!0));_.initonly||pulse.modifies(as);return pulse.visit(flag,function(t){return t[as]=func(t,_)})}});vegaUtil.inherits(Generate,vegaDataflow.Transform,{transform:function(_,pulse){pulse=pulse.fork(pulse.ALL);var gen=_.generator,data=this.value,num=_.size-data.length,add,t;if(0<num){for(add=[];0<=--num;)add.push(t=vegaDataflow.ingest(gen(_))),\ndata.push(t);pulse.add=pulse.add.length?pulse.materialize(pulse.ADD).add.concat(add):add}else _=data.slice(0,-num),pulse.rem=pulse.rem.length?pulse.materialize(pulse.REM).rem.concat(_):_,data=data.slice(-num);pulse.source=this.value=data;return pulse}});var Methods={value:\"value\",median:d3Array.median,mean:d3Array.mean,min:d3Array.min,max:d3Array.max},Empty=[];Impute.Definition={type:\"Impute\",metadata:{changes:!0},params:[{name:\"field\",type:\"field\",required:!0},{name:\"key\",type:\"field\",required:!0},\n{name:\"keyvals\",array:!0},{name:\"groupby\",type:\"field\",array:!0},{name:\"method\",type:\"enum\",\"default\":\"value\",values:[\"value\",\"mean\",\"median\",\"max\",\"min\"]},{name:\"value\",\"default\":0}]};vegaUtil.inherits(Impute,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.ALL),impute=getValue(_),field=getField(_),fName=vegaUtil.accessorName(_.field),kName=vegaUtil.accessorName(_.key),gNames=(_.groupby||[]).map(vegaUtil.accessorName);_=partition$1(pulse.source,_.groupby,_.key,_.keyvals);\npulse=[];var prev=this.value,m=_.domain.length,j,l,n;var g=0;for(l=_.length;g<l;++g){var group=_[g];var gVals=group.values;var value=NaN;for(j=0;j<m;++j)if(null==group[j]){var kVal=_.domain[j];var t={_impute:!0};var i=0;for(n=gVals.length;i<n;++i)t[gNames[i]]=gVals[i];t[kName]=kVal;t[fName]=Number.isNaN(value)?value=impute(group,field):value;pulse.push(vegaDataflow.ingest(t))}}pulse.length&&(out.add=out.materialize(out.ADD).add.concat(pulse));prev.length&&(out.rem=out.materialize(out.REM).rem.concat(prev));\nthis.value=pulse;return out}});JoinAggregate.Definition={type:\"JoinAggregate\",metadata:{modifies:!0},params:[{name:\"groupby\",type:\"field\",array:!0},{name:\"fields\",type:\"field\",\"null\":!0,array:!0},{name:\"ops\",type:\"enum\",array:!0,values:noop},{name:\"as\",type:\"string\",\"null\":!0,array:!0},{name:\"key\",type:\"field\"}]};vegaUtil.inherits(JoinAggregate,Aggregate,{transform:function(_,pulse){var aggr=this,mod=_.modified();if(aggr.value&&(mod||pulse.modified(aggr._inputs,!0))){var cells=aggr.value=mod?aggr.init(_):\n{};pulse.visit(pulse.SOURCE,function(t){return aggr.add(t)})}else cells=aggr.value=aggr.value||this.init(_),pulse.visit(pulse.REM,function(t){return aggr.rem(t)}),pulse.visit(pulse.ADD,function(t){return aggr.add(t)});aggr.changes();pulse.visit(pulse.SOURCE,function(t){vegaUtil.extend(t,cells[aggr.cellkey(t)].tuple)});return pulse.reflow(mod).modifies(this._outputs)},changes:function(){var adds=this._adds,mods=this._mods,n;var i=0;for(n=this._alen;i<n;++i)this.celltuple(adds[i]),adds[i]=null;i=0;\nfor(n=this._mlen;i<n;++i)this.celltuple(mods[i]),mods[i]=null;this._alen=this._mlen=0}});KDE.Definition={type:\"KDE\",metadata:{generates:!0},params:[{name:\"groupby\",type:\"field\",array:!0},{name:\"field\",type:\"field\",required:!0},{name:\"cumulative\",type:\"boolean\",\"default\":!1},{name:\"counts\",type:\"boolean\",\"default\":!1},{name:\"bandwidth\",type:\"number\",\"default\":0},{name:\"extent\",type:\"number\",array:!0,length:2},{name:\"resolve\",type:\"enum\",values:[\"shared\",\"independent\"],\"default\":\"independent\"},{name:\"steps\",\ntype:\"number\"},{name:\"minsteps\",type:\"number\",\"default\":25},{name:\"maxsteps\",type:\"number\",\"default\":200},{name:\"as\",type:\"string\",array:!0,\"default\":[\"value\",\"density\"]}]};vegaUtil.inherits(KDE,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);if(!this.value||pulse.changed()||_.modified()){pulse=pulse.materialize(pulse.SOURCE).source;var groups=partition(pulse,_.groupby,_.field),names=(_.groupby||[]).map(vegaUtil.accessorName),bandwidth=_.bandwidth,\nmethod=_.cumulative?\"cdf\":\"pdf\",as=_.as||[\"value\",\"density\"],values=[],domain=_.extent,minsteps=_.steps||_.minsteps||25,maxsteps=_.steps||_.maxsteps||200;\"pdf\"!==method&&\"cdf\"!==method&&vegaUtil.error(\"Invalid density method: \"+method);\"shared\"===_.resolve&&(domain||(domain=vegaUtil.extent(pulse,_.field)),minsteps=maxsteps=_.steps||maxsteps);groups.forEach(function(g){var density=vegaStatistics.randomKDE(g,bandwidth)[method],scale=_.counts?g.length:1,local=domain||vegaUtil.extent(g);vegaStatistics.sampleCurve(density,\nlocal,minsteps,maxsteps).forEach(function(v){for(var t={},i=0;i<names.length;++i)t[names[i]]=g.dims[i];t[as[0]]=v[0];t[as[1]]=v[1]*scale;values.push(vegaDataflow.ingest(t))})});this.value&&(out.rem=this.value);this.value=out.add=out.source=values}return out}});vegaUtil.inherits(Key,vegaDataflow.Operator);vegaUtil.inherits(Load,vegaDataflow.Transform,{transform:function(_,pulse){var $jscomp$this=this,df$jscomp$0=pulse.dataflow;return this._pending?output$jscomp$0(this,pulse,this._pending):stop$jscomp$0(_)?\npulse.StopPropagation:_.values?output$jscomp$0(this,pulse,df$jscomp$0.parse(_.values,_.format)):_.async?{async:df$jscomp$0.request(_.url,_.format).then(function(res){$jscomp$this._pending=vegaUtil.array(res.data);return function(df){return df.touch($jscomp$this)}})}:df$jscomp$0.request(_.url,_.format).then(function(res){return output$jscomp$0($jscomp$this,pulse,vegaUtil.array(res.data))})}});Lookup.Definition={type:\"Lookup\",metadata:{modifies:!0},params:[{name:\"index\",type:\"index\",params:[{name:\"from\",\ntype:\"data\",required:!0},{name:\"key\",type:\"field\",required:!0}]},{name:\"values\",type:\"field\",array:!0},{name:\"fields\",type:\"field\",array:!0,required:!0},{name:\"as\",type:\"string\",array:!0},{name:\"default\",\"default\":null}]};vegaUtil.inherits(Lookup,vegaDataflow.Transform,{transform:function(_,pulse){var keys=_.fields,index=_.index,values=_.values,defaultValue=null==_.default?null:_.default,reset=_.modified(),n=keys.length,flag=reset?pulse.SOURCE:pulse.ADD,out=pulse,as=_.as;if(values){var m=values.length;\n1<n&&!as&&vegaUtil.error('Multi-field lookup requires explicit \"as\" parameter.');as&&as.length!==n*m&&vegaUtil.error('The \"as\" parameter has too few output field names.');as=as||values.map(vegaUtil.accessorName);_=function(t){for(var i=0,k=0,j,v;i<n;++i)if(v=index.get(keys[i](t)),null==v)for(j=0;j<m;++j,++k)t[as[k]]=defaultValue;else for(j=0;j<m;++j,++k)t[as[k]]=values[j](v)}}else as||vegaUtil.error(\"Missing output field names.\"),_=function(t){for(var i=0,v;i<n;++i)v=index.get(keys[i](t)),t[as[i]]=\nnull==v?defaultValue:v};reset?out=pulse.reflow(!0):(reset=keys.some(function(k){return pulse.modified(k.fields)}),flag|=reset?pulse.MOD:0);pulse.visit(flag,_);return out.modifies(as)}});vegaUtil.inherits(MultiExtent,vegaDataflow.Operator);vegaUtil.inherits(MultiValues,vegaDataflow.Operator);vegaUtil.inherits(Params,vegaDataflow.Transform,{transform:function(_,pulse){this.modified(_.modified());this.value=_;return pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS)}});Pivot.Definition={type:\"Pivot\",metadata:{generates:!0,\nchanges:!0},params:[{name:\"groupby\",type:\"field\",array:!0},{name:\"field\",type:\"field\",required:!0},{name:\"value\",type:\"field\",required:!0},{name:\"op\",type:\"enum\",values:noop,\"default\":\"sum\"},{name:\"limit\",type:\"number\",\"default\":0},{name:\"key\",type:\"field\"}]};vegaUtil.inherits(Pivot,Aggregate,{_transform:Aggregate.prototype.transform,transform:function(_,pulse){return this._transform(aggregateParams(_,pulse),pulse)}});vegaUtil.inherits(PreFacet,Facet,{transform:function(_$jscomp$0,pulse){var $jscomp$this=\nthis,flow=_$jscomp$0.subflow,field=_$jscomp$0.field,subflow=function(t){return $jscomp$this.subflow(vegaDataflow.tupleid(t),flow,pulse,t)};(_$jscomp$0.modified(\"field\")||field&&pulse.modified(vegaUtil.accessorFields(field)))&&vegaUtil.error(\"PreFacet does not support field modification.\");this.initTargets();field?(pulse.visit(pulse.MOD,function(t){var sf=subflow(t);field(t).forEach(function(_){return sf.mod(_)})}),pulse.visit(pulse.ADD,function(t){var sf=subflow(t);field(t).forEach(function(_){return sf.add(vegaDataflow.ingest(_))})}),\npulse.visit(pulse.REM,function(t){var sf=subflow(t);field(t).forEach(function(_){return sf.rem(_)})})):(pulse.visit(pulse.MOD,function(t){return subflow(t).mod(t)}),pulse.visit(pulse.ADD,function(t){return subflow(t).add(t)}),pulse.visit(pulse.REM,function(t){return subflow(t).rem(t)}));pulse.clean()&&pulse.runAfter(function(){return $jscomp$this.clean()});return pulse}});Project.Definition={type:\"Project\",metadata:{generates:!0,changes:!0},params:[{name:\"fields\",type:\"field\",array:!0},{name:\"as\",\ntype:\"string\",\"null\":!0,array:!0}]};vegaUtil.inherits(Project,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.NO_SOURCE),fields=_.fields,as=fieldNames(_.fields,_.as||[]),derive=fields?function(s,t){for(var i=0,n=fields.length;i<n;++i)t[as[i]]=fields[i](s);return t}:vegaDataflow.rederive;if(this.value)var lut=this.value;else pulse=pulse.addAll(),lut=this.value={};pulse.visit(pulse.REM,function(t){t=vegaDataflow.tupleid(t);out.rem.push(lut[t]);lut[t]=null});pulse.visit(pulse.ADD,\nfunction(t){var dt=derive(t,vegaDataflow.ingest({}));lut[vegaDataflow.tupleid(t)]=dt;out.add.push(dt)});pulse.visit(pulse.MOD,function(t){out.mod.push(derive(t,lut[vegaDataflow.tupleid(t)]))});return out}});vegaUtil.inherits(Proxy,vegaDataflow.Transform,{transform:function(_,pulse){this.value=_.value;return _.modified(\"value\")?pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS):pulse.StopPropagation}});Quantile.Definition={type:\"Quantile\",metadata:{generates:!0,changes:!0},params:[{name:\"groupby\",type:\"field\",\narray:!0},{name:\"field\",type:\"field\",required:!0},{name:\"probs\",type:\"number\",array:!0},{name:\"step\",type:\"number\",\"default\":.01},{name:\"as\",type:\"string\",array:!0,\"default\":[\"prob\",\"value\"]}]};vegaUtil.inherits(Quantile,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),as=_.as||[\"prob\",\"value\"];if(this.value&&!_.modified()&&!pulse.changed())return out.source=this.value,out;pulse=pulse.materialize(pulse.SOURCE).source;pulse=partition(pulse,_.groupby,\n_.field);var names=(_.groupby||[]).map(vegaUtil.accessorName),values=[],step=_.step||.01,p=_.probs||d3Array.range(step/2,1-1E-14,step),n=p.length;pulse.forEach(function(g){for(var q=vegaStatistics.quantiles(g,p),i=0;i<n;++i){for(var t={},i$323=0;i$323<names.length;++i$323)t[names[i$323]]=g.dims[i$323];t[as[0]]=p[i];t[as[1]]=q[i];values.push(vegaDataflow.ingest(t))}});this.value&&(out.rem=this.value);this.value=out.add=out.source=values;return out}});vegaUtil.inherits(Relay,vegaDataflow.Transform,\n{transform:function(_,pulse){if(this.value)var lut=this.value;else{var out=pulse=pulse.addAll();lut=this.value={}}_.derive&&(out=pulse.fork(pulse.NO_SOURCE),pulse.visit(pulse.REM,function(t){t=vegaDataflow.tupleid(t);out.rem.push(lut[t]);lut[t]=null}),pulse.visit(pulse.ADD,function(t){var dt=vegaDataflow.derive(t);lut[vegaDataflow.tupleid(t)]=dt;out.add.push(dt)}),pulse.visit(pulse.MOD,function(t){var dt=lut[vegaDataflow.tupleid(t)],k;for(k in t)dt[k]=t[k],out.modifies(k);out.mod.push(dt)}));return out}});\nSample.Definition={type:\"Sample\",metadata:{},params:[{name:\"size\",type:\"number\",\"default\":1E3}]};vegaUtil.inherits(Sample,vegaDataflow.Transform,{transform:function(_,pulse){function update(t){if(res.length<num)res.push(t);else{var idx=~~((cnt+1)*vegaStatistics.random());if(idx<res.length&&idx>=cap){var p=res[idx];map[vegaDataflow.tupleid(p)]&&out.rem.push(p);res[idx]=t}}++cnt}var out=pulse.fork(pulse.NO_SOURCE),mod=_.modified(\"size\"),num=_.size,map=this.value.reduce(function(m,t){return m[vegaDataflow.tupleid(t)]=\n1,m},{}),res=this.value,cnt=this.count,cap=0;pulse.rem.length&&(pulse.visit(pulse.REM,function(t){var id=vegaDataflow.tupleid(t);map[id]&&(map[id]=-1,out.rem.push(t));--cnt}),res=res.filter(function(t){return-1!==map[vegaDataflow.tupleid(t)]}));(pulse.rem.length||mod)&&res.length<num&&pulse.source&&(cap=cnt=res.length,pulse.visit(pulse.SOURCE,function(t){map[vegaDataflow.tupleid(t)]||update(t)}),cap=-1);if(mod&&res.length>num){_=res.length-num;for(mod=0;mod<_;++mod)map[vegaDataflow.tupleid(res[mod])]=\n-1,out.rem.push(res[mod]);res=res.slice(_)}pulse.mod.length&&pulse.visit(pulse.MOD,function(t){map[vegaDataflow.tupleid(t)]&&out.mod.push(t)});pulse.add.length&&pulse.visit(pulse.ADD,update);if(pulse.add.length||0>cap)out.add=res.filter(function(t){return!map[vegaDataflow.tupleid(t)]});this.count=cnt;this.value=out.source=res;return out}});Sequence.Definition={type:\"Sequence\",metadata:{generates:!0,changes:!0},params:[{name:\"start\",type:\"number\",required:!0},{name:\"stop\",type:\"number\",required:!0},\n{name:\"step\",type:\"number\",\"default\":1},{name:\"as\",type:\"string\",\"default\":\"data\"}]};vegaUtil.inherits(Sequence,vegaDataflow.Transform,{transform:function(_,pulse){if(!this.value||_.modified()){var out=pulse.materialize().fork(pulse.MOD),as=_.as||\"data\";out.rem=this.value?pulse.rem.concat(this.value):pulse.rem;this.value=d3Array.range(_.start,_.stop,_.step||1).map(function(v){var t={};t[as]=v;return vegaDataflow.ingest(t)});out.add=pulse.add.concat(this.value);return out}}});vegaUtil.inherits(Sieve,\nvegaDataflow.Transform,{transform:function(_,pulse){this.value=pulse.source;return pulse.changed()?pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS):pulse.StopPropagation}});var OUTPUT=[\"unit0\",\"unit1\"];TimeUnit.Definition={type:\"TimeUnit\",metadata:{modifies:!0},params:[{name:\"field\",type:\"field\",required:!0},{name:\"interval\",type:\"boolean\",\"default\":!0},{name:\"units\",type:\"enum\",values:vegaTime.TIME_UNITS,array:!0},{name:\"step\",type:\"number\",\"default\":1},{name:\"maxbins\",type:\"number\",\"default\":40},{name:\"extent\",\ntype:\"date\",array:!0},{name:\"timezone\",type:\"enum\",\"default\":\"local\",values:[\"local\",\"utc\"]},{name:\"as\",type:\"string\",array:!0,length:2,\"default\":OUTPUT}]};vegaUtil.inherits(TimeUnit,vegaDataflow.Transform,{transform:function(_,pulse){var field=_.field,band=!1!==_.interval,utc=\"utc\"===_.timezone,floor=this._floor(_,pulse),offset=(utc?vegaTime.utcInterval:vegaTime.timeInterval)(floor.unit).offset;utc=_.as||OUTPUT;var u0=utc[0],u1=utc[1],step=floor.step,min=floor.start||Infinity,max=floor.stop||-Infinity,\nflag=pulse.ADD;if(_.modified()||pulse.modified(vegaUtil.accessorFields(field)))pulse=pulse.reflow(!0),flag=pulse.SOURCE,min=Infinity,max=-Infinity;pulse.visit(flag,function(t){var v=field(t),b;null==v?(t[u0]=null,band&&(t[u1]=null)):(t[u0]=v=b=floor(v),band&&(t[u1]=b=offset(v,step)),v<min&&(min=v),b>max&&(max=b))});floor.start=min;floor.stop=max;return pulse.modifies(band?utc:u0)},_floor:function(_,pulse){var utc=\"utc\"===_.timezone;pulse=_.units?{units:_.units,step:_.step||1}:vegaTime.timeBin({extent:_.extent||\nvegaUtil.extent(pulse.materialize(pulse.SOURCE).source,_.field),maxbins:_.maxbins});_=pulse.step;pulse=vegaTime.timeUnits(pulse.units);var prev=this.value||{};utc=(utc?vegaTime.utcFloor:vegaTime.timeFloor)(pulse,_);utc.unit=vegaUtil.peek(pulse);utc.units=pulse;utc.step=_;utc.start=prev.start;utc.stop=prev.stop;return this.value=utc}});vegaUtil.inherits(TupleIndex,vegaDataflow.Transform,{transform:function(_,pulse){var df=pulse.dataflow,field=_.field,index=this.value,set=function(t){return index.set(field(t),\nt)},mod=!0;_.modified(\"field\")||pulse.modified(field.fields)?(index.clear(),pulse.visit(pulse.SOURCE,set)):pulse.changed()?(pulse.visit(pulse.REM,function(t){return index.delete(field(t))}),pulse.visit(pulse.ADD,set)):mod=!1;this.modified(mod);index.empty>df.cleanThreshold&&df.runAfter(index.clean);return pulse.fork()}});vegaUtil.inherits(Values,vegaDataflow.Transform,{transform:function(_,pulse){if(!this.value||_.modified(\"field\")||_.modified(\"sort\")||pulse.changed()||_.sort&&pulse.modified(_.sort.fields))this.value=\n(_.sort?pulse.source.slice().sort(vegaDataflow.stableCompare(_.sort)):pulse.source).map(_.field)}});var WindowOps={row_number:function(){return{next:function(w){return w.index+1}}},rank:function(){var rank;return{init:function(){return rank=1},next:function(w){var i=w.index,data=w.data;return i&&w.compare(data[i-1],data[i])?rank=i+1:rank}}},dense_rank:function(){var drank;return{init:function(){return drank=1},next:function(w){var i=w.index,d=w.data;return i&&w.compare(d[i-1],d[i])?++drank:drank}}},\npercent_rank:function(){var rank=WindowOps.rank(),next=rank.next;return{init:rank.init,next:function(w){return(next(w)-1)/(w.data.length-1)}}},cume_dist:function(){var cume;return{init:function(){return cume=0},next:function(w){var d=w.data,c=w.compare;w=w.index;if(cume<w){for(;w+1<d.length&&!c(d[w],d[w+1]);)++w;cume=w}return(1+cume)/d.length}}},ntile:function(field,num){num=+num;0<num||vegaUtil.error(\"ntile num must be greater than zero.\");field=WindowOps.cume_dist();var next=field.next;return{init:field.init,\nnext:function(w){return Math.ceil(num*next(w))}}},lag:function(field,offset){offset=+offset||1;return{next:function(w){var i=w.index-offset;return 0<=i?field(w.data[i]):null}}},lead:function(field,offset){offset=+offset||1;return{next:function(w){var i=w.index+offset;w=w.data;return i<w.length?field(w[i]):null}}},first_value:function(field){return{next:function(w){return field(w.data[w.i0])}}},last_value:function(field){return{next:function(w){return field(w.data[w.i1-1])}}},nth_value:function(field,\nnth){nth=+nth;0<nth||vegaUtil.error(\"nth_value nth must be greater than zero.\");return{next:function(w){var i=w.i0+(nth-1);return i<w.i1?field(w.data[i]):null}}},prev_value:function(field){var prev;return{init:function(){return prev=null},next:function(w){w=field(w.data[w.index]);return null!=w?prev=w:prev}}},next_value:function(field){var v,i;return{init:function(){return v=null,i=-1},next:function(w){var d=w.data;if(w.index<=i)d=v;else{a:{w=w.index;for(var n=d.length;w<n;++w)if(null!=field(d[w]))break a;\nw=-1}d=0>(i=w)?(i=d.length,v=null):v=field(d[i])}return d}}}};prototype=Object.keys(WindowOps);var prototype$1=WindowState.prototype;prototype$1.init=function(){this.windows.forEach(function(_){return _.init()});this.cell&&this.cell.init()};prototype$1.update=function(w,t){var cell=this.cell,wind=this.windows,data=w.data,m=wind&&wind.length,j;if(cell){for(j=w.p0;j<w.i0;++j)cell.rem(data[j]);for(j=w.p1;j<w.i1;++j)cell.add(data[j]);cell.set(t)}for(j=0;j<m;++j)wind[j].update(w,t)};Window.Definition=\n{type:\"Window\",metadata:{modifies:!0},params:[{name:\"sort\",type:\"compare\"},{name:\"groupby\",type:\"field\",array:!0},{name:\"ops\",type:\"enum\",array:!0,values:prototype.concat(noop)},{name:\"params\",type:\"number\",\"null\":!0,array:!0},{name:\"fields\",type:\"field\",\"null\":!0,array:!0},{name:\"as\",type:\"string\",\"null\":!0,array:!0},{name:\"frame\",type:\"number\",\"null\":!0,array:!0,length:2,\"default\":[null,0]},{name:\"ignorePeers\",type:\"boolean\",\"default\":!1}]};vegaUtil.inherits(Window,vegaDataflow.Transform,{transform:function(_,\npulse){var $jscomp$this=this;this.stamp=pulse.stamp;var mod=_.modified(),cmp=vegaDataflow.stableCompare(_.sort),key=groupkey(_.groupby),state=this.state;if(!state||mod)state=this.state=new WindowState(_);mod||pulse.modified(state.inputs)?(this.value={},pulse.visit(pulse.SOURCE,function(t){return $jscomp$this.group(key(t)).add(t)})):(pulse.visit(pulse.REM,function(t){return $jscomp$this.group(key(t)).remove(t)}),pulse.visit(pulse.ADD,function(t){return $jscomp$this.group(key(t)).add(t)}));for(var i=\n0,n=this._mlen;i<n;++i)processPartition(this._mods[i],state,cmp,_);this._mlen=0;this._mods=[];return pulse.reflow(mod).modifies(state.outputs)},group:function(key){var group=this.value[key];group||(group=this.value[key]=SortedList(vegaDataflow.tupleid),group.stamp=-1);group.stamp<this.stamp&&(group.stamp=this.stamp,this._mods[this._mlen++]=group);return group}});exports.aggregate=Aggregate;exports.bin=Bin;exports.collect=Collect;exports.compare=Compare;exports.countpattern=CountPattern;exports.cross=\nCross;exports.density=Density;exports.dotbin=DotBin;exports.expression=Expression;exports.extent=Extent;exports.facet=Facet;exports.field=Field;exports.filter=Filter;exports.flatten=Flatten;exports.fold=Fold;exports.formula=Formula;exports.generate=Generate;exports.impute=Impute;exports.joinaggregate=JoinAggregate;exports.kde=KDE;exports.key=Key;exports.load=Load;exports.lookup=Lookup;exports.multiextent=MultiExtent;exports.multivalues=MultiValues;exports.params=Params;exports.pivot=Pivot;exports.prefacet=\nPreFacet;exports.project=Project;exports.proxy=Proxy;exports.quantile=Quantile;exports.relay=Relay;exports.sample=Sample;exports.sequence=Sequence;exports.sieve=Sieve;exports.subflow=Subflow;exports.timeunit=TimeUnit;exports.tupleindex=TupleIndex;exports.values=Values;exports.window=Window;Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_transforms$build$vega_transforms\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-dataflow'), require('vega-statistics'), require('d3-array'), require('vega-time')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-dataflow', 'vega-statistics', 'd3-array', 'vega-time'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.vega, global.d3, global.vega));\n}(this, (function (exports, vegaUtil, vegaDataflow, vegaStatistics, d3Array, vegaTime) { 'use strict';\n\n  function multikey(f) {\n    return x => {\n      const n = f.length;\n      let i = 1,\n          k = String(f[0](x));\n\n      for (; i<n; ++i) {\n        k += '|' + f[i](x);\n      }\n\n      return k;\n    };\n  }\n\n  function groupkey(fields) {\n    return !fields || !fields.length ? function() { return ''; }\n      : fields.length === 1 ? fields[0]\n      : multikey(fields);\n  }\n\n  function measureName(op, field, as) {\n    return as || (op + (!field ? '' : '_' + field));\n  }\n\n  const noop = () => {};\n\n  const base_op = {\n    init: noop,\n    add:  noop,\n    rem:  noop,\n    idx:  0\n  };\n\n  const AggregateOps = {\n    values: {\n      init:  m => m.cell.store = true,\n      value: m => m.cell.data.values(),\n      idx:  -1\n    },\n    count: {\n      value: m => m.cell.num\n    },\n    __count__: {\n      value: m => m.missing + m.valid\n    },\n    missing: {\n      value: m => m.missing\n    },\n    valid: {\n      value: m => m.valid\n    },\n    sum: {\n      init:  m => m.sum = 0,\n      value: m => m.sum,\n      add:  (m, v) => m.sum += +v,\n      rem:  (m, v) => m.sum -= v\n    },\n    product: {\n      init:  m => m.product = 1,\n      value: m => m.valid ? m.product : undefined,\n      add:  (m, v) => m.product *= v,\n      rem:  (m, v) => m.product /= v\n    },\n    mean: {\n      init:  m => m.mean = 0,\n      value: m => m.valid ? m.mean : undefined,\n      add:  (m, v) => (m.mean_d = v - m.mean, m.mean += m.mean_d / m.valid),\n      rem:  (m, v) => (m.mean_d = v - m.mean, m.mean -= m.valid ? m.mean_d / m.valid : m.mean)\n    },\n    average: {\n      value: m => m.valid ? m.mean : undefined,\n      req:  ['mean'], idx: 1\n    },\n    variance: {\n      init:  m => m.dev = 0,\n      value: m => m.valid > 1 ? m.dev / (m.valid - 1) : undefined,\n      add:  (m, v) => m.dev += m.mean_d * (v - m.mean),\n      rem:  (m, v) => m.dev -= m.mean_d * (v - m.mean),\n      req:  ['mean'], idx: 1\n    },\n    variancep: {\n      value: m => m.valid > 1 ? m.dev / m.valid : undefined,\n      req:  ['variance'], idx: 2\n    },\n    stdev: {\n      value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid - 1)) : undefined,\n      req:  ['variance'], idx: 2\n    },\n    stdevp: {\n      value: m => m.valid > 1 ? Math.sqrt(m.dev / m.valid) : undefined,\n      req:  ['variance'], idx: 2\n    },\n    stderr: {\n      value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid * (m.valid - 1))) : undefined,\n      req:  ['variance'], idx: 2\n    },\n    distinct: {\n      value: m => m.cell.data.distinct(m.get),\n      req:  ['values'], idx: 3\n    },\n    ci0: {\n      value: m => m.cell.data.ci0(m.get),\n      req:  ['values'], idx: 3\n    },\n    ci1: {\n      value: m => m.cell.data.ci1(m.get),\n      req:  ['values'], idx: 3\n    },\n    median: {\n      value: m => m.cell.data.q2(m.get),\n      req:  ['values'], idx: 3\n    },\n    q1: {\n      value: m => m.cell.data.q1(m.get),\n      req: ['values'], idx: 3\n    },\n    q3: {\n      value: m => m.cell.data.q3(m.get),\n      req:  ['values'], idx: 3\n    },\n    min: {\n      init:  m => m.min = undefined,\n      value: m => m.min = (Number.isNaN(m.min) ? m.cell.data.min(m.get) : m.min),\n      add:  (m, v) => { if (v < m.min || m.min === undefined) m.min = v; },\n      rem:  (m, v) => { if (v <= m.min) m.min = NaN; },\n      req:  ['values'], idx: 4\n    },\n    max: {\n      init:  m => m.max = undefined,\n      value: m => m.max = (Number.isNaN(m.max) ? m.cell.data.max(m.get) : m.max),\n      add:  (m, v) => { if (v > m.max || m.max === undefined) m.max = v; },\n      rem:  (m, v) => { if (v >= m.max) m.max = NaN; },\n      req:  ['values'], idx: 4\n    },\n    argmin: {\n      init:  m => m.argmin = undefined,\n      value: m => m.argmin || m.cell.data.argmin(m.get),\n      add:  (m, v, t) => { if (v < m.min) m.argmin = t; },\n      rem:  (m, v) => { if (v <= m.min) m.argmin = undefined; },\n      req:  ['min', 'values'], idx: 3\n    },\n    argmax: {\n      init:  m => m.argmax = undefined,\n      value: m => m.argmax || m.cell.data.argmax(m.get),\n      add:  (m, v, t) => { if (v > m.max) m.argmax = t; },\n      rem:  (m, v) => { if (v >= m.max) m.argmax = undefined; },\n      req:  ['max', 'values'], idx: 3\n    }\n  };\n\n  const ValidAggregateOps = Object.keys(AggregateOps);\n\n  function measure(key, value) {\n    return out => vegaUtil.extend({\n      name: key,\n      out: out || key\n    }, base_op, value);\n  }\n\n  ValidAggregateOps.forEach(key => {\n    AggregateOps[key] = measure(key, AggregateOps[key]);\n  });\n\n  function createMeasure(op, name) {\n    return AggregateOps[op](name);\n  }\n\n  function compareIndex(a, b) {\n    return a.idx - b.idx;\n  }\n\n  function resolve(agg) {\n    const map = {};\n    agg.forEach(a => map[a.name] = a);\n\n    const getreqs = a => {\n      if (!a.req) return;\n      a.req.forEach(key => {\n        if (!map[key]) getreqs(map[key] = AggregateOps[key]());\n      });\n    };\n    agg.forEach(getreqs);\n\n    return Object.values(map).sort(compareIndex);\n  }\n\n  function init() {\n    this.valid = 0;\n    this.missing = 0;\n    this._ops.forEach(op => op.init(this));\n  }\n\n  function add(v, t) {\n    if (v == null || v === '') { ++this.missing; return; }\n    if (v !== v) return;\n    ++this.valid;\n    this._ops.forEach(op => op.add(this, v, t));\n  }\n\n  function rem(v, t) {\n    if (v == null || v === '') { --this.missing; return; }\n    if (v !== v) return;\n    --this.valid;\n    this._ops.forEach(op => op.rem(this, v, t));\n  }\n\n  function set(t) {\n    this._out.forEach(op => t[op.out] = op.value(this));\n    return t;\n  }\n\n  function compileMeasures(agg, field) {\n    const get = field || vegaUtil.identity,\n          ops = resolve(agg),\n          out = agg.slice().sort(compareIndex);\n\n    function ctr(cell) {\n      this._ops = ops;\n      this._out = out;\n      this.cell = cell;\n      this.init();\n    }\n\n    ctr.prototype.init = init;\n    ctr.prototype.add = add;\n    ctr.prototype.rem = rem;\n    ctr.prototype.set = set;\n    ctr.prototype.get = get;\n    ctr.fields = agg.map(op => op.out);\n\n    return ctr;\n  }\n\n  function TupleStore(key) {\n    this._key = key ? vegaUtil.field(key) : vegaDataflow.tupleid;\n    this.reset();\n  }\n\n  const prototype = TupleStore.prototype;\n\n  prototype.reset = function() {\n    this._add = [];\n    this._rem = [];\n    this._ext = null;\n    this._get = null;\n    this._q = null;\n  };\n\n  prototype.add = function(v) {\n    this._add.push(v);\n  };\n\n  prototype.rem = function(v) {\n    this._rem.push(v);\n  };\n\n  prototype.values = function() {\n    this._get = null;\n    if (this._rem.length === 0) return this._add;\n\n    const a = this._add,\n          r = this._rem,\n          k = this._key,\n          n = a.length,\n          m = r.length,\n          x = Array(n - m),\n          map = {};\n    let i, j, v;\n\n    // use unique key field to clear removed values\n    for (i=0; i<m; ++i) {\n      map[k(r[i])] = 1;\n    }\n    for (i=0, j=0; i<n; ++i) {\n      if (map[k(v = a[i])]) {\n        map[k(v)] = 0;\n      } else {\n        x[j++] = v;\n      }\n    }\n\n    this._rem = [];\n    return (this._add = x);\n  };\n\n  // memoizing statistics methods\n\n  prototype.distinct = function(get) {\n    const v = this.values(),\n          map = {};\n\n    let n = v.length,\n        count = 0, s;\n\n    while (--n >= 0) {\n      s = get(v[n]) + '';\n      if (!vegaUtil.hasOwnProperty(map, s)) {\n        map[s] = 1;\n        ++count;\n      }\n    }\n\n    return count;\n  };\n\n  prototype.extent = function(get) {\n    if (this._get !== get || !this._ext) {\n      const v = this.values(),\n            i = vegaUtil.extentIndex(v, get);\n      this._ext = [v[i[0]], v[i[1]]];\n      this._get = get;\n    }\n    return this._ext;\n  };\n\n  prototype.argmin = function(get) {\n    return this.extent(get)[0] || {};\n  };\n\n  prototype.argmax = function(get) {\n    return this.extent(get)[1] || {};\n  };\n\n  prototype.min = function(get) {\n    const m = this.extent(get)[0];\n    return m != null ? get(m) : undefined;\n  };\n\n  prototype.max = function(get) {\n    const m = this.extent(get)[1];\n    return m != null ? get(m) : undefined;\n  };\n\n  prototype.quartile = function(get) {\n    if (this._get !== get || !this._q) {\n      this._q = vegaStatistics.quartiles(this.values(), get);\n      this._get = get;\n    }\n    return this._q;\n  };\n\n  prototype.q1 = function(get) {\n    return this.quartile(get)[0];\n  };\n\n  prototype.q2 = function(get) {\n    return this.quartile(get)[1];\n  };\n\n  prototype.q3 = function(get) {\n    return this.quartile(get)[2];\n  };\n\n  prototype.ci = function(get) {\n    if (this._get !== get || !this._ci) {\n      this._ci = vegaStatistics.bootstrapCI(this.values(), 1000, 0.05, get);\n      this._get = get;\n    }\n    return this._ci;\n  };\n\n  prototype.ci0 = function(get) {\n    return this.ci(get)[0];\n  };\n\n  prototype.ci1 = function(get) {\n    return this.ci(get)[1];\n  };\n\n  /**\n   * Group-by aggregation operator.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n   * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.\n   * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.\n   * @param {Array<string>} [params.as] - An array of output field names for aggregated values.\n   * @param {boolean} [params.cross=false] - A flag indicating that the full\n   *   cross-product of groupby values should be generated, including empty cells.\n   *   If true, the drop parameter is ignored and empty cells are retained.\n   * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.\n   */\n  function Aggregate(params) {\n    vegaDataflow.Transform.call(this, null, params);\n\n    this._adds = []; // array of added output tuples\n    this._mods = []; // array of modified output tuples\n    this._alen = 0;  // number of active added tuples\n    this._mlen = 0;  // number of active modified tuples\n    this._drop = true;   // should empty aggregation cells be removed\n    this._cross = false; // produce full cross-product of group-by values\n\n    this._dims = [];   // group-by dimension accessors\n    this._dnames = []; // group-by dimension names\n\n    this._measures = []; // collection of aggregation monoids\n    this._countOnly = false; // flag indicating only count aggregation\n    this._counts = null; // collection of count fields\n    this._prev = null;   // previous aggregation cells\n\n    this._inputs = null;  // array of dependent input tuple field names\n    this._outputs = null; // array of output tuple field names\n  }\n\n  Aggregate.Definition = {\n    'type': 'Aggregate',\n    'metadata': {'generates': true, 'changes': true},\n    'params': [\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'ops', 'type': 'enum', 'array': true, 'values': ValidAggregateOps },\n      { 'name': 'fields', 'type': 'field', 'null': true, 'array': true },\n      { 'name': 'as', 'type': 'string', 'null': true, 'array': true },\n      { 'name': 'drop', 'type': 'boolean', 'default': true },\n      { 'name': 'cross', 'type': 'boolean', 'default': false },\n      { 'name': 'key', 'type': 'field' }\n    ]\n  };\n\n  vegaUtil.inherits(Aggregate, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const aggr = this,\n            out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n            mod = _.modified();\n\n      aggr.stamp = out.stamp;\n\n      if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\n        aggr._prev = aggr.value;\n        aggr.value = mod ? aggr.init(_) : {};\n        pulse.visit(pulse.SOURCE, t => aggr.add(t));\n      } else {\n        aggr.value = aggr.value || aggr.init(_);\n        pulse.visit(pulse.REM, t => aggr.rem(t));\n        pulse.visit(pulse.ADD, t => aggr.add(t));\n      }\n\n      // Indicate output fields and return aggregate tuples.\n      out.modifies(aggr._outputs);\n\n      // Should empty cells be dropped?\n      aggr._drop = _.drop !== false;\n\n      // If domain cross-product requested, generate empty cells as needed\n      // and ensure that empty cells are not dropped\n      if (_.cross && aggr._dims.length > 1) {\n        aggr._drop = false;\n        aggr.cross();\n      }\n\n      if (pulse.clean() && aggr._drop) {\n        out.clean(true).runAfter(() => this.clean());\n      }\n\n      return aggr.changes(out);\n    },\n\n    cross() {\n      const aggr = this,\n            curr = aggr.value,\n            dims = aggr._dnames,\n            vals = dims.map(() => ({})),\n            n = dims.length;\n\n      // collect all group-by domain values\n      function collect(cells) {\n        let key, i, t, v;\n        for (key in cells) {\n          t = cells[key].tuple;\n          for (i=0; i<n; ++i) {\n            vals[i][(v = t[dims[i]])] = v;\n          }\n        }\n      }\n      collect(aggr._prev);\n      collect(curr);\n\n      // iterate over key cross-product, create cells as needed\n      function generate(base, tuple, index) {\n        const name = dims[index],\n            v = vals[index++];\n\n        for (const k in v) {\n          const key = base ? base + '|' + k : k;\n          tuple[name] = v[k];\n          if (index < n) generate(key, tuple, index);\n          else if (!curr[key]) aggr.cell(key, tuple);\n        }\n      }\n      generate('', {}, 0);\n    },\n\n    init(_) {\n      // initialize input and output fields\n      const inputs = (this._inputs = []),\n            outputs = (this._outputs = []),\n            inputMap = {};\n\n      function inputVisit(get) {\n        const fields = vegaUtil.array(vegaUtil.accessorFields(get)),\n              n = fields.length;\n        let i = 0, f;\n        for (; i<n; ++i) {\n          if (!inputMap[f=fields[i]]) {\n            inputMap[f] = 1;\n            inputs.push(f);\n          }\n        }\n      }\n\n      // initialize group-by dimensions\n      this._dims = vegaUtil.array(_.groupby);\n      this._dnames = this._dims.map(d => {\n        var dname = vegaUtil.accessorName(d);\n        inputVisit(d);\n        outputs.push(dname);\n        return dname;\n      });\n      this.cellkey = _.key ? _.key : groupkey(this._dims);\n\n      // initialize aggregate measures\n      this._countOnly = true;\n      this._counts = [];\n      this._measures = [];\n\n      const fields = _.fields || [null],\n            ops = _.ops || ['count'],\n            as = _.as || [],\n            n = fields.length,\n            map = {};\n      let field, op, m, mname, outname, i;\n\n      if (n !== ops.length) {\n        vegaUtil.error('Unmatched number of fields and aggregate ops.');\n      }\n\n      for (i=0; i<n; ++i) {\n        field = fields[i];\n        op = ops[i];\n\n        if (field == null && op !== 'count') {\n          vegaUtil.error('Null aggregate field specified.');\n        }\n        mname = vegaUtil.accessorName(field);\n        outname = measureName(op, mname, as[i]);\n        outputs.push(outname);\n\n        if (op === 'count') {\n          this._counts.push(outname);\n          continue;\n        }\n\n        m = map[mname];\n        if (!m) {\n          inputVisit(field);\n          m = (map[mname] = []);\n          m.field = field;\n          this._measures.push(m);\n        }\n\n        if (op !== 'count') this._countOnly = false;\n        m.push(createMeasure(op, outname));\n      }\n\n      this._measures = this._measures.map(m => compileMeasures(m, m.field));\n\n      return {}; // aggregation cells (this.value)\n    },\n\n    // -- Cell Management -----\n\n    cellkey: groupkey(),\n\n    cell(key, t) {\n      let cell = this.value[key];\n      if (!cell) {\n        cell = this.value[key] = this.newcell(key, t);\n        this._adds[this._alen++] = cell;\n      } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {\n        cell.stamp = this.stamp;\n        this._adds[this._alen++] = cell;\n      } else if (cell.stamp < this.stamp) {\n        cell.stamp = this.stamp;\n        this._mods[this._mlen++] = cell;\n      }\n      return cell;\n    },\n\n    newcell(key, t) {\n      const cell = {\n        key:   key,\n        num:   0,\n        agg:   null,\n        tuple: this.newtuple(t, this._prev && this._prev[key]),\n        stamp: this.stamp,\n        store: false\n      };\n\n      if (!this._countOnly) {\n        const measures = this._measures,\n              n = measures.length;\n\n        cell.agg = Array(n);\n        for (let i=0; i<n; ++i) {\n          cell.agg[i] = new measures[i](cell);\n        }\n      }\n\n      if (cell.store) {\n        cell.data = new TupleStore();\n      }\n\n      return cell;\n    },\n\n    newtuple(t, p) {\n      const names = this._dnames,\n            dims = this._dims,\n            n = dims.length,\n            x = {};\n\n      for (let i=0; i<n; ++i) {\n        x[names[i]] = dims[i](t);\n      }\n\n      return p ? vegaDataflow.replace(p.tuple, x) : vegaDataflow.ingest(x);\n    },\n\n    clean() {\n      const cells = this.value;\n      for (const key in cells) {\n        if (cells[key].num === 0) {\n          delete cells[key];\n        }\n      }\n    },\n\n    // -- Process Tuples -----\n\n    add(t) {\n      const key = this.cellkey(t),\n            cell = this.cell(key, t);\n\n      cell.num += 1;\n      if (this._countOnly) return;\n\n      if (cell.store) cell.data.add(t);\n\n      const agg = cell.agg;\n      for (let i=0, n=agg.length; i<n; ++i) {\n        agg[i].add(agg[i].get(t), t);\n      }\n    },\n\n    rem(t) {\n      const key = this.cellkey(t),\n            cell = this.cell(key, t);\n\n      cell.num -= 1;\n      if (this._countOnly) return;\n\n      if (cell.store) cell.data.rem(t);\n\n      const agg = cell.agg;\n      for (let i=0, n=agg.length; i<n; ++i) {\n        agg[i].rem(agg[i].get(t), t);\n      }\n    },\n\n    celltuple(cell) {\n      const tuple = cell.tuple,\n            counts = this._counts;\n\n      // consolidate stored values\n      if (cell.store) {\n        cell.data.values();\n      }\n\n      // update tuple properties\n      for (let i=0, n=counts.length; i<n; ++i) {\n        tuple[counts[i]] = cell.num;\n      }\n      if (!this._countOnly) {\n        const agg = cell.agg;\n        for (let i=0, n=agg.length; i<n; ++i) {\n          agg[i].set(tuple);\n        }\n      }\n\n      return tuple;\n    },\n\n    changes(out) {\n      const adds = this._adds,\n            mods = this._mods,\n            prev = this._prev,\n            drop = this._drop,\n            add = out.add,\n            rem = out.rem,\n            mod = out.mod;\n\n      let cell, key, i, n;\n\n      if (prev) for (key in prev) {\n        cell = prev[key];\n        if (!drop || cell.num) rem.push(cell.tuple);\n      }\n\n      for (i=0, n=this._alen; i<n; ++i) {\n        add.push(this.celltuple(adds[i]));\n        adds[i] = null; // for garbage collection\n      }\n\n      for (i=0, n=this._mlen; i<n; ++i) {\n        cell = mods[i];\n        (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));\n        mods[i] = null; // for garbage collection\n      }\n\n      this._alen = this._mlen = 0; // reset list of active cells\n      this._prev = null;\n      return out;\n    }\n  });\n\n  // epsilon bias to offset floating point error (#1737)\n  const EPSILON = 1e-14;\n\n  /**\n   * Generates a binning function for discretizing data.\n   * @constructor\n   * @param {object} params - The parameters for this operator. The\n   *   provided values should be valid options for the {@link bin} function.\n   * @param {function(object): *} params.field - The data field to bin.\n   */\n  function Bin(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Bin.Definition = {\n    'type': 'Bin',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'field', 'type': 'field', 'required': true },\n      { 'name': 'interval', 'type': 'boolean', 'default': true },\n      { 'name': 'anchor', 'type': 'number' },\n      { 'name': 'maxbins', 'type': 'number', 'default': 20 },\n      { 'name': 'base', 'type': 'number', 'default': 10 },\n      { 'name': 'divide', 'type': 'number', 'array': true, 'default': [5, 2] },\n      { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2, 'required': true },\n      { 'name': 'span', 'type': 'number' },\n      { 'name': 'step', 'type': 'number' },\n      { 'name': 'steps', 'type': 'number', 'array': true },\n      { 'name': 'minstep', 'type': 'number', 'default': 0 },\n      { 'name': 'nice', 'type': 'boolean', 'default': true },\n      { 'name': 'name', 'type': 'string' },\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['bin0', 'bin1'] }\n    ]\n  };\n\n  vegaUtil.inherits(Bin, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const band = _.interval !== false,\n          bins = this._bins(_),\n          start = bins.start,\n          step = bins.step,\n          as = _.as || ['bin0', 'bin1'],\n          b0 = as[0],\n          b1 = as[1];\n\n      let flag;\n      if (_.modified()) {\n        pulse = pulse.reflow(true);\n        flag = pulse.SOURCE;\n      } else {\n        flag = pulse.modified(vegaUtil.accessorFields(_.field)) ? pulse.ADD_MOD : pulse.ADD;\n      }\n\n      pulse.visit(flag, band\n        ? t => {\n            const v = bins(t);\n            // minimum bin value (inclusive)\n            t[b0] = v;\n            // maximum bin value (exclusive)\n            // use convoluted math for better floating point agreement\n            // see https://github.com/vega/vega/issues/830\n            // infinite values propagate through this formula! #2227\n            t[b1] = v == null ? null : start + step * (1 + (v - start) / step);\n          }\n        : t => t[b0] = bins(t)\n      );\n\n      return pulse.modifies(band ? as : b0);\n    },\n\n    _bins(_) {\n      if (this.value && !_.modified()) {\n        return this.value;\n      }\n\n      const field = _.field,\n            bins  = vegaStatistics.bin(_),\n            step  = bins.step;\n      let start = bins.start,\n          stop  = start + Math.ceil((bins.stop - start) / step) * step,\n          a, d;\n\n      if ((a = _.anchor) != null) {\n        d = a - (start + step * Math.floor((a - start) / step));\n        start += d;\n        stop += d;\n      }\n\n      const f = function(t) {\n        let v = vegaUtil.toNumber(field(t));\n        return v == null ? null\n          : v < start ? -Infinity\n          : v > stop ? +Infinity\n          : (\n              v = Math.max(start, Math.min(v, stop - step)),\n              start + step * Math.floor(EPSILON + (v - start) / step)\n            );\n      };\n\n      f.start = start;\n      f.stop = bins.stop;\n      f.step = step;\n\n      return this.value = vegaUtil.accessor(\n        f,\n        vegaUtil.accessorFields(field),\n        _.name || 'bin_' + vegaUtil.accessorName(field)\n      );\n    }\n  });\n\n  function SortedList(idFunc, source, input) {\n    const $ = idFunc;\n    let data = source || [],\n        add = input || [],\n        rem = {},\n        cnt = 0;\n\n    return {\n      add: t => add.push(t),\n      remove: t => rem[$(t)] = ++cnt,\n      size: () => data.length,\n      data: (compare, resort) => {\n        if (cnt) {\n          data = data.filter(t => !rem[$(t)]);\n          rem = {};\n          cnt = 0;\n        }\n        if (resort && compare) {\n          data.sort(compare);\n        }\n        if (add.length) {\n          data = compare\n            ? vegaUtil.merge(compare, data, add.sort(compare))\n            : data.concat(add);\n          add = [];\n        }\n        return data;\n      }\n    };\n  }\n\n  /**\n   * Collects all data tuples that pass through this operator.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(*,*): number} [params.sort] - An optional\n   *   comparator function for additionally sorting the collected tuples.\n   */\n  function Collect(params) {\n    vegaDataflow.Transform.call(this, [], params);\n  }\n\n  Collect.Definition = {\n    'type': 'Collect',\n    'metadata': {'source': true},\n    'params': [\n      { 'name': 'sort', 'type': 'compare' }\n    ]\n  };\n\n  vegaUtil.inherits(Collect, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.ALL),\n            list = SortedList(vegaDataflow.tupleid, this.value, out.materialize(out.ADD).add),\n            sort = _.sort,\n            mod = pulse.changed() || (sort &&\n                  (_.modified('sort') || pulse.modified(sort.fields)));\n\n      out.visit(out.REM, list.remove);\n\n      this.modified(mod);\n      this.value = out.source = list.data(vegaDataflow.stableCompare(sort), mod);\n\n      // propagate tree root if defined\n      if (pulse.source && pulse.source.root) {\n        this.value.root = pulse.source.root;\n      }\n\n      return out;\n    }\n  });\n\n  /**\n   * Generates a comparator function.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<string|function>} params.fields - The fields to compare.\n   * @param {Array<string>} [params.orders] - The sort orders.\n   *   Each entry should be one of \"ascending\" (default) or \"descending\".\n   */\n  function Compare(params) {\n    vegaDataflow.Operator.call(this, null, update, params);\n  }\n\n  vegaUtil.inherits(Compare, vegaDataflow.Operator);\n\n  function update(_) {\n    return (this.value && !_.modified())\n      ? this.value\n      : vegaUtil.compare(_.fields, _.orders);\n  }\n\n  /**\n   * Count regexp-defined pattern occurrences in a text field.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - An accessor for the text field.\n   * @param {string} [params.pattern] - RegExp string defining the text pattern.\n   * @param {string} [params.case] - One of 'lower', 'upper' or null (mixed) case.\n   * @param {string} [params.stopwords] - RegExp string of words to ignore.\n   */\n  function CountPattern(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  CountPattern.Definition = {\n    'type': 'CountPattern',\n    'metadata': {'generates': true, 'changes': true},\n    'params': [\n      { 'name': 'field', 'type': 'field', 'required': true },\n      { 'name': 'case', 'type': 'enum', 'values': ['upper', 'lower', 'mixed'], 'default': 'mixed' },\n      { 'name': 'pattern', 'type': 'string', 'default': '[\\\\w\"]+' },\n      { 'name': 'stopwords', 'type': 'string', 'default': '' },\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['text', 'count'] }\n    ]\n  };\n\n  function tokenize(text, tcase, match) {\n    switch (tcase) {\n      case 'upper': text = text.toUpperCase(); break;\n      case 'lower': text = text.toLowerCase(); break;\n    }\n    return text.match(match);\n  }\n\n  vegaUtil.inherits(CountPattern, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const process = update => tuple => {\n        var tokens = tokenize(get(tuple), _.case, match) || [], t;\n        for (var i=0, n=tokens.length; i<n; ++i) {\n          if (!stop.test(t = tokens[i])) update(t);\n        }\n      };\n\n      const init = this._parameterCheck(_, pulse),\n            counts = this._counts,\n            match = this._match,\n            stop = this._stop,\n            get = _.field,\n            as = _.as || ['text', 'count'],\n            add = process(t => counts[t] = 1 + (counts[t] || 0)),\n            rem = process(t => counts[t] -= 1);\n\n      if (init) {\n        pulse.visit(pulse.SOURCE, add);\n      } else {\n        pulse.visit(pulse.ADD, add);\n        pulse.visit(pulse.REM, rem);\n      }\n\n      return this._finish(pulse, as); // generate output tuples\n    },\n\n    _parameterCheck(_, pulse) {\n      let init = false;\n\n      if (_.modified('stopwords') || !this._stop) {\n        this._stop = new RegExp('^' + (_.stopwords || '') + '$', 'i');\n        init = true;\n      }\n\n      if (_.modified('pattern') || !this._match) {\n        this._match = new RegExp((_.pattern || '[\\\\w\\']+'), 'g');\n        init = true;\n      }\n\n      if (_.modified('field') || pulse.modified(_.field.fields)) {\n        init = true;\n      }\n\n      if (init) this._counts = {};\n      return init;\n    },\n\n    _finish(pulse, as) {\n      const counts = this._counts,\n            tuples = this._tuples || (this._tuples = {}),\n            text = as[0],\n            count = as[1],\n            out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n      let w, t, c;\n\n      for (w in counts) {\n        t = tuples[w];\n        c = counts[w] || 0;\n        if (!t && c) {\n          tuples[w] = (t = vegaDataflow.ingest({}));\n          t[text] = w;\n          t[count] = c;\n          out.add.push(t);\n        } else if (c === 0) {\n          if (t) out.rem.push(t);\n          counts[w] = null;\n          tuples[w] = null;\n        } else if (t[count] !== c) {\n          t[count] = c;\n          out.mod.push(t);\n        }\n      }\n\n      return out.modifies(as);\n    }\n  });\n\n  /**\n   * Perform a cross-product of a tuple stream with itself.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object):boolean} [params.filter] - An optional filter\n   *   function for selectively including tuples in the cross product.\n   * @param {Array<string>} [params.as] - The names of the output fields.\n   */\n  function Cross(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Cross.Definition = {\n    'type': 'Cross',\n    'metadata': {'generates': true},\n    'params': [\n      { 'name': 'filter', 'type': 'expr' },\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['a', 'b'] }\n    ]\n  };\n\n  vegaUtil.inherits(Cross, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE),\n            as = _.as || ['a', 'b'],\n            a = as[0], b = as[1],\n            reset = !this.value\n                || pulse.changed(pulse.ADD_REM)\n                || _.modified('as')\n                || _.modified('filter');\n\n      let data = this.value;\n      if (reset) {\n        if (data) out.rem = data;\n        data = pulse.materialize(pulse.SOURCE).source;\n        out.add = this.value = cross(data, a, b, _.filter || vegaUtil.truthy);\n      } else {\n        out.mod = data;\n      }\n\n      out.source = this.value;\n      return out.modifies(as);\n    }\n  });\n\n  function cross(input, a, b, filter) {\n    var data = [],\n        t = {},\n        n = input.length,\n        i = 0,\n        j, left;\n\n    for (; i<n; ++i) {\n      t[a] = left = input[i];\n      for (j=0; j<n; ++j) {\n        t[b] = input[j];\n        if (filter(t)) {\n          data.push(vegaDataflow.ingest(t));\n          t = {};\n          t[a] = left;\n        }\n      }\n    }\n\n    return data;\n  }\n\n  const Distributions = {\n    kde:       vegaStatistics.randomKDE,\n    mixture:   vegaStatistics.randomMixture,\n    normal:    vegaStatistics.randomNormal,\n    lognormal: vegaStatistics.randomLogNormal,\n    uniform:   vegaStatistics.randomUniform\n  };\n\n  const DISTRIBUTIONS = 'distributions',\n        FUNCTION = 'function',\n        FIELD = 'field';\n\n  /**\n   * Parse a parameter object for a probability distribution.\n   * @param {object} def - The distribution parameter object.\n   * @param {function():Array<object>} - A method for requesting\n   *   source data. Used for distributions (such as KDE) that\n   *   require sample data points. This method will only be\n   *   invoked if the 'from' parameter for a target data source\n   *   is not provided. Typically this method returns backing\n   *   source data for a Pulse object.\n   * @return {object} - The output distribution object.\n   */\n  function parse(def, data) {\n    const func = def[FUNCTION];\n    if (!vegaUtil.hasOwnProperty(Distributions, func)) {\n      vegaUtil.error('Unknown distribution function: ' + func);\n    }\n\n    const d = Distributions[func]();\n\n    for (const name in def) {\n      // if data field, extract values\n      if (name === FIELD) {\n        d.data((def.from || data()).map(def[name]));\n      }\n\n      // if distribution mixture, recurse to parse each definition\n      else if (name === DISTRIBUTIONS) {\n        d[name](def[name].map(_ => parse(_, data)));\n      }\n\n      // otherwise, simply set the parameter\n      else if (typeof d[name] === FUNCTION) {\n        d[name](def[name]);\n      }\n    }\n\n    return d;\n  }\n\n  /**\n   * Grid sample points for a probability density. Given a distribution and\n   * a sampling extent, will generate points suitable for plotting either\n   * PDF (probability density function) or CDF (cumulative distribution\n   * function) curves.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {object} params.distribution - The probability distribution. This\n   *   is an object parameter dependent on the distribution type.\n   * @param {string} [params.method='pdf'] - The distribution method to sample.\n   *   One of 'pdf' or 'cdf'.\n   * @param {Array<number>} [params.extent] - The [min, max] extent over which\n   *   to sample the distribution. This argument is required in most cases, but\n   *   can be omitted if the distribution (e.g., 'kde') supports a 'data' method\n   *   that returns numerical sample points from which the extent can be deduced.\n   * @param {number} [params.minsteps=25] - The minimum number of curve samples\n   *   for plotting the density.\n   * @param {number} [params.maxsteps=200] - The maximum number of curve samples\n   *   for plotting the density.\n   * @param {number} [params.steps] - The exact number of curve samples for\n   *   plotting the density. If specified, overrides both minsteps and maxsteps\n   *   to set an exact number of uniform samples. Useful in conjunction with\n   *   a fixed extent to ensure consistent sample points for stacked densities.\n   */\n  function Density(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  var distributions = [\n    {\n      'key': {'function': 'normal'},\n      'params': [\n        { 'name': 'mean', 'type': 'number', 'default': 0 },\n        { 'name': 'stdev', 'type': 'number', 'default': 1 }\n      ]\n    },\n    {\n      'key': {'function': 'lognormal'},\n      'params': [\n        { 'name': 'mean', 'type': 'number', 'default': 0 },\n        { 'name': 'stdev', 'type': 'number', 'default': 1 }\n      ]\n    },\n    {\n      'key': {'function': 'uniform'},\n      'params': [\n        { 'name': 'min', 'type': 'number', 'default': 0 },\n        { 'name': 'max', 'type': 'number', 'default': 1 }\n      ]\n    },\n    {\n      'key': {'function': 'kde'},\n      'params': [\n        { 'name': 'field', 'type': 'field', 'required': true },\n        { 'name': 'from', 'type': 'data' },\n        { 'name': 'bandwidth', 'type': 'number', 'default': 0 }\n      ]\n    }\n  ];\n\n  var mixture = {\n    'key': {'function': 'mixture'},\n    'params': [\n      { 'name': 'distributions', 'type': 'param', 'array': true,\n        'params': distributions },\n      { 'name': 'weights', 'type': 'number', 'array': true }\n    ]\n  };\n\n  Density.Definition = {\n    'type': 'Density',\n    'metadata': {'generates': true},\n    'params': [\n      { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2 },\n      { 'name': 'steps', 'type': 'number' },\n      { 'name': 'minsteps', 'type': 'number', 'default': 25 },\n      { 'name': 'maxsteps', 'type': 'number', 'default': 200 },\n      { 'name': 'method', 'type': 'string', 'default': 'pdf',\n        'values': ['pdf', 'cdf'] },\n      { 'name': 'distribution', 'type': 'param',\n        'params': distributions.concat(mixture) },\n      { 'name': 'as', 'type': 'string', 'array': true,\n        'default': ['value', 'density'] }\n    ]\n  };\n\n  vegaUtil.inherits(Density, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n      if (!this.value || pulse.changed() || _.modified()) {\n        const dist = parse(_.distribution, source(pulse)),\n              minsteps = _.steps || _.minsteps || 25,\n              maxsteps = _.steps || _.maxsteps || 200;\n        let method = _.method || 'pdf';\n\n        if (method !== 'pdf' && method !== 'cdf') {\n          vegaUtil.error('Invalid density method: ' + method);\n        }\n        if (!_.extent && !dist.data) {\n          vegaUtil.error('Missing density extent parameter.');\n        }\n        method = dist[method];\n\n        const as = _.as || ['value', 'density'],\n              domain = _.extent || vegaUtil.extent(dist.data()),\n              values = vegaStatistics.sampleCurve(method, domain, minsteps, maxsteps)\n                .map(v => {\n                  const tuple = {};\n                  tuple[as[0]] = v[0];\n                  tuple[as[1]] = v[1];\n                  return vegaDataflow.ingest(tuple);\n                });\n\n        if (this.value) out.rem = this.value;\n        this.value = out.add = out.source = values;\n      }\n\n      return out;\n    }\n  });\n\n  function source(pulse) {\n    return () => pulse.materialize(pulse.SOURCE).source;\n  }\n\n  // use either provided alias or accessor field name\n  function fieldNames(fields, as) {\n    if (!fields) return null;\n    return fields.map((f, i) => as[i] || vegaUtil.accessorName(f));\n  }\n\n  function partition(data, groupby, field) {\n    const groups = [],\n          get = f => f(t);\n    let map, i, n, t, k, g;\n\n    // partition data points into groups\n    if (groupby == null) {\n      groups.push(data.map(field));\n    } else {\n      for (map={}, i=0, n=data.length; i<n; ++i) {\n        t = data[i];\n        k = groupby.map(get);\n        g = map[k];\n        if (!g) {\n          map[k] = (g = []);\n          g.dims = k;\n          groups.push(g);\n        }\n        g.push(field(t));\n      }\n    }\n\n    return groups;\n  }\n\n  const Output = 'bin';\n\n  /**\n   * Dot density binning for dot plot construction.\n   * Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.\n   * https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - The value field to bin.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n   * @param {number} [params.step] - The step size (bin width) within which dots should be\n   *   stacked. Defaults to 1/30 of the extent of the data *field*.\n   * @param {boolean} [params.smooth=false] - A boolean flag indicating if dot density\n   *   stacks should be smoothed to reduce variance.\n   */\n  function DotBin(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  DotBin.Definition = {\n    'type': 'DotBin',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'field', 'type': 'field', 'required': true },\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'step', 'type': 'number' },\n      { 'name': 'smooth', 'type': 'boolean', 'default': false },\n      { 'name': 'as', 'type': 'string', 'default': Output }\n    ]\n  };\n\n  const autostep = (data, field) => vegaUtil.span(vegaUtil.extent(data, field)) / 30;\n\n  vegaUtil.inherits(DotBin, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      if (this.value && !(_.modified() || pulse.changed())) {\n        return pulse; // early exit\n      }\n\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(pulse.source, _.groupby, vegaUtil.identity),\n            smooth = _.smooth || false,\n            field = _.field,\n            step = _.step || autostep(source, field),\n            sort = vegaDataflow.stableCompare((a, b) => field(a) - field(b)),\n            as = _.as || Output,\n            n = groups.length;\n\n      // compute dotplot bins per group\n      let min = Infinity, max = -Infinity, i = 0, j;\n      for (; i<n; ++i) {\n        const g = groups[i].sort(sort);\n        j = -1;\n        for (const v of vegaStatistics.dotbin(g, step, smooth, field)) {\n          if (v < min) min = v;\n          if (v > max) max = v;\n          g[++j][as] = v;\n        }\n      }\n\n      this.value = {\n        start: min,\n        stop: max,\n        step: step\n      };\n      return pulse.reflow(true).modifies(as);\n    }\n  });\n\n  /**\n   * Wraps an expression function with access to external parameters.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function} params.expr - The expression function. The\n   *  function should accept both a datum and a parameter object.\n   *  This operator's value will be a new function that wraps the\n   *  expression function with access to this operator's parameters.\n   */\n  function Expression(params) {\n    vegaDataflow.Operator.call(this, null, update$1, params);\n    this.modified(true);\n  }\n\n  vegaUtil.inherits(Expression, vegaDataflow.Operator);\n\n  function update$1(_) {\n    const expr = _.expr;\n    return this.value && !_.modified('expr')\n      ? this.value\n      : vegaUtil.accessor(\n          datum => expr(datum, _),\n          vegaUtil.accessorFields(expr),\n          vegaUtil.accessorName(expr)\n        );\n  }\n\n  /**\n   * Computes extents (min/max) for a data field.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - The field over which to compute extends.\n   */\n  function Extent(params) {\n    vegaDataflow.Transform.call(this, [undefined, undefined], params);\n  }\n\n  Extent.Definition = {\n    'type': 'Extent',\n    'metadata': {},\n    'params': [\n      { 'name': 'field', 'type': 'field', 'required': true }\n    ]\n  };\n\n  vegaUtil.inherits(Extent, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const extent = this.value,\n            field = _.field,\n            mod = pulse.changed()\n              || pulse.modified(field.fields)\n              || _.modified('field');\n\n      let min = extent[0],\n          max = extent[1];\n      if (mod || min == null) {\n        min = +Infinity;\n        max = -Infinity;\n      }\n\n      pulse.visit(mod ? pulse.SOURCE : pulse.ADD, t => {\n        const v = vegaUtil.toNumber(field(t));\n        if (v != null) {\n          // NaNs will fail all comparisons!\n          if (v < min) min = v;\n          if (v > max) max = v;\n        }\n      });\n\n      if (!Number.isFinite(min) || !Number.isFinite(max)) {\n        let name = vegaUtil.accessorName(field);\n        if (name) name = ` for field \"${name}\"`;\n        pulse.dataflow.warn(`Infinite extent${name}: [${min}, ${max}]`);\n        min = max = undefined;\n      }\n      this.value = [min, max];\n    }\n  });\n\n  /**\n   * Provides a bridge between a parent transform and a target subflow that\n   * consumes only a subset of the tuples that pass through the parent.\n   * @constructor\n   * @param {Pulse} pulse - A pulse to use as the value of this operator.\n   * @param {Transform} parent - The parent transform (typically a Facet instance).\n   */\n  function Subflow(pulse, parent) {\n    vegaDataflow.Operator.call(this, pulse);\n    this.parent = parent;\n    this.count = 0;\n  }\n\n  vegaUtil.inherits(Subflow, vegaDataflow.Operator, {\n    /**\n     * Routes pulses from this subflow to a target transform.\n     * @param {Transform} target - A transform that receives the subflow of tuples.\n     */\n    connect(target) {\n      this.detachSubflow = target.detachSubflow;\n      this.targets().add(target);\n      return (target.source = this);\n    },\n\n    /**\n     * Add an 'add' tuple to the subflow pulse.\n     * @param {Tuple} t - The tuple being added.\n     */\n    add(t) {\n      this.count += 1;\n      this.value.add.push(t);\n    },\n\n    /**\n     * Add a 'rem' tuple to the subflow pulse.\n     * @param {Tuple} t - The tuple being removed.\n     */\n    rem(t) {\n      this.count -= 1;\n      this.value.rem.push(t);\n    },\n\n    /**\n     * Add a 'mod' tuple to the subflow pulse.\n     * @param {Tuple} t - The tuple being modified.\n     */\n    mod(t) {\n      this.value.mod.push(t);\n    },\n\n    /**\n     * Re-initialize this operator's pulse value.\n     * @param {Pulse} pulse - The pulse to copy from.\n     * @see Pulse.init\n     */\n    init(pulse) {\n      this.value.init(pulse, pulse.NO_SOURCE);\n    },\n\n    /**\n     * Evaluate this operator. This method overrides the\n     * default behavior to simply return the contained pulse value.\n     * @return {Pulse}\n     */\n    evaluate() {\n      // assert: this.value.stamp === pulse.stamp\n      return this.value;\n    }\n  });\n\n  /**\n   * Facets a dataflow into a set of subflows based on a key.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(Dataflow, string): Operator} params.subflow - A function\n   *   that generates a subflow of operators and returns its root operator.\n   * @param {function(object): *} params.key - The key field to facet by.\n   */\n  function Facet(params) {\n    vegaDataflow.Transform.call(this, {}, params);\n    this._keys = vegaUtil.fastmap(); // cache previously calculated key values\n\n    // keep track of active subflows, use as targets array for listeners\n    // this allows us to limit propagation to only updated subflows\n    const a = this._targets = [];\n    a.active = 0;\n    a.forEach = f => {\n      for (let i=0, n=a.active; i<n; ++i) {\n        f(a[i], i, a);\n      }\n    };\n  }\n\n  vegaUtil.inherits(Facet, vegaDataflow.Transform, {\n    activate(flow) {\n      this._targets[this._targets.active++] = flow;\n    },\n\n    // parent argument provided by PreFacet subclass\n    subflow(key, flow, pulse, parent) {\n      const flows = this.value;\n      let sf = vegaUtil.hasOwnProperty(flows, key) && flows[key],\n          df, p;\n\n      if (!sf) {\n        p = parent || (p = this._group[key]) && p.tuple;\n        df = pulse.dataflow;\n        sf = new Subflow(pulse.fork(pulse.NO_SOURCE), this);\n        df.add(sf).connect(flow(df, key, p));\n        flows[key] = sf;\n        this.activate(sf);\n      } else if (sf.value.stamp < pulse.stamp) {\n        sf.init(pulse);\n        this.activate(sf);\n      }\n\n      return sf;\n    },\n\n    clean() {\n      const flows = this.value;\n      for (const key in flows) {\n        if (flows[key].count === 0) {\n          const detach = flows[key].detachSubflow;\n          if (detach) detach();\n          delete flows[key];\n        }\n      }\n    },\n\n    initTargets() {\n      const a = this._targets,\n            n = a.length;\n      for (let i=0; i<n && a[i] != null; ++i) {\n        a[i] = null; // ensure old flows can be garbage collected\n      }\n      a.active = 0;\n    },\n\n    transform(_, pulse) {\n      const df = pulse.dataflow,\n            key = _.key,\n            flow = _.subflow,\n            cache = this._keys,\n            rekey = _.modified('key'),\n            subflow = key => this.subflow(key, flow, pulse);\n\n      this._group = _.group || {};\n      this.initTargets(); // reset list of active subflows\n\n      pulse.visit(pulse.REM, t => {\n        const id = vegaDataflow.tupleid(t),\n              k = cache.get(id);\n        if (k !== undefined) {\n          cache.delete(id);\n          subflow(k).rem(t);\n        }\n      });\n\n      pulse.visit(pulse.ADD, t => {\n        const k = key(t);\n        cache.set(vegaDataflow.tupleid(t), k);\n        subflow(k).add(t);\n      });\n\n      if (rekey || pulse.modified(key.fields)) {\n        pulse.visit(pulse.MOD, t => {\n          const id = vegaDataflow.tupleid(t),\n                k0 = cache.get(id),\n                k1 = key(t);\n          if (k0 === k1) {\n            subflow(k1).mod(t);\n          } else {\n            cache.set(id, k1);\n            subflow(k0).rem(t);\n            subflow(k1).add(t);\n          }\n        });\n      } else if (pulse.changed(pulse.MOD)) {\n        pulse.visit(pulse.MOD, t => {\n          subflow(cache.get(vegaDataflow.tupleid(t))).mod(t);\n        });\n      }\n\n      if (rekey) {\n        pulse.visit(pulse.REFLOW, t => {\n          const id = vegaDataflow.tupleid(t),\n                k0 = cache.get(id),\n                k1 = key(t);\n          if (k0 !== k1) {\n            cache.set(id, k1);\n            subflow(k0).rem(t);\n            subflow(k1).add(t);\n          }\n        });\n      }\n\n      if (pulse.clean()) {\n        df.runAfter(() => { this.clean(); cache.clean(); });\n      } else if (cache.empty > df.cleanThreshold) {\n        df.runAfter(cache.clean);\n      }\n\n      return pulse;\n    }\n  });\n\n  /**\n   * Generates one or more field accessor functions.\n   * If the 'name' parameter is an array, an array of field accessors\n   * will be created and the 'as' parameter will be ignored.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {string} params.name - The field name(s) to access.\n   * @param {string} params.as - The accessor function name.\n   */\n  function Field(params) {\n    vegaDataflow.Operator.call(this, null, update$2, params);\n  }\n\n  vegaUtil.inherits(Field, vegaDataflow.Operator);\n\n  function update$2(_) {\n    return (this.value && !_.modified()) ? this.value\n      : vegaUtil.isArray(_.name) ? vegaUtil.array(_.name).map(f => vegaUtil.field(f))\n      : vegaUtil.field(_.name, _.as);\n  }\n\n  /**\n   * Filters data tuples according to a predicate function.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.expr - The predicate expression function\n   *   that determines a tuple's filter status. Truthy values pass the filter.\n   */\n  function Filter(params) {\n    vegaDataflow.Transform.call(this, vegaUtil.fastmap(), params);\n  }\n\n  Filter.Definition = {\n    'type': 'Filter',\n    'metadata': {'changes': true},\n    'params': [\n      { 'name': 'expr', 'type': 'expr', 'required': true }\n    ]\n  };\n\n  vegaUtil.inherits(Filter, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const df = pulse.dataflow,\n            cache = this.value, // cache ids of filtered tuples\n            output = pulse.fork(),\n            add = output.add,\n            rem = output.rem,\n            mod = output.mod,\n            test = _.expr;\n      let isMod = true;\n\n      pulse.visit(pulse.REM, t => {\n        var id = vegaDataflow.tupleid(t);\n        if (!cache.has(id)) rem.push(t);\n        else cache.delete(id);\n      });\n\n      pulse.visit(pulse.ADD, t => {\n        if (test(t, _)) add.push(t);\n        else cache.set(vegaDataflow.tupleid(t), 1);\n      });\n\n      function revisit(t) {\n        const id = vegaDataflow.tupleid(t),\n              b = test(t, _),\n              s = cache.get(id);\n        if (b && s) {\n          cache.delete(id);\n          add.push(t);\n        } else if (!b && !s) {\n          cache.set(id, 1);\n          rem.push(t);\n        } else if (isMod && b && !s) {\n          mod.push(t);\n        }\n      }\n\n      pulse.visit(pulse.MOD, revisit);\n\n      if (_.modified()) {\n        isMod = false;\n        pulse.visit(pulse.REFLOW, revisit);\n      }\n\n      if (cache.empty > df.cleanThreshold) df.runAfter(cache.clean);\n      return output;\n    }\n  });\n\n  /**\n   * Flattens array-typed field values into new data objects.\n   * If multiple fields are specified, they are treated as parallel arrays,\n   * with output values included for each matching index (or null if missing).\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<function(object): *>} params.fields - An array of field\n   *   accessors for the tuple fields that should be flattened.\n   * @param {string} [params.index] - Optional output field name for index\n   *   value. If unspecified, no index field is included in the output.\n   * @param {Array<string>} [params.as] - Output field names for flattened\n   *   array fields. Any unspecified fields will use the field name provided\n   *   by the fields accessors.\n   */\n  function Flatten(params) {\n    vegaDataflow.Transform.call(this, [], params);\n  }\n\n  Flatten.Definition = {\n    'type': 'Flatten',\n    'metadata': {'generates': true},\n    'params': [\n      { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\n      { 'name': 'index', 'type': 'string' },\n      { 'name': 'as', 'type': 'string', 'array': true }\n    ]\n  };\n\n  vegaUtil.inherits(Flatten, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE),\n            fields = _.fields,\n            as = fieldNames(fields, _.as || []),\n            index = _.index || null,\n            m = as.length;\n\n      // remove any previous results\n      out.rem = this.value;\n\n      // generate flattened tuples\n      pulse.visit(pulse.SOURCE, t => {\n        const arrays = fields.map(f => f(t)),\n              maxlen = arrays.reduce((l, a) => Math.max(l, a.length), 0);\n        let i = 0, j, d, v;\n\n        for (; i<maxlen; ++i) {\n          d = vegaDataflow.derive(t);\n          for (j=0; j<m; ++j) {\n            d[as[j]] = (v = arrays[j][i]) == null ? null : v;\n          }\n          if (index) {\n            d[index] = i;\n          }\n          out.add.push(d);\n        }\n      });\n\n      this.value = out.source = out.add;\n      if (index) out.modifies(index);\n      return out.modifies(as);\n    }\n  });\n\n  /**\n   * Folds one more tuple fields into multiple tuples in which the field\n   * name and values are available under new 'key' and 'value' fields.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.fields - An array of field accessors\n   *   for the tuple fields that should be folded.\n   * @param {Array<string>} [params.as] - Output field names for folded key\n   *   and value fields, defaults to ['key', 'value'].\n   */\n  function Fold(params) {\n    vegaDataflow.Transform.call(this, [], params);\n  }\n\n  Fold.Definition = {\n    'type': 'Fold',\n    'metadata': {'generates': true},\n    'params': [\n      { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['key', 'value'] }\n    ]\n  };\n\n  vegaUtil.inherits(Fold, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE),\n            fields = _.fields,\n            fnames = fields.map(vegaUtil.accessorName),\n            as = _.as || ['key', 'value'],\n            k = as[0],\n            v = as[1],\n            n = fields.length;\n\n      out.rem = this.value;\n\n      pulse.visit(pulse.SOURCE, t => {\n        for (let i=0, d; i<n; ++i) {\n          d = vegaDataflow.derive(t);\n          d[k] = fnames[i];\n          d[v] = fields[i](t);\n          out.add.push(d);\n        }\n      });\n\n      this.value = out.source = out.add;\n      return out.modifies(as);\n    }\n  });\n\n  /**\n   * Invokes a function for each data tuple and saves the results as a new field.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.expr - The formula function to invoke for each tuple.\n   * @param {string} params.as - The field name under which to save the result.\n   * @param {boolean} [params.initonly=false] - If true, the formula is applied to\n   *   added tuples only, and does not update in response to modifications.\n   */\n  function Formula(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Formula.Definition = {\n    'type': 'Formula',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'expr', 'type': 'expr', 'required': true },\n      { 'name': 'as', 'type': 'string', 'required': true },\n      { 'name': 'initonly', 'type': 'boolean' }\n    ]\n  };\n\n  vegaUtil.inherits(Formula, vegaDataflow.Transform, {\n    transform (_, pulse) {\n      const func = _.expr,\n            as = _.as,\n            mod = _.modified(),\n            flag = _.initonly ? pulse.ADD\n              : mod ? pulse.SOURCE\n              : pulse.modified(func.fields) || pulse.modified(as) ? pulse.ADD_MOD\n              : pulse.ADD;\n\n      if (mod) {\n        // parameters updated, need to reflow\n        pulse = pulse.materialize().reflow(true);\n      }\n\n      if (!_.initonly) {\n        pulse.modifies(as);\n      }\n\n      return pulse.visit(flag, t => t[as] = func(t, _));\n    }\n  });\n\n  /**\n   * Generates data tuples using a provided generator function.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(Parameters): object} params.generator - A tuple generator\n   *   function. This function is given the operator parameters as input.\n   *   Changes to any additional parameters will not trigger re-calculation\n   *   of previously generated tuples. Only future tuples are affected.\n   * @param {number} params.size - The number of tuples to produce.\n   */\n  function Generate(params) {\n    vegaDataflow.Transform.call(this, [], params);\n  }\n\n  vegaUtil.inherits(Generate, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.ALL),\n            gen = _.generator;\n\n      let data = this.value,\n          num = _.size - data.length,\n          add, rem, t;\n\n      if (num > 0) {\n        // need more tuples, generate and add\n        for (add=[]; --num >= 0;) {\n          add.push(t = vegaDataflow.ingest(gen(_)));\n          data.push(t);\n        }\n        out.add = out.add.length\n          ? out.materialize(out.ADD).add.concat(add)\n          : add;\n      } else {\n        // need fewer tuples, remove\n        rem = data.slice(0, -num);\n        out.rem = out.rem.length\n          ? out.materialize(out.REM).rem.concat(rem)\n          : rem;\n        data = data.slice(-num);\n      }\n\n      out.source = this.value = data;\n      return out;\n    }\n  });\n\n  const Methods = {\n    value: 'value',\n    median: d3Array.median,\n    mean: d3Array.mean,\n    min: d3Array.min,\n    max: d3Array.max\n  };\n\n  const Empty = [];\n\n  /**\n   * Impute missing values.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - The value field to impute.\n   * @param {Array<function(object): *>} [params.groupby] - An array of\n   *   accessors to determine series within which to perform imputation.\n   * @param {function(object): *} params.key - An accessor for a key value.\n   *   Each key value should be unique within a group. New tuples will be\n   *   imputed for any key values that are not found within a group.\n   * @param {Array<*>} [params.keyvals] - Optional array of required key\n   *   values. New tuples will be imputed for any key values that are not\n   *   found within a group. In addition, these values will be automatically\n   *   augmented with the key values observed in the input data.\n   * @param {string} [method='value'] - The imputation method to use. One of\n   *   'value', 'mean', 'median', 'max', 'min'.\n   * @param {*} [value=0] - The constant value to use for imputation\n   *   when using method 'value'.\n   */\n  function Impute(params) {\n    vegaDataflow.Transform.call(this, [], params);\n  }\n\n  Impute.Definition = {\n    'type': 'Impute',\n    'metadata': {'changes': true},\n    'params': [\n      { 'name': 'field', 'type': 'field', 'required': true },\n      { 'name': 'key', 'type': 'field', 'required': true },\n      { 'name': 'keyvals', 'array': true },\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'method', 'type': 'enum', 'default': 'value',\n        'values': ['value', 'mean', 'median', 'max', 'min'] },\n      { 'name': 'value', 'default': 0 }\n    ]\n  };\n\n  function getValue(_) {\n    var m = _.method || Methods.value, v;\n\n    if (Methods[m] == null) {\n      vegaUtil.error('Unrecognized imputation method: ' + m);\n    } else if (m === Methods.value) {\n      v = _.value !== undefined ? _.value : 0;\n      return () => v;\n    } else {\n      return Methods[m];\n    }\n  }\n\n  function getField(_) {\n    var f = _.field;\n    return t => t ? f(t) : NaN;\n  }\n\n  vegaUtil.inherits(Impute, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      var out = pulse.fork(pulse.ALL),\n          impute = getValue(_),\n          field = getField(_),\n          fName = vegaUtil.accessorName(_.field),\n          kName = vegaUtil.accessorName(_.key),\n          gNames = (_.groupby || []).map(vegaUtil.accessorName),\n          groups = partition$1(pulse.source, _.groupby, _.key, _.keyvals),\n          curr = [],\n          prev = this.value,\n          m = groups.domain.length,\n          group, value, gVals, kVal, g, i, j, l, n, t;\n\n      for (g=0, l=groups.length; g<l; ++g) {\n        group = groups[g];\n        gVals = group.values;\n        value = NaN;\n\n        // add tuples for missing values\n        for (j=0; j<m; ++j) {\n          if (group[j] != null) continue;\n          kVal = groups.domain[j];\n\n          t = {_impute: true};\n          for (i=0, n=gVals.length; i<n; ++i) t[gNames[i]] = gVals[i];\n          t[kName] = kVal;\n          t[fName] = Number.isNaN(value) ? (value = impute(group, field)) : value;\n\n          curr.push(vegaDataflow.ingest(t));\n        }\n      }\n\n      // update pulse with imputed tuples\n      if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);\n      if (prev.length) out.rem = out.materialize(out.REM).rem.concat(prev);\n      this.value = curr;\n\n      return out;\n    }\n  });\n\n  function partition$1(data, groupby, key, keyvals) {\n    var get = f => f(t),\n        groups = [],\n        domain = keyvals ? keyvals.slice() : [],\n        kMap = {},\n        gMap = {}, gVals, gKey,\n        group, i, j, k, n, t;\n\n    domain.forEach((k, i) => kMap[k] = i + 1);\n\n    for (i=0, n=data.length; i<n; ++i) {\n      t = data[i];\n      k = key(t);\n      j = kMap[k] || (kMap[k] = domain.push(k));\n\n      gKey = (gVals = groupby ? groupby.map(get) : Empty) + '';\n      if (!(group = gMap[gKey])) {\n        group = (gMap[gKey] = []);\n        groups.push(group);\n        group.values = gVals;\n      }\n      group[j-1] = t;\n    }\n\n    groups.domain = domain;\n    return groups;\n  }\n\n  /**\n   * Extend input tuples with aggregate values.\n   * Calcuates aggregate values and joins them with the input stream.\n   * @constructor\n   */\n  function JoinAggregate(params) {\n    Aggregate.call(this, params);\n  }\n\n  JoinAggregate.Definition = {\n    'type': 'JoinAggregate',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'fields', 'type': 'field', 'null': true, 'array': true },\n      { 'name': 'ops', 'type': 'enum', 'array': true, 'values': ValidAggregateOps },\n      { 'name': 'as', 'type': 'string', 'null': true, 'array': true },\n      { 'name': 'key', 'type': 'field' }\n    ]\n  };\n\n  vegaUtil.inherits(JoinAggregate, Aggregate, {\n    transform(_, pulse) {\n      const aggr = this,\n            mod = _.modified();\n      let cells;\n\n      // process all input tuples to calculate aggregates\n      if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\n        cells = aggr.value = mod ? aggr.init(_) : {};\n        pulse.visit(pulse.SOURCE, t => aggr.add(t));\n      } else {\n        cells = aggr.value = aggr.value || this.init(_);\n        pulse.visit(pulse.REM, t => aggr.rem(t));\n        pulse.visit(pulse.ADD, t => aggr.add(t));\n      }\n\n      // update aggregation cells\n      aggr.changes();\n\n      // write aggregate values to input tuples\n      pulse.visit(pulse.SOURCE, t => {\n        vegaUtil.extend(t, cells[aggr.cellkey(t)].tuple);\n      });\n\n      return pulse.reflow(mod).modifies(this._outputs);\n    },\n\n    changes() {\n      const adds = this._adds,\n            mods = this._mods;\n      let i, n;\n\n      for (i=0, n=this._alen; i<n; ++i) {\n        this.celltuple(adds[i]);\n        adds[i] = null; // for garbage collection\n      }\n\n      for (i=0, n=this._mlen; i<n; ++i) {\n        this.celltuple(mods[i]);\n        mods[i] = null; // for garbage collection\n      }\n\n      this._alen = this._mlen = 0; // reset list of active cells\n    }\n  });\n\n  /**\n   * Compute kernel density estimates (KDE) for one or more data groups.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n   *   to groupby.\n   * @param {function(object): *} params.field - An accessor for the data field\n   *   to estimate.\n   * @param {number} [params.bandwidth=0] - The KDE kernel bandwidth.\n   *   If zero or unspecified, the bandwidth is automatically determined.\n   * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n   *   output values should be probability estimates (false, default) or\n   *   smoothed counts (true).\n   * @param {string} [params.cumulative=false] - A boolean flag indicating if a\n   *   density (false) or cumulative distribution (true) should be generated.\n   * @param {Array<number>} [params.extent] - The domain extent over which to\n   *   plot the density. If unspecified, the [min, max] data extent is used.\n   * @param {string} [params.resolve='independent'] - Indicates how parameters for\n   *   multiple densities should be resolved. If \"independent\" (the default), each\n   *   density may have its own domain extent and dynamic number of curve sample\n   *   steps. If \"shared\", the KDE transform will ensure that all densities are\n   *   defined over a shared domain and curve steps, enabling stacking.\n   * @param {number} [params.minsteps=25] - The minimum number of curve samples\n   *   for plotting the density.\n   * @param {number} [params.maxsteps=200] - The maximum number of curve samples\n   *   for plotting the density.\n   * @param {number} [params.steps] - The exact number of curve samples for\n   *   plotting the density. If specified, overrides both minsteps and maxsteps\n   *   to set an exact number of uniform samples. Useful in conjunction with\n   *   a fixed extent to ensure consistent sample points for stacked densities.\n   */\n  function KDE(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  KDE.Definition = {\n    'type': 'KDE',\n    'metadata': {'generates': true},\n    'params': [\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'field', 'type': 'field', 'required': true },\n      { 'name': 'cumulative', 'type': 'boolean', 'default': false },\n      { 'name': 'counts', 'type': 'boolean', 'default': false },\n      { 'name': 'bandwidth', 'type': 'number', 'default': 0 },\n      { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2 },\n      { 'name': 'resolve', 'type': 'enum', 'values': ['shared', 'independent'], 'default': 'independent' },\n      { 'name': 'steps', 'type': 'number' },\n      { 'name': 'minsteps', 'type': 'number', 'default': 25 },\n      { 'name': 'maxsteps', 'type': 'number', 'default': 200 },\n      { 'name': 'as', 'type': 'string', 'array': true, 'default': ['value', 'density'] }\n    ]\n  };\n\n  vegaUtil.inherits(KDE, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n      if (!this.value || pulse.changed() || _.modified()) {\n        const source = pulse.materialize(pulse.SOURCE).source,\n              groups = partition(source, _.groupby, _.field),\n              names = (_.groupby || []).map(vegaUtil.accessorName),\n              bandwidth = _.bandwidth,\n              method = _.cumulative ? 'cdf' : 'pdf',\n              as = _.as || ['value', 'density'],\n              values = [];\n\n        let domain = _.extent,\n            minsteps = _.steps || _.minsteps || 25,\n            maxsteps = _.steps || _.maxsteps || 200;\n\n        if (method !== 'pdf' && method !== 'cdf') {\n          vegaUtil.error('Invalid density method: ' + method);\n        }\n\n        if (_.resolve === 'shared') {\n          if (!domain) domain = vegaUtil.extent(source, _.field);\n          minsteps = maxsteps = _.steps || maxsteps;\n        }\n\n        groups.forEach(g => {\n          const density = vegaStatistics.randomKDE(g, bandwidth)[method],\n                scale = _.counts ? g.length : 1,\n                local = domain || vegaUtil.extent(g);\n\n          vegaStatistics.sampleCurve(density, local, minsteps, maxsteps)\n            .forEach(v => {\n              const t = {};\n              for (let i=0; i<names.length; ++i) {\n                t[names[i]] = g.dims[i];\n              }\n              t[as[0]] = v[0];\n              t[as[1]] = v[1] * scale;\n              values.push(vegaDataflow.ingest(t));\n            });\n        });\n\n        if (this.value) out.rem = this.value;\n        this.value = out.add = out.source = values;\n      }\n\n      return out;\n    }\n  });\n\n  /**\n   * Generates a key function.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<string>} params.fields - The field name(s) for the key function.\n   * @param {boolean} params.flat - A boolean flag indicating if the field names\n   *  should be treated as flat property names, side-stepping nested field\n   *  lookups normally indicated by dot or bracket notation.\n   */\n  function Key(params) {\n    vegaDataflow.Operator.call(this, null, update$3, params);\n  }\n\n  vegaUtil.inherits(Key, vegaDataflow.Operator);\n\n  function update$3(_) {\n    return (this.value && !_.modified()) ? this.value : vegaUtil.key(_.fields, _.flat);\n  }\n\n  /**\n   * Load and parse data from an external source. Marshalls parameter\n   * values and then invokes the Dataflow request method.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {string} params.url - The URL to load from.\n   * @param {object} params.format - The data format options.\n   */\n  function Load(params) {\n    vegaDataflow.Transform.call(this, [], params);\n    this._pending = null;\n  }\n\n  vegaUtil.inherits(Load, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const df = pulse.dataflow;\n\n      if (this._pending) {\n        // update state and return pulse\n        return output(this, pulse, this._pending);\n      }\n\n      if (stop(_)) return pulse.StopPropagation;\n\n      if (_.values) {\n        // parse and ingest values, return output pulse\n        return output(this, pulse, df.parse(_.values, _.format));\n      } else if (_.async) {\n        // return promise for non-blocking async loading\n        const p = df.request(_.url, _.format).then(res => {\n          this._pending = vegaUtil.array(res.data);\n          return df => df.touch(this);\n        });\n        return {async: p};\n      } else {\n        // return promise for synchronous loading\n        return df.request(_.url, _.format)\n          .then(res => output(this, pulse, vegaUtil.array(res.data)));\n      }\n    }\n  });\n\n  function stop(_) {\n    return _.modified('async') && !(\n      _.modified('values') || _.modified('url') || _.modified('format')\n    );\n  }\n\n  function output(op, pulse, data) {\n    data.forEach(vegaDataflow.ingest);\n    const out = pulse.fork(pulse.NO_FIELDS & pulse.NO_SOURCE);\n    out.rem = op.value;\n    op.value = out.source = out.add = data;\n    op._pending = null;\n    if (out.rem.length) out.clean(true);\n    return out;\n  }\n\n  /**\n   * Extend tuples by joining them with values from a lookup table.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Map} params.index - The lookup table map.\n   * @param {Array<function(object): *} params.fields - The fields to lookup.\n   * @param {Array<string>} params.as - Output field names for each lookup value.\n   * @param {*} [params.default] - A default value to use if lookup fails.\n   */\n  function Lookup(params) {\n    vegaDataflow.Transform.call(this, {}, params);\n  }\n\n  Lookup.Definition = {\n    'type': 'Lookup',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'index', 'type': 'index', 'params': [\n          {'name': 'from', 'type': 'data', 'required': true },\n          {'name': 'key', 'type': 'field', 'required': true }\n        ] },\n      { 'name': 'values', 'type': 'field', 'array': true },\n      { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\n      { 'name': 'as', 'type': 'string', 'array': true },\n      { 'name': 'default', 'default': null }\n    ]\n  };\n\n  vegaUtil.inherits(Lookup, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const keys = _.fields,\n            index = _.index,\n            values = _.values,\n            defaultValue = _.default==null ? null : _.default,\n            reset = _.modified(),\n            n = keys.length;\n\n      let flag = reset ? pulse.SOURCE : pulse.ADD,\n          out = pulse,\n          as = _.as,\n          set, m, mods;\n\n      if (values) {\n        m = values.length;\n\n        if (n > 1 && !as) {\n          vegaUtil.error('Multi-field lookup requires explicit \"as\" parameter.');\n        }\n        if (as && as.length !== n * m) {\n          vegaUtil.error('The \"as\" parameter has too few output field names.');\n        }\n        as = as || values.map(vegaUtil.accessorName);\n\n        set = function(t) {\n          for (var i=0, k=0, j, v; i<n; ++i) {\n            v = index.get(keys[i](t));\n            if (v == null) for (j=0; j<m; ++j, ++k) t[as[k]] = defaultValue;\n            else for (j=0; j<m; ++j, ++k) t[as[k]] = values[j](v);\n          }\n        };\n      } else {\n        if (!as) {\n          vegaUtil.error('Missing output field names.');\n        }\n\n        set = function(t) {\n          for (var i=0, v; i<n; ++i) {\n            v = index.get(keys[i](t));\n            t[as[i]] = v==null ? defaultValue : v;\n          }\n        };\n      }\n\n      if (reset) {\n        out = pulse.reflow(true);\n      } else {\n        mods = keys.some(k =>pulse.modified(k.fields));\n        flag |= (mods ? pulse.MOD : 0);\n      }\n      pulse.visit(flag, set);\n\n      return out.modifies(as);\n    }\n  });\n\n  /**\n   * Computes global min/max extents over a collection of extents.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<Array<number>>} params.extents - The input extents.\n   */\n  function MultiExtent(params) {\n    vegaDataflow.Operator.call(this, null, update$4, params);\n  }\n\n  vegaUtil.inherits(MultiExtent, vegaDataflow.Operator);\n\n  function update$4(_) {\n    if (this.value && !_.modified()) {\n      return this.value;\n    }\n\n    const ext = _.extents,\n          n = ext.length;\n\n    let min = +Infinity,\n        max = -Infinity,\n        i, e;\n\n    for (i = 0; i < n; ++i) {\n      e = ext[i];\n      if (e[0] < min) min = e[0];\n      if (e[1] > max) max = e[1];\n    }\n    return [min, max];\n  }\n\n  /**\n   * Merge a collection of value arrays.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<Array<*>>} params.values - The input value arrrays.\n   */\n  function MultiValues(params) {\n    vegaDataflow.Operator.call(this, null, update$5, params);\n  }\n\n  vegaUtil.inherits(MultiValues, vegaDataflow.Operator);\n\n  function update$5(_) {\n    return (this.value && !_.modified())\n      ? this.value\n      : _.values.reduce((data, _) => data.concat(_), []);\n  }\n\n  /**\n   * Operator whose value is simply its parameter hash. This operator is\n   * useful for enabling reactive updates to values of nested objects.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   */\n  function Params(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  vegaUtil.inherits(Params, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      this.modified(_.modified());\n      this.value = _;\n      return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS); // do not pass tuples\n    }\n  });\n\n  /**\n   * Aggregate and pivot selected field values to become new fields.\n   * This operator is useful to construction cross-tabulations.\n   * @constructor\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n   *  to groupby. These fields act just like groupby fields of an Aggregate transform.\n   * @param {function(object): *} params.field - The field to pivot on. The unique\n   *  values of this field become new field names in the output stream.\n   * @param {function(object): *} params.value - The field to populate pivoted fields.\n   *  The aggregate values of this field become the values of the new pivoted fields.\n   * @param {string} [params.op] - The aggregation operation for the value field,\n   *  applied per cell in the output stream. The default is \"sum\".\n   * @param {number} [params.limit] - An optional parameter indicating the maximum\n   *  number of pivoted fields to generate. The pivoted field names are sorted in\n   *  ascending order prior to enforcing the limit.\n   */\n  function Pivot(params) {\n    Aggregate.call(this, params);\n  }\n\n  Pivot.Definition = {\n    'type': 'Pivot',\n    'metadata': {'generates': true, 'changes': true},\n    'params': [\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'field', 'type': 'field', 'required': true },\n      { 'name': 'value', 'type': 'field', 'required': true },\n      { 'name': 'op', 'type': 'enum', 'values': ValidAggregateOps, 'default': 'sum' },\n      { 'name': 'limit', 'type': 'number', 'default': 0 },\n      { 'name': 'key', 'type': 'field' }\n    ]\n  };\n\n  vegaUtil.inherits(Pivot, Aggregate, {\n    _transform: Aggregate.prototype.transform,\n    transform(_, pulse) {\n      return this._transform(aggregateParams(_, pulse), pulse);\n    }\n  });\n\n  // Shoehorn a pivot transform into an aggregate transform!\n  // First collect all unique pivot field values.\n  // Then generate aggregate fields for each output pivot field.\n  function aggregateParams(_, pulse) {\n    const key    = _.field,\n          value  = _.value,\n          op     = (_.op === 'count' ? '__count__' : _.op) || 'sum',\n          fields = vegaUtil.accessorFields(key).concat(vegaUtil.accessorFields(value)),\n          keys   = pivotKeys(key, _.limit || 0, pulse);\n\n    // if data stream content changes, pivot fields may change\n    // flag parameter modification to ensure re-initialization\n    if (pulse.changed()) _.set('__pivot__', null, null, true);\n\n    return {\n      key:      _.key,\n      groupby:  _.groupby,\n      ops:      keys.map(() => op),\n      fields:   keys.map(k => get(k, key, value, fields)),\n      as:       keys.map(k => k + ''),\n      modified: _.modified.bind(_)\n    };\n  }\n\n  // Generate aggregate field accessor.\n  // Output NaN for non-existent values; aggregator will ignore!\n  function get(k, key, value, fields) {\n    return vegaUtil.accessor(\n      d => key(d) === k ? value(d) : NaN,\n      fields,\n      k + ''\n    );\n  }\n\n  // Collect (and optionally limit) all unique pivot values.\n  function pivotKeys(key, limit, pulse) {\n    const map = {},\n          list = [];\n\n    pulse.visit(pulse.SOURCE, t => {\n      const k = key(t);\n      if (!map[k]) {\n        map[k] = 1;\n        list.push(k);\n      }\n    });\n\n    list.sort(vegaUtil.ascending);\n\n    return limit ? list.slice(0, limit) : list;\n  }\n\n  /**\n   * Partitions pre-faceted data into tuple subflows.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(Dataflow, string): Operator} params.subflow - A function\n   *   that generates a subflow of operators and returns its root operator.\n   * @param {function(object): Array<object>} params.field - The field\n   *   accessor for an array of subflow tuple objects.\n   */\n  function PreFacet(params) {\n    Facet.call(this, params);\n  }\n\n  vegaUtil.inherits(PreFacet, Facet, {\n    transform(_, pulse) {\n      const flow = _.subflow,\n            field = _.field,\n            subflow = t => this.subflow(vegaDataflow.tupleid(t), flow, pulse, t);\n\n      if (_.modified('field') || field && pulse.modified(vegaUtil.accessorFields(field))) {\n        vegaUtil.error('PreFacet does not support field modification.');\n      }\n\n      this.initTargets(); // reset list of active subflows\n\n      if (field) {\n        pulse.visit(pulse.MOD, t => {\n          const sf = subflow(t);\n          field(t).forEach(_ => sf.mod(_));\n        });\n\n        pulse.visit(pulse.ADD, t => {\n          const sf = subflow(t);\n          field(t).forEach(_ => sf.add(vegaDataflow.ingest(_)));\n        });\n\n        pulse.visit(pulse.REM, t => {\n          const sf = subflow(t);\n          field(t).forEach(_ => sf.rem(_));\n        });\n      } else {\n        pulse.visit(pulse.MOD, t => subflow(t).mod(t));\n        pulse.visit(pulse.ADD, t => subflow(t).add(t));\n        pulse.visit(pulse.REM, t => subflow(t).rem(t));\n      }\n\n      if (pulse.clean()) {\n        pulse.runAfter(() => this.clean());\n      }\n\n      return pulse;\n    }\n  });\n\n  /**\n   * Performs a relational projection, copying selected fields from source\n   * tuples to a new set of derived tuples.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<function(object): *} params.fields - The fields to project,\n   *   as an array of field accessors. If unspecified, all fields will be\n   *   copied with names unchanged.\n   * @param {Array<string>} [params.as] - Output field names for each projected\n   *   field. Any unspecified fields will use the field name provided by\n   *   the field accessor.\n   */\n  function Project(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Project.Definition = {\n    'type': 'Project',\n    'metadata': {'generates': true, 'changes': true},\n    'params': [\n      { 'name': 'fields', 'type': 'field', 'array': true },\n      { 'name': 'as', 'type': 'string', 'null': true, 'array': true }\n    ]\n  };\n\n  vegaUtil.inherits(Project, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE),\n            fields = _.fields,\n            as = fieldNames(_.fields, _.as || []),\n            derive = fields\n              ? (s, t) => project(s, t, fields, as)\n              : vegaDataflow.rederive;\n\n      let lut;\n      if (this.value) {\n        lut = this.value;\n      } else {\n        pulse = pulse.addAll();\n        lut = this.value = {};\n      }\n\n      pulse.visit(pulse.REM, t => {\n        const id = vegaDataflow.tupleid(t);\n        out.rem.push(lut[id]);\n        lut[id] = null;\n      });\n\n      pulse.visit(pulse.ADD, t => {\n        const dt = derive(t, vegaDataflow.ingest({}));\n        lut[vegaDataflow.tupleid(t)] = dt;\n        out.add.push(dt);\n      });\n\n      pulse.visit(pulse.MOD, t => {\n        out.mod.push(derive(t, lut[vegaDataflow.tupleid(t)]));\n      });\n\n      return out;\n    }\n  });\n\n  function project(s, t, fields, as) {\n    for (let i=0, n=fields.length; i<n; ++i) {\n      t[as[i]] = fields[i](s);\n    }\n    return t;\n  }\n\n  /**\n   * Proxy the value of another operator as a pure signal value.\n   * Ensures no tuples are propagated.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {*} params.value - The value to proxy, becomes the value of this operator.\n   */\n  function Proxy(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  vegaUtil.inherits(Proxy, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      this.value = _.value;\n      return _.modified('value')\n        ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS)\n        : pulse.StopPropagation;\n    }\n  });\n\n  /**\n   * Generates sample quantile values from an input data stream.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - An accessor for the data field\n   *   over which to calculate quantile values.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n   *   to groupby.\n   * @param {Array<number>} [params.probs] - An array of probabilities in\n   *   the range (0, 1) for which to compute quantile values. If not specified,\n   *   the *step* parameter will be used.\n   * @param {Array<number>} [params.step=0.01] - A probability step size for\n   *   sampling quantile values. All values from one-half the step size up to\n   *   1 (exclusive) will be sampled. This parameter is only used if the\n   *   *quantiles* parameter is not provided.\n   */\n  function Quantile(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Quantile.Definition = {\n    'type': 'Quantile',\n    'metadata': {'generates': true, 'changes': true},\n    'params': [\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'field', 'type': 'field', 'required': true },\n      { 'name': 'probs', 'type': 'number', 'array': true },\n      { 'name': 'step', 'type': 'number', 'default': 0.01 },\n      { 'name': 'as', 'type': 'string', 'array': true, 'default': ['prob', 'value'] }\n    ]\n  };\n\n  const EPSILON$1 = 1e-14;\n\n  vegaUtil.inherits(Quantile, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n            as = _.as || ['prob', 'value'];\n\n      if (this.value && !_.modified() && !pulse.changed()) {\n        out.source = this.value;\n        return out;\n      }\n\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby, _.field),\n            names = (_.groupby || []).map(vegaUtil.accessorName),\n            values = [],\n            step = _.step || 0.01,\n            p = _.probs || d3Array.range(step/2, 1 - EPSILON$1, step),\n            n = p.length;\n\n      groups.forEach(g => {\n        const q = vegaStatistics.quantiles(g, p);\n\n        for (let i=0; i<n; ++i) {\n          const t = {};\n          for (let i=0; i<names.length; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n          t[as[0]] = p[i];\n          t[as[1]] = q[i];\n          values.push(vegaDataflow.ingest(t));\n        }\n      });\n\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n\n      return out;\n    }\n  });\n\n  /**\n   * Relays a data stream between data processing pipelines.\n   * If the derive parameter is set, this transform will create derived\n   * copies of observed tuples. This provides derived data streams in which\n   * modifications to the tuples do not pollute an upstream data source.\n   * @param {object} params - The parameters for this operator.\n   * @param {number} [params.derive=false] - Boolean flag indicating if\n   *   the transform should make derived copies of incoming tuples.\n   * @constructor\n   */\n  function Relay(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  vegaUtil.inherits(Relay, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      let out, lut;\n\n      if (this.value) {\n        lut = this.value;\n      } else {\n        out = pulse = pulse.addAll();\n        lut = this.value = {};\n      }\n\n      if (_.derive) {\n        out = pulse.fork(pulse.NO_SOURCE);\n\n        pulse.visit(pulse.REM, t => {\n          const id = vegaDataflow.tupleid(t);\n          out.rem.push(lut[id]);\n          lut[id] = null;\n        });\n\n        pulse.visit(pulse.ADD, t => {\n          const dt = vegaDataflow.derive(t);\n          lut[vegaDataflow.tupleid(t)] = dt;\n          out.add.push(dt);\n        });\n\n        pulse.visit(pulse.MOD, t => {\n          const dt = lut[vegaDataflow.tupleid(t)];\n          for (const k in t) {\n            dt[k] = t[k];\n            // down stream writes may overwrite re-derived tuples\n            // conservatively mark all source fields as modified\n            out.modifies(k);\n          }\n          out.mod.push(dt);\n        });\n      }\n\n      return out;\n    }\n  });\n\n  /**\n   * Samples tuples passing through this operator.\n   * Uses reservoir sampling to maintain a representative sample.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {number} [params.size=1000] - The maximum number of samples.\n   */\n  function Sample(params) {\n    vegaDataflow.Transform.call(this, [], params);\n    this.count = 0;\n  }\n\n  Sample.Definition = {\n    'type': 'Sample',\n    'metadata': {},\n    'params': [\n      { 'name': 'size', 'type': 'number', 'default': 1000 }\n    ]\n  };\n\n  vegaUtil.inherits(Sample, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE),\n            mod = _.modified('size'),\n            num = _.size,\n            map = this.value.reduce((m, t) => (m[vegaDataflow.tupleid(t)] = 1, m), {});\n\n      let res = this.value,\n          cnt = this.count,\n          cap = 0;\n\n      // sample reservoir update function\n      function update(t) {\n        let p, idx;\n\n        if (res.length < num) {\n          res.push(t);\n        } else {\n          idx = ~~((cnt + 1) * vegaStatistics.random());\n          if (idx < res.length && idx >= cap) {\n            p = res[idx];\n            if (map[vegaDataflow.tupleid(p)]) out.rem.push(p); // eviction\n            res[idx] = t;\n          }\n        }\n        ++cnt;\n      }\n\n      if (pulse.rem.length) {\n        // find all tuples that should be removed, add to output\n        pulse.visit(pulse.REM, t => {\n          const id = vegaDataflow.tupleid(t);\n          if (map[id]) {\n            map[id] = -1;\n            out.rem.push(t);\n          }\n          --cnt;\n        });\n\n        // filter removed tuples out of the sample reservoir\n        res = res.filter(t => map[vegaDataflow.tupleid(t)] !== -1);\n      }\n\n      if ((pulse.rem.length || mod) && res.length < num && pulse.source) {\n        // replenish sample if backing data source is available\n        cap = cnt = res.length;\n        pulse.visit(pulse.SOURCE, t => {\n          // update, but skip previously sampled tuples\n          if (!map[vegaDataflow.tupleid(t)]) update(t);\n        });\n        cap = -1;\n      }\n\n      if (mod && res.length > num) {\n        const n = res.length-num;\n        for (let i=0; i<n; ++i) {\n          map[vegaDataflow.tupleid(res[i])] = -1;\n          out.rem.push(res[i]);\n        }\n        res = res.slice(n);\n      }\n\n      if (pulse.mod.length) {\n        // propagate modified tuples in the sample reservoir\n        pulse.visit(pulse.MOD, t => {\n          if (map[vegaDataflow.tupleid(t)]) out.mod.push(t);\n        });\n      }\n\n      if (pulse.add.length) {\n        // update sample reservoir\n        pulse.visit(pulse.ADD, update);\n      }\n\n      if (pulse.add.length || cap < 0) {\n        // output newly added tuples\n        out.add = res.filter(t => !map[vegaDataflow.tupleid(t)]);\n      }\n\n      this.count = cnt;\n      this.value = out.source = res;\n      return out;\n    }\n  });\n\n  /**\n   * Generates data tuples for a specified sequence range of numbers.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {number} params.start - The first number in the sequence.\n   * @param {number} params.stop - The last number (exclusive) in the sequence.\n   * @param {number} [params.step=1] - The step size between numbers in the sequence.\n   */\n  function Sequence(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Sequence.Definition = {\n    'type': 'Sequence',\n    'metadata': {'generates': true, 'changes': true},\n    'params': [\n      { 'name': 'start', 'type': 'number', 'required': true },\n      { 'name': 'stop', 'type': 'number', 'required': true },\n      { 'name': 'step', 'type': 'number', 'default': 1 },\n      { 'name': 'as', 'type': 'string', 'default': 'data' }\n    ]\n  };\n\n  vegaUtil.inherits(Sequence, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      if (this.value && !_.modified()) return;\n\n      const out = pulse.materialize().fork(pulse.MOD),\n            as = _.as || 'data';\n\n      out.rem = this.value ? pulse.rem.concat(this.value) : pulse.rem;\n\n      this.value = d3Array.range(_.start, _.stop, _.step || 1).map(v => {\n        const t = {};\n        t[as] = v;\n        return vegaDataflow.ingest(t);\n      });\n\n      out.add = pulse.add.concat(this.value);\n\n      return out;\n    }\n  });\n\n  /**\n   * Propagates a new pulse without any tuples so long as the input\n   * pulse contains some added, removed or modified tuples.\n   * @param {object} params - The parameters for this operator.\n   * @constructor\n   */\n  function Sieve(params) {\n    vegaDataflow.Transform.call(this, null, params);\n    this.modified(true); // always treat as modified\n  }\n\n  vegaUtil.inherits(Sieve, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      this.value = pulse.source;\n      return pulse.changed()\n        ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS)\n        : pulse.StopPropagation;\n    }\n  });\n\n  /**\n   * Discretize dates to specific time units.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - The data field containing date/time values.\n   */\n  function TimeUnit(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  const OUTPUT = ['unit0', 'unit1'];\n\n  TimeUnit.Definition = {\n    'type': 'TimeUnit',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'field', 'type': 'field', 'required': true },\n      { 'name': 'interval', 'type': 'boolean', 'default': true },\n      { 'name': 'units', 'type': 'enum', 'values': vegaTime.TIME_UNITS, 'array': true },\n      { 'name': 'step', 'type': 'number', 'default': 1 },\n      { 'name': 'maxbins', 'type': 'number', 'default': 40 },\n      { 'name': 'extent', 'type': 'date', 'array': true},\n      { 'name': 'timezone', 'type': 'enum', 'default': 'local', 'values': ['local', 'utc'] },\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': OUTPUT }\n    ]\n  };\n\n  vegaUtil.inherits(TimeUnit, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const field = _.field,\n            band = _.interval !== false,\n            utc = _.timezone === 'utc',\n            floor = this._floor(_, pulse),\n            offset = (utc ? vegaTime.utcInterval : vegaTime.timeInterval)(floor.unit).offset,\n            as = _.as || OUTPUT,\n            u0 = as[0],\n            u1 = as[1],\n            step = floor.step;\n\n      let min = floor.start || Infinity,\n          max = floor.stop || -Infinity,\n          flag = pulse.ADD;\n\n      if (_.modified() || pulse.modified(vegaUtil.accessorFields(field))) {\n        pulse = pulse.reflow(true);\n        flag = pulse.SOURCE;\n        min = Infinity;\n        max = -Infinity;\n      }\n\n      pulse.visit(flag, t => {\n        const v = field(t);\n        let a, b;\n        if (v == null) {\n          t[u0] = null;\n          if (band) t[u1] = null;\n        } else {\n          t[u0] = a = b = floor(v);\n          if (band) t[u1] = b = offset(a, step);\n          if (a < min) min = a;\n          if (b > max) max = b;\n        }\n      });\n\n      floor.start = min;\n      floor.stop = max;\n\n      return pulse.modifies(band ? as : u0);\n    },\n\n    _floor(_, pulse) {\n      const utc = _.timezone === 'utc';\n\n      // get parameters\n      const {units, step} = _.units\n        ? {units: _.units, step: _.step || 1}\n        : vegaTime.timeBin({\n          extent:  _.extent || vegaUtil.extent(pulse.materialize(pulse.SOURCE).source, _.field),\n          maxbins: _.maxbins\n        });\n\n      // check / standardize time units\n      const tunits = vegaTime.timeUnits(units),\n            prev = this.value || {},\n            floor = (utc ? vegaTime.utcFloor : vegaTime.timeFloor)(tunits, step);\n\n      floor.unit = vegaUtil.peek(tunits);\n      floor.units = tunits;\n      floor.step = step;\n      floor.start = prev.start;\n      floor.stop = prev.stop;\n      return this.value = floor;\n    }\n  });\n\n  /**\n   * An index that maps from unique, string-coerced, field values to tuples.\n   * Assumes that the field serves as a unique key with no duplicate values.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - The field accessor to index.\n   */\n  function TupleIndex(params) {\n    vegaDataflow.Transform.call(this, vegaUtil.fastmap(), params);\n  }\n\n  vegaUtil.inherits(TupleIndex, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const df = pulse.dataflow,\n          field = _.field,\n          index = this.value,\n          set = t => index.set(field(t), t);\n\n      let mod = true;\n\n      if (_.modified('field') || pulse.modified(field.fields)) {\n        index.clear();\n        pulse.visit(pulse.SOURCE, set);\n      } else if (pulse.changed()) {\n        pulse.visit(pulse.REM, t => index.delete(field(t)));\n        pulse.visit(pulse.ADD, set);\n      } else {\n        mod = false;\n      }\n\n      this.modified(mod);\n      if (index.empty > df.cleanThreshold) df.runAfter(index.clean);\n      return pulse.fork();\n    }\n  });\n\n  /**\n   * Extracts an array of values. Assumes the source data has already been\n   * reduced as needed (e.g., by an upstream Aggregate transform).\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.field - The domain field to extract.\n   * @param {function(*,*): number} [params.sort] - An optional\n   *   comparator function for sorting the values. The comparator will be\n   *   applied to backing tuples prior to value extraction.\n   */\n  function Values(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  vegaUtil.inherits(Values, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const run = !this.value\n        || _.modified('field')\n        || _.modified('sort')\n        || pulse.changed()\n        || (_.sort && pulse.modified(_.sort.fields));\n\n      if (run) {\n        this.value = (_.sort\n          ? pulse.source.slice().sort(vegaDataflow.stableCompare(_.sort))\n          : pulse.source).map(_.field);\n      }\n    }\n  });\n\n  function WindowOp(op, field, param, as) {\n    const fn = WindowOps[op](field, param);\n    return {\n      init:   fn.init || vegaUtil.zero,\n      update: function(w, t) { t[as] = fn.next(w); }\n    };\n  }\n\n  const WindowOps = {\n    row_number: function() {\n      return {\n        next: w => w.index + 1\n      };\n    },\n    rank: function() {\n      let rank;\n      return {\n        init: () => rank = 1,\n        next: w => {\n          const i = w.index,\n                data = w.data;\n          return (i && w.compare(data[i - 1], data[i])) ? (rank = i + 1) : rank;\n        }\n      };\n    },\n    dense_rank: function() {\n      let drank;\n      return {\n        init: () => drank = 1,\n        next: w => {\n          const i = w.index,\n                d = w.data;\n          return (i && w.compare(d[i - 1], d[i])) ? ++drank : drank;\n        }\n      };\n    },\n    percent_rank: function() {\n      const rank = WindowOps.rank(),\n            next = rank.next;\n      return {\n        init: rank.init,\n        next: w => (next(w) - 1) / (w.data.length - 1)\n      };\n    },\n    cume_dist: function() {\n      let cume;\n      return {\n        init: () => cume = 0,\n        next: w => {\n          const d = w.data,\n                c = w.compare;\n          let i = w.index;\n          if (cume < i) {\n            while (i + 1 < d.length && !c(d[i], d[i + 1])) ++i;\n            cume = i;\n          }\n          return (1 + cume) / d.length;\n        }\n      };\n    },\n    ntile: function(field, num) {\n      num = +num;\n      if (!(num > 0)) vegaUtil.error('ntile num must be greater than zero.');\n      const cume = WindowOps.cume_dist(),\n            next = cume.next;\n      return {\n        init: cume.init,\n        next: w => Math.ceil(num * next(w))\n      };\n    },\n\n    lag: function(field, offset) {\n      offset = +offset || 1;\n      return {\n        next: w => {\n          const i = w.index - offset;\n          return i >= 0 ? field(w.data[i]) : null;\n        }\n      };\n    },\n    lead: function(field, offset) {\n      offset = +offset || 1;\n      return {\n        next: w => {\n          const i = w.index + offset,\n              d = w.data;\n          return i < d.length ? field(d[i]) : null;\n        }\n      };\n    },\n\n    first_value: function(field) {\n      return {\n        next: w => field(w.data[w.i0])\n      };\n    },\n    last_value: function(field) {\n      return {\n        next: w => field(w.data[w.i1 - 1])\n      };\n    },\n    nth_value: function(field, nth) {\n      nth = +nth;\n      if (!(nth > 0)) vegaUtil.error('nth_value nth must be greater than zero.');\n      return {\n        next: w => {\n          const i = w.i0 + (nth - 1);\n          return i < w.i1 ? field(w.data[i]) : null;\n        }\n      };\n    },\n\n    prev_value: function(field) {\n      let prev;\n      return {\n        init: () => prev = null,\n        next: w => {\n          const v = field(w.data[w.index]);\n          return v != null ? (prev = v) : prev;\n        }\n      };\n    },\n    next_value: function(field) {\n      let v, i;\n      return {\n        init: () => (v = null, i = -1),\n        next: w => {\n          const d = w.data;\n          return w.index <= i ? v\n            : (i = find(field, d, w.index)) < 0\n              ? (i = d.length, v = null)\n              : (v = field(d[i]));\n        }\n      };\n    }\n  };\n\n  function find(field, data, index) {\n    for (let n = data.length; index < n; ++index) {\n      const v = field(data[index]);\n      if (v != null) return index;\n    }\n    return -1;\n  }\n\n  const ValidWindowOps = Object.keys(WindowOps);\n\n  function WindowState(_) {\n    const ops = vegaUtil.array(_.ops),\n          fields = vegaUtil.array(_.fields),\n          params = vegaUtil.array(_.params),\n          as = vegaUtil.array(_.as),\n          outputs = this.outputs = [],\n          windows = this.windows = [],\n          inputs = {},\n          map = {},\n          counts = [],\n          measures = [];\n\n    let countOnly = true;\n\n    function visitInputs(f) {\n      vegaUtil.array(vegaUtil.accessorFields(f)).forEach(_ => inputs[_] = 1);\n    }\n    visitInputs(_.sort);\n\n    ops.forEach((op, i) => {\n      const field = fields[i],\n            mname = vegaUtil.accessorName(field),\n            name = measureName(op, mname, as[i]);\n\n      visitInputs(field);\n      outputs.push(name);\n\n      // Window operation\n      if (vegaUtil.hasOwnProperty(WindowOps, op)) {\n        windows.push(WindowOp(op, fields[i], params[i], name));\n      }\n\n      // Aggregate operation\n      else {\n        if (field == null && op !== 'count') {\n          vegaUtil.error('Null aggregate field specified.');\n        }\n        if (op === 'count') {\n          counts.push(name);\n          return;\n        }\n\n        countOnly = false;\n        let m = map[mname];\n        if (!m) {\n          m = (map[mname] = []);\n          m.field = field;\n          measures.push(m);\n        }\n        m.push(createMeasure(op, name));\n      }\n    });\n\n    if (counts.length || measures.length) {\n      this.cell = cell(measures, counts, countOnly);\n    }\n\n    this.inputs = Object.keys(inputs);\n  }\n\n  const prototype$1 = WindowState.prototype;\n\n  prototype$1.init = function() {\n    this.windows.forEach(_ => _.init());\n    if (this.cell) this.cell.init();\n  };\n\n  prototype$1.update = function(w, t) {\n    const cell = this.cell,\n          wind = this.windows,\n          data = w.data,\n          m = wind && wind.length;\n    let j;\n\n    if (cell) {\n      for (j = w.p0; j < w.i0; ++j) cell.rem(data[j]);\n      for (j = w.p1; j < w.i1; ++j) cell.add(data[j]);\n      cell.set(t);\n    }\n    for (j = 0; j < m; ++j) wind[j].update(w, t);\n  };\n\n  function cell(measures, counts, countOnly) {\n    measures = measures.map(m => compileMeasures(m, m.field));\n\n    const cell = {\n      num:   0,\n      agg:   null,\n      store: false,\n      count: counts\n    };\n\n    if (!countOnly) {\n      var n = measures.length,\n          a = cell.agg = Array(n),\n          i = 0;\n      for (; i<n; ++i) a[i] = new measures[i](cell);\n    }\n\n    if (cell.store) {\n      var store = cell.data = new TupleStore();\n    }\n\n    cell.add = function(t) {\n      cell.num += 1;\n      if (countOnly) return;\n      if (store) store.add(t);\n      for (let i=0; i<n; ++i) {\n        a[i].add(a[i].get(t), t);\n      }\n    };\n\n    cell.rem = function(t) {\n      cell.num -= 1;\n      if (countOnly) return;\n      if (store) store.rem(t);\n      for (let i=0; i<n; ++i) {\n        a[i].rem(a[i].get(t), t);\n      }\n    };\n\n    cell.set = function(t) {\n      let i, n;\n\n      // consolidate stored values\n      if (store) store.values();\n\n      // update tuple properties\n      for (i=0, n=counts.length; i<n; ++i) t[counts[i]] = cell.num;\n      if (!countOnly) for (i=0, n=a.length; i<n; ++i) a[i].set(t);\n    };\n\n    cell.init = function() {\n      cell.num = 0;\n      if (store) store.reset();\n      for (let i=0; i<n; ++i) a[i].init();\n    };\n\n    return cell;\n  }\n\n  /**\n   * Perform window calculations and write results to the input stream.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(*,*): number} [params.sort] - A comparator function for sorting tuples within a window.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors by which to partition tuples into separate windows.\n   * @param {Array<string>} params.ops - An array of strings indicating window operations to perform.\n   * @param {Array<function(object): *>} [params.fields] - An array of accessors\n   *   for data fields to use as inputs to window operations.\n   * @param {Array<*>} [params.params] - An array of parameter values for window operations.\n   * @param {Array<string>} [params.as] - An array of output field names for window operations.\n   * @param {Array<number>} [params.frame] - Window frame definition as two-element array.\n   * @param {boolean} [params.ignorePeers=false] - If true, base window frame boundaries on row\n   *   number alone, ignoring peers with identical sort values. If false (default),\n   *   the window boundaries will be adjusted to include peer values.\n   */\n  function Window(params) {\n    vegaDataflow.Transform.call(this, {}, params);\n    this._mlen = 0;\n    this._mods = [];\n  }\n\n  Window.Definition = {\n    'type': 'Window',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'sort', 'type': 'compare' },\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'ops', 'type': 'enum', 'array': true, 'values': ValidWindowOps.concat(ValidAggregateOps) },\n      { 'name': 'params', 'type': 'number', 'null': true, 'array': true },\n      { 'name': 'fields', 'type': 'field', 'null': true, 'array': true },\n      { 'name': 'as', 'type': 'string', 'null': true, 'array': true },\n      { 'name': 'frame', 'type': 'number', 'null': true, 'array': true, 'length': 2, 'default': [null, 0] },\n      { 'name': 'ignorePeers', 'type': 'boolean', 'default': false }\n    ]\n  };\n\n  vegaUtil.inherits(Window, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      this.stamp = pulse.stamp;\n\n      const mod = _.modified(),\n            cmp = vegaDataflow.stableCompare(_.sort),\n            key = groupkey(_.groupby),\n            group = t => this.group(key(t));\n\n      // initialize window state\n      let state = this.state;\n      if (!state || mod) {\n        state = this.state = new WindowState(_);\n      }\n\n      // partition input tuples\n      if (mod || pulse.modified(state.inputs)) {\n        this.value = {};\n        pulse.visit(pulse.SOURCE, t => group(t).add(t));\n      } else {\n        pulse.visit(pulse.REM, t => group(t).remove(t));\n        pulse.visit(pulse.ADD, t => group(t).add(t));\n      }\n\n      // perform window calculations for each modified partition\n      for (let i=0, n=this._mlen; i<n; ++i) {\n        processPartition(this._mods[i], state, cmp, _);\n      }\n      this._mlen = 0;\n      this._mods = [];\n\n      // TODO don't reflow everything?\n      return pulse.reflow(mod).modifies(state.outputs);\n    },\n\n    group(key) {\n      let group = this.value[key];\n\n      if (!group) {\n        group = this.value[key] = SortedList(vegaDataflow.tupleid);\n        group.stamp = -1;\n      }\n\n      if (group.stamp < this.stamp) {\n        group.stamp = this.stamp;\n        this._mods[this._mlen++] = group;\n      }\n\n      return group;\n    }\n  });\n\n  function processPartition(list, state, cmp, _) {\n    const sort = _.sort,\n          range = sort && !_.ignorePeers,\n          frame = _.frame || [null, 0],\n          data = list.data(cmp), // use cmp for stable sort\n          n = data.length,\n          b = range ? d3Array.bisector(sort) : null,\n          w = {\n            i0: 0, i1: 0, p0: 0, p1: 0, index: 0,\n            data: data, compare: sort || vegaUtil.constant(-1)\n          };\n\n    state.init();\n    for (let i=0; i<n; ++i) {\n      setWindow(w, frame, i, n);\n      if (range) adjustRange(w, b);\n      state.update(w, data[i]);\n    }\n  }\n\n  function setWindow(w, f, i, n) {\n    w.p0 = w.i0;\n    w.p1 = w.i1;\n    w.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));\n    w.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);\n    w.index = i;\n  }\n\n  // if frame type is 'range', adjust window for peer values\n  function adjustRange(w, bisect) {\n    const r0 = w.i0,\n          r1 = w.i1 - 1,\n          c = w.compare,\n          d = w.data,\n          n = d.length - 1;\n\n    if (r0 > 0 && !c(d[r0], d[r0-1])) w.i0 = bisect.left(d, d[r0]);\n    if (r1 < n && !c(d[r1], d[r1+1])) w.i1 = bisect.right(d, d[r1]);\n  }\n\n  exports.aggregate = Aggregate;\n  exports.bin = Bin;\n  exports.collect = Collect;\n  exports.compare = Compare;\n  exports.countpattern = CountPattern;\n  exports.cross = Cross;\n  exports.density = Density;\n  exports.dotbin = DotBin;\n  exports.expression = Expression;\n  exports.extent = Extent;\n  exports.facet = Facet;\n  exports.field = Field;\n  exports.filter = Filter;\n  exports.flatten = Flatten;\n  exports.fold = Fold;\n  exports.formula = Formula;\n  exports.generate = Generate;\n  exports.impute = Impute;\n  exports.joinaggregate = JoinAggregate;\n  exports.kde = KDE;\n  exports.key = Key;\n  exports.load = Load;\n  exports.lookup = Lookup;\n  exports.multiextent = MultiExtent;\n  exports.multivalues = MultiValues;\n  exports.params = Params;\n  exports.pivot = Pivot;\n  exports.prefacet = PreFacet;\n  exports.project = Project;\n  exports.proxy = Proxy;\n  exports.quantile = Quantile;\n  exports.relay = Relay;\n  exports.sample = Sample;\n  exports.sequence = Sequence;\n  exports.sieve = Sieve;\n  exports.subflow = Subflow;\n  exports.timeunit = TimeUnit;\n  exports.tupleindex = TupleIndex;\n  exports.values = Values;\n  exports.window = Window;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vega_time$build$vega_time","~$module$node_modules$vega_dataflow$build$vega_dataflow","~$shadow.js","~$module$node_modules$vega_statistics$build$vega_statistics","~$module$node_modules$vega_util$build$vega_util","~$module$node_modules$d3_array$dist$d3_array"]],"~:properties",["^5",["stop","_targets","window","_key","compare","countpattern","multiextent","_group","_drop","dims","values","min","dotbin","_countOnly","_add","_cross","row_number","_q","_parameterCheck","forEach","next","_outputs","_bins","joinaggregate","index","_keys","subflow","_finish","_ops","timeunit","params","average","_mlen","_tuples","ci","activate","pivot","group","argmax","mean","stderr","maxbins","q1","load","sum","last_value","sieve","ops","cross","detachSubflow","key","parent","project","__esModule","lead","newtuple","max","__count__","newcell","dense_rank","cell","groupby","generate","quartile","transform","stdevp","lookup","reset","root","argmin","vega","_pending","expression","_rem","rank","count","update","quantile","_prev","normal","async","impute","agg","_transform","_get","rem","_inputs","product","kde","uniform","i0","distinct","cellkey","req","name","sequence","p0","value","outputs","_ext","valid","evaluate","aggregate","connect","i1","_match","relay","dev","field","start","remove","fold","nth_value","bin","changes","domain","_mods","variancep","units","filter","windows","percent_rank","_ci","_alen","prefacet","ntile","stamp","out","lognormal","first_value","mod","multivalues","ci0","source","_dims","_measures","initTargets","Definition","state","init","fields","missing","modified","_floor","_adds","transforms","cume_dist","p1","unit","prev_value","collect","mixture","_dnames","add","set","inputs","num","variance","clean","facet","tuple","size","q2","next_value","_counts","flatten","active","idx","proxy","tupleindex","formula","q3","data","get","density","extent","stdev","store","as","celltuple","ci1","mean_d","_impute","sample","step","_out","lag","_stop","median"]],"~:compiled-at",1600144479856,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_transforms$build$vega_transforms.js\",\n\"lineCount\":113,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-transforms/build/vega-transforms.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_transforms$build$vega_transforms\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-dataflow'), require('vega-statistics'), require('d3-array'), require('vega-time')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-dataflow', 'vega-statistics', 'd3-array', 'vega-time'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.vega, global.d3, global.vega));\\n}(this, (function (exports, vegaUtil, vegaDataflow, vegaStatistics, d3Array, vegaTime) { 'use strict';\\n\\n  function multikey(f) {\\n    return x => {\\n      const n = f.length;\\n      let i = 1,\\n          k = String(f[0](x));\\n\\n      for (; i<n; ++i) {\\n        k += '|' + f[i](x);\\n      }\\n\\n      return k;\\n    };\\n  }\\n\\n  function groupkey(fields) {\\n    return !fields || !fields.length ? function() { return ''; }\\n      : fields.length === 1 ? fields[0]\\n      : multikey(fields);\\n  }\\n\\n  function measureName(op, field, as) {\\n    return as || (op + (!field ? '' : '_' + field));\\n  }\\n\\n  const noop = () => {};\\n\\n  const base_op = {\\n    init: noop,\\n    add:  noop,\\n    rem:  noop,\\n    idx:  0\\n  };\\n\\n  const AggregateOps = {\\n    values: {\\n      init:  m => m.cell.store = true,\\n      value: m => m.cell.data.values(),\\n      idx:  -1\\n    },\\n    count: {\\n      value: m => m.cell.num\\n    },\\n    __count__: {\\n      value: m => m.missing + m.valid\\n    },\\n    missing: {\\n      value: m => m.missing\\n    },\\n    valid: {\\n      value: m => m.valid\\n    },\\n    sum: {\\n      init:  m => m.sum = 0,\\n      value: m => m.sum,\\n      add:  (m, v) => m.sum += +v,\\n      rem:  (m, v) => m.sum -= v\\n    },\\n    product: {\\n      init:  m => m.product = 1,\\n      value: m => m.valid ? m.product : undefined,\\n      add:  (m, v) => m.product *= v,\\n      rem:  (m, v) => m.product /= v\\n    },\\n    mean: {\\n      init:  m => m.mean = 0,\\n      value: m => m.valid ? m.mean : undefined,\\n      add:  (m, v) => (m.mean_d = v - m.mean, m.mean += m.mean_d / m.valid),\\n      rem:  (m, v) => (m.mean_d = v - m.mean, m.mean -= m.valid ? m.mean_d / m.valid : m.mean)\\n    },\\n    average: {\\n      value: m => m.valid ? m.mean : undefined,\\n      req:  ['mean'], idx: 1\\n    },\\n    variance: {\\n      init:  m => m.dev = 0,\\n      value: m => m.valid > 1 ? m.dev / (m.valid - 1) : undefined,\\n      add:  (m, v) => m.dev += m.mean_d * (v - m.mean),\\n      rem:  (m, v) => m.dev -= m.mean_d * (v - m.mean),\\n      req:  ['mean'], idx: 1\\n    },\\n    variancep: {\\n      value: m => m.valid > 1 ? m.dev / m.valid : undefined,\\n      req:  ['variance'], idx: 2\\n    },\\n    stdev: {\\n      value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid - 1)) : undefined,\\n      req:  ['variance'], idx: 2\\n    },\\n    stdevp: {\\n      value: m => m.valid > 1 ? Math.sqrt(m.dev / m.valid) : undefined,\\n      req:  ['variance'], idx: 2\\n    },\\n    stderr: {\\n      value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid * (m.valid - 1))) : undefined,\\n      req:  ['variance'], idx: 2\\n    },\\n    distinct: {\\n      value: m => m.cell.data.distinct(m.get),\\n      req:  ['values'], idx: 3\\n    },\\n    ci0: {\\n      value: m => m.cell.data.ci0(m.get),\\n      req:  ['values'], idx: 3\\n    },\\n    ci1: {\\n      value: m => m.cell.data.ci1(m.get),\\n      req:  ['values'], idx: 3\\n    },\\n    median: {\\n      value: m => m.cell.data.q2(m.get),\\n      req:  ['values'], idx: 3\\n    },\\n    q1: {\\n      value: m => m.cell.data.q1(m.get),\\n      req: ['values'], idx: 3\\n    },\\n    q3: {\\n      value: m => m.cell.data.q3(m.get),\\n      req:  ['values'], idx: 3\\n    },\\n    min: {\\n      init:  m => m.min = undefined,\\n      value: m => m.min = (Number.isNaN(m.min) ? m.cell.data.min(m.get) : m.min),\\n      add:  (m, v) => { if (v < m.min || m.min === undefined) m.min = v; },\\n      rem:  (m, v) => { if (v <= m.min) m.min = NaN; },\\n      req:  ['values'], idx: 4\\n    },\\n    max: {\\n      init:  m => m.max = undefined,\\n      value: m => m.max = (Number.isNaN(m.max) ? m.cell.data.max(m.get) : m.max),\\n      add:  (m, v) => { if (v > m.max || m.max === undefined) m.max = v; },\\n      rem:  (m, v) => { if (v >= m.max) m.max = NaN; },\\n      req:  ['values'], idx: 4\\n    },\\n    argmin: {\\n      init:  m => m.argmin = undefined,\\n      value: m => m.argmin || m.cell.data.argmin(m.get),\\n      add:  (m, v, t) => { if (v < m.min) m.argmin = t; },\\n      rem:  (m, v) => { if (v <= m.min) m.argmin = undefined; },\\n      req:  ['min', 'values'], idx: 3\\n    },\\n    argmax: {\\n      init:  m => m.argmax = undefined,\\n      value: m => m.argmax || m.cell.data.argmax(m.get),\\n      add:  (m, v, t) => { if (v > m.max) m.argmax = t; },\\n      rem:  (m, v) => { if (v >= m.max) m.argmax = undefined; },\\n      req:  ['max', 'values'], idx: 3\\n    }\\n  };\\n\\n  const ValidAggregateOps = Object.keys(AggregateOps);\\n\\n  function measure(key, value) {\\n    return out => vegaUtil.extend({\\n      name: key,\\n      out: out || key\\n    }, base_op, value);\\n  }\\n\\n  ValidAggregateOps.forEach(key => {\\n    AggregateOps[key] = measure(key, AggregateOps[key]);\\n  });\\n\\n  function createMeasure(op, name) {\\n    return AggregateOps[op](name);\\n  }\\n\\n  function compareIndex(a, b) {\\n    return a.idx - b.idx;\\n  }\\n\\n  function resolve(agg) {\\n    const map = {};\\n    agg.forEach(a => map[a.name] = a);\\n\\n    const getreqs = a => {\\n      if (!a.req) return;\\n      a.req.forEach(key => {\\n        if (!map[key]) getreqs(map[key] = AggregateOps[key]());\\n      });\\n    };\\n    agg.forEach(getreqs);\\n\\n    return Object.values(map).sort(compareIndex);\\n  }\\n\\n  function init() {\\n    this.valid = 0;\\n    this.missing = 0;\\n    this._ops.forEach(op => op.init(this));\\n  }\\n\\n  function add(v, t) {\\n    if (v == null || v === '') { ++this.missing; return; }\\n    if (v !== v) return;\\n    ++this.valid;\\n    this._ops.forEach(op => op.add(this, v, t));\\n  }\\n\\n  function rem(v, t) {\\n    if (v == null || v === '') { --this.missing; return; }\\n    if (v !== v) return;\\n    --this.valid;\\n    this._ops.forEach(op => op.rem(this, v, t));\\n  }\\n\\n  function set(t) {\\n    this._out.forEach(op => t[op.out] = op.value(this));\\n    return t;\\n  }\\n\\n  function compileMeasures(agg, field) {\\n    const get = field || vegaUtil.identity,\\n          ops = resolve(agg),\\n          out = agg.slice().sort(compareIndex);\\n\\n    function ctr(cell) {\\n      this._ops = ops;\\n      this._out = out;\\n      this.cell = cell;\\n      this.init();\\n    }\\n\\n    ctr.prototype.init = init;\\n    ctr.prototype.add = add;\\n    ctr.prototype.rem = rem;\\n    ctr.prototype.set = set;\\n    ctr.prototype.get = get;\\n    ctr.fields = agg.map(op => op.out);\\n\\n    return ctr;\\n  }\\n\\n  function TupleStore(key) {\\n    this._key = key ? vegaUtil.field(key) : vegaDataflow.tupleid;\\n    this.reset();\\n  }\\n\\n  const prototype = TupleStore.prototype;\\n\\n  prototype.reset = function() {\\n    this._add = [];\\n    this._rem = [];\\n    this._ext = null;\\n    this._get = null;\\n    this._q = null;\\n  };\\n\\n  prototype.add = function(v) {\\n    this._add.push(v);\\n  };\\n\\n  prototype.rem = function(v) {\\n    this._rem.push(v);\\n  };\\n\\n  prototype.values = function() {\\n    this._get = null;\\n    if (this._rem.length === 0) return this._add;\\n\\n    const a = this._add,\\n          r = this._rem,\\n          k = this._key,\\n          n = a.length,\\n          m = r.length,\\n          x = Array(n - m),\\n          map = {};\\n    let i, j, v;\\n\\n    // use unique key field to clear removed values\\n    for (i=0; i<m; ++i) {\\n      map[k(r[i])] = 1;\\n    }\\n    for (i=0, j=0; i<n; ++i) {\\n      if (map[k(v = a[i])]) {\\n        map[k(v)] = 0;\\n      } else {\\n        x[j++] = v;\\n      }\\n    }\\n\\n    this._rem = [];\\n    return (this._add = x);\\n  };\\n\\n  // memoizing statistics methods\\n\\n  prototype.distinct = function(get) {\\n    const v = this.values(),\\n          map = {};\\n\\n    let n = v.length,\\n        count = 0, s;\\n\\n    while (--n >= 0) {\\n      s = get(v[n]) + '';\\n      if (!vegaUtil.hasOwnProperty(map, s)) {\\n        map[s] = 1;\\n        ++count;\\n      }\\n    }\\n\\n    return count;\\n  };\\n\\n  prototype.extent = function(get) {\\n    if (this._get !== get || !this._ext) {\\n      const v = this.values(),\\n            i = vegaUtil.extentIndex(v, get);\\n      this._ext = [v[i[0]], v[i[1]]];\\n      this._get = get;\\n    }\\n    return this._ext;\\n  };\\n\\n  prototype.argmin = function(get) {\\n    return this.extent(get)[0] || {};\\n  };\\n\\n  prototype.argmax = function(get) {\\n    return this.extent(get)[1] || {};\\n  };\\n\\n  prototype.min = function(get) {\\n    const m = this.extent(get)[0];\\n    return m != null ? get(m) : undefined;\\n  };\\n\\n  prototype.max = function(get) {\\n    const m = this.extent(get)[1];\\n    return m != null ? get(m) : undefined;\\n  };\\n\\n  prototype.quartile = function(get) {\\n    if (this._get !== get || !this._q) {\\n      this._q = vegaStatistics.quartiles(this.values(), get);\\n      this._get = get;\\n    }\\n    return this._q;\\n  };\\n\\n  prototype.q1 = function(get) {\\n    return this.quartile(get)[0];\\n  };\\n\\n  prototype.q2 = function(get) {\\n    return this.quartile(get)[1];\\n  };\\n\\n  prototype.q3 = function(get) {\\n    return this.quartile(get)[2];\\n  };\\n\\n  prototype.ci = function(get) {\\n    if (this._get !== get || !this._ci) {\\n      this._ci = vegaStatistics.bootstrapCI(this.values(), 1000, 0.05, get);\\n      this._get = get;\\n    }\\n    return this._ci;\\n  };\\n\\n  prototype.ci0 = function(get) {\\n    return this.ci(get)[0];\\n  };\\n\\n  prototype.ci1 = function(get) {\\n    return this.ci(get)[1];\\n  };\\n\\n  /**\\n   * Group-by aggregation operator.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\\n   * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.\\n   * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.\\n   * @param {Array<string>} [params.as] - An array of output field names for aggregated values.\\n   * @param {boolean} [params.cross=false] - A flag indicating that the full\\n   *   cross-product of groupby values should be generated, including empty cells.\\n   *   If true, the drop parameter is ignored and empty cells are retained.\\n   * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.\\n   */\\n  function Aggregate(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n\\n    this._adds = []; // array of added output tuples\\n    this._mods = []; // array of modified output tuples\\n    this._alen = 0;  // number of active added tuples\\n    this._mlen = 0;  // number of active modified tuples\\n    this._drop = true;   // should empty aggregation cells be removed\\n    this._cross = false; // produce full cross-product of group-by values\\n\\n    this._dims = [];   // group-by dimension accessors\\n    this._dnames = []; // group-by dimension names\\n\\n    this._measures = []; // collection of aggregation monoids\\n    this._countOnly = false; // flag indicating only count aggregation\\n    this._counts = null; // collection of count fields\\n    this._prev = null;   // previous aggregation cells\\n\\n    this._inputs = null;  // array of dependent input tuple field names\\n    this._outputs = null; // array of output tuple field names\\n  }\\n\\n  Aggregate.Definition = {\\n    'type': 'Aggregate',\\n    'metadata': {'generates': true, 'changes': true},\\n    'params': [\\n      { 'name': 'groupby', 'type': 'field', 'array': true },\\n      { 'name': 'ops', 'type': 'enum', 'array': true, 'values': ValidAggregateOps },\\n      { 'name': 'fields', 'type': 'field', 'null': true, 'array': true },\\n      { 'name': 'as', 'type': 'string', 'null': true, 'array': true },\\n      { 'name': 'drop', 'type': 'boolean', 'default': true },\\n      { 'name': 'cross', 'type': 'boolean', 'default': false },\\n      { 'name': 'key', 'type': 'field' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Aggregate, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const aggr = this,\\n            out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\\n            mod = _.modified();\\n\\n      aggr.stamp = out.stamp;\\n\\n      if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\\n        aggr._prev = aggr.value;\\n        aggr.value = mod ? aggr.init(_) : {};\\n        pulse.visit(pulse.SOURCE, t => aggr.add(t));\\n      } else {\\n        aggr.value = aggr.value || aggr.init(_);\\n        pulse.visit(pulse.REM, t => aggr.rem(t));\\n        pulse.visit(pulse.ADD, t => aggr.add(t));\\n      }\\n\\n      // Indicate output fields and return aggregate tuples.\\n      out.modifies(aggr._outputs);\\n\\n      // Should empty cells be dropped?\\n      aggr._drop = _.drop !== false;\\n\\n      // If domain cross-product requested, generate empty cells as needed\\n      // and ensure that empty cells are not dropped\\n      if (_.cross && aggr._dims.length > 1) {\\n        aggr._drop = false;\\n        aggr.cross();\\n      }\\n\\n      if (pulse.clean() && aggr._drop) {\\n        out.clean(true).runAfter(() => this.clean());\\n      }\\n\\n      return aggr.changes(out);\\n    },\\n\\n    cross() {\\n      const aggr = this,\\n            curr = aggr.value,\\n            dims = aggr._dnames,\\n            vals = dims.map(() => ({})),\\n            n = dims.length;\\n\\n      // collect all group-by domain values\\n      function collect(cells) {\\n        let key, i, t, v;\\n        for (key in cells) {\\n          t = cells[key].tuple;\\n          for (i=0; i<n; ++i) {\\n            vals[i][(v = t[dims[i]])] = v;\\n          }\\n        }\\n      }\\n      collect(aggr._prev);\\n      collect(curr);\\n\\n      // iterate over key cross-product, create cells as needed\\n      function generate(base, tuple, index) {\\n        const name = dims[index],\\n            v = vals[index++];\\n\\n        for (const k in v) {\\n          const key = base ? base + '|' + k : k;\\n          tuple[name] = v[k];\\n          if (index < n) generate(key, tuple, index);\\n          else if (!curr[key]) aggr.cell(key, tuple);\\n        }\\n      }\\n      generate('', {}, 0);\\n    },\\n\\n    init(_) {\\n      // initialize input and output fields\\n      const inputs = (this._inputs = []),\\n            outputs = (this._outputs = []),\\n            inputMap = {};\\n\\n      function inputVisit(get) {\\n        const fields = vegaUtil.array(vegaUtil.accessorFields(get)),\\n              n = fields.length;\\n        let i = 0, f;\\n        for (; i<n; ++i) {\\n          if (!inputMap[f=fields[i]]) {\\n            inputMap[f] = 1;\\n            inputs.push(f);\\n          }\\n        }\\n      }\\n\\n      // initialize group-by dimensions\\n      this._dims = vegaUtil.array(_.groupby);\\n      this._dnames = this._dims.map(d => {\\n        var dname = vegaUtil.accessorName(d);\\n        inputVisit(d);\\n        outputs.push(dname);\\n        return dname;\\n      });\\n      this.cellkey = _.key ? _.key : groupkey(this._dims);\\n\\n      // initialize aggregate measures\\n      this._countOnly = true;\\n      this._counts = [];\\n      this._measures = [];\\n\\n      const fields = _.fields || [null],\\n            ops = _.ops || ['count'],\\n            as = _.as || [],\\n            n = fields.length,\\n            map = {};\\n      let field, op, m, mname, outname, i;\\n\\n      if (n !== ops.length) {\\n        vegaUtil.error('Unmatched number of fields and aggregate ops.');\\n      }\\n\\n      for (i=0; i<n; ++i) {\\n        field = fields[i];\\n        op = ops[i];\\n\\n        if (field == null && op !== 'count') {\\n          vegaUtil.error('Null aggregate field specified.');\\n        }\\n        mname = vegaUtil.accessorName(field);\\n        outname = measureName(op, mname, as[i]);\\n        outputs.push(outname);\\n\\n        if (op === 'count') {\\n          this._counts.push(outname);\\n          continue;\\n        }\\n\\n        m = map[mname];\\n        if (!m) {\\n          inputVisit(field);\\n          m = (map[mname] = []);\\n          m.field = field;\\n          this._measures.push(m);\\n        }\\n\\n        if (op !== 'count') this._countOnly = false;\\n        m.push(createMeasure(op, outname));\\n      }\\n\\n      this._measures = this._measures.map(m => compileMeasures(m, m.field));\\n\\n      return {}; // aggregation cells (this.value)\\n    },\\n\\n    // -- Cell Management -----\\n\\n    cellkey: groupkey(),\\n\\n    cell(key, t) {\\n      let cell = this.value[key];\\n      if (!cell) {\\n        cell = this.value[key] = this.newcell(key, t);\\n        this._adds[this._alen++] = cell;\\n      } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {\\n        cell.stamp = this.stamp;\\n        this._adds[this._alen++] = cell;\\n      } else if (cell.stamp < this.stamp) {\\n        cell.stamp = this.stamp;\\n        this._mods[this._mlen++] = cell;\\n      }\\n      return cell;\\n    },\\n\\n    newcell(key, t) {\\n      const cell = {\\n        key:   key,\\n        num:   0,\\n        agg:   null,\\n        tuple: this.newtuple(t, this._prev && this._prev[key]),\\n        stamp: this.stamp,\\n        store: false\\n      };\\n\\n      if (!this._countOnly) {\\n        const measures = this._measures,\\n              n = measures.length;\\n\\n        cell.agg = Array(n);\\n        for (let i=0; i<n; ++i) {\\n          cell.agg[i] = new measures[i](cell);\\n        }\\n      }\\n\\n      if (cell.store) {\\n        cell.data = new TupleStore();\\n      }\\n\\n      return cell;\\n    },\\n\\n    newtuple(t, p) {\\n      const names = this._dnames,\\n            dims = this._dims,\\n            n = dims.length,\\n            x = {};\\n\\n      for (let i=0; i<n; ++i) {\\n        x[names[i]] = dims[i](t);\\n      }\\n\\n      return p ? vegaDataflow.replace(p.tuple, x) : vegaDataflow.ingest(x);\\n    },\\n\\n    clean() {\\n      const cells = this.value;\\n      for (const key in cells) {\\n        if (cells[key].num === 0) {\\n          delete cells[key];\\n        }\\n      }\\n    },\\n\\n    // -- Process Tuples -----\\n\\n    add(t) {\\n      const key = this.cellkey(t),\\n            cell = this.cell(key, t);\\n\\n      cell.num += 1;\\n      if (this._countOnly) return;\\n\\n      if (cell.store) cell.data.add(t);\\n\\n      const agg = cell.agg;\\n      for (let i=0, n=agg.length; i<n; ++i) {\\n        agg[i].add(agg[i].get(t), t);\\n      }\\n    },\\n\\n    rem(t) {\\n      const key = this.cellkey(t),\\n            cell = this.cell(key, t);\\n\\n      cell.num -= 1;\\n      if (this._countOnly) return;\\n\\n      if (cell.store) cell.data.rem(t);\\n\\n      const agg = cell.agg;\\n      for (let i=0, n=agg.length; i<n; ++i) {\\n        agg[i].rem(agg[i].get(t), t);\\n      }\\n    },\\n\\n    celltuple(cell) {\\n      const tuple = cell.tuple,\\n            counts = this._counts;\\n\\n      // consolidate stored values\\n      if (cell.store) {\\n        cell.data.values();\\n      }\\n\\n      // update tuple properties\\n      for (let i=0, n=counts.length; i<n; ++i) {\\n        tuple[counts[i]] = cell.num;\\n      }\\n      if (!this._countOnly) {\\n        const agg = cell.agg;\\n        for (let i=0, n=agg.length; i<n; ++i) {\\n          agg[i].set(tuple);\\n        }\\n      }\\n\\n      return tuple;\\n    },\\n\\n    changes(out) {\\n      const adds = this._adds,\\n            mods = this._mods,\\n            prev = this._prev,\\n            drop = this._drop,\\n            add = out.add,\\n            rem = out.rem,\\n            mod = out.mod;\\n\\n      let cell, key, i, n;\\n\\n      if (prev) for (key in prev) {\\n        cell = prev[key];\\n        if (!drop || cell.num) rem.push(cell.tuple);\\n      }\\n\\n      for (i=0, n=this._alen; i<n; ++i) {\\n        add.push(this.celltuple(adds[i]));\\n        adds[i] = null; // for garbage collection\\n      }\\n\\n      for (i=0, n=this._mlen; i<n; ++i) {\\n        cell = mods[i];\\n        (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));\\n        mods[i] = null; // for garbage collection\\n      }\\n\\n      this._alen = this._mlen = 0; // reset list of active cells\\n      this._prev = null;\\n      return out;\\n    }\\n  });\\n\\n  // epsilon bias to offset floating point error (#1737)\\n  const EPSILON = 1e-14;\\n\\n  /**\\n   * Generates a binning function for discretizing data.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator. The\\n   *   provided values should be valid options for the {@link bin} function.\\n   * @param {function(object): *} params.field - The data field to bin.\\n   */\\n  function Bin(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Bin.Definition = {\\n    'type': 'Bin',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field', 'required': true },\\n      { 'name': 'interval', 'type': 'boolean', 'default': true },\\n      { 'name': 'anchor', 'type': 'number' },\\n      { 'name': 'maxbins', 'type': 'number', 'default': 20 },\\n      { 'name': 'base', 'type': 'number', 'default': 10 },\\n      { 'name': 'divide', 'type': 'number', 'array': true, 'default': [5, 2] },\\n      { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2, 'required': true },\\n      { 'name': 'span', 'type': 'number' },\\n      { 'name': 'step', 'type': 'number' },\\n      { 'name': 'steps', 'type': 'number', 'array': true },\\n      { 'name': 'minstep', 'type': 'number', 'default': 0 },\\n      { 'name': 'nice', 'type': 'boolean', 'default': true },\\n      { 'name': 'name', 'type': 'string' },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['bin0', 'bin1'] }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Bin, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const band = _.interval !== false,\\n          bins = this._bins(_),\\n          start = bins.start,\\n          step = bins.step,\\n          as = _.as || ['bin0', 'bin1'],\\n          b0 = as[0],\\n          b1 = as[1];\\n\\n      let flag;\\n      if (_.modified()) {\\n        pulse = pulse.reflow(true);\\n        flag = pulse.SOURCE;\\n      } else {\\n        flag = pulse.modified(vegaUtil.accessorFields(_.field)) ? pulse.ADD_MOD : pulse.ADD;\\n      }\\n\\n      pulse.visit(flag, band\\n        ? t => {\\n            const v = bins(t);\\n            // minimum bin value (inclusive)\\n            t[b0] = v;\\n            // maximum bin value (exclusive)\\n            // use convoluted math for better floating point agreement\\n            // see https://github.com/vega/vega/issues/830\\n            // infinite values propagate through this formula! #2227\\n            t[b1] = v == null ? null : start + step * (1 + (v - start) / step);\\n          }\\n        : t => t[b0] = bins(t)\\n      );\\n\\n      return pulse.modifies(band ? as : b0);\\n    },\\n\\n    _bins(_) {\\n      if (this.value && !_.modified()) {\\n        return this.value;\\n      }\\n\\n      const field = _.field,\\n            bins  = vegaStatistics.bin(_),\\n            step  = bins.step;\\n      let start = bins.start,\\n          stop  = start + Math.ceil((bins.stop - start) / step) * step,\\n          a, d;\\n\\n      if ((a = _.anchor) != null) {\\n        d = a - (start + step * Math.floor((a - start) / step));\\n        start += d;\\n        stop += d;\\n      }\\n\\n      const f = function(t) {\\n        let v = vegaUtil.toNumber(field(t));\\n        return v == null ? null\\n          : v < start ? -Infinity\\n          : v > stop ? +Infinity\\n          : (\\n              v = Math.max(start, Math.min(v, stop - step)),\\n              start + step * Math.floor(EPSILON + (v - start) / step)\\n            );\\n      };\\n\\n      f.start = start;\\n      f.stop = bins.stop;\\n      f.step = step;\\n\\n      return this.value = vegaUtil.accessor(\\n        f,\\n        vegaUtil.accessorFields(field),\\n        _.name || 'bin_' + vegaUtil.accessorName(field)\\n      );\\n    }\\n  });\\n\\n  function SortedList(idFunc, source, input) {\\n    const $ = idFunc;\\n    let data = source || [],\\n        add = input || [],\\n        rem = {},\\n        cnt = 0;\\n\\n    return {\\n      add: t => add.push(t),\\n      remove: t => rem[$(t)] = ++cnt,\\n      size: () => data.length,\\n      data: (compare, resort) => {\\n        if (cnt) {\\n          data = data.filter(t => !rem[$(t)]);\\n          rem = {};\\n          cnt = 0;\\n        }\\n        if (resort && compare) {\\n          data.sort(compare);\\n        }\\n        if (add.length) {\\n          data = compare\\n            ? vegaUtil.merge(compare, data, add.sort(compare))\\n            : data.concat(add);\\n          add = [];\\n        }\\n        return data;\\n      }\\n    };\\n  }\\n\\n  /**\\n   * Collects all data tuples that pass through this operator.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(*,*): number} [params.sort] - An optional\\n   *   comparator function for additionally sorting the collected tuples.\\n   */\\n  function Collect(params) {\\n    vegaDataflow.Transform.call(this, [], params);\\n  }\\n\\n  Collect.Definition = {\\n    'type': 'Collect',\\n    'metadata': {'source': true},\\n    'params': [\\n      { 'name': 'sort', 'type': 'compare' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Collect, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const out = pulse.fork(pulse.ALL),\\n            list = SortedList(vegaDataflow.tupleid, this.value, out.materialize(out.ADD).add),\\n            sort = _.sort,\\n            mod = pulse.changed() || (sort &&\\n                  (_.modified('sort') || pulse.modified(sort.fields)));\\n\\n      out.visit(out.REM, list.remove);\\n\\n      this.modified(mod);\\n      this.value = out.source = list.data(vegaDataflow.stableCompare(sort), mod);\\n\\n      // propagate tree root if defined\\n      if (pulse.source && pulse.source.root) {\\n        this.value.root = pulse.source.root;\\n      }\\n\\n      return out;\\n    }\\n  });\\n\\n  /**\\n   * Generates a comparator function.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<string|function>} params.fields - The fields to compare.\\n   * @param {Array<string>} [params.orders] - The sort orders.\\n   *   Each entry should be one of \\\"ascending\\\" (default) or \\\"descending\\\".\\n   */\\n  function Compare(params) {\\n    vegaDataflow.Operator.call(this, null, update, params);\\n  }\\n\\n  vegaUtil.inherits(Compare, vegaDataflow.Operator);\\n\\n  function update(_) {\\n    return (this.value && !_.modified())\\n      ? this.value\\n      : vegaUtil.compare(_.fields, _.orders);\\n  }\\n\\n  /**\\n   * Count regexp-defined pattern occurrences in a text field.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - An accessor for the text field.\\n   * @param {string} [params.pattern] - RegExp string defining the text pattern.\\n   * @param {string} [params.case] - One of 'lower', 'upper' or null (mixed) case.\\n   * @param {string} [params.stopwords] - RegExp string of words to ignore.\\n   */\\n  function CountPattern(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  CountPattern.Definition = {\\n    'type': 'CountPattern',\\n    'metadata': {'generates': true, 'changes': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field', 'required': true },\\n      { 'name': 'case', 'type': 'enum', 'values': ['upper', 'lower', 'mixed'], 'default': 'mixed' },\\n      { 'name': 'pattern', 'type': 'string', 'default': '[\\\\\\\\w\\\"]+' },\\n      { 'name': 'stopwords', 'type': 'string', 'default': '' },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['text', 'count'] }\\n    ]\\n  };\\n\\n  function tokenize(text, tcase, match) {\\n    switch (tcase) {\\n      case 'upper': text = text.toUpperCase(); break;\\n      case 'lower': text = text.toLowerCase(); break;\\n    }\\n    return text.match(match);\\n  }\\n\\n  vegaUtil.inherits(CountPattern, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const process = update => tuple => {\\n        var tokens = tokenize(get(tuple), _.case, match) || [], t;\\n        for (var i=0, n=tokens.length; i<n; ++i) {\\n          if (!stop.test(t = tokens[i])) update(t);\\n        }\\n      };\\n\\n      const init = this._parameterCheck(_, pulse),\\n            counts = this._counts,\\n            match = this._match,\\n            stop = this._stop,\\n            get = _.field,\\n            as = _.as || ['text', 'count'],\\n            add = process(t => counts[t] = 1 + (counts[t] || 0)),\\n            rem = process(t => counts[t] -= 1);\\n\\n      if (init) {\\n        pulse.visit(pulse.SOURCE, add);\\n      } else {\\n        pulse.visit(pulse.ADD, add);\\n        pulse.visit(pulse.REM, rem);\\n      }\\n\\n      return this._finish(pulse, as); // generate output tuples\\n    },\\n\\n    _parameterCheck(_, pulse) {\\n      let init = false;\\n\\n      if (_.modified('stopwords') || !this._stop) {\\n        this._stop = new RegExp('^' + (_.stopwords || '') + '$', 'i');\\n        init = true;\\n      }\\n\\n      if (_.modified('pattern') || !this._match) {\\n        this._match = new RegExp((_.pattern || '[\\\\\\\\w\\\\']+'), 'g');\\n        init = true;\\n      }\\n\\n      if (_.modified('field') || pulse.modified(_.field.fields)) {\\n        init = true;\\n      }\\n\\n      if (init) this._counts = {};\\n      return init;\\n    },\\n\\n    _finish(pulse, as) {\\n      const counts = this._counts,\\n            tuples = this._tuples || (this._tuples = {}),\\n            text = as[0],\\n            count = as[1],\\n            out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\\n      let w, t, c;\\n\\n      for (w in counts) {\\n        t = tuples[w];\\n        c = counts[w] || 0;\\n        if (!t && c) {\\n          tuples[w] = (t = vegaDataflow.ingest({}));\\n          t[text] = w;\\n          t[count] = c;\\n          out.add.push(t);\\n        } else if (c === 0) {\\n          if (t) out.rem.push(t);\\n          counts[w] = null;\\n          tuples[w] = null;\\n        } else if (t[count] !== c) {\\n          t[count] = c;\\n          out.mod.push(t);\\n        }\\n      }\\n\\n      return out.modifies(as);\\n    }\\n  });\\n\\n  /**\\n   * Perform a cross-product of a tuple stream with itself.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object):boolean} [params.filter] - An optional filter\\n   *   function for selectively including tuples in the cross product.\\n   * @param {Array<string>} [params.as] - The names of the output fields.\\n   */\\n  function Cross(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Cross.Definition = {\\n    'type': 'Cross',\\n    'metadata': {'generates': true},\\n    'params': [\\n      { 'name': 'filter', 'type': 'expr' },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['a', 'b'] }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Cross, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const out = pulse.fork(pulse.NO_SOURCE),\\n            as = _.as || ['a', 'b'],\\n            a = as[0], b = as[1],\\n            reset = !this.value\\n                || pulse.changed(pulse.ADD_REM)\\n                || _.modified('as')\\n                || _.modified('filter');\\n\\n      let data = this.value;\\n      if (reset) {\\n        if (data) out.rem = data;\\n        data = pulse.materialize(pulse.SOURCE).source;\\n        out.add = this.value = cross(data, a, b, _.filter || vegaUtil.truthy);\\n      } else {\\n        out.mod = data;\\n      }\\n\\n      out.source = this.value;\\n      return out.modifies(as);\\n    }\\n  });\\n\\n  function cross(input, a, b, filter) {\\n    var data = [],\\n        t = {},\\n        n = input.length,\\n        i = 0,\\n        j, left;\\n\\n    for (; i<n; ++i) {\\n      t[a] = left = input[i];\\n      for (j=0; j<n; ++j) {\\n        t[b] = input[j];\\n        if (filter(t)) {\\n          data.push(vegaDataflow.ingest(t));\\n          t = {};\\n          t[a] = left;\\n        }\\n      }\\n    }\\n\\n    return data;\\n  }\\n\\n  const Distributions = {\\n    kde:       vegaStatistics.randomKDE,\\n    mixture:   vegaStatistics.randomMixture,\\n    normal:    vegaStatistics.randomNormal,\\n    lognormal: vegaStatistics.randomLogNormal,\\n    uniform:   vegaStatistics.randomUniform\\n  };\\n\\n  const DISTRIBUTIONS = 'distributions',\\n        FUNCTION = 'function',\\n        FIELD = 'field';\\n\\n  /**\\n   * Parse a parameter object for a probability distribution.\\n   * @param {object} def - The distribution parameter object.\\n   * @param {function():Array<object>} - A method for requesting\\n   *   source data. Used for distributions (such as KDE) that\\n   *   require sample data points. This method will only be\\n   *   invoked if the 'from' parameter for a target data source\\n   *   is not provided. Typically this method returns backing\\n   *   source data for a Pulse object.\\n   * @return {object} - The output distribution object.\\n   */\\n  function parse(def, data) {\\n    const func = def[FUNCTION];\\n    if (!vegaUtil.hasOwnProperty(Distributions, func)) {\\n      vegaUtil.error('Unknown distribution function: ' + func);\\n    }\\n\\n    const d = Distributions[func]();\\n\\n    for (const name in def) {\\n      // if data field, extract values\\n      if (name === FIELD) {\\n        d.data((def.from || data()).map(def[name]));\\n      }\\n\\n      // if distribution mixture, recurse to parse each definition\\n      else if (name === DISTRIBUTIONS) {\\n        d[name](def[name].map(_ => parse(_, data)));\\n      }\\n\\n      // otherwise, simply set the parameter\\n      else if (typeof d[name] === FUNCTION) {\\n        d[name](def[name]);\\n      }\\n    }\\n\\n    return d;\\n  }\\n\\n  /**\\n   * Grid sample points for a probability density. Given a distribution and\\n   * a sampling extent, will generate points suitable for plotting either\\n   * PDF (probability density function) or CDF (cumulative distribution\\n   * function) curves.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {object} params.distribution - The probability distribution. This\\n   *   is an object parameter dependent on the distribution type.\\n   * @param {string} [params.method='pdf'] - The distribution method to sample.\\n   *   One of 'pdf' or 'cdf'.\\n   * @param {Array<number>} [params.extent] - The [min, max] extent over which\\n   *   to sample the distribution. This argument is required in most cases, but\\n   *   can be omitted if the distribution (e.g., 'kde') supports a 'data' method\\n   *   that returns numerical sample points from which the extent can be deduced.\\n   * @param {number} [params.minsteps=25] - The minimum number of curve samples\\n   *   for plotting the density.\\n   * @param {number} [params.maxsteps=200] - The maximum number of curve samples\\n   *   for plotting the density.\\n   * @param {number} [params.steps] - The exact number of curve samples for\\n   *   plotting the density. If specified, overrides both minsteps and maxsteps\\n   *   to set an exact number of uniform samples. Useful in conjunction with\\n   *   a fixed extent to ensure consistent sample points for stacked densities.\\n   */\\n  function Density(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  var distributions = [\\n    {\\n      'key': {'function': 'normal'},\\n      'params': [\\n        { 'name': 'mean', 'type': 'number', 'default': 0 },\\n        { 'name': 'stdev', 'type': 'number', 'default': 1 }\\n      ]\\n    },\\n    {\\n      'key': {'function': 'lognormal'},\\n      'params': [\\n        { 'name': 'mean', 'type': 'number', 'default': 0 },\\n        { 'name': 'stdev', 'type': 'number', 'default': 1 }\\n      ]\\n    },\\n    {\\n      'key': {'function': 'uniform'},\\n      'params': [\\n        { 'name': 'min', 'type': 'number', 'default': 0 },\\n        { 'name': 'max', 'type': 'number', 'default': 1 }\\n      ]\\n    },\\n    {\\n      'key': {'function': 'kde'},\\n      'params': [\\n        { 'name': 'field', 'type': 'field', 'required': true },\\n        { 'name': 'from', 'type': 'data' },\\n        { 'name': 'bandwidth', 'type': 'number', 'default': 0 }\\n      ]\\n    }\\n  ];\\n\\n  var mixture = {\\n    'key': {'function': 'mixture'},\\n    'params': [\\n      { 'name': 'distributions', 'type': 'param', 'array': true,\\n        'params': distributions },\\n      { 'name': 'weights', 'type': 'number', 'array': true }\\n    ]\\n  };\\n\\n  Density.Definition = {\\n    'type': 'Density',\\n    'metadata': {'generates': true},\\n    'params': [\\n      { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2 },\\n      { 'name': 'steps', 'type': 'number' },\\n      { 'name': 'minsteps', 'type': 'number', 'default': 25 },\\n      { 'name': 'maxsteps', 'type': 'number', 'default': 200 },\\n      { 'name': 'method', 'type': 'string', 'default': 'pdf',\\n        'values': ['pdf', 'cdf'] },\\n      { 'name': 'distribution', 'type': 'param',\\n        'params': distributions.concat(mixture) },\\n      { 'name': 'as', 'type': 'string', 'array': true,\\n        'default': ['value', 'density'] }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Density, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\\n\\n      if (!this.value || pulse.changed() || _.modified()) {\\n        const dist = parse(_.distribution, source(pulse)),\\n              minsteps = _.steps || _.minsteps || 25,\\n              maxsteps = _.steps || _.maxsteps || 200;\\n        let method = _.method || 'pdf';\\n\\n        if (method !== 'pdf' && method !== 'cdf') {\\n          vegaUtil.error('Invalid density method: ' + method);\\n        }\\n        if (!_.extent && !dist.data) {\\n          vegaUtil.error('Missing density extent parameter.');\\n        }\\n        method = dist[method];\\n\\n        const as = _.as || ['value', 'density'],\\n              domain = _.extent || vegaUtil.extent(dist.data()),\\n              values = vegaStatistics.sampleCurve(method, domain, minsteps, maxsteps)\\n                .map(v => {\\n                  const tuple = {};\\n                  tuple[as[0]] = v[0];\\n                  tuple[as[1]] = v[1];\\n                  return vegaDataflow.ingest(tuple);\\n                });\\n\\n        if (this.value) out.rem = this.value;\\n        this.value = out.add = out.source = values;\\n      }\\n\\n      return out;\\n    }\\n  });\\n\\n  function source(pulse) {\\n    return () => pulse.materialize(pulse.SOURCE).source;\\n  }\\n\\n  // use either provided alias or accessor field name\\n  function fieldNames(fields, as) {\\n    if (!fields) return null;\\n    return fields.map((f, i) => as[i] || vegaUtil.accessorName(f));\\n  }\\n\\n  function partition(data, groupby, field) {\\n    const groups = [],\\n          get = f => f(t);\\n    let map, i, n, t, k, g;\\n\\n    // partition data points into groups\\n    if (groupby == null) {\\n      groups.push(data.map(field));\\n    } else {\\n      for (map={}, i=0, n=data.length; i<n; ++i) {\\n        t = data[i];\\n        k = groupby.map(get);\\n        g = map[k];\\n        if (!g) {\\n          map[k] = (g = []);\\n          g.dims = k;\\n          groups.push(g);\\n        }\\n        g.push(field(t));\\n      }\\n    }\\n\\n    return groups;\\n  }\\n\\n  const Output = 'bin';\\n\\n  /**\\n   * Dot density binning for dot plot construction.\\n   * Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.\\n   * https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - The value field to bin.\\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\\n   * @param {number} [params.step] - The step size (bin width) within which dots should be\\n   *   stacked. Defaults to 1/30 of the extent of the data *field*.\\n   * @param {boolean} [params.smooth=false] - A boolean flag indicating if dot density\\n   *   stacks should be smoothed to reduce variance.\\n   */\\n  function DotBin(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  DotBin.Definition = {\\n    'type': 'DotBin',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field', 'required': true },\\n      { 'name': 'groupby', 'type': 'field', 'array': true },\\n      { 'name': 'step', 'type': 'number' },\\n      { 'name': 'smooth', 'type': 'boolean', 'default': false },\\n      { 'name': 'as', 'type': 'string', 'default': Output }\\n    ]\\n  };\\n\\n  const autostep = (data, field) => vegaUtil.span(vegaUtil.extent(data, field)) / 30;\\n\\n  vegaUtil.inherits(DotBin, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      if (this.value && !(_.modified() || pulse.changed())) {\\n        return pulse; // early exit\\n      }\\n\\n      const source = pulse.materialize(pulse.SOURCE).source,\\n            groups = partition(pulse.source, _.groupby, vegaUtil.identity),\\n            smooth = _.smooth || false,\\n            field = _.field,\\n            step = _.step || autostep(source, field),\\n            sort = vegaDataflow.stableCompare((a, b) => field(a) - field(b)),\\n            as = _.as || Output,\\n            n = groups.length;\\n\\n      // compute dotplot bins per group\\n      let min = Infinity, max = -Infinity, i = 0, j;\\n      for (; i<n; ++i) {\\n        const g = groups[i].sort(sort);\\n        j = -1;\\n        for (const v of vegaStatistics.dotbin(g, step, smooth, field)) {\\n          if (v < min) min = v;\\n          if (v > max) max = v;\\n          g[++j][as] = v;\\n        }\\n      }\\n\\n      this.value = {\\n        start: min,\\n        stop: max,\\n        step: step\\n      };\\n      return pulse.reflow(true).modifies(as);\\n    }\\n  });\\n\\n  /**\\n   * Wraps an expression function with access to external parameters.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function} params.expr - The expression function. The\\n   *  function should accept both a datum and a parameter object.\\n   *  This operator's value will be a new function that wraps the\\n   *  expression function with access to this operator's parameters.\\n   */\\n  function Expression(params) {\\n    vegaDataflow.Operator.call(this, null, update$1, params);\\n    this.modified(true);\\n  }\\n\\n  vegaUtil.inherits(Expression, vegaDataflow.Operator);\\n\\n  function update$1(_) {\\n    const expr = _.expr;\\n    return this.value && !_.modified('expr')\\n      ? this.value\\n      : vegaUtil.accessor(\\n          datum => expr(datum, _),\\n          vegaUtil.accessorFields(expr),\\n          vegaUtil.accessorName(expr)\\n        );\\n  }\\n\\n  /**\\n   * Computes extents (min/max) for a data field.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - The field over which to compute extends.\\n   */\\n  function Extent(params) {\\n    vegaDataflow.Transform.call(this, [undefined, undefined], params);\\n  }\\n\\n  Extent.Definition = {\\n    'type': 'Extent',\\n    'metadata': {},\\n    'params': [\\n      { 'name': 'field', 'type': 'field', 'required': true }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Extent, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const extent = this.value,\\n            field = _.field,\\n            mod = pulse.changed()\\n              || pulse.modified(field.fields)\\n              || _.modified('field');\\n\\n      let min = extent[0],\\n          max = extent[1];\\n      if (mod || min == null) {\\n        min = +Infinity;\\n        max = -Infinity;\\n      }\\n\\n      pulse.visit(mod ? pulse.SOURCE : pulse.ADD, t => {\\n        const v = vegaUtil.toNumber(field(t));\\n        if (v != null) {\\n          // NaNs will fail all comparisons!\\n          if (v < min) min = v;\\n          if (v > max) max = v;\\n        }\\n      });\\n\\n      if (!Number.isFinite(min) || !Number.isFinite(max)) {\\n        let name = vegaUtil.accessorName(field);\\n        if (name) name = ` for field \\\"${name}\\\"`;\\n        pulse.dataflow.warn(`Infinite extent${name}: [${min}, ${max}]`);\\n        min = max = undefined;\\n      }\\n      this.value = [min, max];\\n    }\\n  });\\n\\n  /**\\n   * Provides a bridge between a parent transform and a target subflow that\\n   * consumes only a subset of the tuples that pass through the parent.\\n   * @constructor\\n   * @param {Pulse} pulse - A pulse to use as the value of this operator.\\n   * @param {Transform} parent - The parent transform (typically a Facet instance).\\n   */\\n  function Subflow(pulse, parent) {\\n    vegaDataflow.Operator.call(this, pulse);\\n    this.parent = parent;\\n    this.count = 0;\\n  }\\n\\n  vegaUtil.inherits(Subflow, vegaDataflow.Operator, {\\n    /**\\n     * Routes pulses from this subflow to a target transform.\\n     * @param {Transform} target - A transform that receives the subflow of tuples.\\n     */\\n    connect(target) {\\n      this.detachSubflow = target.detachSubflow;\\n      this.targets().add(target);\\n      return (target.source = this);\\n    },\\n\\n    /**\\n     * Add an 'add' tuple to the subflow pulse.\\n     * @param {Tuple} t - The tuple being added.\\n     */\\n    add(t) {\\n      this.count += 1;\\n      this.value.add.push(t);\\n    },\\n\\n    /**\\n     * Add a 'rem' tuple to the subflow pulse.\\n     * @param {Tuple} t - The tuple being removed.\\n     */\\n    rem(t) {\\n      this.count -= 1;\\n      this.value.rem.push(t);\\n    },\\n\\n    /**\\n     * Add a 'mod' tuple to the subflow pulse.\\n     * @param {Tuple} t - The tuple being modified.\\n     */\\n    mod(t) {\\n      this.value.mod.push(t);\\n    },\\n\\n    /**\\n     * Re-initialize this operator's pulse value.\\n     * @param {Pulse} pulse - The pulse to copy from.\\n     * @see Pulse.init\\n     */\\n    init(pulse) {\\n      this.value.init(pulse, pulse.NO_SOURCE);\\n    },\\n\\n    /**\\n     * Evaluate this operator. This method overrides the\\n     * default behavior to simply return the contained pulse value.\\n     * @return {Pulse}\\n     */\\n    evaluate() {\\n      // assert: this.value.stamp === pulse.stamp\\n      return this.value;\\n    }\\n  });\\n\\n  /**\\n   * Facets a dataflow into a set of subflows based on a key.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(Dataflow, string): Operator} params.subflow - A function\\n   *   that generates a subflow of operators and returns its root operator.\\n   * @param {function(object): *} params.key - The key field to facet by.\\n   */\\n  function Facet(params) {\\n    vegaDataflow.Transform.call(this, {}, params);\\n    this._keys = vegaUtil.fastmap(); // cache previously calculated key values\\n\\n    // keep track of active subflows, use as targets array for listeners\\n    // this allows us to limit propagation to only updated subflows\\n    const a = this._targets = [];\\n    a.active = 0;\\n    a.forEach = f => {\\n      for (let i=0, n=a.active; i<n; ++i) {\\n        f(a[i], i, a);\\n      }\\n    };\\n  }\\n\\n  vegaUtil.inherits(Facet, vegaDataflow.Transform, {\\n    activate(flow) {\\n      this._targets[this._targets.active++] = flow;\\n    },\\n\\n    // parent argument provided by PreFacet subclass\\n    subflow(key, flow, pulse, parent) {\\n      const flows = this.value;\\n      let sf = vegaUtil.hasOwnProperty(flows, key) && flows[key],\\n          df, p;\\n\\n      if (!sf) {\\n        p = parent || (p = this._group[key]) && p.tuple;\\n        df = pulse.dataflow;\\n        sf = new Subflow(pulse.fork(pulse.NO_SOURCE), this);\\n        df.add(sf).connect(flow(df, key, p));\\n        flows[key] = sf;\\n        this.activate(sf);\\n      } else if (sf.value.stamp < pulse.stamp) {\\n        sf.init(pulse);\\n        this.activate(sf);\\n      }\\n\\n      return sf;\\n    },\\n\\n    clean() {\\n      const flows = this.value;\\n      for (const key in flows) {\\n        if (flows[key].count === 0) {\\n          const detach = flows[key].detachSubflow;\\n          if (detach) detach();\\n          delete flows[key];\\n        }\\n      }\\n    },\\n\\n    initTargets() {\\n      const a = this._targets,\\n            n = a.length;\\n      for (let i=0; i<n && a[i] != null; ++i) {\\n        a[i] = null; // ensure old flows can be garbage collected\\n      }\\n      a.active = 0;\\n    },\\n\\n    transform(_, pulse) {\\n      const df = pulse.dataflow,\\n            key = _.key,\\n            flow = _.subflow,\\n            cache = this._keys,\\n            rekey = _.modified('key'),\\n            subflow = key => this.subflow(key, flow, pulse);\\n\\n      this._group = _.group || {};\\n      this.initTargets(); // reset list of active subflows\\n\\n      pulse.visit(pulse.REM, t => {\\n        const id = vegaDataflow.tupleid(t),\\n              k = cache.get(id);\\n        if (k !== undefined) {\\n          cache.delete(id);\\n          subflow(k).rem(t);\\n        }\\n      });\\n\\n      pulse.visit(pulse.ADD, t => {\\n        const k = key(t);\\n        cache.set(vegaDataflow.tupleid(t), k);\\n        subflow(k).add(t);\\n      });\\n\\n      if (rekey || pulse.modified(key.fields)) {\\n        pulse.visit(pulse.MOD, t => {\\n          const id = vegaDataflow.tupleid(t),\\n                k0 = cache.get(id),\\n                k1 = key(t);\\n          if (k0 === k1) {\\n            subflow(k1).mod(t);\\n          } else {\\n            cache.set(id, k1);\\n            subflow(k0).rem(t);\\n            subflow(k1).add(t);\\n          }\\n        });\\n      } else if (pulse.changed(pulse.MOD)) {\\n        pulse.visit(pulse.MOD, t => {\\n          subflow(cache.get(vegaDataflow.tupleid(t))).mod(t);\\n        });\\n      }\\n\\n      if (rekey) {\\n        pulse.visit(pulse.REFLOW, t => {\\n          const id = vegaDataflow.tupleid(t),\\n                k0 = cache.get(id),\\n                k1 = key(t);\\n          if (k0 !== k1) {\\n            cache.set(id, k1);\\n            subflow(k0).rem(t);\\n            subflow(k1).add(t);\\n          }\\n        });\\n      }\\n\\n      if (pulse.clean()) {\\n        df.runAfter(() => { this.clean(); cache.clean(); });\\n      } else if (cache.empty > df.cleanThreshold) {\\n        df.runAfter(cache.clean);\\n      }\\n\\n      return pulse;\\n    }\\n  });\\n\\n  /**\\n   * Generates one or more field accessor functions.\\n   * If the 'name' parameter is an array, an array of field accessors\\n   * will be created and the 'as' parameter will be ignored.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {string} params.name - The field name(s) to access.\\n   * @param {string} params.as - The accessor function name.\\n   */\\n  function Field(params) {\\n    vegaDataflow.Operator.call(this, null, update$2, params);\\n  }\\n\\n  vegaUtil.inherits(Field, vegaDataflow.Operator);\\n\\n  function update$2(_) {\\n    return (this.value && !_.modified()) ? this.value\\n      : vegaUtil.isArray(_.name) ? vegaUtil.array(_.name).map(f => vegaUtil.field(f))\\n      : vegaUtil.field(_.name, _.as);\\n  }\\n\\n  /**\\n   * Filters data tuples according to a predicate function.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.expr - The predicate expression function\\n   *   that determines a tuple's filter status. Truthy values pass the filter.\\n   */\\n  function Filter(params) {\\n    vegaDataflow.Transform.call(this, vegaUtil.fastmap(), params);\\n  }\\n\\n  Filter.Definition = {\\n    'type': 'Filter',\\n    'metadata': {'changes': true},\\n    'params': [\\n      { 'name': 'expr', 'type': 'expr', 'required': true }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Filter, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const df = pulse.dataflow,\\n            cache = this.value, // cache ids of filtered tuples\\n            output = pulse.fork(),\\n            add = output.add,\\n            rem = output.rem,\\n            mod = output.mod,\\n            test = _.expr;\\n      let isMod = true;\\n\\n      pulse.visit(pulse.REM, t => {\\n        var id = vegaDataflow.tupleid(t);\\n        if (!cache.has(id)) rem.push(t);\\n        else cache.delete(id);\\n      });\\n\\n      pulse.visit(pulse.ADD, t => {\\n        if (test(t, _)) add.push(t);\\n        else cache.set(vegaDataflow.tupleid(t), 1);\\n      });\\n\\n      function revisit(t) {\\n        const id = vegaDataflow.tupleid(t),\\n              b = test(t, _),\\n              s = cache.get(id);\\n        if (b && s) {\\n          cache.delete(id);\\n          add.push(t);\\n        } else if (!b && !s) {\\n          cache.set(id, 1);\\n          rem.push(t);\\n        } else if (isMod && b && !s) {\\n          mod.push(t);\\n        }\\n      }\\n\\n      pulse.visit(pulse.MOD, revisit);\\n\\n      if (_.modified()) {\\n        isMod = false;\\n        pulse.visit(pulse.REFLOW, revisit);\\n      }\\n\\n      if (cache.empty > df.cleanThreshold) df.runAfter(cache.clean);\\n      return output;\\n    }\\n  });\\n\\n  /**\\n   * Flattens array-typed field values into new data objects.\\n   * If multiple fields are specified, they are treated as parallel arrays,\\n   * with output values included for each matching index (or null if missing).\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<function(object): *>} params.fields - An array of field\\n   *   accessors for the tuple fields that should be flattened.\\n   * @param {string} [params.index] - Optional output field name for index\\n   *   value. If unspecified, no index field is included in the output.\\n   * @param {Array<string>} [params.as] - Output field names for flattened\\n   *   array fields. Any unspecified fields will use the field name provided\\n   *   by the fields accessors.\\n   */\\n  function Flatten(params) {\\n    vegaDataflow.Transform.call(this, [], params);\\n  }\\n\\n  Flatten.Definition = {\\n    'type': 'Flatten',\\n    'metadata': {'generates': true},\\n    'params': [\\n      { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\\n      { 'name': 'index', 'type': 'string' },\\n      { 'name': 'as', 'type': 'string', 'array': true }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Flatten, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const out = pulse.fork(pulse.NO_SOURCE),\\n            fields = _.fields,\\n            as = fieldNames(fields, _.as || []),\\n            index = _.index || null,\\n            m = as.length;\\n\\n      // remove any previous results\\n      out.rem = this.value;\\n\\n      // generate flattened tuples\\n      pulse.visit(pulse.SOURCE, t => {\\n        const arrays = fields.map(f => f(t)),\\n              maxlen = arrays.reduce((l, a) => Math.max(l, a.length), 0);\\n        let i = 0, j, d, v;\\n\\n        for (; i<maxlen; ++i) {\\n          d = vegaDataflow.derive(t);\\n          for (j=0; j<m; ++j) {\\n            d[as[j]] = (v = arrays[j][i]) == null ? null : v;\\n          }\\n          if (index) {\\n            d[index] = i;\\n          }\\n          out.add.push(d);\\n        }\\n      });\\n\\n      this.value = out.source = out.add;\\n      if (index) out.modifies(index);\\n      return out.modifies(as);\\n    }\\n  });\\n\\n  /**\\n   * Folds one more tuple fields into multiple tuples in which the field\\n   * name and values are available under new 'key' and 'value' fields.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.fields - An array of field accessors\\n   *   for the tuple fields that should be folded.\\n   * @param {Array<string>} [params.as] - Output field names for folded key\\n   *   and value fields, defaults to ['key', 'value'].\\n   */\\n  function Fold(params) {\\n    vegaDataflow.Transform.call(this, [], params);\\n  }\\n\\n  Fold.Definition = {\\n    'type': 'Fold',\\n    'metadata': {'generates': true},\\n    'params': [\\n      { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['key', 'value'] }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Fold, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const out = pulse.fork(pulse.NO_SOURCE),\\n            fields = _.fields,\\n            fnames = fields.map(vegaUtil.accessorName),\\n            as = _.as || ['key', 'value'],\\n            k = as[0],\\n            v = as[1],\\n            n = fields.length;\\n\\n      out.rem = this.value;\\n\\n      pulse.visit(pulse.SOURCE, t => {\\n        for (let i=0, d; i<n; ++i) {\\n          d = vegaDataflow.derive(t);\\n          d[k] = fnames[i];\\n          d[v] = fields[i](t);\\n          out.add.push(d);\\n        }\\n      });\\n\\n      this.value = out.source = out.add;\\n      return out.modifies(as);\\n    }\\n  });\\n\\n  /**\\n   * Invokes a function for each data tuple and saves the results as a new field.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.expr - The formula function to invoke for each tuple.\\n   * @param {string} params.as - The field name under which to save the result.\\n   * @param {boolean} [params.initonly=false] - If true, the formula is applied to\\n   *   added tuples only, and does not update in response to modifications.\\n   */\\n  function Formula(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Formula.Definition = {\\n    'type': 'Formula',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'expr', 'type': 'expr', 'required': true },\\n      { 'name': 'as', 'type': 'string', 'required': true },\\n      { 'name': 'initonly', 'type': 'boolean' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Formula, vegaDataflow.Transform, {\\n    transform (_, pulse) {\\n      const func = _.expr,\\n            as = _.as,\\n            mod = _.modified(),\\n            flag = _.initonly ? pulse.ADD\\n              : mod ? pulse.SOURCE\\n              : pulse.modified(func.fields) || pulse.modified(as) ? pulse.ADD_MOD\\n              : pulse.ADD;\\n\\n      if (mod) {\\n        // parameters updated, need to reflow\\n        pulse = pulse.materialize().reflow(true);\\n      }\\n\\n      if (!_.initonly) {\\n        pulse.modifies(as);\\n      }\\n\\n      return pulse.visit(flag, t => t[as] = func(t, _));\\n    }\\n  });\\n\\n  /**\\n   * Generates data tuples using a provided generator function.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(Parameters): object} params.generator - A tuple generator\\n   *   function. This function is given the operator parameters as input.\\n   *   Changes to any additional parameters will not trigger re-calculation\\n   *   of previously generated tuples. Only future tuples are affected.\\n   * @param {number} params.size - The number of tuples to produce.\\n   */\\n  function Generate(params) {\\n    vegaDataflow.Transform.call(this, [], params);\\n  }\\n\\n  vegaUtil.inherits(Generate, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const out = pulse.fork(pulse.ALL),\\n            gen = _.generator;\\n\\n      let data = this.value,\\n          num = _.size - data.length,\\n          add, rem, t;\\n\\n      if (num > 0) {\\n        // need more tuples, generate and add\\n        for (add=[]; --num >= 0;) {\\n          add.push(t = vegaDataflow.ingest(gen(_)));\\n          data.push(t);\\n        }\\n        out.add = out.add.length\\n          ? out.materialize(out.ADD).add.concat(add)\\n          : add;\\n      } else {\\n        // need fewer tuples, remove\\n        rem = data.slice(0, -num);\\n        out.rem = out.rem.length\\n          ? out.materialize(out.REM).rem.concat(rem)\\n          : rem;\\n        data = data.slice(-num);\\n      }\\n\\n      out.source = this.value = data;\\n      return out;\\n    }\\n  });\\n\\n  const Methods = {\\n    value: 'value',\\n    median: d3Array.median,\\n    mean: d3Array.mean,\\n    min: d3Array.min,\\n    max: d3Array.max\\n  };\\n\\n  const Empty = [];\\n\\n  /**\\n   * Impute missing values.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - The value field to impute.\\n   * @param {Array<function(object): *>} [params.groupby] - An array of\\n   *   accessors to determine series within which to perform imputation.\\n   * @param {function(object): *} params.key - An accessor for a key value.\\n   *   Each key value should be unique within a group. New tuples will be\\n   *   imputed for any key values that are not found within a group.\\n   * @param {Array<*>} [params.keyvals] - Optional array of required key\\n   *   values. New tuples will be imputed for any key values that are not\\n   *   found within a group. In addition, these values will be automatically\\n   *   augmented with the key values observed in the input data.\\n   * @param {string} [method='value'] - The imputation method to use. One of\\n   *   'value', 'mean', 'median', 'max', 'min'.\\n   * @param {*} [value=0] - The constant value to use for imputation\\n   *   when using method 'value'.\\n   */\\n  function Impute(params) {\\n    vegaDataflow.Transform.call(this, [], params);\\n  }\\n\\n  Impute.Definition = {\\n    'type': 'Impute',\\n    'metadata': {'changes': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field', 'required': true },\\n      { 'name': 'key', 'type': 'field', 'required': true },\\n      { 'name': 'keyvals', 'array': true },\\n      { 'name': 'groupby', 'type': 'field', 'array': true },\\n      { 'name': 'method', 'type': 'enum', 'default': 'value',\\n        'values': ['value', 'mean', 'median', 'max', 'min'] },\\n      { 'name': 'value', 'default': 0 }\\n    ]\\n  };\\n\\n  function getValue(_) {\\n    var m = _.method || Methods.value, v;\\n\\n    if (Methods[m] == null) {\\n      vegaUtil.error('Unrecognized imputation method: ' + m);\\n    } else if (m === Methods.value) {\\n      v = _.value !== undefined ? _.value : 0;\\n      return () => v;\\n    } else {\\n      return Methods[m];\\n    }\\n  }\\n\\n  function getField(_) {\\n    var f = _.field;\\n    return t => t ? f(t) : NaN;\\n  }\\n\\n  vegaUtil.inherits(Impute, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      var out = pulse.fork(pulse.ALL),\\n          impute = getValue(_),\\n          field = getField(_),\\n          fName = vegaUtil.accessorName(_.field),\\n          kName = vegaUtil.accessorName(_.key),\\n          gNames = (_.groupby || []).map(vegaUtil.accessorName),\\n          groups = partition$1(pulse.source, _.groupby, _.key, _.keyvals),\\n          curr = [],\\n          prev = this.value,\\n          m = groups.domain.length,\\n          group, value, gVals, kVal, g, i, j, l, n, t;\\n\\n      for (g=0, l=groups.length; g<l; ++g) {\\n        group = groups[g];\\n        gVals = group.values;\\n        value = NaN;\\n\\n        // add tuples for missing values\\n        for (j=0; j<m; ++j) {\\n          if (group[j] != null) continue;\\n          kVal = groups.domain[j];\\n\\n          t = {_impute: true};\\n          for (i=0, n=gVals.length; i<n; ++i) t[gNames[i]] = gVals[i];\\n          t[kName] = kVal;\\n          t[fName] = Number.isNaN(value) ? (value = impute(group, field)) : value;\\n\\n          curr.push(vegaDataflow.ingest(t));\\n        }\\n      }\\n\\n      // update pulse with imputed tuples\\n      if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);\\n      if (prev.length) out.rem = out.materialize(out.REM).rem.concat(prev);\\n      this.value = curr;\\n\\n      return out;\\n    }\\n  });\\n\\n  function partition$1(data, groupby, key, keyvals) {\\n    var get = f => f(t),\\n        groups = [],\\n        domain = keyvals ? keyvals.slice() : [],\\n        kMap = {},\\n        gMap = {}, gVals, gKey,\\n        group, i, j, k, n, t;\\n\\n    domain.forEach((k, i) => kMap[k] = i + 1);\\n\\n    for (i=0, n=data.length; i<n; ++i) {\\n      t = data[i];\\n      k = key(t);\\n      j = kMap[k] || (kMap[k] = domain.push(k));\\n\\n      gKey = (gVals = groupby ? groupby.map(get) : Empty) + '';\\n      if (!(group = gMap[gKey])) {\\n        group = (gMap[gKey] = []);\\n        groups.push(group);\\n        group.values = gVals;\\n      }\\n      group[j-1] = t;\\n    }\\n\\n    groups.domain = domain;\\n    return groups;\\n  }\\n\\n  /**\\n   * Extend input tuples with aggregate values.\\n   * Calcuates aggregate values and joins them with the input stream.\\n   * @constructor\\n   */\\n  function JoinAggregate(params) {\\n    Aggregate.call(this, params);\\n  }\\n\\n  JoinAggregate.Definition = {\\n    'type': 'JoinAggregate',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'groupby', 'type': 'field', 'array': true },\\n      { 'name': 'fields', 'type': 'field', 'null': true, 'array': true },\\n      { 'name': 'ops', 'type': 'enum', 'array': true, 'values': ValidAggregateOps },\\n      { 'name': 'as', 'type': 'string', 'null': true, 'array': true },\\n      { 'name': 'key', 'type': 'field' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(JoinAggregate, Aggregate, {\\n    transform(_, pulse) {\\n      const aggr = this,\\n            mod = _.modified();\\n      let cells;\\n\\n      // process all input tuples to calculate aggregates\\n      if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\\n        cells = aggr.value = mod ? aggr.init(_) : {};\\n        pulse.visit(pulse.SOURCE, t => aggr.add(t));\\n      } else {\\n        cells = aggr.value = aggr.value || this.init(_);\\n        pulse.visit(pulse.REM, t => aggr.rem(t));\\n        pulse.visit(pulse.ADD, t => aggr.add(t));\\n      }\\n\\n      // update aggregation cells\\n      aggr.changes();\\n\\n      // write aggregate values to input tuples\\n      pulse.visit(pulse.SOURCE, t => {\\n        vegaUtil.extend(t, cells[aggr.cellkey(t)].tuple);\\n      });\\n\\n      return pulse.reflow(mod).modifies(this._outputs);\\n    },\\n\\n    changes() {\\n      const adds = this._adds,\\n            mods = this._mods;\\n      let i, n;\\n\\n      for (i=0, n=this._alen; i<n; ++i) {\\n        this.celltuple(adds[i]);\\n        adds[i] = null; // for garbage collection\\n      }\\n\\n      for (i=0, n=this._mlen; i<n; ++i) {\\n        this.celltuple(mods[i]);\\n        mods[i] = null; // for garbage collection\\n      }\\n\\n      this._alen = this._mlen = 0; // reset list of active cells\\n    }\\n  });\\n\\n  /**\\n   * Compute kernel density estimates (KDE) for one or more data groups.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors\\n   *   to groupby.\\n   * @param {function(object): *} params.field - An accessor for the data field\\n   *   to estimate.\\n   * @param {number} [params.bandwidth=0] - The KDE kernel bandwidth.\\n   *   If zero or unspecified, the bandwidth is automatically determined.\\n   * @param {boolean} [params.counts=false] - A boolean flag indicating if the\\n   *   output values should be probability estimates (false, default) or\\n   *   smoothed counts (true).\\n   * @param {string} [params.cumulative=false] - A boolean flag indicating if a\\n   *   density (false) or cumulative distribution (true) should be generated.\\n   * @param {Array<number>} [params.extent] - The domain extent over which to\\n   *   plot the density. If unspecified, the [min, max] data extent is used.\\n   * @param {string} [params.resolve='independent'] - Indicates how parameters for\\n   *   multiple densities should be resolved. If \\\"independent\\\" (the default), each\\n   *   density may have its own domain extent and dynamic number of curve sample\\n   *   steps. If \\\"shared\\\", the KDE transform will ensure that all densities are\\n   *   defined over a shared domain and curve steps, enabling stacking.\\n   * @param {number} [params.minsteps=25] - The minimum number of curve samples\\n   *   for plotting the density.\\n   * @param {number} [params.maxsteps=200] - The maximum number of curve samples\\n   *   for plotting the density.\\n   * @param {number} [params.steps] - The exact number of curve samples for\\n   *   plotting the density. If specified, overrides both minsteps and maxsteps\\n   *   to set an exact number of uniform samples. Useful in conjunction with\\n   *   a fixed extent to ensure consistent sample points for stacked densities.\\n   */\\n  function KDE(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  KDE.Definition = {\\n    'type': 'KDE',\\n    'metadata': {'generates': true},\\n    'params': [\\n      { 'name': 'groupby', 'type': 'field', 'array': true },\\n      { 'name': 'field', 'type': 'field', 'required': true },\\n      { 'name': 'cumulative', 'type': 'boolean', 'default': false },\\n      { 'name': 'counts', 'type': 'boolean', 'default': false },\\n      { 'name': 'bandwidth', 'type': 'number', 'default': 0 },\\n      { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2 },\\n      { 'name': 'resolve', 'type': 'enum', 'values': ['shared', 'independent'], 'default': 'independent' },\\n      { 'name': 'steps', 'type': 'number' },\\n      { 'name': 'minsteps', 'type': 'number', 'default': 25 },\\n      { 'name': 'maxsteps', 'type': 'number', 'default': 200 },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'default': ['value', 'density'] }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(KDE, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\\n\\n      if (!this.value || pulse.changed() || _.modified()) {\\n        const source = pulse.materialize(pulse.SOURCE).source,\\n              groups = partition(source, _.groupby, _.field),\\n              names = (_.groupby || []).map(vegaUtil.accessorName),\\n              bandwidth = _.bandwidth,\\n              method = _.cumulative ? 'cdf' : 'pdf',\\n              as = _.as || ['value', 'density'],\\n              values = [];\\n\\n        let domain = _.extent,\\n            minsteps = _.steps || _.minsteps || 25,\\n            maxsteps = _.steps || _.maxsteps || 200;\\n\\n        if (method !== 'pdf' && method !== 'cdf') {\\n          vegaUtil.error('Invalid density method: ' + method);\\n        }\\n\\n        if (_.resolve === 'shared') {\\n          if (!domain) domain = vegaUtil.extent(source, _.field);\\n          minsteps = maxsteps = _.steps || maxsteps;\\n        }\\n\\n        groups.forEach(g => {\\n          const density = vegaStatistics.randomKDE(g, bandwidth)[method],\\n                scale = _.counts ? g.length : 1,\\n                local = domain || vegaUtil.extent(g);\\n\\n          vegaStatistics.sampleCurve(density, local, minsteps, maxsteps)\\n            .forEach(v => {\\n              const t = {};\\n              for (let i=0; i<names.length; ++i) {\\n                t[names[i]] = g.dims[i];\\n              }\\n              t[as[0]] = v[0];\\n              t[as[1]] = v[1] * scale;\\n              values.push(vegaDataflow.ingest(t));\\n            });\\n        });\\n\\n        if (this.value) out.rem = this.value;\\n        this.value = out.add = out.source = values;\\n      }\\n\\n      return out;\\n    }\\n  });\\n\\n  /**\\n   * Generates a key function.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<string>} params.fields - The field name(s) for the key function.\\n   * @param {boolean} params.flat - A boolean flag indicating if the field names\\n   *  should be treated as flat property names, side-stepping nested field\\n   *  lookups normally indicated by dot or bracket notation.\\n   */\\n  function Key(params) {\\n    vegaDataflow.Operator.call(this, null, update$3, params);\\n  }\\n\\n  vegaUtil.inherits(Key, vegaDataflow.Operator);\\n\\n  function update$3(_) {\\n    return (this.value && !_.modified()) ? this.value : vegaUtil.key(_.fields, _.flat);\\n  }\\n\\n  /**\\n   * Load and parse data from an external source. Marshalls parameter\\n   * values and then invokes the Dataflow request method.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {string} params.url - The URL to load from.\\n   * @param {object} params.format - The data format options.\\n   */\\n  function Load(params) {\\n    vegaDataflow.Transform.call(this, [], params);\\n    this._pending = null;\\n  }\\n\\n  vegaUtil.inherits(Load, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const df = pulse.dataflow;\\n\\n      if (this._pending) {\\n        // update state and return pulse\\n        return output(this, pulse, this._pending);\\n      }\\n\\n      if (stop(_)) return pulse.StopPropagation;\\n\\n      if (_.values) {\\n        // parse and ingest values, return output pulse\\n        return output(this, pulse, df.parse(_.values, _.format));\\n      } else if (_.async) {\\n        // return promise for non-blocking async loading\\n        const p = df.request(_.url, _.format).then(res => {\\n          this._pending = vegaUtil.array(res.data);\\n          return df => df.touch(this);\\n        });\\n        return {async: p};\\n      } else {\\n        // return promise for synchronous loading\\n        return df.request(_.url, _.format)\\n          .then(res => output(this, pulse, vegaUtil.array(res.data)));\\n      }\\n    }\\n  });\\n\\n  function stop(_) {\\n    return _.modified('async') && !(\\n      _.modified('values') || _.modified('url') || _.modified('format')\\n    );\\n  }\\n\\n  function output(op, pulse, data) {\\n    data.forEach(vegaDataflow.ingest);\\n    const out = pulse.fork(pulse.NO_FIELDS & pulse.NO_SOURCE);\\n    out.rem = op.value;\\n    op.value = out.source = out.add = data;\\n    op._pending = null;\\n    if (out.rem.length) out.clean(true);\\n    return out;\\n  }\\n\\n  /**\\n   * Extend tuples by joining them with values from a lookup table.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Map} params.index - The lookup table map.\\n   * @param {Array<function(object): *} params.fields - The fields to lookup.\\n   * @param {Array<string>} params.as - Output field names for each lookup value.\\n   * @param {*} [params.default] - A default value to use if lookup fails.\\n   */\\n  function Lookup(params) {\\n    vegaDataflow.Transform.call(this, {}, params);\\n  }\\n\\n  Lookup.Definition = {\\n    'type': 'Lookup',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'index', 'type': 'index', 'params': [\\n          {'name': 'from', 'type': 'data', 'required': true },\\n          {'name': 'key', 'type': 'field', 'required': true }\\n        ] },\\n      { 'name': 'values', 'type': 'field', 'array': true },\\n      { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\\n      { 'name': 'as', 'type': 'string', 'array': true },\\n      { 'name': 'default', 'default': null }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Lookup, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const keys = _.fields,\\n            index = _.index,\\n            values = _.values,\\n            defaultValue = _.default==null ? null : _.default,\\n            reset = _.modified(),\\n            n = keys.length;\\n\\n      let flag = reset ? pulse.SOURCE : pulse.ADD,\\n          out = pulse,\\n          as = _.as,\\n          set, m, mods;\\n\\n      if (values) {\\n        m = values.length;\\n\\n        if (n > 1 && !as) {\\n          vegaUtil.error('Multi-field lookup requires explicit \\\"as\\\" parameter.');\\n        }\\n        if (as && as.length !== n * m) {\\n          vegaUtil.error('The \\\"as\\\" parameter has too few output field names.');\\n        }\\n        as = as || values.map(vegaUtil.accessorName);\\n\\n        set = function(t) {\\n          for (var i=0, k=0, j, v; i<n; ++i) {\\n            v = index.get(keys[i](t));\\n            if (v == null) for (j=0; j<m; ++j, ++k) t[as[k]] = defaultValue;\\n            else for (j=0; j<m; ++j, ++k) t[as[k]] = values[j](v);\\n          }\\n        };\\n      } else {\\n        if (!as) {\\n          vegaUtil.error('Missing output field names.');\\n        }\\n\\n        set = function(t) {\\n          for (var i=0, v; i<n; ++i) {\\n            v = index.get(keys[i](t));\\n            t[as[i]] = v==null ? defaultValue : v;\\n          }\\n        };\\n      }\\n\\n      if (reset) {\\n        out = pulse.reflow(true);\\n      } else {\\n        mods = keys.some(k =>pulse.modified(k.fields));\\n        flag |= (mods ? pulse.MOD : 0);\\n      }\\n      pulse.visit(flag, set);\\n\\n      return out.modifies(as);\\n    }\\n  });\\n\\n  /**\\n   * Computes global min/max extents over a collection of extents.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<Array<number>>} params.extents - The input extents.\\n   */\\n  function MultiExtent(params) {\\n    vegaDataflow.Operator.call(this, null, update$4, params);\\n  }\\n\\n  vegaUtil.inherits(MultiExtent, vegaDataflow.Operator);\\n\\n  function update$4(_) {\\n    if (this.value && !_.modified()) {\\n      return this.value;\\n    }\\n\\n    const ext = _.extents,\\n          n = ext.length;\\n\\n    let min = +Infinity,\\n        max = -Infinity,\\n        i, e;\\n\\n    for (i = 0; i < n; ++i) {\\n      e = ext[i];\\n      if (e[0] < min) min = e[0];\\n      if (e[1] > max) max = e[1];\\n    }\\n    return [min, max];\\n  }\\n\\n  /**\\n   * Merge a collection of value arrays.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<Array<*>>} params.values - The input value arrrays.\\n   */\\n  function MultiValues(params) {\\n    vegaDataflow.Operator.call(this, null, update$5, params);\\n  }\\n\\n  vegaUtil.inherits(MultiValues, vegaDataflow.Operator);\\n\\n  function update$5(_) {\\n    return (this.value && !_.modified())\\n      ? this.value\\n      : _.values.reduce((data, _) => data.concat(_), []);\\n  }\\n\\n  /**\\n   * Operator whose value is simply its parameter hash. This operator is\\n   * useful for enabling reactive updates to values of nested objects.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   */\\n  function Params(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  vegaUtil.inherits(Params, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      this.modified(_.modified());\\n      this.value = _;\\n      return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS); // do not pass tuples\\n    }\\n  });\\n\\n  /**\\n   * Aggregate and pivot selected field values to become new fields.\\n   * This operator is useful to construction cross-tabulations.\\n   * @constructor\\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors\\n   *  to groupby. These fields act just like groupby fields of an Aggregate transform.\\n   * @param {function(object): *} params.field - The field to pivot on. The unique\\n   *  values of this field become new field names in the output stream.\\n   * @param {function(object): *} params.value - The field to populate pivoted fields.\\n   *  The aggregate values of this field become the values of the new pivoted fields.\\n   * @param {string} [params.op] - The aggregation operation for the value field,\\n   *  applied per cell in the output stream. The default is \\\"sum\\\".\\n   * @param {number} [params.limit] - An optional parameter indicating the maximum\\n   *  number of pivoted fields to generate. The pivoted field names are sorted in\\n   *  ascending order prior to enforcing the limit.\\n   */\\n  function Pivot(params) {\\n    Aggregate.call(this, params);\\n  }\\n\\n  Pivot.Definition = {\\n    'type': 'Pivot',\\n    'metadata': {'generates': true, 'changes': true},\\n    'params': [\\n      { 'name': 'groupby', 'type': 'field', 'array': true },\\n      { 'name': 'field', 'type': 'field', 'required': true },\\n      { 'name': 'value', 'type': 'field', 'required': true },\\n      { 'name': 'op', 'type': 'enum', 'values': ValidAggregateOps, 'default': 'sum' },\\n      { 'name': 'limit', 'type': 'number', 'default': 0 },\\n      { 'name': 'key', 'type': 'field' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Pivot, Aggregate, {\\n    _transform: Aggregate.prototype.transform,\\n    transform(_, pulse) {\\n      return this._transform(aggregateParams(_, pulse), pulse);\\n    }\\n  });\\n\\n  // Shoehorn a pivot transform into an aggregate transform!\\n  // First collect all unique pivot field values.\\n  // Then generate aggregate fields for each output pivot field.\\n  function aggregateParams(_, pulse) {\\n    const key    = _.field,\\n          value  = _.value,\\n          op     = (_.op === 'count' ? '__count__' : _.op) || 'sum',\\n          fields = vegaUtil.accessorFields(key).concat(vegaUtil.accessorFields(value)),\\n          keys   = pivotKeys(key, _.limit || 0, pulse);\\n\\n    // if data stream content changes, pivot fields may change\\n    // flag parameter modification to ensure re-initialization\\n    if (pulse.changed()) _.set('__pivot__', null, null, true);\\n\\n    return {\\n      key:      _.key,\\n      groupby:  _.groupby,\\n      ops:      keys.map(() => op),\\n      fields:   keys.map(k => get(k, key, value, fields)),\\n      as:       keys.map(k => k + ''),\\n      modified: _.modified.bind(_)\\n    };\\n  }\\n\\n  // Generate aggregate field accessor.\\n  // Output NaN for non-existent values; aggregator will ignore!\\n  function get(k, key, value, fields) {\\n    return vegaUtil.accessor(\\n      d => key(d) === k ? value(d) : NaN,\\n      fields,\\n      k + ''\\n    );\\n  }\\n\\n  // Collect (and optionally limit) all unique pivot values.\\n  function pivotKeys(key, limit, pulse) {\\n    const map = {},\\n          list = [];\\n\\n    pulse.visit(pulse.SOURCE, t => {\\n      const k = key(t);\\n      if (!map[k]) {\\n        map[k] = 1;\\n        list.push(k);\\n      }\\n    });\\n\\n    list.sort(vegaUtil.ascending);\\n\\n    return limit ? list.slice(0, limit) : list;\\n  }\\n\\n  /**\\n   * Partitions pre-faceted data into tuple subflows.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(Dataflow, string): Operator} params.subflow - A function\\n   *   that generates a subflow of operators and returns its root operator.\\n   * @param {function(object): Array<object>} params.field - The field\\n   *   accessor for an array of subflow tuple objects.\\n   */\\n  function PreFacet(params) {\\n    Facet.call(this, params);\\n  }\\n\\n  vegaUtil.inherits(PreFacet, Facet, {\\n    transform(_, pulse) {\\n      const flow = _.subflow,\\n            field = _.field,\\n            subflow = t => this.subflow(vegaDataflow.tupleid(t), flow, pulse, t);\\n\\n      if (_.modified('field') || field && pulse.modified(vegaUtil.accessorFields(field))) {\\n        vegaUtil.error('PreFacet does not support field modification.');\\n      }\\n\\n      this.initTargets(); // reset list of active subflows\\n\\n      if (field) {\\n        pulse.visit(pulse.MOD, t => {\\n          const sf = subflow(t);\\n          field(t).forEach(_ => sf.mod(_));\\n        });\\n\\n        pulse.visit(pulse.ADD, t => {\\n          const sf = subflow(t);\\n          field(t).forEach(_ => sf.add(vegaDataflow.ingest(_)));\\n        });\\n\\n        pulse.visit(pulse.REM, t => {\\n          const sf = subflow(t);\\n          field(t).forEach(_ => sf.rem(_));\\n        });\\n      } else {\\n        pulse.visit(pulse.MOD, t => subflow(t).mod(t));\\n        pulse.visit(pulse.ADD, t => subflow(t).add(t));\\n        pulse.visit(pulse.REM, t => subflow(t).rem(t));\\n      }\\n\\n      if (pulse.clean()) {\\n        pulse.runAfter(() => this.clean());\\n      }\\n\\n      return pulse;\\n    }\\n  });\\n\\n  /**\\n   * Performs a relational projection, copying selected fields from source\\n   * tuples to a new set of derived tuples.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<function(object): *} params.fields - The fields to project,\\n   *   as an array of field accessors. If unspecified, all fields will be\\n   *   copied with names unchanged.\\n   * @param {Array<string>} [params.as] - Output field names for each projected\\n   *   field. Any unspecified fields will use the field name provided by\\n   *   the field accessor.\\n   */\\n  function Project(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Project.Definition = {\\n    'type': 'Project',\\n    'metadata': {'generates': true, 'changes': true},\\n    'params': [\\n      { 'name': 'fields', 'type': 'field', 'array': true },\\n      { 'name': 'as', 'type': 'string', 'null': true, 'array': true }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Project, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const out = pulse.fork(pulse.NO_SOURCE),\\n            fields = _.fields,\\n            as = fieldNames(_.fields, _.as || []),\\n            derive = fields\\n              ? (s, t) => project(s, t, fields, as)\\n              : vegaDataflow.rederive;\\n\\n      let lut;\\n      if (this.value) {\\n        lut = this.value;\\n      } else {\\n        pulse = pulse.addAll();\\n        lut = this.value = {};\\n      }\\n\\n      pulse.visit(pulse.REM, t => {\\n        const id = vegaDataflow.tupleid(t);\\n        out.rem.push(lut[id]);\\n        lut[id] = null;\\n      });\\n\\n      pulse.visit(pulse.ADD, t => {\\n        const dt = derive(t, vegaDataflow.ingest({}));\\n        lut[vegaDataflow.tupleid(t)] = dt;\\n        out.add.push(dt);\\n      });\\n\\n      pulse.visit(pulse.MOD, t => {\\n        out.mod.push(derive(t, lut[vegaDataflow.tupleid(t)]));\\n      });\\n\\n      return out;\\n    }\\n  });\\n\\n  function project(s, t, fields, as) {\\n    for (let i=0, n=fields.length; i<n; ++i) {\\n      t[as[i]] = fields[i](s);\\n    }\\n    return t;\\n  }\\n\\n  /**\\n   * Proxy the value of another operator as a pure signal value.\\n   * Ensures no tuples are propagated.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {*} params.value - The value to proxy, becomes the value of this operator.\\n   */\\n  function Proxy(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  vegaUtil.inherits(Proxy, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      this.value = _.value;\\n      return _.modified('value')\\n        ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS)\\n        : pulse.StopPropagation;\\n    }\\n  });\\n\\n  /**\\n   * Generates sample quantile values from an input data stream.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - An accessor for the data field\\n   *   over which to calculate quantile values.\\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors\\n   *   to groupby.\\n   * @param {Array<number>} [params.probs] - An array of probabilities in\\n   *   the range (0, 1) for which to compute quantile values. If not specified,\\n   *   the *step* parameter will be used.\\n   * @param {Array<number>} [params.step=0.01] - A probability step size for\\n   *   sampling quantile values. All values from one-half the step size up to\\n   *   1 (exclusive) will be sampled. This parameter is only used if the\\n   *   *quantiles* parameter is not provided.\\n   */\\n  function Quantile(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Quantile.Definition = {\\n    'type': 'Quantile',\\n    'metadata': {'generates': true, 'changes': true},\\n    'params': [\\n      { 'name': 'groupby', 'type': 'field', 'array': true },\\n      { 'name': 'field', 'type': 'field', 'required': true },\\n      { 'name': 'probs', 'type': 'number', 'array': true },\\n      { 'name': 'step', 'type': 'number', 'default': 0.01 },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'default': ['prob', 'value'] }\\n    ]\\n  };\\n\\n  const EPSILON$1 = 1e-14;\\n\\n  vegaUtil.inherits(Quantile, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\\n            as = _.as || ['prob', 'value'];\\n\\n      if (this.value && !_.modified() && !pulse.changed()) {\\n        out.source = this.value;\\n        return out;\\n      }\\n\\n      const source = pulse.materialize(pulse.SOURCE).source,\\n            groups = partition(source, _.groupby, _.field),\\n            names = (_.groupby || []).map(vegaUtil.accessorName),\\n            values = [],\\n            step = _.step || 0.01,\\n            p = _.probs || d3Array.range(step/2, 1 - EPSILON$1, step),\\n            n = p.length;\\n\\n      groups.forEach(g => {\\n        const q = vegaStatistics.quantiles(g, p);\\n\\n        for (let i=0; i<n; ++i) {\\n          const t = {};\\n          for (let i=0; i<names.length; ++i) {\\n            t[names[i]] = g.dims[i];\\n          }\\n          t[as[0]] = p[i];\\n          t[as[1]] = q[i];\\n          values.push(vegaDataflow.ingest(t));\\n        }\\n      });\\n\\n      if (this.value) out.rem = this.value;\\n      this.value = out.add = out.source = values;\\n\\n      return out;\\n    }\\n  });\\n\\n  /**\\n   * Relays a data stream between data processing pipelines.\\n   * If the derive parameter is set, this transform will create derived\\n   * copies of observed tuples. This provides derived data streams in which\\n   * modifications to the tuples do not pollute an upstream data source.\\n   * @param {object} params - The parameters for this operator.\\n   * @param {number} [params.derive=false] - Boolean flag indicating if\\n   *   the transform should make derived copies of incoming tuples.\\n   * @constructor\\n   */\\n  function Relay(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  vegaUtil.inherits(Relay, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      let out, lut;\\n\\n      if (this.value) {\\n        lut = this.value;\\n      } else {\\n        out = pulse = pulse.addAll();\\n        lut = this.value = {};\\n      }\\n\\n      if (_.derive) {\\n        out = pulse.fork(pulse.NO_SOURCE);\\n\\n        pulse.visit(pulse.REM, t => {\\n          const id = vegaDataflow.tupleid(t);\\n          out.rem.push(lut[id]);\\n          lut[id] = null;\\n        });\\n\\n        pulse.visit(pulse.ADD, t => {\\n          const dt = vegaDataflow.derive(t);\\n          lut[vegaDataflow.tupleid(t)] = dt;\\n          out.add.push(dt);\\n        });\\n\\n        pulse.visit(pulse.MOD, t => {\\n          const dt = lut[vegaDataflow.tupleid(t)];\\n          for (const k in t) {\\n            dt[k] = t[k];\\n            // down stream writes may overwrite re-derived tuples\\n            // conservatively mark all source fields as modified\\n            out.modifies(k);\\n          }\\n          out.mod.push(dt);\\n        });\\n      }\\n\\n      return out;\\n    }\\n  });\\n\\n  /**\\n   * Samples tuples passing through this operator.\\n   * Uses reservoir sampling to maintain a representative sample.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {number} [params.size=1000] - The maximum number of samples.\\n   */\\n  function Sample(params) {\\n    vegaDataflow.Transform.call(this, [], params);\\n    this.count = 0;\\n  }\\n\\n  Sample.Definition = {\\n    'type': 'Sample',\\n    'metadata': {},\\n    'params': [\\n      { 'name': 'size', 'type': 'number', 'default': 1000 }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Sample, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const out = pulse.fork(pulse.NO_SOURCE),\\n            mod = _.modified('size'),\\n            num = _.size,\\n            map = this.value.reduce((m, t) => (m[vegaDataflow.tupleid(t)] = 1, m), {});\\n\\n      let res = this.value,\\n          cnt = this.count,\\n          cap = 0;\\n\\n      // sample reservoir update function\\n      function update(t) {\\n        let p, idx;\\n\\n        if (res.length < num) {\\n          res.push(t);\\n        } else {\\n          idx = ~~((cnt + 1) * vegaStatistics.random());\\n          if (idx < res.length && idx >= cap) {\\n            p = res[idx];\\n            if (map[vegaDataflow.tupleid(p)]) out.rem.push(p); // eviction\\n            res[idx] = t;\\n          }\\n        }\\n        ++cnt;\\n      }\\n\\n      if (pulse.rem.length) {\\n        // find all tuples that should be removed, add to output\\n        pulse.visit(pulse.REM, t => {\\n          const id = vegaDataflow.tupleid(t);\\n          if (map[id]) {\\n            map[id] = -1;\\n            out.rem.push(t);\\n          }\\n          --cnt;\\n        });\\n\\n        // filter removed tuples out of the sample reservoir\\n        res = res.filter(t => map[vegaDataflow.tupleid(t)] !== -1);\\n      }\\n\\n      if ((pulse.rem.length || mod) && res.length < num && pulse.source) {\\n        // replenish sample if backing data source is available\\n        cap = cnt = res.length;\\n        pulse.visit(pulse.SOURCE, t => {\\n          // update, but skip previously sampled tuples\\n          if (!map[vegaDataflow.tupleid(t)]) update(t);\\n        });\\n        cap = -1;\\n      }\\n\\n      if (mod && res.length > num) {\\n        const n = res.length-num;\\n        for (let i=0; i<n; ++i) {\\n          map[vegaDataflow.tupleid(res[i])] = -1;\\n          out.rem.push(res[i]);\\n        }\\n        res = res.slice(n);\\n      }\\n\\n      if (pulse.mod.length) {\\n        // propagate modified tuples in the sample reservoir\\n        pulse.visit(pulse.MOD, t => {\\n          if (map[vegaDataflow.tupleid(t)]) out.mod.push(t);\\n        });\\n      }\\n\\n      if (pulse.add.length) {\\n        // update sample reservoir\\n        pulse.visit(pulse.ADD, update);\\n      }\\n\\n      if (pulse.add.length || cap < 0) {\\n        // output newly added tuples\\n        out.add = res.filter(t => !map[vegaDataflow.tupleid(t)]);\\n      }\\n\\n      this.count = cnt;\\n      this.value = out.source = res;\\n      return out;\\n    }\\n  });\\n\\n  /**\\n   * Generates data tuples for a specified sequence range of numbers.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {number} params.start - The first number in the sequence.\\n   * @param {number} params.stop - The last number (exclusive) in the sequence.\\n   * @param {number} [params.step=1] - The step size between numbers in the sequence.\\n   */\\n  function Sequence(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  Sequence.Definition = {\\n    'type': 'Sequence',\\n    'metadata': {'generates': true, 'changes': true},\\n    'params': [\\n      { 'name': 'start', 'type': 'number', 'required': true },\\n      { 'name': 'stop', 'type': 'number', 'required': true },\\n      { 'name': 'step', 'type': 'number', 'default': 1 },\\n      { 'name': 'as', 'type': 'string', 'default': 'data' }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Sequence, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      if (this.value && !_.modified()) return;\\n\\n      const out = pulse.materialize().fork(pulse.MOD),\\n            as = _.as || 'data';\\n\\n      out.rem = this.value ? pulse.rem.concat(this.value) : pulse.rem;\\n\\n      this.value = d3Array.range(_.start, _.stop, _.step || 1).map(v => {\\n        const t = {};\\n        t[as] = v;\\n        return vegaDataflow.ingest(t);\\n      });\\n\\n      out.add = pulse.add.concat(this.value);\\n\\n      return out;\\n    }\\n  });\\n\\n  /**\\n   * Propagates a new pulse without any tuples so long as the input\\n   * pulse contains some added, removed or modified tuples.\\n   * @param {object} params - The parameters for this operator.\\n   * @constructor\\n   */\\n  function Sieve(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n    this.modified(true); // always treat as modified\\n  }\\n\\n  vegaUtil.inherits(Sieve, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      this.value = pulse.source;\\n      return pulse.changed()\\n        ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS)\\n        : pulse.StopPropagation;\\n    }\\n  });\\n\\n  /**\\n   * Discretize dates to specific time units.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - The data field containing date/time values.\\n   */\\n  function TimeUnit(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  const OUTPUT = ['unit0', 'unit1'];\\n\\n  TimeUnit.Definition = {\\n    'type': 'TimeUnit',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'field', 'type': 'field', 'required': true },\\n      { 'name': 'interval', 'type': 'boolean', 'default': true },\\n      { 'name': 'units', 'type': 'enum', 'values': vegaTime.TIME_UNITS, 'array': true },\\n      { 'name': 'step', 'type': 'number', 'default': 1 },\\n      { 'name': 'maxbins', 'type': 'number', 'default': 40 },\\n      { 'name': 'extent', 'type': 'date', 'array': true},\\n      { 'name': 'timezone', 'type': 'enum', 'default': 'local', 'values': ['local', 'utc'] },\\n      { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': OUTPUT }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(TimeUnit, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const field = _.field,\\n            band = _.interval !== false,\\n            utc = _.timezone === 'utc',\\n            floor = this._floor(_, pulse),\\n            offset = (utc ? vegaTime.utcInterval : vegaTime.timeInterval)(floor.unit).offset,\\n            as = _.as || OUTPUT,\\n            u0 = as[0],\\n            u1 = as[1],\\n            step = floor.step;\\n\\n      let min = floor.start || Infinity,\\n          max = floor.stop || -Infinity,\\n          flag = pulse.ADD;\\n\\n      if (_.modified() || pulse.modified(vegaUtil.accessorFields(field))) {\\n        pulse = pulse.reflow(true);\\n        flag = pulse.SOURCE;\\n        min = Infinity;\\n        max = -Infinity;\\n      }\\n\\n      pulse.visit(flag, t => {\\n        const v = field(t);\\n        let a, b;\\n        if (v == null) {\\n          t[u0] = null;\\n          if (band) t[u1] = null;\\n        } else {\\n          t[u0] = a = b = floor(v);\\n          if (band) t[u1] = b = offset(a, step);\\n          if (a < min) min = a;\\n          if (b > max) max = b;\\n        }\\n      });\\n\\n      floor.start = min;\\n      floor.stop = max;\\n\\n      return pulse.modifies(band ? as : u0);\\n    },\\n\\n    _floor(_, pulse) {\\n      const utc = _.timezone === 'utc';\\n\\n      // get parameters\\n      const {units, step} = _.units\\n        ? {units: _.units, step: _.step || 1}\\n        : vegaTime.timeBin({\\n          extent:  _.extent || vegaUtil.extent(pulse.materialize(pulse.SOURCE).source, _.field),\\n          maxbins: _.maxbins\\n        });\\n\\n      // check / standardize time units\\n      const tunits = vegaTime.timeUnits(units),\\n            prev = this.value || {},\\n            floor = (utc ? vegaTime.utcFloor : vegaTime.timeFloor)(tunits, step);\\n\\n      floor.unit = vegaUtil.peek(tunits);\\n      floor.units = tunits;\\n      floor.step = step;\\n      floor.start = prev.start;\\n      floor.stop = prev.stop;\\n      return this.value = floor;\\n    }\\n  });\\n\\n  /**\\n   * An index that maps from unique, string-coerced, field values to tuples.\\n   * Assumes that the field serves as a unique key with no duplicate values.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - The field accessor to index.\\n   */\\n  function TupleIndex(params) {\\n    vegaDataflow.Transform.call(this, vegaUtil.fastmap(), params);\\n  }\\n\\n  vegaUtil.inherits(TupleIndex, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const df = pulse.dataflow,\\n          field = _.field,\\n          index = this.value,\\n          set = t => index.set(field(t), t);\\n\\n      let mod = true;\\n\\n      if (_.modified('field') || pulse.modified(field.fields)) {\\n        index.clear();\\n        pulse.visit(pulse.SOURCE, set);\\n      } else if (pulse.changed()) {\\n        pulse.visit(pulse.REM, t => index.delete(field(t)));\\n        pulse.visit(pulse.ADD, set);\\n      } else {\\n        mod = false;\\n      }\\n\\n      this.modified(mod);\\n      if (index.empty > df.cleanThreshold) df.runAfter(index.clean);\\n      return pulse.fork();\\n    }\\n  });\\n\\n  /**\\n   * Extracts an array of values. Assumes the source data has already been\\n   * reduced as needed (e.g., by an upstream Aggregate transform).\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(object): *} params.field - The domain field to extract.\\n   * @param {function(*,*): number} [params.sort] - An optional\\n   *   comparator function for sorting the values. The comparator will be\\n   *   applied to backing tuples prior to value extraction.\\n   */\\n  function Values(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  vegaUtil.inherits(Values, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const run = !this.value\\n        || _.modified('field')\\n        || _.modified('sort')\\n        || pulse.changed()\\n        || (_.sort && pulse.modified(_.sort.fields));\\n\\n      if (run) {\\n        this.value = (_.sort\\n          ? pulse.source.slice().sort(vegaDataflow.stableCompare(_.sort))\\n          : pulse.source).map(_.field);\\n      }\\n    }\\n  });\\n\\n  function WindowOp(op, field, param, as) {\\n    const fn = WindowOps[op](field, param);\\n    return {\\n      init:   fn.init || vegaUtil.zero,\\n      update: function(w, t) { t[as] = fn.next(w); }\\n    };\\n  }\\n\\n  const WindowOps = {\\n    row_number: function() {\\n      return {\\n        next: w => w.index + 1\\n      };\\n    },\\n    rank: function() {\\n      let rank;\\n      return {\\n        init: () => rank = 1,\\n        next: w => {\\n          const i = w.index,\\n                data = w.data;\\n          return (i && w.compare(data[i - 1], data[i])) ? (rank = i + 1) : rank;\\n        }\\n      };\\n    },\\n    dense_rank: function() {\\n      let drank;\\n      return {\\n        init: () => drank = 1,\\n        next: w => {\\n          const i = w.index,\\n                d = w.data;\\n          return (i && w.compare(d[i - 1], d[i])) ? ++drank : drank;\\n        }\\n      };\\n    },\\n    percent_rank: function() {\\n      const rank = WindowOps.rank(),\\n            next = rank.next;\\n      return {\\n        init: rank.init,\\n        next: w => (next(w) - 1) / (w.data.length - 1)\\n      };\\n    },\\n    cume_dist: function() {\\n      let cume;\\n      return {\\n        init: () => cume = 0,\\n        next: w => {\\n          const d = w.data,\\n                c = w.compare;\\n          let i = w.index;\\n          if (cume < i) {\\n            while (i + 1 < d.length && !c(d[i], d[i + 1])) ++i;\\n            cume = i;\\n          }\\n          return (1 + cume) / d.length;\\n        }\\n      };\\n    },\\n    ntile: function(field, num) {\\n      num = +num;\\n      if (!(num > 0)) vegaUtil.error('ntile num must be greater than zero.');\\n      const cume = WindowOps.cume_dist(),\\n            next = cume.next;\\n      return {\\n        init: cume.init,\\n        next: w => Math.ceil(num * next(w))\\n      };\\n    },\\n\\n    lag: function(field, offset) {\\n      offset = +offset || 1;\\n      return {\\n        next: w => {\\n          const i = w.index - offset;\\n          return i >= 0 ? field(w.data[i]) : null;\\n        }\\n      };\\n    },\\n    lead: function(field, offset) {\\n      offset = +offset || 1;\\n      return {\\n        next: w => {\\n          const i = w.index + offset,\\n              d = w.data;\\n          return i < d.length ? field(d[i]) : null;\\n        }\\n      };\\n    },\\n\\n    first_value: function(field) {\\n      return {\\n        next: w => field(w.data[w.i0])\\n      };\\n    },\\n    last_value: function(field) {\\n      return {\\n        next: w => field(w.data[w.i1 - 1])\\n      };\\n    },\\n    nth_value: function(field, nth) {\\n      nth = +nth;\\n      if (!(nth > 0)) vegaUtil.error('nth_value nth must be greater than zero.');\\n      return {\\n        next: w => {\\n          const i = w.i0 + (nth - 1);\\n          return i < w.i1 ? field(w.data[i]) : null;\\n        }\\n      };\\n    },\\n\\n    prev_value: function(field) {\\n      let prev;\\n      return {\\n        init: () => prev = null,\\n        next: w => {\\n          const v = field(w.data[w.index]);\\n          return v != null ? (prev = v) : prev;\\n        }\\n      };\\n    },\\n    next_value: function(field) {\\n      let v, i;\\n      return {\\n        init: () => (v = null, i = -1),\\n        next: w => {\\n          const d = w.data;\\n          return w.index <= i ? v\\n            : (i = find(field, d, w.index)) < 0\\n              ? (i = d.length, v = null)\\n              : (v = field(d[i]));\\n        }\\n      };\\n    }\\n  };\\n\\n  function find(field, data, index) {\\n    for (let n = data.length; index < n; ++index) {\\n      const v = field(data[index]);\\n      if (v != null) return index;\\n    }\\n    return -1;\\n  }\\n\\n  const ValidWindowOps = Object.keys(WindowOps);\\n\\n  function WindowState(_) {\\n    const ops = vegaUtil.array(_.ops),\\n          fields = vegaUtil.array(_.fields),\\n          params = vegaUtil.array(_.params),\\n          as = vegaUtil.array(_.as),\\n          outputs = this.outputs = [],\\n          windows = this.windows = [],\\n          inputs = {},\\n          map = {},\\n          counts = [],\\n          measures = [];\\n\\n    let countOnly = true;\\n\\n    function visitInputs(f) {\\n      vegaUtil.array(vegaUtil.accessorFields(f)).forEach(_ => inputs[_] = 1);\\n    }\\n    visitInputs(_.sort);\\n\\n    ops.forEach((op, i) => {\\n      const field = fields[i],\\n            mname = vegaUtil.accessorName(field),\\n            name = measureName(op, mname, as[i]);\\n\\n      visitInputs(field);\\n      outputs.push(name);\\n\\n      // Window operation\\n      if (vegaUtil.hasOwnProperty(WindowOps, op)) {\\n        windows.push(WindowOp(op, fields[i], params[i], name));\\n      }\\n\\n      // Aggregate operation\\n      else {\\n        if (field == null && op !== 'count') {\\n          vegaUtil.error('Null aggregate field specified.');\\n        }\\n        if (op === 'count') {\\n          counts.push(name);\\n          return;\\n        }\\n\\n        countOnly = false;\\n        let m = map[mname];\\n        if (!m) {\\n          m = (map[mname] = []);\\n          m.field = field;\\n          measures.push(m);\\n        }\\n        m.push(createMeasure(op, name));\\n      }\\n    });\\n\\n    if (counts.length || measures.length) {\\n      this.cell = cell(measures, counts, countOnly);\\n    }\\n\\n    this.inputs = Object.keys(inputs);\\n  }\\n\\n  const prototype$1 = WindowState.prototype;\\n\\n  prototype$1.init = function() {\\n    this.windows.forEach(_ => _.init());\\n    if (this.cell) this.cell.init();\\n  };\\n\\n  prototype$1.update = function(w, t) {\\n    const cell = this.cell,\\n          wind = this.windows,\\n          data = w.data,\\n          m = wind && wind.length;\\n    let j;\\n\\n    if (cell) {\\n      for (j = w.p0; j < w.i0; ++j) cell.rem(data[j]);\\n      for (j = w.p1; j < w.i1; ++j) cell.add(data[j]);\\n      cell.set(t);\\n    }\\n    for (j = 0; j < m; ++j) wind[j].update(w, t);\\n  };\\n\\n  function cell(measures, counts, countOnly) {\\n    measures = measures.map(m => compileMeasures(m, m.field));\\n\\n    const cell = {\\n      num:   0,\\n      agg:   null,\\n      store: false,\\n      count: counts\\n    };\\n\\n    if (!countOnly) {\\n      var n = measures.length,\\n          a = cell.agg = Array(n),\\n          i = 0;\\n      for (; i<n; ++i) a[i] = new measures[i](cell);\\n    }\\n\\n    if (cell.store) {\\n      var store = cell.data = new TupleStore();\\n    }\\n\\n    cell.add = function(t) {\\n      cell.num += 1;\\n      if (countOnly) return;\\n      if (store) store.add(t);\\n      for (let i=0; i<n; ++i) {\\n        a[i].add(a[i].get(t), t);\\n      }\\n    };\\n\\n    cell.rem = function(t) {\\n      cell.num -= 1;\\n      if (countOnly) return;\\n      if (store) store.rem(t);\\n      for (let i=0; i<n; ++i) {\\n        a[i].rem(a[i].get(t), t);\\n      }\\n    };\\n\\n    cell.set = function(t) {\\n      let i, n;\\n\\n      // consolidate stored values\\n      if (store) store.values();\\n\\n      // update tuple properties\\n      for (i=0, n=counts.length; i<n; ++i) t[counts[i]] = cell.num;\\n      if (!countOnly) for (i=0, n=a.length; i<n; ++i) a[i].set(t);\\n    };\\n\\n    cell.init = function() {\\n      cell.num = 0;\\n      if (store) store.reset();\\n      for (let i=0; i<n; ++i) a[i].init();\\n    };\\n\\n    return cell;\\n  }\\n\\n  /**\\n   * Perform window calculations and write results to the input stream.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(*,*): number} [params.sort] - A comparator function for sorting tuples within a window.\\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors by which to partition tuples into separate windows.\\n   * @param {Array<string>} params.ops - An array of strings indicating window operations to perform.\\n   * @param {Array<function(object): *>} [params.fields] - An array of accessors\\n   *   for data fields to use as inputs to window operations.\\n   * @param {Array<*>} [params.params] - An array of parameter values for window operations.\\n   * @param {Array<string>} [params.as] - An array of output field names for window operations.\\n   * @param {Array<number>} [params.frame] - Window frame definition as two-element array.\\n   * @param {boolean} [params.ignorePeers=false] - If true, base window frame boundaries on row\\n   *   number alone, ignoring peers with identical sort values. If false (default),\\n   *   the window boundaries will be adjusted to include peer values.\\n   */\\n  function Window(params) {\\n    vegaDataflow.Transform.call(this, {}, params);\\n    this._mlen = 0;\\n    this._mods = [];\\n  }\\n\\n  Window.Definition = {\\n    'type': 'Window',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'sort', 'type': 'compare' },\\n      { 'name': 'groupby', 'type': 'field', 'array': true },\\n      { 'name': 'ops', 'type': 'enum', 'array': true, 'values': ValidWindowOps.concat(ValidAggregateOps) },\\n      { 'name': 'params', 'type': 'number', 'null': true, 'array': true },\\n      { 'name': 'fields', 'type': 'field', 'null': true, 'array': true },\\n      { 'name': 'as', 'type': 'string', 'null': true, 'array': true },\\n      { 'name': 'frame', 'type': 'number', 'null': true, 'array': true, 'length': 2, 'default': [null, 0] },\\n      { 'name': 'ignorePeers', 'type': 'boolean', 'default': false }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Window, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      this.stamp = pulse.stamp;\\n\\n      const mod = _.modified(),\\n            cmp = vegaDataflow.stableCompare(_.sort),\\n            key = groupkey(_.groupby),\\n            group = t => this.group(key(t));\\n\\n      // initialize window state\\n      let state = this.state;\\n      if (!state || mod) {\\n        state = this.state = new WindowState(_);\\n      }\\n\\n      // partition input tuples\\n      if (mod || pulse.modified(state.inputs)) {\\n        this.value = {};\\n        pulse.visit(pulse.SOURCE, t => group(t).add(t));\\n      } else {\\n        pulse.visit(pulse.REM, t => group(t).remove(t));\\n        pulse.visit(pulse.ADD, t => group(t).add(t));\\n      }\\n\\n      // perform window calculations for each modified partition\\n      for (let i=0, n=this._mlen; i<n; ++i) {\\n        processPartition(this._mods[i], state, cmp, _);\\n      }\\n      this._mlen = 0;\\n      this._mods = [];\\n\\n      // TODO don't reflow everything?\\n      return pulse.reflow(mod).modifies(state.outputs);\\n    },\\n\\n    group(key) {\\n      let group = this.value[key];\\n\\n      if (!group) {\\n        group = this.value[key] = SortedList(vegaDataflow.tupleid);\\n        group.stamp = -1;\\n      }\\n\\n      if (group.stamp < this.stamp) {\\n        group.stamp = this.stamp;\\n        this._mods[this._mlen++] = group;\\n      }\\n\\n      return group;\\n    }\\n  });\\n\\n  function processPartition(list, state, cmp, _) {\\n    const sort = _.sort,\\n          range = sort && !_.ignorePeers,\\n          frame = _.frame || [null, 0],\\n          data = list.data(cmp), // use cmp for stable sort\\n          n = data.length,\\n          b = range ? d3Array.bisector(sort) : null,\\n          w = {\\n            i0: 0, i1: 0, p0: 0, p1: 0, index: 0,\\n            data: data, compare: sort || vegaUtil.constant(-1)\\n          };\\n\\n    state.init();\\n    for (let i=0; i<n; ++i) {\\n      setWindow(w, frame, i, n);\\n      if (range) adjustRange(w, b);\\n      state.update(w, data[i]);\\n    }\\n  }\\n\\n  function setWindow(w, f, i, n) {\\n    w.p0 = w.i0;\\n    w.p1 = w.i1;\\n    w.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));\\n    w.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);\\n    w.index = i;\\n  }\\n\\n  // if frame type is 'range', adjust window for peer values\\n  function adjustRange(w, bisect) {\\n    const r0 = w.i0,\\n          r1 = w.i1 - 1,\\n          c = w.compare,\\n          d = w.data,\\n          n = d.length - 1;\\n\\n    if (r0 > 0 && !c(d[r0], d[r0-1])) w.i0 = bisect.left(d, d[r0]);\\n    if (r1 < n && !c(d[r1], d[r1+1])) w.i1 = bisect.right(d, d[r1]);\\n  }\\n\\n  exports.aggregate = Aggregate;\\n  exports.bin = Bin;\\n  exports.collect = Collect;\\n  exports.compare = Compare;\\n  exports.countpattern = CountPattern;\\n  exports.cross = Cross;\\n  exports.density = Density;\\n  exports.dotbin = DotBin;\\n  exports.expression = Expression;\\n  exports.extent = Extent;\\n  exports.facet = Facet;\\n  exports.field = Field;\\n  exports.filter = Filter;\\n  exports.flatten = Flatten;\\n  exports.fold = Fold;\\n  exports.formula = Formula;\\n  exports.generate = Generate;\\n  exports.impute = Impute;\\n  exports.joinaggregate = JoinAggregate;\\n  exports.kde = KDE;\\n  exports.key = Key;\\n  exports.load = Load;\\n  exports.lookup = Lookup;\\n  exports.multiextent = MultiExtent;\\n  exports.multivalues = MultiValues;\\n  exports.params = Params;\\n  exports.pivot = Pivot;\\n  exports.prefacet = PreFacet;\\n  exports.project = Project;\\n  exports.proxy = Proxy;\\n  exports.quantile = Quantile;\\n  exports.relay = Relay;\\n  exports.sample = Sample;\\n  exports.sequence = Sequence;\\n  exports.sieve = Sieve;\\n  exports.subflow = Subflow;\\n  exports.timeunit = TimeUnit;\\n  exports.tupleindex = TupleIndex;\\n  exports.values = Values;\\n  exports.window = Window;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"transforms\",\"d3\",\"vegaUtil\",\"vegaDataflow\",\"vegaStatistics\",\"d3Array\",\"vegaTime\",\"multikey\",\"f\",\"x\",\"n\",\"length\",\"i\",\"k\",\"String\",\"groupkey\",\"fields\",\"measure\",\"key\",\"value\",\"out\",\"extend\",\"name\",\"base_op\",\"compareIndex\",\"a\",\"b\",\"idx\",\"resolve\",\"agg\",\"map\",\"forEach\",\"getreqs\",\"req\",\"AggregateOps\",\"Object\",\"values\",\"sort\",\"init\",\"missing\",\"valid\",\"_ops\",\"op\",\"add\",\"v\",\"t\",\"rem\",\"set\",\"_out\",\"compileMeasures\",\"field\",\"ctr\",\"cell\",\"ops\",\"get\",\"identity\",\"slice\",\"prototype\",\"TupleStore\",\"_key\",\"tupleid\",\"reset\",\"Aggregate\",\"params\",\"Transform\",\"call\",\"_adds\",\"_mods\",\"_mlen\",\"_alen\",\"_drop\",\"_cross\",\"_dims\",\"_dnames\",\"_measures\",\"_countOnly\",\"_outputs\",\"_inputs\",\"_prev\",\"_counts\",\"Bin\",\"SortedList\",\"idFunc\",\"source\",\"input\",\"data\",\"cnt\",\"push\",\"remove\",\"size\",\"compare\",\"resort\",\"filter\",\"merge\",\"concat\",\"Collect\",\"Compare\",\"Operator\",\"update\",\"_\",\"modified\",\"orders\",\"CountPattern\",\"Cross\",\"parse\",\"def\",\"func\",\"FUNCTION\",\"hasOwnProperty\",\"Distributions\",\"error\",\"d\",\"FIELD\",\"from\",\"DISTRIBUTIONS\",\"Density\",\"pulse\",\"fieldNames\",\"as\",\"accessorName\",\"partition\",\"groupby\",\"groups\",\"g\",\"dims\",\"DotBin\",\"Expression\",\"update$1\",\"expr\",\"accessor\",\"datum\",\"accessorFields\",\"Extent\",\"undefined\",\"Subflow\",\"parent\",\"count\",\"Facet\",\"_keys\",\"fastmap\",\"_targets\",\"active\",\"a.forEach\",\"Field\",\"update$2\",\"isArray\",\"array\",\"Filter\",\"Flatten\",\"Fold\",\"Formula\",\"Generate\",\"Impute\",\"getValue\",\"m\",\"method\",\"Methods\",\"getField\",\"NaN\",\"partition$1\",\"keyvals\",\"domain\",\"kMap\",\"gMap\",\"group\",\"j\",\"gKey\",\"gVals\",\"Empty\",\"JoinAggregate\",\"KDE\",\"Key\",\"update$3\",\"flat\",\"Load\",\"_pending\",\"stop\",\"output\",\"ingest\",\"fork\",\"NO_FIELDS\",\"NO_SOURCE\",\"clean\",\"Lookup\",\"MultiExtent\",\"update$4\",\"ext\",\"extents\",\"min\",\"Infinity\",\"max\",\"e\",\"MultiValues\",\"update$5\",\"reduce\",\"Params\",\"Pivot\",\"aggregateParams\",\"keys\",\"pivotKeys\",\"limit\",\"changed\",\"bind\",\"list\",\"visit\",\"SOURCE\",\"ascending\",\"PreFacet\",\"Project\",\"Proxy\",\"Quantile\",\"Relay\",\"Sample\",\"Sequence\",\"Sieve\",\"TimeUnit\",\"TupleIndex\",\"Values\",\"WindowOp\",\"param\",\"fn\",\"WindowOps\",\"zero\",\"w\",\"next\",\"WindowState\",\"visitInputs\",\"inputs\",\"outputs\",\"windows\",\"counts\",\"measures\",\"countOnly\",\"mname\",\"num\",\"store\",\"Array\",\"cell.add\",\"cell.rem\",\"cell.set\",\"cell.init\",\"Window\",\"processPartition\",\"state\",\"cmp\",\"range\",\"ignorePeers\",\"frame\",\"bisector\",\"i0\",\"i1\",\"p0\",\"p1\",\"index\",\"constant\",\"Math\",\"abs\",\"r0\",\"r1\",\"c\",\"left\",\"right\",\"noop\",\"__count__\",\"sum\",\"product\",\"mean\",\"mean_d\",\"average\",\"variance\",\"dev\",\"variancep\",\"stdev\",\"sqrt\",\"stdevp\",\"stderr\",\"distinct\",\"ci0\",\"ci1\",\"median\",\"q2\",\"q1\",\"q3\",\"Number\",\"isNaN\",\"argmin\",\"argmax\",\"ValidAggregateOps\",\"prototype.reset\",\"_add\",\"_rem\",\"_q\",\"_get\",\"_ext\",\"prototype.add\",\"prototype.rem\",\"prototype.values\",\"r\",\"prototype.distinct\",\"s\",\"extent\",\"prototype.extent\",\"extentIndex\",\"prototype.argmin\",\"prototype.argmax\",\"prototype.min\",\"prototype.max\",\"quartile\",\"prototype.quartile\",\"quartiles\",\"prototype.q1\",\"prototype.q2\",\"prototype.q3\",\"ci\",\"prototype.ci\",\"_ci\",\"bootstrapCI\",\"prototype.ci0\",\"prototype.ci1\",\"Definition\",\"inherits\",\"transform\",\"aggr\",\"mod\",\"stamp\",\"REM\",\"ADD\",\"modifies\",\"drop\",\"cross\",\"runAfter\",\"changes\",\"collect\",\"cells\",\"tuple\",\"vals\",\"generate\",\"base\",\"curr\",\"inputVisit\",\"inputMap\",\"dname\",\"cellkey\",\"outname\",\"newcell\",\"newtuple\",\"p\",\"names\",\"replace\",\"celltuple\",\"adds\",\"mods\",\"prev\",\"band\",\"interval\",\"bins\",\"_bins\",\"start\",\"step\",\"b0\",\"b1\",\"reflow\",\"flag\",\"ADD_MOD\",\"bin\",\"ceil\",\"anchor\",\"floor\",\"toNumber\",\"EPSILON\",\"ALL\",\"materialize\",\"stableCompare\",\"root\",\"process\",\"case\",\"text\",\"toUpperCase\",\"toLowerCase\",\"tokens\",\"match\",\"test\",\"_parameterCheck\",\"_match\",\"_stop\",\"_finish\",\"RegExp\",\"stopwords\",\"pattern\",\"tuples\",\"_tuples\",\"ADD_REM\",\"truthy\",\"kde\",\"randomKDE\",\"mixture\",\"randomMixture\",\"normal\",\"randomNormal\",\"lognormal\",\"randomLogNormal\",\"uniform\",\"randomUniform\",\"distributions\",\"dist\",\"distribution\",\"minsteps\",\"steps\",\"maxsteps\",\"sampleCurve\",\"Output\",\"smooth\",\"span\",\"dotbin\",\"isFinite\",\"dataflow\",\"warn\",\"connect\",\"target\",\"detachSubflow\",\"targets\",\"evaluate\",\"activate\",\"flow\",\"subflow\",\"flows\",\"sf\",\"_group\",\"df\",\"detach\",\"initTargets\",\"cache\",\"rekey\",\"id\",\"delete\",\"MOD\",\"k0\",\"k1\",\"REFLOW\",\"empty\",\"cleanThreshold\",\"revisit\",\"isMod\",\"has\",\"arrays\",\"maxlen\",\"l\",\"derive\",\"fnames\",\"initonly\",\"gen\",\"generator\",\"impute\",\"fName\",\"kName\",\"gNames\",\"kVal\",\"_impute\",\"bandwidth\",\"cumulative\",\"density\",\"scale\",\"local\",\"StopPropagation\",\"format\",\"async\",\"request\",\"url\",\"then\",\"res\",\"touch\",\"defaultValue\",\"default\",\"some\",\"_transform\",\"rederive\",\"lut\",\"addAll\",\"dt\",\"probs\",\"EPSILON$1\",\"q\",\"quantiles\",\"random\",\"cap\",\"OUTPUT\",\"TIME_UNITS\",\"utc\",\"timezone\",\"_floor\",\"offset\",\"utcInterval\",\"timeInterval\",\"unit\",\"u0\",\"u1\",\"units\",\"timeBin\",\"maxbins\",\"tunits\",\"timeUnits\",\"utcFloor\",\"timeFloor\",\"peek\",\"clear\",\"row_number\",\"rank\",\"dense_rank\",\"drank\",\"percent_rank\",\"cume_dist\",\"cume\",\"ntile\",\"lag\",\"lead\",\"first_value\",\"last_value\",\"nth_value\",\"nth\",\"prev_value\",\"next_value\",\"ValidWindowOps\",\"prototype$1\",\"prototype$1.init\",\"prototype$1.update\",\"wind\",\"aggregate\",\"countpattern\",\"expression\",\"facet\",\"flatten\",\"fold\",\"formula\",\"joinaggregate\",\"load\",\"lookup\",\"multiextent\",\"multivalues\",\"pivot\",\"prefacet\",\"project\",\"proxy\",\"quantile\",\"relay\",\"sample\",\"sequence\",\"sieve\",\"timeunit\",\"tupleindex\",\"window\",\"defineProperty\"]\n}\n"]