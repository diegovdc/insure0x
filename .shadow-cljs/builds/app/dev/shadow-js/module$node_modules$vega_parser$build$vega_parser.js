["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-parser/build/vega-parser.js"],"~:js","shadow$provide.module$node_modules$vega_parser$build$vega_parser=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_util$build$vega_util\"),require(\"module$node_modules$vega_functions$build$vega_functions\"),require(\"module$node_modules$vega_event_selector$build$vega_event_selector\"),require(\"module$node_modules$vega_scale$build$vega_scale\"),require(\"module$node_modules$vega_dataflow$build$vega_dataflow\")):\n\"function\"===typeof define&&define.amd?define(\"exports vega-util vega-functions vega-event-selector vega-scale vega-dataflow\".split(\" \"),factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory(global.vega={},global.vega,global.vega,global.vega,global.vega,global.vega))})(this,function(exports,vegaUtil,vegaFunctions,vegaEventSelector,vegaScale,vegaDataflow){function parseAutosize(spec){return vegaUtil.isObject(spec)?spec:{type:spec||\"pad\"}}function parsePadding(spec){vegaUtil.isObject(spec)?\nspec=spec.signal?spec:{top:+spec.top||0,bottom:+spec.bottom||0,left:+spec.left||0,right:+spec.right||0}:(spec=+spec||0,spec={top:spec,bottom:spec,left:spec,right:spec});return spec}function addEncode(object,name,value,set){return null!=value?(vegaUtil.isObject(value)&&!vegaUtil.isArray(value)||vegaUtil.isArray(value)&&value.length&&vegaUtil.isObject(value[0])?object.update[name]=value:object[set||\"enter\"][name]={value:value},1):0}function addEncoders(object,enter,update){for(var name in enter)addEncode(object,\nname,enter[name]);for(var name$390 in update)addEncode(object,name$390,update[name$390],\"update\")}function extendEncode(encode,extra,skip){for(var name in extra)skip&&vegaUtil.hasOwnProperty(skip,name)||(encode[name]=vegaUtil.extend(encode[name]||{},extra[name]));return encode}function has(key,encode){return encode&&(encode.enter&&encode.enter[key]||encode.update&&encode.update[key])}function applyDefaults(encode,type,role,style,config){var defaults={},enter={},update;var key=\"lineBreak\";\"text\"!==\ntype||null==config[key]||has(key,encode)||applyDefault(defaults,key,config[key]);if(\"legend\"==role||String(role).startsWith(\"axis\"))role=null;role=\"frame\"===role?config.group:\"mark\"===role?vegaUtil.extend({},config.mark,config[type]):null;for(key in role)(type=has(key,encode)||(\"fill\"===key||\"stroke\"===key)&&(has(\"fill\",encode)||has(\"stroke\",encode)))||applyDefault(defaults,key,role[key]);vegaUtil.array(style).forEach(function(name){name=config.style&&config.style[name];for(var key$391 in name)has(key$391,\nencode)||applyDefault(defaults,key$391,name[key$391])});encode=vegaUtil.extend({},encode);for(key in defaults)role=defaults[key],role.signal?(update=update||{})[key]=role:enter[key]=role;encode.enter=vegaUtil.extend(enter,encode.enter);update&&(encode.update=vegaUtil.extend(update,encode.update));return encode}function applyDefault(defaults,key,value){defaults[key]=value&&value.signal?{signal:value.signal}:{value:value}}function entry$jscomp$0(enc){if(null!=enc.gradient)return gradient(enc);if(enc.signal)var JSCompiler_temp=\n\"(\"+enc.signal+\")\";else enc.color?(JSCompiler_temp=enc.color,JSCompiler_temp=JSCompiler_temp.c?_color(\"hcl\",JSCompiler_temp.h,JSCompiler_temp.c,JSCompiler_temp.l):JSCompiler_temp.h||JSCompiler_temp.s?_color(\"hsl\",JSCompiler_temp.h,JSCompiler_temp.s,JSCompiler_temp.l):JSCompiler_temp.l||JSCompiler_temp.a?_color(\"lab\",JSCompiler_temp.l,JSCompiler_temp.a,JSCompiler_temp.b):JSCompiler_temp.r||JSCompiler_temp.g||JSCompiler_temp.b?_color(\"rgb\",JSCompiler_temp.r,JSCompiler_temp.g,JSCompiler_temp.b):null):\nJSCompiler_temp=null!=enc.field?field$jscomp$0(enc.field):void 0!==enc.value?vegaUtil.stringValue(enc.value):void 0;if(null!=enc.scale){var scale=scaleRef(enc.scale);null!=enc.range?JSCompiler_temp=\"lerp(_range(\"+scale+\"), \"+ +enc.range+\")\":(void 0!==JSCompiler_temp&&(JSCompiler_temp=\"_scale(\"+scale+\", \"+JSCompiler_temp+\")\"),enc.band&&(JSCompiler_temp=(JSCompiler_temp?JSCompiler_temp+\"+\":\"\")+(\"_bandwidth(\"+scale+\")\")+(1===+enc.band?\"\":\"*\"+property$jscomp$0(enc.band)),enc.extra&&(JSCompiler_temp=\"(datum.extra ? _scale(\"+\nscale+\", datum.extra.value) : \"+JSCompiler_temp+\")\")),null==JSCompiler_temp&&(JSCompiler_temp=\"0\"))}void 0===JSCompiler_temp&&(JSCompiler_temp=null);null!=enc.exponent&&(JSCompiler_temp=\"pow(\"+JSCompiler_temp+\",\"+property$jscomp$0(enc.exponent)+\")\");null!=enc.mult&&(JSCompiler_temp+=\"*\"+property$jscomp$0(enc.mult));null!=enc.offset&&(JSCompiler_temp+=\"+\"+property$jscomp$0(enc.offset));enc.round&&(JSCompiler_temp=\"round(\"+JSCompiler_temp+\")\");return JSCompiler_temp}function gradient(enc){for(var args=\n[enc.start,enc.stop,enc.count].map(function(_){return null==_?null:vegaUtil.stringValue(_)});args.length&&null==vegaUtil.peek(args);)args.pop();args.unshift(scaleRef(enc.gradient));return\"gradient(\"+args.join(\",\")+\")\"}function property$jscomp$0(property){return vegaUtil.isObject(property)?\"(\"+entry$jscomp$0(property)+\")\":property}function field$jscomp$0(ref){return resolveField(vegaUtil.isObject(ref)?ref:{datum:ref})}function resolveField(ref){if(ref.signal){var object=\"datum\";var level=ref.signal}else if(ref.group||\nref.parent){level=Math.max(1,ref.level||1);for(object=\"item\";0<level--;)object+=\".mark.group\";ref.parent?(level=ref.parent,object+=\".datum\"):level=ref.group}else ref.datum?(object=\"datum\",level=ref.datum):vegaUtil.error(\"Invalid field reference: \"+vegaUtil.stringValue(ref));ref.signal||(level=vegaUtil.isString(level)?vegaUtil.splitAccessPath(level).map(vegaUtil.stringValue).join(\"][\"):resolveField(level));return object+\"[\"+level+\"]\"}function rule$jscomp$0(enc){var code=\"\";enc.forEach(function(rule){var value=\nentry$jscomp$0(rule);code+=rule.test?\"(\"+rule.test+\")?\"+value+\":\":value});\":\"===vegaUtil.peek(code)&&(code+=\"null\");return code}function parseEncode(encode,type,role,style,scope$jscomp$0,params$jscomp$0){var enc={};params$jscomp$0=params$jscomp$0||{};params$jscomp$0.encoders={$encode:enc};encode=applyDefaults(encode,type,role,style,scope$jscomp$0.config);for(var key in encode){role=void 0;style=encode[key];var marktype=type,params=params$jscomp$0,scope=scope$jscomp$0,channels={},fields={};for(role in style)if(null!=\nstyle[role]){var JSCompiler_inline_result=style[role];JSCompiler_inline_result=vegaUtil.isArray(JSCompiler_inline_result)?rule$jscomp$0(JSCompiler_inline_result):entry$jscomp$0(JSCompiler_inline_result);channels[role]=parse(JSCompiler_inline_result,scope,params,fields)}role={$expr:{marktype:marktype,channels:channels},$fields:Object.keys(fields),$output:Object.keys(style)};enc[key]=role}return params$jscomp$0}function parse(code,scope,params,fields){code=vegaFunctions.parseExpression(code,scope);\ncode.$fields.forEach(function(name){return fields[name]=1});vegaUtil.extend(params,code.$params);return code.$expr}function outerError(prefix,name){vegaUtil.error(prefix+' for \"outer\" push: '+vegaUtil.stringValue(name))}function parseSignal(signal,scope){var name=signal.name;if(\"outer\"===signal.push)scope.signals[name]||outerError(\"No prior signal definition\",name),OUTER_INVALID.forEach(function(prop){void 0!==signal[prop]&&outerError(\"Invalid property \",prop)});else{var op=scope.addSignal(name,signal.value);\n!1===signal.react&&(op.react=!1);signal.bind&&scope.addBinding(name,signal.bind)}}function Entry(type,value,params,parent){this.id=-1;this.type=type;this.value=value;this.params=params;parent&&(this.parent=parent)}function ref$jscomp$0(op){var ref={$ref:op.id};0>op.id&&(op.refs=op.refs||[]).push(ref);return ref}function fieldRef(field,name){return name?{$field:field,$name:name}:{$field:field}}function keyRef(fields,flat){fields={$key:fields};flat&&(fields.$flat=!0);return fields}function aggrField(op,\nfield){return(op&&op.signal?\"$\"+op.signal:op||\"\")+(op&&field?\"_\":\"\")+(field&&field.signal?\"$\"+field.signal:field||\"\")}function isSignal(_){return _&&_.signal}function hasSignal(_){if(isSignal(_))return!0;if(vegaUtil.isObject(_))for(var key in _)if(hasSignal(_[key]))return!0;return!1}function value$jscomp$0(specValue,defaultValue){return null!=specValue?specValue:defaultValue}function deref(v){return v&&v.signal||v}function parseStream(stream,scope){return(stream.merge?mergeStream:stream.stream?nestedStream:\nstream.type?eventStream:vegaUtil.error(\"Invalid stream specification: \"+vegaUtil.stringValue(stream)))(stream,scope)}function eventSource(source){return\"scope\"===source?\"view\":source||\"view\"}function mergeStream(stream,scope){var list=stream.merge.map(function(s){return parseStream(s,scope)});stream=streamParameters({merge:list},stream,scope);return scope.addStream(stream).id}function nestedStream(stream,scope){var id=parseStream(stream.stream,scope);stream=streamParameters({stream:id},stream,scope);\nreturn scope.addStream(stream).id}function eventStream(stream,scope){if(\"timer\"===stream.type){var id=scope.event(\"timer\",stream.throttle);stream={between:stream.between,filter:stream.filter}}else id=scope.event(eventSource(stream.source),stream.type);stream=streamParameters({stream:id},stream,scope);return 1===Object.keys(stream).length?id:scope.addStream(stream).id}function streamParameters(entry,stream,scope){var param=stream.between;param&&(2!==param.length&&vegaUtil.error('Stream \"between\" parameter must have 2 entries: '+\nvegaUtil.stringValue(stream)),entry.between=[parseStream(param[0],scope),parseStream(param[1],scope)]);param=stream.filter?[].concat(stream.filter):[];(stream.marktype||stream.markname||stream.markrole)&&param.push(filterMark(stream.marktype,stream.markname,stream.markrole));\"scope\"===stream.source&&param.push(\"inScope(event.item)\");param.length&&(entry.filter=vegaFunctions.parseExpression(\"(\"+param.join(\")\\x26\\x26(\")+\")\",scope).$expr);null!=(param=stream.throttle)&&(entry.throttle=+param);null!=\n(param=stream.debounce)&&(entry.debounce=+param);stream.consume&&(entry.consume=!0);return entry}function filterMark(type,name,role){return\"event.item\"+(type&&\"*\"!==type?\"\\x26\\x26event.item.mark.marktype\\x3d\\x3d\\x3d'\"+type+\"'\":\"\")+(role?\"\\x26\\x26event.item.mark.role\\x3d\\x3d\\x3d'\"+role+\"'\":\"\")+(name?\"\\x26\\x26event.item.mark.name\\x3d\\x3d\\x3d'\"+name+\"'\":\"\")}function parseUpdate(spec,scope,target){var encode=spec.encode,entry={target:target};target=spec.events;var update=spec.update,sources=[];target||\nvegaUtil.error(\"Signal update missing events specification.\");vegaUtil.isString(target)&&(target=vegaEventSelector.selector(target,scope.isSubscope()?\"scope\":\"view\"));target=vegaUtil.array(target).filter(function(s){return s.signal||s.scale?(sources.push(s),0):1});1<sources.length&&(sources=[mergeSources(sources)]);target.length&&sources.push(1<target.length?{merge:target}:target[0]);null!=encode&&(update&&vegaUtil.error(\"Signal encode and update are mutually exclusive.\"),update=\"encode(item(),\"+\nvegaUtil.stringValue(encode)+\")\");entry.update=vegaUtil.isString(update)?vegaFunctions.parseExpression(update,scope):null!=update.expr?vegaFunctions.parseExpression(update.expr,scope):null!=update.value?update.value:null!=update.signal?{$expr:OP_VALUE_EXPR,$params:{$value:scope.signalRef(update.signal)}}:vegaUtil.error(\"Invalid signal update specification.\");spec.force&&(entry.options={force:!0});sources.forEach(function(source){return scope.addUpdate(vegaUtil.extend(streamSource(source,scope),entry))})}\nfunction streamSource(stream,scope){return{source:stream.signal?scope.signalRef(stream.signal):stream.scale?scope.scaleRef(stream.scale):parseStream(stream,scope)}}function mergeSources(sources){return{signal:\"[\"+sources.map(function(s){return s.scale?'scale(\"'+s.scale+'\")':s.signal})+\"]\"}}function parseSignalUpdates(signal,scope){var op=scope.getSignal(signal.name),expr=signal.update;signal.init&&(expr?vegaUtil.error(\"Signals can not include both init and update expressions.\"):(expr=signal.init,\nop.initonly=!0));expr&&(expr=vegaFunctions.parseExpression(expr,scope),op.update=expr.$expr,op.params=expr.$params);signal.on&&signal.on.forEach(function(_){return parseUpdate(_,scope,op.id)})}function parseLiteral(v,scope){return vegaUtil.isObject(v)?v.signal?scope.signalRef(v.signal):vegaUtil.error(\"Unsupported object: \"+vegaUtil.stringValue(v)):v}function parseArray(v$jscomp$0,scope){return v$jscomp$0.signal?scope.signalRef(v$jscomp$0.signal):v$jscomp$0.map(function(v){return parseLiteral(v,scope)})}\nfunction dataLookupError(name){vegaUtil.error(\"Can not find data set: \"+vegaUtil.stringValue(name))}function parseScaleDomain(domain,spec,scope){if(domain)return domain.signal?scope.signalRef(domain.signal):(vegaUtil.isArray(domain)?explicitDomain:domain.fields?multipleDomain:singularDomain)(domain,spec,scope);null==spec.domainMin&&null==spec.domainMax||vegaUtil.error(\"No scale domain defined for domainMin/domainMax to override.\")}function explicitDomain(domain,spec,scope){return domain.map(function(v){return parseLiteral(v,\nscope)})}function singularDomain(domain,spec,scope){var data=scope.getData(domain.data);data||dataLookupError(domain.data);return vegaScale.isDiscrete(spec.type)?data.valuesRef(scope,domain.field,parseSort(domain.sort,!1)):vegaScale.isQuantile(spec.type)?data.domainRef(scope,domain.field):data.extentRef(scope,domain.field)}function multipleDomain(domain,spec,scope){var data$jscomp$0=domain.data,fields=domain.fields.reduce(function(dom,d){if(vegaUtil.isString(d))d={data:data$jscomp$0,field:d};else if(vegaUtil.isArray(d)||\nd.signal){var data=d;d=\"_:vega:_\"+FIELD_REF_ID++;var coll=Collect({});vegaUtil.isArray(data)?coll.value={$ingest:data}:data.signal&&(data=\"setdata(\"+vegaUtil.stringValue(d)+\",\"+data.signal+\")\",coll.params.input=scope.signalRef(data));scope.addDataPipeline(d,[coll,Sieve({})]);d={data:d,field:\"data\"}}dom.push(d);return dom},[]);return(vegaScale.isDiscrete(spec.type)?ordinalMultipleDomain:vegaScale.isQuantile(spec.type)?quantileMultipleDomain:numericMultipleDomain)(domain,scope,fields)}function ordinalMultipleDomain(domain,\nscope,fields){var sort=parseSort(domain.sort,!0);domain=fields.map(function(f){var data=scope.getData(f.data);data||dataLookupError(f.data);return data.countsRef(scope,f.field,sort)});var p={groupby:keyFieldRef,pulse:domain};sort&&(domain=sort.op||\"count\",fields=sort.field?aggrField(domain,sort.field):\"count\",p.ops=[MULTIDOMAIN_SORT_OPS[domain]],p.fields=[scope.fieldRef(fields)],p.as=[fields]);domain=scope.add(Aggregate(p));domain=scope.add(Collect({pulse:ref$jscomp$0(domain)}));fields=scope.add(Values({field:keyFieldRef,\nsort:scope.sortRef(sort),pulse:ref$jscomp$0(domain)}));return ref$jscomp$0(fields)}function parseSort(sort,multidomain){sort&&(sort.field||sort.op?sort.field||\"count\"===sort.op?multidomain&&sort.field&&sort.op&&!MULTIDOMAIN_SORT_OPS[sort.op]&&vegaUtil.error(\"Multiple domain scales can not be sorted using \"+sort.op):vegaUtil.error(\"No field provided for sort aggregate op: \"+sort.op):vegaUtil.isObject(sort)?sort.field=\"key\":sort={field:\"key\"});return sort}function quantileMultipleDomain(domain,scope,\nfields){domain=fields.map(function(f){var data=scope.getData(f.data);data||dataLookupError(f.data);return data.domainRef(scope,f.field)});return ref$jscomp$0(scope.add(MultiValues({values:domain})))}function numericMultipleDomain(domain,scope,fields){domain=fields.map(function(f){var data=scope.getData(f.data);data||dataLookupError(f.data);return data.extentRef(scope,f.field)});return ref$jscomp$0(scope.add(MultiExtent({extents:domain})))}function parseScaleRange(spec,scope,params){var config=scope.config.range,\nrange=spec.range;if(range.signal)return scope.signalRef(range.signal);if(vegaUtil.isString(range)){if(config&&vegaUtil.hasOwnProperty(config,range))return spec=vegaUtil.extend({},spec,{range:config[range]}),parseScaleRange(spec,scope,params);\"width\"===range?range=[0,{signal:\"width\"}]:\"height\"===range?range=vegaScale.isDiscrete(spec.type)?[0,{signal:\"height\"}]:[{signal:\"height\"},0]:vegaUtil.error(\"Unrecognized scale range value: \"+vegaUtil.stringValue(range))}else{if(range.scheme){params.scheme=vegaUtil.isArray(range.scheme)?\nparseArray(range.scheme,scope):parseLiteral(range.scheme,scope);range.extent&&(params.schemeExtent=parseArray(range.extent,scope));range.count&&(params.schemeCount=parseLiteral(range.count,scope));return}if(range.step){params.rangeStep=parseLiteral(range.step,scope);return}if(vegaScale.isDiscrete(spec.type)&&!vegaUtil.isArray(range))return parseScaleDomain(range,spec,scope);vegaUtil.isArray(range)||vegaUtil.error(\"Unsupported range type: \"+vegaUtil.stringValue(range))}return range.map(function(v){return(vegaUtil.isArray(v)?\nparseArray:parseLiteral)(v,scope)})}function parseParameter(_$jscomp$0,name,scope){return vegaUtil.isArray(_$jscomp$0)?_$jscomp$0.map(function(_){return parseParameter(_,name,scope)}):vegaUtil.isObject(_$jscomp$0)?_$jscomp$0.signal?scope.signalRef(_$jscomp$0.signal):\"fit\"===name?_$jscomp$0:vegaUtil.error(\"Unsupported parameter object: \"+vegaUtil.stringValue(_$jscomp$0)):_$jscomp$0}function guideGroup(mark){mark.type=\"group\";mark.interactive=mark.interactive||!1;return mark}function lookup$jscomp$0(spec,\nconfig){var _=function(name,dflt){return value$jscomp$0(spec[name],value$jscomp$0(config[name],dflt))};_.isVertical=function(s){return\"vertical\"===value$jscomp$0(spec.direction,config.direction||(s?config.symbolDirection:config.gradientDirection))};_.gradientLength=function(){return value$jscomp$0(spec.gradientLength,config.gradientLength||config.gradientWidth)};_.gradientThickness=function(){return value$jscomp$0(spec.gradientThickness,config.gradientThickness||config.gradientHeight)};_.entryColumns=\nfunction(){return value$jscomp$0(spec.columns,value$jscomp$0(config.columns,+_.isVertical(!0)))};return _}function getEncoding(name,encode){return(name=encode&&(encode.update&&encode.update[name]||encode.enter&&encode.enter[name]))&&name.signal?name:name?name.value:null}function anchorExpr(s,e,m){return\"item.anchor \\x3d\\x3d\\x3d 'start' ? \"+s+\" : item.anchor \\x3d\\x3d\\x3d 'end' ? \"+e+\" : \"+m}function extendOffset(value,offset){return offset?value?vegaUtil.isObject(value)?Object.assign({},value,{offset:extendOffset(value.offset,\noffset)}):{value:value,offset:offset}:offset:value}function guideMark(mark,extras){extras?(mark.name=extras.name,mark.style=extras.style||mark.style,mark.interactive=!!extras.interactive,mark.encode=extendEncode(mark.encode,extras,Skip)):mark.interactive=!1;return mark}function legendGradient(spec,scale,config,userEncode){spec=lookup$jscomp$0(spec,config);var vertical=spec.isVertical();config=spec.gradientThickness();var length=spec.gradientLength(),enter;if(vertical){vertical=[0,1];var stop=[0,0];\nvar width=config;config=length}else vertical=[0,0],stop=[1,0],width=length;scale={enter:enter={opacity:zero$jscomp$0,x:zero$jscomp$0,y:zero$jscomp$0,width:encoder(width),height:encoder(config)},update:vegaUtil.extend({},enter,{opacity:one,fill:{gradient:scale,start:vertical,stop:stop}}),exit:{opacity:zero$jscomp$0}};addEncoders(scale,{stroke:spec(\"gradientStrokeColor\"),strokeWidth:spec(\"gradientStrokeWidth\")},{opacity:spec(\"gradientOpacity\")});return guideMark({type:\"rect\",role:\"legend-gradient\",\nencode:scale},userEncode)}function legendGradientDiscrete(spec,scale,config,userEncode,dataRef){spec=lookup$jscomp$0(spec,config);var vertical=spec.isVertical();config=spec.gradientThickness();var length=spec.gradientLength(),u,v,uu,vv,adjust=\"\";vertical?(u=\"y\",uu=\"y2\",v=\"x\",vv=\"width\",adjust=\"1-\"):(u=\"x\",uu=\"x2\",v=\"y\",vv=\"height\");scale={opacity:zero$jscomp$0,fill:{scale:scale,field:\"value\"}};scale[u]={signal:adjust+\"datum.perc\",mult:length};scale[v]=zero$jscomp$0;scale[uu]={signal:adjust+\"datum.perc2\",\nmult:length};scale[vv]=encoder(config);u={enter:scale,update:vegaUtil.extend({},scale,{opacity:one}),exit:{opacity:zero$jscomp$0}};addEncoders(u,{stroke:spec(\"gradientStrokeColor\"),strokeWidth:spec(\"gradientStrokeWidth\")},{opacity:spec(\"gradientOpacity\")});return guideMark({type:\"rect\",role:\"legend-band\",key:\"value\",from:dataRef,encode:u},userEncode)}function legendGradientLabels(spec,config,userEncode,dataRef){var _=lookup$jscomp$0(spec,config),vertical=_.isVertical(),thickness=encoder(_.gradientThickness()),\nlength=_.gradientLength(),overlap=_(\"labelOverlap\"),enter,update,adjust=\"\",encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one,text:{field:\"label\"}},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{fill:_(\"labelColor\"),fillOpacity:_(\"labelOpacity\"),font:_(\"labelFont\"),fontSize:_(\"labelFontSize\"),fontStyle:_(\"labelFontStyle\"),fontWeight:_(\"labelFontWeight\"),limit:value$jscomp$0(spec.labelLimit,config.gradientLabelLimit)});if(vertical){enter.align={value:\"left\"};enter.baseline=update.baseline=\n{signal:'datum.perc\\x3c\\x3d0?\"bottom\":datum.perc\\x3e\\x3d1?\"top\":\"middle\"'};vertical=\"y\";var v=\"x\";adjust=\"1-\"}else enter.align=update.align={signal:'datum.perc\\x3c\\x3d0?\"left\":datum.perc\\x3e\\x3d1?\"right\":\"center\"'},enter.baseline={value:\"top\"},vertical=\"x\",v=\"y\";enter[vertical]=update[vertical]={signal:adjust+\"datum.perc\",mult:length};enter[v]=update[v]=thickness;thickness.offset=value$jscomp$0(spec.labelOffset,config.gradientLabelOffset)||0;overlap=overlap?{separation:_(\"labelSeparation\"),method:overlap,\norder:\"datum.index\"}:void 0;return guideMark({type:\"text\",role:\"legend-label\",style:\"guide-label\",key:\"value\",from:dataRef,encode:encode,overlap:overlap},userEncode)}function legendSymbolGroups(spec,config,userEncode,dataRef,columns){var _=lookup$jscomp$0(spec,config),entries=userEncode.entries,interactive=!(!entries||!entries.interactive),name=entries?entries.name:void 0,height=_(\"clipHeight\"),symbolOffset=_(\"symbolOffset\"),valueRef={data:\"value\"},xSignal=\"(\"+columns+\") ? datum.offset : datum.size\",\nyEncode=height?encoder(height):{field:\"size\"},ncols=\"max(1, \"+columns+\")\",enter,update;yEncode.mult=.5;var encode={enter:enter={opacity:zero$jscomp$0,x:{signal:xSignal,mult:.5,offset:symbolOffset},y:yEncode},update:update={opacity:one,x:enter.x,y:enter.y},exit:{opacity:zero$jscomp$0}};var baseFill=null,baseStroke=null;spec.fill||(baseFill=config.symbolBaseFillColor,baseStroke=config.symbolBaseStrokeColor);addEncoders(encode,{fill:_(\"symbolFillColor\",baseFill),shape:_(\"symbolType\"),size:_(\"symbolSize\"),\nstroke:_(\"symbolStrokeColor\",baseStroke),strokeDash:_(\"symbolDash\"),strokeDashOffset:_(\"symbolDashOffset\"),strokeWidth:_(\"symbolStrokeWidth\")},{opacity:_(\"symbolOpacity\")});LegendScales.forEach(function(scale){spec[scale]&&(update[scale]=enter[scale]={scale:spec[scale],field:\"value\"})});config=guideMark({type:\"symbol\",role:\"legend-symbol\",key:\"value\",from:valueRef,clip:height?!0:void 0,encode:encode},userEncode.symbols);encode=encoder(symbolOffset);encode.offset=_(\"labelOffset\");encode={enter:enter=\n{opacity:zero$jscomp$0,x:{signal:xSignal,offset:encode},y:yEncode},update:update={opacity:one,text:{field:\"label\"},x:enter.x,y:enter.y},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{align:_(\"labelAlign\"),baseline:_(\"labelBaseline\"),fill:_(\"labelColor\"),fillOpacity:_(\"labelOpacity\"),font:_(\"labelFont\"),fontSize:_(\"labelFontSize\"),fontStyle:_(\"labelFontStyle\"),fontWeight:_(\"labelFontWeight\"),limit:_(\"labelLimit\")});userEncode=guideMark({type:\"text\",role:\"legend-label\",style:\"guide-label\",key:\"value\",\nfrom:valueRef,encode:encode},userEncode.labels);encode={enter:{noBound:{value:!height},width:zero$jscomp$0,height:height?encoder(height):zero$jscomp$0,opacity:zero$jscomp$0},exit:{opacity:zero$jscomp$0},update:update={opacity:one,row:{signal:null},column:{signal:null}}};_.isVertical(!0)?(_=\"ceil(item.mark.items.length / \"+ncols+\")\",update.row.signal=\"datum.index%\"+_,update.column.signal=\"floor(datum.index / \"+_+\")\",_={field:[\"row\",\"datum.index\"]}):(update.row.signal=\"floor(datum.index / \"+ncols+\")\",\nupdate.column.signal=\"datum.index % \"+ncols,_={field:\"datum.index\"});update.column.signal=\"(\"+columns+\")?\"+update.column.signal+\":datum.index\";dataRef={facet:{data:dataRef,name:\"value\",groupby:\"index\"}};return guideGroup({role:\"scope\",from:dataRef,encode:extendEncode(encode,entries,Skip),marks:[config,userEncode],name:name,interactive:interactive,sort:_})}function legendSymbolLayout(spec,config){spec=lookup$jscomp$0(spec,config);return{align:spec(\"gridAlign\"),columns:spec.entryColumns(),center:{row:!0,\ncolumn:!1},padding:{row:spec(\"rowPadding\"),column:spec(\"columnPadding\")}}}function legendTitle(spec,config,userEncode,dataRef){config=lookup$jscomp$0(spec,config);var encode={enter:{opacity:zero$jscomp$0},update:{opacity:one,x:{field:{group:\"padding\"}},y:{field:{group:\"padding\"}}},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{orient:config(\"titleOrient\"),_anchor:config(\"titleAnchor\"),anchor:{signal:'item._anchor || ((item.orient \\x3d\\x3d\\x3d \"left\" || item.orient \\x3d\\x3d\\x3d \"right\") ? \"middle\" : \"start\")'},\nangle:{signal:'datum.vgrad \\x26\\x26 (item.orient \\x3d\\x3d\\x3d \"left\" || item.orient \\x3d\\x3d\\x3d \"right\") ? (item.orient \\x3d\\x3d\\x3d \"left\" ? -90 : 90) : 0'},align:{signal:exprAlign},baseline:{signal:exprBaseline},text:spec.title,fill:config(\"titleColor\"),fillOpacity:config(\"titleOpacity\"),font:config(\"titleFont\"),fontSize:config(\"titleFontSize\"),fontStyle:config(\"titleFontStyle\"),fontWeight:config(\"titleFontWeight\"),limit:config(\"titleLimit\"),lineHeight:config(\"titleLineHeight\")},{align:config(\"titleAlign\"),\nbaseline:config(\"titleBaseline\")});return guideMark({type:\"text\",role:\"legend-title\",style:\"guide-title\",from:dataRef,encode:encode},userEncode)}function clip$jscomp$0(clip,scope){var expr;vegaUtil.isObject(clip)&&(clip.signal?expr=clip.signal:clip.path?expr=\"pathShape(\"+param$jscomp$0(clip.path)+\")\":clip.sphere&&(expr=\"geoShape(\"+param$jscomp$0(clip.sphere)+', {type: \"Sphere\"})'));return expr?scope.signalRef(expr):!!clip}function param$jscomp$0(value){return vegaUtil.isObject(value)&&value.signal?\nvalue.signal:vegaUtil.stringValue(value)}function getRole(spec){var role=spec.role||\"\";return role.indexOf(\"axis\")&&role.indexOf(\"legend\")&&role.indexOf(\"title\")?\"group\"===spec.type?\"scope\":role||\"mark\":role}function definition(spec){return{marktype:spec.type,name:spec.name||void 0,role:spec.role||getRole(spec),zindex:+spec.zindex||void 0,aria:spec.aria,description:spec.description}}function interactive(spec,scope){return spec&&spec.signal?scope.signalRef(spec.signal):!1===spec?!1:!0}function parseTransform(spec,\nscope){var def=vegaDataflow.definition(spec.type);def||vegaUtil.error(\"Unrecognized transform type: \"+vegaUtil.stringValue(spec.type));var JSCompiler_inline_result=def.type.toLowerCase();var params=parseParameters(def,spec,scope);JSCompiler_inline_result=new Entry(JSCompiler_inline_result,null,params,void 0);spec.signal&&scope.addSignal(spec.signal,scope.proxy(JSCompiler_inline_result));JSCompiler_inline_result.metadata=def.metadata||{};return JSCompiler_inline_result}function parseParameters(def,\nspec,scope){for(var params={},n=def.params.length,i=0;i<n;++i){var pdef=def.params[i];params[pdef.name]=parseParameter$1(pdef,spec,scope)}return params}function parseParameter$1(def,spec,scope){var type=def.type,value=spec[def.name];if(\"index\"===type)return parseIndexParameter(def,spec,scope);if(void 0===value)def.required&&vegaUtil.error(\"Missing required \"+vegaUtil.stringValue(spec.type)+\" parameter: \"+vegaUtil.stringValue(def.name));else return\"param\"===type?parseSubParameters(def,spec,scope):\n\"projection\"===type?scope.projectionRef(spec[def.name]):def.array&&!isSignal(value)?value.map(function(v){return parameterValue(def,v,scope)}):parameterValue(def,value,scope)}function parameterValue(def,value,scope){var type=def.type;return isSignal(value)?\"expr\"===type?vegaUtil.error(\"Expression references can not be signals.\"):\"field\"===type?scope.fieldRef(value):\"compare\"===type?scope.compareRef(value):scope.signalRef(value.signal):(def=def.expr||\"field\"===type)&&value&&value.expr?scope.exprRef(value.expr,\nvalue.as):def&&value&&value.field?fieldRef(value.field,value.as):\"expr\"===type?vegaFunctions.parseExpression(value,scope):\"data\"===type?ref$jscomp$0(scope.getData(value).values):\"field\"===type?fieldRef(value):\"compare\"===type?scope.compareRef(value):value}function parseIndexParameter(def,spec,scope){vegaUtil.isString(spec.from)||vegaUtil.error('Lookup \"from\" parameter must be a string literal.');return scope.getData(spec.from).lookupRef(scope,spec.key)}function parseSubParameters(def,spec,scope){spec=\nspec[def.name];return def.array?(vegaUtil.isArray(spec)||vegaUtil.error(\"Expected an array of sub-parameters. Instead: \"+vegaUtil.stringValue(spec)),spec.map(function(v){return parseSubParameter(def,v,scope)})):parseSubParameter(def,spec,scope)}function parseSubParameter(def,value,scope){for(var n=def.params.length,pdef,i=0;i<n;++i){pdef=def.params[i];for(var k in pdef.key)if(pdef.key[k]!==value[k]){pdef=null;break}if(pdef)break}pdef||vegaUtil.error(\"Unsupported parameter: \"+vegaUtil.stringValue(value));\ndef=vegaUtil.extend(parseParameters(pdef,value,scope),pdef.key);return ref$jscomp$0(scope.add(Params(def)))}function parseData(from,group,scope){var facet,parent;if(!from)var dataRef=ref$jscomp$0(scope.add(Collect(null,[{}])));else if(facet=from.facet)if(group||vegaUtil.error(\"Only group marks can be faceted.\"),null!=facet.field)dataRef=parent=getDataRef(facet,scope);else{from.data?parent=ref$jscomp$0(scope.getData(from.data).aggregate):(group=parseTransform(vegaUtil.extend({type:\"aggregate\",groupby:vegaUtil.array(facet.groupby)},\nfacet.aggregate),scope),group.params.key=scope.keyRef(facet.groupby),group.params.pulse=getDataRef(facet,scope),dataRef=parent=ref$jscomp$0(scope.add(group)));var key=scope.keyRef(facet.groupby,!0)}dataRef||(dataRef=getDataRef(from,scope));return{key:key,pulse:dataRef,parent:parent}}function getDataRef(from,scope){return from.$ref?from:from.data&&from.data.$ref?from.data:ref$jscomp$0(scope.getData(from.data).output)}function DataScope(scope,input,output,values,aggr){this.scope=scope;this.input=input;\nthis.output=output;this.values=values;this.aggregate=aggr;this.index={}}function fieldKey(field){return vegaUtil.isString(field)?field:null}function addSortField(scope,p,sort){var as=aggrField(sort.op,sort.field),s;if(p.ops)for(var i=0,n=p.as.length;i<n;++i){if(p.as[i]===as)return}else p.ops=[\"count\"],p.fields=[null],p.as=[\"count\"];sort.op&&(p.ops.push((s=sort.op.signal)?scope.signalRef(s):sort.op),p.fields.push(scope.fieldRef(sort.field)),p.as.push(as))}function cache$jscomp$0(scope,ds,name,optype,\nfield,counts,index){name=ds[name]||(ds[name]={});var JSCompiler_inline_result=vegaUtil.isObject(counts)?(\"descending\"===counts.order?\"-\":\"+\")+aggrField(counts.op,counts.field):\"\";var k=fieldKey(field);if(null!=k){scope=ds.scope;k+=JSCompiler_inline_result?\"|\"+JSCompiler_inline_result:\"\";var v=name[k]}v||(v=counts?{field:keyFieldRef,pulse:ds.countsRef(scope,field,counts)}:{field:scope.fieldRef(field),pulse:ref$jscomp$0(ds.output)},JSCompiler_inline_result&&(v.sort=scope.sortRef(counts)),scope=scope.add(new Entry(optype,\nvoid 0,v,void 0)),index&&(ds.index[field]=scope),v=ref$jscomp$0(scope),null!=k&&(name[k]=v));return v}function parseFacet(spec,scope,group){var facet=spec.from.facet,name=facet.name,data=getDataRef(facet,scope),op;facet.name||vegaUtil.error(\"Facet must have a name: \"+vegaUtil.stringValue(facet));facet.data||vegaUtil.error(\"Facet must reference a data set: \"+vegaUtil.stringValue(facet));facet.field?op=scope.add(PreFacet({field:scope.fieldRef(facet.field),pulse:data})):facet.groupby?op=scope.add(Facet({key:scope.keyRef(facet.groupby),\ngroup:ref$jscomp$0(scope.proxy(group.parent)),pulse:data})):vegaUtil.error(\"Facet must specify groupby or field: \"+vegaUtil.stringValue(facet));scope=scope.fork();group=scope.add(Collect());facet=scope.add(Sieve({pulse:ref$jscomp$0(group)}));scope.addData(name,new DataScope(scope,group,group,facet));scope.addSignal(\"parent\",null);op.params.subflow={$subflow:scope.parse(spec).toRuntime()}}function parseSubflow(spec,scope,input){input=scope.add(PreFacet({pulse:input.pulse}));scope=scope.fork();scope.add(Sieve());\nscope.addSignal(\"parent\",null);input.params.subflow={$subflow:scope.parse(spec).toRuntime()}}function parseTrigger(spec,scope,name){var remove=spec.remove,insert=spec.insert,toggle=spec.toggle,modify=spec.modify,values=spec.values,op=scope.add(new Entry(\"operator\",void 0,void 0,void 0));spec=\"if(\"+spec.trigger+',modify(\"'+name+'\",'+[insert,remove,toggle,modify,values].map(function(_){return null==_?\"null\":_}).join(\",\")+\"),0)\";scope=vegaFunctions.parseExpression(spec,scope);op.update=scope.$expr;op.params=\nscope.$params}function parseMark(spec,scope){var role=getRole(spec),group=\"group\"===spec.type,facet=spec.from&&spec.from.facet,overlap=spec.overlap,layout=spec.layout||\"scope\"===role||\"frame\"===role,store,enc,nested=\"mark\"===role||layout||facet,input=parseData(spec.from,group,scope);var op=scope.add(DataJoin({key:input.key||(spec.key?fieldRef(spec.key):void 0),pulse:input.pulse,clean:!group}));var joinRef=ref$jscomp$0(op);op=store=scope.add(Collect({pulse:joinRef}));op=scope.add(Mark({markdef:definition(spec),\ninteractive:interactive(spec.interactive,scope),clip:clip$jscomp$0(spec.clip,scope),context:{$context:!0},groups:scope.lookup(),parent:scope.signals.parent?scope.signalRef(\"parent\"):null,index:scope.markpath(),pulse:ref$jscomp$0(op)}));var boundRef=ref$jscomp$0(op);op=enc=scope.add(Encode(parseEncode(spec.encode,spec.type,role,spec.style,scope,{mod:!1,pulse:boundRef})));op.params.parent=scope.encode();spec.transform&&spec.transform.forEach(function(_){_=parseTransform(_,scope);var md=_.metadata;(md.generates||\nmd.changes)&&vegaUtil.error(\"Mark transforms should not generate new data.\");md.nomod||(enc.params.mod=!0);_.params.pulse=ref$jscomp$0(op);scope.add(op=_)});spec.sort&&(op=scope.add(SortItems({sort:scope.compareRef(spec.sort),pulse:ref$jscomp$0(op)})));role=ref$jscomp$0(op);if(facet||layout){layout=scope.add(ViewLayout({layout:scope.objectProperty(spec.layout),legends:scope.legends,mark:boundRef,pulse:role}));var layoutRef=ref$jscomp$0(layout)}var bound=scope.add(Bound({mark:boundRef,pulse:layoutRef||\nrole}));boundRef=ref$jscomp$0(bound);if(group){if(nested){var ops=scope.operators;ops.pop();layout&&ops.pop()}scope.pushState(role,layoutRef||boundRef,joinRef);facet?parseFacet(spec,scope,input):nested?parseSubflow(spec,scope,input):scope.parse(spec);scope.popState();nested&&(layout&&ops.push(layout),ops.push(bound))}overlap&&(boundRef=parseOverlap(overlap,boundRef,scope));group=scope.add(Render({pulse:boundRef}));facet=scope.add(Sieve({pulse:ref$jscomp$0(group)},void 0,scope.parent()));if(null!=\nspec.name){var name=spec.name;scope.addData(name,new DataScope(scope,store,group,facet));spec.on&&spec.on.forEach(function(on){(on.insert||on.remove||on.toggle)&&vegaUtil.error(\"Marks only support modify triggers.\");parseTrigger(on,scope,name)})}}function parseOverlap(overlap,source,scope){var method=overlap.method,bound=overlap.bound,sep=overlap.separation;source={separation:isSignal(sep)?scope.signalRef(sep.signal):sep,method:isSignal(method)?scope.signalRef(method.signal):method,pulse:source};\noverlap.order&&(source.sort=scope.compareRef({field:overlap.order}));bound&&(overlap=bound.tolerance,source.boundTolerance=isSignal(overlap)?scope.signalRef(overlap.signal):+overlap,source.boundScale=scope.scaleRef(bound.scale),source.boundOrient=bound.orient);return ref$jscomp$0(scope.add(Overlap(source)))}function parseLegend(spec,scope){var config=scope.config.legend,encode=spec.encode||{},_=lookup$jscomp$0(spec,config),legendEncode=encode.legend||{},name=legendEncode.name||void 0,interactive=\nlegendEncode.interactive,style=legendEncode.style,scales={},scale=0,params;LegendScales.forEach(function(s){return spec[s]?(scales[s]=spec[s],scale=scale||spec[s]):0});scale||vegaUtil.error(\"Missing valid scale for legend.\");var children=legendType(spec,scope.scaleType(scale));var datum={title:null!=spec.title,scales:scales,type:children,vgrad:\"symbol\"!==children&&_.isVertical()},dataRef=ref$jscomp$0(scope.add(Collect(null,[datum]))),entryRef=ref$jscomp$0(scope.add(LegendEntries(params={type:children,\nscale:scope.scaleRef(scale),count:scope.objectProperty(_(\"tickCount\")),limit:scope.property(_(\"symbolLimit\")),values:scope.objectProperty(spec.values),minstep:scope.property(spec.tickMinStep),formatType:scope.property(spec.formatType),formatSpecifier:scope.property(spec.format)})));if(\"gradient\"===children)children=[legendGradient(spec,scale,config,encode.gradient),legendGradientLabels(spec,config,encode.labels,entryRef)],params.count=params.count||scope.signalRef(\"max(2,2*floor((\"+deref(_.gradientLength())+\n\")/100))\");else if(\"discrete\"===children)children=[legendGradientDiscrete(spec,scale,config,encode.gradient,entryRef),legendGradientLabels(spec,config,encode.labels,entryRef)];else{var entryLayout=legendSymbolLayout(spec,config);children=[legendSymbolGroups(spec,config,encode,entryRef,deref(entryLayout.columns))];params.size=sizeExpression(spec,scope,children[0].marks)}children=[guideGroup({role:\"legend-entry\",from:dataRef,encode:{enter:{x:{value:0},y:{value:0}}},marks:children,layout:entryLayout,\ninteractive:interactive})];datum.title&&children.push(legendTitle(spec,config,encode.title,dataRef));return parseMark(guideGroup({role:\"legend\",from:dataRef,encode:extendEncode(buildLegendEncode(_,spec,config),legendEncode,Skip),marks:children,aria:_(\"aria\"),description:_(\"description\"),zindex:_(\"zindex\"),name:name,interactive:interactive,style:style}),scope)}function legendType(spec,scaleType){var type=spec.type||\"symbol\";spec.type||1!==scaleCount(spec)||!spec.fill&&!spec.stroke||(type=vegaScale.isContinuous(scaleType)?\n\"gradient\":vegaScale.isDiscretizing(scaleType)?\"discrete\":\"symbol\");return\"gradient\"!==type?type:vegaScale.isDiscretizing(scaleType)?\"discrete\":\"gradient\"}function scaleCount(spec){return LegendScales.reduce(function(count,type){return count+(spec[type]?1:0)},0)}function buildLegendEncode(_,spec,config){var encode={enter:{},update:{}};addEncoders(encode,{orient:_(\"orient\"),offset:_(\"offset\"),padding:_(\"padding\"),titlePadding:_(\"titlePadding\"),cornerRadius:_(\"cornerRadius\"),fill:_(\"fillColor\"),stroke:_(\"strokeColor\"),\nstrokeWidth:config.strokeWidth,strokeDash:config.strokeDash,x:_(\"legendX\"),y:_(\"legendY\"),format:spec.format,formatType:spec.formatType});return encode}function sizeExpression(spec,scope,marks){var size=deref(getChannel(\"size\",spec,marks));spec=deref(getChannel(\"strokeWidth\",spec,marks));(marks=getEncoding(\"fontSize\",marks[1].encode))||(marks=(marks=scope.config.style[\"guide-label\"])&&marks.fontSize);marks=deref(marks);return vegaFunctions.parseExpression(\"max(ceil(sqrt(\"+size+\")+\"+spec+\"),\"+marks+\n\")\",scope)}function getChannel(name,spec,marks){return spec[name]?'scale(\"'+spec[name]+'\",datum)':getEncoding(name,marks[0].encode)}function parseTitle(spec,scope){spec=vegaUtil.isString(spec)?{text:spec}:spec;var _=lookup$jscomp$0(spec,scope.config.title),encode=spec.encode||{},userEncode=encode.group||{},name=userEncode.name||void 0,interactive=userEncode.interactive,style=userEncode.style,children=[],dataRef=ref$jscomp$0(scope.add(Collect(null,[{}])));children.push(buildTitle(spec,_,titleEncode(spec),\ndataRef));spec.subtitle&&children.push(buildSubTitle(spec,_,encode.subtitle,dataRef));spec={enter:{},update:{}};addEncoders(spec,{orient:_(\"orient\"),anchor:_(\"anchor\"),align:{signal:alignExpr},angle:{signal:'item.orient\\x3d\\x3d\\x3d\"left\"?-90:item.orient\\x3d\\x3d\\x3d\"right\"?90:0'},limit:_(\"limit\"),frame:_(\"frame\"),offset:_(\"offset\")||0,padding:_(\"subtitlePadding\")});userEncode=extendEncode(spec,userEncode,Skip);return parseMark(guideGroup({role:\"title\",from:dataRef,encode:userEncode,marks:children,\naria:_(\"aria\"),description:_(\"description\"),zindex:_(\"zindex\"),name:name,interactive:interactive,style:style}),scope)}function titleEncode(spec){var encode=spec.encode;return encode&&encode.title||vegaUtil.extend({name:spec.name,interactive:spec.interactive,style:spec.style},encode)}function buildTitle(spec,_,userEncode,dataRef){var zero={value:0};zero={enter:{opacity:zero},update:{opacity:{value:1}},exit:{opacity:zero}};addEncoders(zero,{text:spec.text,align:{signal:\"item.mark.group.align\"},angle:{signal:\"item.mark.group.angle\"},\nlimit:{signal:\"item.mark.group.limit\"},baseline:\"top\",dx:_(\"dx\"),dy:_(\"dy\"),fill:_(\"color\"),font:_(\"font\"),fontSize:_(\"fontSize\"),fontStyle:_(\"fontStyle\"),fontWeight:_(\"fontWeight\"),lineHeight:_(\"lineHeight\")},{align:_(\"align\"),angle:_(\"angle\"),baseline:_(\"baseline\")});return guideMark({type:\"text\",role:\"title-text\",style:\"group-title\",from:dataRef,encode:zero},userEncode)}function buildSubTitle(spec,_,userEncode,dataRef){var zero={value:0};zero={enter:{opacity:zero},update:{opacity:{value:1}},exit:{opacity:zero}};\naddEncoders(zero,{text:spec.subtitle,align:{signal:\"item.mark.group.align\"},angle:{signal:\"item.mark.group.angle\"},limit:{signal:\"item.mark.group.limit\"},baseline:\"top\",dx:_(\"dx\"),dy:_(\"dy\"),fill:_(\"subtitleColor\"),font:_(\"subtitleFont\"),fontSize:_(\"subtitleFontSize\"),fontStyle:_(\"subtitleFontStyle\"),fontWeight:_(\"subtitleFontWeight\"),lineHeight:_(\"subtitleLineHeight\")},{align:_(\"align\"),angle:_(\"angle\"),baseline:_(\"baseline\")});return guideMark({type:\"text\",role:\"title-subtitle\",style:\"group-subtitle\",\nfrom:dataRef,encode:zero},userEncode)}function parseData$1(data,scope){var transforms=[];data.transform&&data.transform.forEach(function(tx){transforms.push(parseTransform(tx,scope))});data.on&&data.on.forEach(function(on){parseTrigger(on,scope,data.name)});scope.addDataPipeline(data.name,analyze(data,scope,transforms))}function analyze(data,scope,ops){var output=[],source=null,modify=!1,generate=!1,upstream,n;data.values?hasSignal(data.values)||hasSignal(data.format)?(output.push(load(scope,data)),\noutput.push(source=collect())):output.push(source=collect({$ingest:data.values,$format:data.format})):data.url?hasSignal(data.url)||hasSignal(data.format)?(output.push(load(scope,data)),output.push(source=collect())):output.push(source=collect({$request:data.url,$format:data.format})):data.source&&(source=upstream=vegaUtil.array(data.source).map(function(d){return ref$jscomp$0(scope.getData(d).output)}),output.push(null));data=0;for(n=ops.length;data<n;++data){var t=ops[data];var m=t.metadata;source||\nm.source||output.push(source=collect());output.push(t);m.generates&&(generate=!0);m.modifies&&!generate&&(modify=!0);m.source?source=t:m.changes&&(source=null)}upstream&&(n=upstream.length-1,output[0]=Relay({derive:modify,pulse:n?upstream:upstream[0]}),(modify||n)&&output.splice(1,0,collect()));source||output.push(collect());output.push(Sieve({}));return output}function collect(values){values=Collect({},values);values.metadata={source:!0};return values}function load(scope,data){return Load({url:data.url?\nscope.property(data.url):void 0,async:data.async?scope.property(data.async):void 0,values:data.values?scope.property(data.values):void 0,format:scope.objectProperty(data.format)})}function fallback(prop,config,axisConfig,style){if(config&&vegaUtil.hasOwnProperty(config,prop))return config[prop];if(vegaUtil.hasOwnProperty(axisConfig,prop))return axisConfig[prop];if(prop.startsWith(\"title\")){switch(prop){case \"titleColor\":var styleProp=\"fill\";break;case \"titleFont\":case \"titleFontSize\":case \"titleFontWeight\":styleProp=\nprop[5].toLowerCase()+prop.slice(6)}return style[\"guide-title\"][styleProp]}if(prop.startsWith(\"label\")){switch(prop){case \"labelColor\":styleProp=\"fill\";break;case \"labelFont\":case \"labelFontSize\":styleProp=prop[5].toLowerCase()+prop.slice(6)}return style[\"guide-label\"][styleProp]}return null}function keys(objects){var map={};objects=$jscomp.makeIterator(objects);for(var $jscomp$key$obj=objects.next();!$jscomp$key$obj.done;$jscomp$key$obj=objects.next())if($jscomp$key$obj=$jscomp$key$obj.value)for(var key in $jscomp$key$obj)map[key]=\n1;return Object.keys(map)}function axisDomain(spec,config,userEncode,dataRef){var _=lookup$jscomp$0(spec,config);config=spec.orient;var enter,update,encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{stroke:_(\"domainColor\"),strokeCap:_(\"domainCap\"),strokeDash:_(\"domainDash\"),strokeDashOffset:_(\"domainDashOffset\"),strokeWidth:_(\"domainWidth\"),strokeOpacity:_(\"domainOpacity\")});_={scale:spec.scale,range:0};spec={scale:spec.scale,\nrange:1};enter.x=update.x=ifX(config,_,zero$jscomp$0);enter.x2=update.x2=ifX(config,spec);enter.y=update.y=ifY(config,_,zero$jscomp$0);enter.y2=update.y2=ifY(config,spec);return guideMark({type:\"rule\",role:\"axis-domain\",from:dataRef,encode:encode},userEncode)}function axisGrid(spec,config,userEncode,dataRef,band){var _=lookup$jscomp$0(spec,config);config=spec.orient;var vscale=spec.gridScale,sign=getSign(config,1,-1);a:{var JSCompiler_inline_result=spec.offset;if(1!==sign)if(vegaUtil.isObject(JSCompiler_inline_result)){for(var entry$394=\nJSCompiler_inline_result=vegaUtil.extend({},JSCompiler_inline_result);null!=entry$394.mult;)if(vegaUtil.isObject(entry$394.mult))entry$394=entry$394.mult=vegaUtil.extend({},entry$394.mult);else{entry$394.mult=isSignal(sign)?{signal:\"(\"+entry$394.mult+\") * (\"+sign.signal+\")\"}:entry$394.mult*sign;break a}entry$394.mult=sign}else JSCompiler_inline_result=isSignal(sign)?{signal:\"(\"+sign.signal+\") * (\"+(JSCompiler_inline_result||0)+\")\"}:sign*(JSCompiler_inline_result||0)}var offset=JSCompiler_inline_result,\nupdate,encode={enter:JSCompiler_inline_result={opacity:zero$jscomp$0},update:update={opacity:one},exit:entry$394={opacity:zero$jscomp$0}};addEncoders(encode,{stroke:_(\"gridColor\"),strokeCap:_(\"gridCap\"),strokeDash:_(\"gridDash\"),strokeDashOffset:_(\"gridDashOffset\"),strokeOpacity:_(\"gridOpacity\"),strokeWidth:_(\"gridWidth\")});spec={scale:spec.scale,field:\"value\",band:band.band,extra:band.extra,offset:band.offset,round:_(\"tickRound\")};_=ifX(config,{signal:\"height\"},{signal:\"width\"});band=vscale?{scale:vscale,\nrange:0,mult:sign,offset:offset}:{value:0,offset:offset};vscale=vscale?{scale:vscale,range:1,mult:sign,offset:offset}:vegaUtil.extend(_,{mult:sign,offset:offset});JSCompiler_inline_result.x=update.x=ifX(config,spec,band);JSCompiler_inline_result.y=update.y=ifY(config,spec,band);JSCompiler_inline_result.x2=update.x2=ifY(config,vscale);JSCompiler_inline_result.y2=update.y2=ifX(config,vscale);entry$394.x=ifX(config,spec);entry$394.y=ifY(config,spec);return guideMark({type:\"rule\",role:\"axis-grid\",key:\"value\",\nfrom:dataRef,encode:encode},userEncode)}function axisTicks(spec,config,userEncode,dataRef,size,band){var _=lookup$jscomp$0(spec,config);config=spec.orient;var sign=getSign(config,-1,1),enter,exit,update,encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one},exit:exit={opacity:zero$jscomp$0}};addEncoders(encode,{stroke:_(\"tickColor\"),strokeCap:_(\"tickCap\"),strokeDash:_(\"tickDash\"),strokeDashOffset:_(\"tickDashOffset\"),strokeOpacity:_(\"tickOpacity\"),strokeWidth:_(\"tickWidth\")});size=\nencoder(size);size.mult=sign;spec={scale:spec.scale,field:\"value\",band:band.band,extra:band.extra,offset:band.offset,round:_(\"tickRound\")};update.y=enter.y=ifX(config,zero$jscomp$0,spec);update.y2=enter.y2=ifX(config,size);exit.x=ifX(config,spec);update.x=enter.x=ifY(config,zero$jscomp$0,spec);update.x2=enter.x2=ifY(config,size);exit.y=ifY(config,spec);return guideMark({type:\"rule\",role:\"axis-tick\",key:\"value\",from:dataRef,encode:encode},userEncode)}function flushExpr(scale,threshold,a,b,c){return{signal:'flush(range(\"'+\nscale+'\"), scale(\"'+scale+'\", datum.value), '+threshold+\",\"+a+\",\"+b+\",\"+c+\")\"}}function axisLabels(spec,config,userEncode,dataRef,size,band){config=lookup$jscomp$0(spec,config);var orient=spec.orient;spec=spec.scale;var sign=getSign(orient,-1,1),flush=deref(config(\"labelFlush\")),flushOffset=deref(config(\"labelFlushOffset\")),labelAlign=config(\"labelAlign\"),labelBaseline=config(\"labelBaseline\"),flushOn=0===flush||!!flush,tickSize=encoder(size);tickSize.mult=sign;tickSize.offset=encoder(config(\"labelPadding\")||\n0);tickSize.offset.mult=sign;sign={scale:spec,field:\"value\",band:.5,offset:extendOffset(band.offset,config(\"labelOffset\"))};band=flushOn?flushExpr(spec,flush,'\"left\"','\"right\"','\"center\"'):{value:\"center\"};size=isSignal(orient)?ifExpr(orient.signal+\" \\x3d\\x3d\\x3d 'right'\",\"left\",\"right\"):\"right\"===orient?{value:\"left\"}:{value:\"right\"};band=ifX(orient,band,size);size=ifX(orient,ifTop(orient,\"bottom\",\"top\"),flushOn?flushExpr(spec,flush,'\"top\"','\"bottom\"','\"middle\"'):{value:\"middle\"});flush=flushExpr(spec,\nflush,\"-(\"+flushOffset+\")\",flushOffset,0);flushOn=flushOn&&flushOffset;tickSize={opacity:zero$jscomp$0,x:ifX(orient,sign,tickSize),y:ifY(orient,sign,tickSize)};tickSize={enter:tickSize,update:flushOffset={opacity:one,text:{field:\"label\"},x:tickSize.x,y:tickSize.y,align:band,baseline:size},exit:{opacity:zero$jscomp$0,x:tickSize.x,y:tickSize.y}};addEncoders(tickSize,{dx:!labelAlign&&flushOn?ifX(orient,flush):null,dy:!labelBaseline&&flushOn?ifY(orient,flush):null});addEncoders(tickSize,{angle:config(\"labelAngle\"),\nfill:config(\"labelColor\"),fillOpacity:config(\"labelOpacity\"),font:config(\"labelFont\"),fontSize:config(\"labelFontSize\"),fontWeight:config(\"labelFontWeight\"),fontStyle:config(\"labelFontStyle\"),limit:config(\"labelLimit\"),lineHeight:config(\"labelLineHeight\")},{align:labelAlign,baseline:labelBaseline});labelAlign=config(\"labelBound\");labelBaseline=(labelBaseline=config(\"labelOverlap\"))||labelAlign?{separation:config(\"labelSeparation\"),method:labelBaseline,order:\"datum.index\",bound:labelAlign?{scale:spec,\norient:orient,tolerance:labelAlign}:null}:void 0;flushOffset.align!==band&&(flushOffset.align=patch(flushOffset.align,band));flushOffset.baseline!==size&&(flushOffset.baseline=patch(flushOffset.baseline,size));return guideMark({type:\"text\",role:\"axis-label\",style:\"guide-label\",key:\"value\",from:dataRef,encode:tickSize,overlap:labelBaseline},userEncode)}function axisTitle(spec,config,userEncode,dataRef){config=lookup$jscomp$0(spec,config);var orient=spec.orient,sign=getSign(orient,-1,1),enter,update,\nencode={enter:enter={opacity:zero$jscomp$0,anchor:encoder(config(\"titleAnchor\",null)),align:{signal:alignExpr}},update:update=vegaUtil.extend({},enter,{opacity:one,text:encoder(spec.title)}),exit:{opacity:zero$jscomp$0}};spec={signal:'lerp(range(\"'+spec.scale+'\"), '+anchorExpr(0,1,.5)+\")\"};update.x=ifX(orient,spec);update.y=ifY(orient,spec);enter.angle=ifX(orient,zero$jscomp$0,isSignal(sign)?{signal:\"(\"+sign.signal+\") * 90\"}:{value:90*sign});enter.baseline=ifX(orient,ifTop(orient,\"bottom\",\"top\"),\n{value:\"bottom\"});update.angle=enter.angle;update.baseline=enter.baseline;addEncoders(encode,{fill:config(\"titleColor\"),fillOpacity:config(\"titleOpacity\"),font:config(\"titleFont\"),fontSize:config(\"titleFontSize\"),fontStyle:config(\"titleFontStyle\"),fontWeight:config(\"titleFontWeight\"),limit:config(\"titleLimit\"),lineHeight:config(\"titleLineHeight\")},{align:config(\"titleAlign\"),angle:config(\"titleAngle\"),baseline:config(\"titleBaseline\")});autoLayout(config,orient,encode,userEncode);encode.update.align=\npatch(encode.update.align,enter.align);encode.update.angle=patch(encode.update.angle,enter.angle);encode.update.baseline=patch(encode.update.baseline,enter.baseline);return guideMark({type:\"text\",role:\"axis-title\",style:\"guide-title\",from:dataRef,encode:encode},userEncode)}function autoLayout(_,orient,encode,userEncode){var auto=function(value,dim){return null!=value?(encode.update[dim]=patch(encoder(value),encode.update[dim]),!1):has(dim,userEncode)?!1:!0},autoY=auto(_(\"titleX\"),\"x\");_=auto(_(\"titleY\"),\n\"y\");encode.enter.auto=_===autoY?encoder(_):ifX(orient,encoder(_),encoder(autoY))}function parseScope(spec,scope,preprocessed){var signals=vegaUtil.array(spec.signals),scales=vegaUtil.array(spec.scales);preprocessed||signals.forEach(function(_){return parseSignal(_,scope)});vegaUtil.array(spec.projections).forEach(function(_){var config=scope.config.projection||{},params={},name;for(name in _)\"name\"!==name&&(params[name]=parseParameter(_[name],name,scope));for(var name$392 in config)null==params[name$392]&&\n(params[name$392]=parseParameter(config[name$392],name$392,scope));scope.addProjection(_.name,params)});scales.forEach(function(_){var type=_.type||\"linear\";vegaScale.isValidScaleType(type)||vegaUtil.error(\"Unrecognized scale type: \"+vegaUtil.stringValue(type));scope.addScale(_.name,{type:type,domain:void 0})});vegaUtil.array(spec.data).forEach(function(_){return parseData$1(_,scope)});scales.forEach(function(_){var params=scope.getScale(_.name).params,key;params.domain=parseScaleDomain(_.domain,\n_,scope);null!=_.range&&(params.range=parseScaleRange(_,scope,params));if(null!=_.interpolate){var interpolate=_.interpolate;params.interpolate=parseLiteral(interpolate.type||interpolate);null!=interpolate.gamma&&(params.interpolateGamma=parseLiteral(interpolate.gamma))}null!=_.nice&&(interpolate=_.nice,interpolate=vegaUtil.isObject(interpolate)?{interval:parseLiteral(interpolate.interval),step:parseLiteral(interpolate.step)}:parseLiteral(interpolate),params.nice=interpolate);null!=_.bins&&(interpolate=\n_.bins,interpolate=interpolate.signal||vegaUtil.isArray(interpolate)?parseArray(interpolate,scope):scope.objectProperty(interpolate),params.bins=interpolate);for(key in _)vegaUtil.hasOwnProperty(params,key)||\"name\"===key||(params[key]=parseLiteral(_[key],scope))});(preprocessed||signals).forEach(function(_){return parseSignalUpdates(_,scope)});vegaUtil.array(spec.axes).forEach(function(_){var config=scope.config,style=config.style,axis=config.axis,band=\"band\"===scope.scaleType(_.scale)&&config.axisBand,\norient=_.orient,key;if(isSignal(orient)){var or=keys([config.axisX,config.axisY]);var orientKeys=keys([config.axisTop,config.axisBottom,config.axisLeft,config.axisRight]);var JSCompiler_inline_result={};or=$jscomp.makeIterator(or);for(key=or.next();!key.done;key=or.next())key=key.value,JSCompiler_inline_result[key]=ifX(orient,fallback(key,config.axisX,axis,style),fallback(key,config.axisY,axis,style));or={};orientKeys=$jscomp.makeIterator(orientKeys);for(key=orientKeys.next();!key.done;key=orientKeys.next()){key=\nkey.value;var JSCompiler_temp_const=or,JSCompiler_temp_const$jscomp$0=key,$orient=orient.signal,t=fallback(key,config.axisTop,axis,style),b=fallback(key,config.axisBottom,axis,style),l=fallback(key,config.axisLeft,axis,style);key=fallback(key,config.axisRight,axis,style);key={signal:(null!=l?$orient+\" \\x3d\\x3d\\x3d 'left' ? (\"+toExpr(l)+\") : \":\"\")+(null!=b?$orient+\" \\x3d\\x3d\\x3d 'bottom' ? (\"+toExpr(b)+\") : \":\"\")+(null!=key?$orient+\" \\x3d\\x3d\\x3d 'right' ? (\"+toExpr(key)+\") : \":\"\")+(null!=t?$orient+\n\" \\x3d\\x3d\\x3d 'top' ? (\"+toExpr(t)+\") : \":\"\")+\"(null)\"};JSCompiler_temp_const[JSCompiler_temp_const$jscomp$0]=key}}else JSCompiler_inline_result=\"top\"===orient||\"bottom\"===orient?config.axisX:config.axisY,or=config[\"axis\"+orient[0].toUpperCase()+orient.slice(1)];JSCompiler_inline_result=JSCompiler_inline_result||or||band?vegaUtil.extend({},axis,JSCompiler_inline_result,or,band):axis;or=_.encode||{};config=or.axis||{};style=config.name||void 0;axis=config.interactive;band=config.style;orient=lookup$jscomp$0(_,\nJSCompiler_inline_result);orientKeys=orient(\"tickBand\");key=orient(\"tickOffset\");orientKeys?orientKeys.signal?(JSCompiler_temp_const={signal:\"(\"+orientKeys.signal+\") \\x3d\\x3d\\x3d 'extent' ? 1 : 0.5\"},JSCompiler_temp_const$jscomp$0={signal:\"(\"+orientKeys.signal+\") \\x3d\\x3d\\x3d 'extent'\"},vegaUtil.isObject(key)||(key={signal:\"(\"+orientKeys.signal+\") \\x3d\\x3d\\x3d 'extent' ? 0 : \"+key})):\"extent\"===orientKeys?(JSCompiler_temp_const=1,JSCompiler_temp_const$jscomp$0=!0,key=0):(JSCompiler_temp_const=.5,\nJSCompiler_temp_const$jscomp$0=!1):(JSCompiler_temp_const=orient(\"bandPosition\"),JSCompiler_temp_const$jscomp$0=orient(\"tickExtra\"));JSCompiler_temp_const={extra:JSCompiler_temp_const$jscomp$0,band:JSCompiler_temp_const,offset:key};JSCompiler_temp_const$jscomp$0={scale:_.scale,ticks:!!orient(\"ticks\"),labels:!!orient(\"labels\"),grid:!!orient(\"grid\"),domain:!!orient(\"domain\"),title:null!=_.title};orientKeys=ref$jscomp$0(scope.add(Collect({},[JSCompiler_temp_const$jscomp$0])));$orient=ref$jscomp$0(scope.add(AxisTicks({scale:scope.scaleRef(_.scale),\nextra:scope.property(JSCompiler_temp_const.extra),count:scope.objectProperty(_.tickCount),values:scope.objectProperty(_.values),minstep:scope.property(_.tickMinStep),formatType:scope.property(_.formatType),formatSpecifier:scope.property(_.format)})));key=[];JSCompiler_temp_const$jscomp$0.grid&&key.push(axisGrid(_,JSCompiler_inline_result,or.grid,$orient,JSCompiler_temp_const));if(JSCompiler_temp_const$jscomp$0.ticks){var size=orient(\"tickSize\");key.push(axisTicks(_,JSCompiler_inline_result,or.ticks,\n$orient,size,JSCompiler_temp_const))}JSCompiler_temp_const$jscomp$0.labels&&(size=JSCompiler_temp_const$jscomp$0.ticks?size:0,key.push(axisLabels(_,JSCompiler_inline_result,or.labels,$orient,size,JSCompiler_temp_const)));JSCompiler_temp_const$jscomp$0.domain&&key.push(axisDomain(_,JSCompiler_inline_result,or.domain,orientKeys));JSCompiler_temp_const$jscomp$0.title&&key.push(axisTitle(_,JSCompiler_inline_result,or.title,orientKeys));size={enter:{},update:{}};addEncoders(size,{orient:orient(\"orient\"),\noffset:orient(\"offset\")||0,position:value$jscomp$0(_.position,0),titlePadding:orient(\"titlePadding\"),minExtent:orient(\"minExtent\"),maxExtent:orient(\"maxExtent\"),range:{signal:'abs(span(range(\"'+_.scale+'\")))'},translate:orient(\"translate\"),format:_.format,formatType:_.formatType});return parseMark(guideGroup({role:\"axis\",from:orientKeys,encode:extendEncode(size,config,Skip),marks:key,aria:orient(\"aria\"),description:orient(\"description\"),zindex:orient(\"zindex\"),name:style,interactive:axis,style:band}),\nscope)});vegaUtil.array(spec.marks).forEach(function(_){return parseMark(_,scope)});vegaUtil.array(spec.legends).forEach(function(_){return parseLegend(_,scope)});spec.title&&parseTitle(spec.title,scope);scope.parseLambdas();return scope}function parseView(spec,scope){var config=scope.config,root=ref$jscomp$0(scope.root=scope.add(new Entry(\"operator\",void 0,void 0,void 0))),signals=collectSignals(spec,config);signals.forEach(function(_){return parseSignal(_,scope)});scope.description=spec.description||\nconfig.description;scope.eventConfig=config.events;scope.legends=scope.objectProperty(config.legend&&config.legend.layout);scope.locale=config.locale;config=scope.add(Collect());var encode=scope.add(Encode(parseEncode(extendEncode({enter:{x:{value:0},y:{value:0}},update:{width:{signal:\"width\"},height:{signal:\"height\"}}},spec.encode),\"group\",\"frame\",spec.style,scope,{pulse:ref$jscomp$0(config)}))),parent=scope.add(ViewLayout({layout:scope.objectProperty(spec.layout),legends:scope.legends,autosize:scope.signalRef(\"autosize\"),\nmark:root,pulse:ref$jscomp$0(encode)}));scope.operators.pop();scope.pushState(ref$jscomp$0(encode),ref$jscomp$0(parent),null);parseScope(spec,scope,signals);scope.operators.push(parent);spec=scope.add(Bound({mark:root,pulse:ref$jscomp$0(parent)}));spec=scope.add(Render({pulse:ref$jscomp$0(spec)}));spec=scope.add(Sieve({pulse:ref$jscomp$0(spec)}));scope.addData(\"root\",new DataScope(scope,config,config,spec));return scope}function signalObject(name,value){return value&&value.signal?{name:name,update:value.signal}:\n{name:name,value:value}}function collectSignals(spec,config){var _=function(name){return value$jscomp$0(spec[name],config[name])},signals=[signalObject(\"background\",_(\"background\")),signalObject(\"autosize\",parseAutosize(_(\"autosize\"))),signalObject(\"padding\",parsePadding(_(\"padding\"))),signalObject(\"width\",_(\"width\")||0),signalObject(\"height\",_(\"height\")||0)],pre=signals.reduce(function(p,s){return p[s.name]=s,p},{}),map={};vegaUtil.array(spec.signals).forEach(function(s){vegaUtil.hasOwnProperty(pre,\ns.name)?s=vegaUtil.extend(pre[s.name],s):signals.push(s);map[s.name]=s});vegaUtil.array(config.signals).forEach(function(s){vegaUtil.hasOwnProperty(map,s.name)||vegaUtil.hasOwnProperty(pre,s.name)||signals.push(s)});return signals}function Scope$1(config,options){this.config=config||{};this.options=options||{};this.bindings=[];this.field={};this.signals={};this.lambdas={};this.scales={};this.events={};this.data={};this.streams=[];this.updates=[];this.operators=[];this.locale=this.eventConfig=null;\nthis._subid=this._id=0;this._nextsub=[0];this._parent=[];this._encode=[];this._lookup=[];this._markpath=[]}function Subscope(scope){this.config=scope.config;this.options=scope.options;this.legends=scope.legends;this.field=Object.create(scope.field);this.signals=Object.create(scope.signals);this.lambdas=Object.create(scope.lambdas);this.scales=Object.create(scope.scales);this.events=Object.create(scope.events);this.data=Object.create(scope.data);this.streams=[];this.updates=[];this.operators=[];this._id=\n0;this._subid=++scope._nextsub[0];this._nextsub=scope._nextsub;this._parent=scope._parent.slice();this._encode=scope._encode.slice();this._lookup=scope._lookup.slice();this._markpath=scope._markpath}function propertyLambda(spec){return(vegaUtil.isArray(spec)?arrayLambda:objectLambda)(spec)}function arrayLambda(array){for(var n=array.length,code=\"[\",i=0;i<n;++i){var value$396=array[i];code+=(0<i?\",\":\"\")+(vegaUtil.isObject(value$396)?value$396.signal||propertyLambda(value$396):vegaUtil.stringValue(value$396))}return code+\n\"]\"}function objectLambda(obj){var code=\"{\",i=0,key;for(key in obj){var value=obj[key];code+=(1<++i?\",\":\"\")+vegaUtil.stringValue(key)+\":\"+(vegaUtil.isObject(value)?value.signal||propertyLambda(value):vegaUtil.stringValue(value))}return code+\"}\"}function defaults(){return{description:\"Vega visualization\",padding:0,autosize:\"pad\",background:null,events:{defaults:{allow:[\"wheel\"]}},group:null,mark:null,arc:{fill:\"#4c78a8\"},area:{fill:\"#4c78a8\"},image:null,line:{stroke:\"#4c78a8\",strokeWidth:2},path:{stroke:\"#4c78a8\"},\nrect:{fill:\"#4c78a8\"},rule:{stroke:\"#000\"},shape:{stroke:\"#4c78a8\"},symbol:{fill:\"#4c78a8\",size:64},text:{fill:\"#000\",font:\"sans-serif\",fontSize:11},trail:{fill:\"#4c78a8\",size:2},style:{\"guide-label\":{fill:\"#000\",font:\"sans-serif\",fontSize:10},\"guide-title\":{fill:\"#000\",font:\"sans-serif\",fontSize:11,fontWeight:\"bold\"},\"group-title\":{fill:\"#000\",font:\"sans-serif\",fontSize:13,fontWeight:\"bold\"},\"group-subtitle\":{fill:\"#000\",font:\"sans-serif\",fontSize:12},point:{size:30,strokeWidth:2,shape:\"circle\"},\ncircle:{size:30,strokeWidth:2},square:{size:30,strokeWidth:2,shape:\"square\"},cell:{fill:\"transparent\",stroke:\"#ddd\"}},title:{orient:\"top\",anchor:\"middle\",offset:4,subtitlePadding:3},axis:{minExtent:0,maxExtent:200,bandPosition:.5,domain:!0,domainWidth:1,domainColor:\"#888\",grid:!1,gridWidth:1,gridColor:\"#ddd\",labels:!0,labelAngle:0,labelLimit:180,labelOffset:0,labelPadding:2,ticks:!0,tickColor:\"#888\",tickOffset:0,tickRound:!0,tickSize:5,tickWidth:1,titlePadding:4},axisBand:{tickOffset:-.5},projection:{type:\"mercator\"},\nlegend:{orient:\"right\",padding:0,gridAlign:\"each\",columnPadding:10,rowPadding:2,symbolDirection:\"vertical\",gradientDirection:\"vertical\",gradientLength:200,gradientThickness:16,gradientStrokeColor:\"#ddd\",gradientStrokeWidth:0,gradientLabelOffset:2,labelAlign:\"left\",labelBaseline:\"middle\",labelLimit:160,labelOffset:4,labelOverlap:!0,symbolLimit:30,symbolType:\"circle\",symbolSize:100,symbolOffset:0,symbolStrokeWidth:1.5,symbolBaseFillColor:\"transparent\",symbolBaseStrokeColor:\"#888\",titleLimit:180,titleOrient:\"top\",\ntitlePadding:5,layout:{offset:18,direction:\"horizontal\",left:{direction:\"vertical\"},right:{direction:\"vertical\"}}},range:{category:{scheme:\"tableau10\"},ordinal:{scheme:\"blues\"},heatmap:{scheme:\"yellowgreenblue\"},ramp:{scheme:\"blues\"},diverging:{scheme:\"blueorange\",extent:[1,0]},symbol:\"circle square triangle-up cross diamond triangle-right triangle-down triangle-left\".split(\" \")}}}var encoder=function(_){return vegaUtil.isObject(_)&&!vegaUtil.isArray(_)?vegaUtil.extend({},_):{value:_}},scaleRef=function(scale){return vegaUtil.isString(scale)?\nvegaUtil.stringValue(scale):scale.signal?\"(\"+scale.signal+\")\":field$jscomp$0(scale)},_color=function(type,x,y,z){return\"(\"+type+\"(\"+[x,y,z].map(entry$jscomp$0).join(\",\")+\")+'')\"},OUTER_INVALID=[\"value\",\"update\",\"init\",\"react\",\"bind\"],keyFieldRef=fieldRef(\"key\"),OP_VALUE_EXPR={code:\"_.$value\",ast:{type:\"Identifier\",value:\"value\"}},transform$jscomp$0=function(name){return function(params,value,parent){return new Entry(name,value,params||void 0,parent)}},Aggregate=transform$jscomp$0(\"aggregate\"),AxisTicks=\ntransform$jscomp$0(\"axisticks\"),Bound=transform$jscomp$0(\"bound\"),Collect=transform$jscomp$0(\"collect\"),Compare=transform$jscomp$0(\"compare\"),DataJoin=transform$jscomp$0(\"datajoin\"),Encode=transform$jscomp$0(\"encode\"),Expression=transform$jscomp$0(\"expression\"),Facet=transform$jscomp$0(\"facet\"),Field=transform$jscomp$0(\"field\"),Key=transform$jscomp$0(\"key\"),LegendEntries=transform$jscomp$0(\"legendentries\"),Load=transform$jscomp$0(\"load\"),Mark=transform$jscomp$0(\"mark\"),MultiExtent=transform$jscomp$0(\"multiextent\"),\nMultiValues=transform$jscomp$0(\"multivalues\"),Overlap=transform$jscomp$0(\"overlap\"),Params=transform$jscomp$0(\"params\"),PreFacet=transform$jscomp$0(\"prefacet\"),Projection=transform$jscomp$0(\"projection\"),Proxy=transform$jscomp$0(\"proxy\"),Relay=transform$jscomp$0(\"relay\"),Render=transform$jscomp$0(\"render\"),Scale=transform$jscomp$0(\"scale\"),Sieve=transform$jscomp$0(\"sieve\"),SortItems=transform$jscomp$0(\"sortitems\"),ViewLayout=transform$jscomp$0(\"viewlayout\"),Values=transform$jscomp$0(\"values\"),FIELD_REF_ID=\n0,MULTIDOMAIN_SORT_OPS={min:\"min\",max:\"max\",count:\"sum\"},LegendScales=\"size shape fill stroke strokeWidth strokeDash opacity\".split(\" \"),Skip={name:1,style:1,interactive:1},zero$jscomp$0={value:0},one={value:1},alignExpr=anchorExpr(vegaUtil.stringValue(\"left\"),vegaUtil.stringValue(\"right\"),vegaUtil.stringValue(\"center\")),baseline=anchorExpr('\"top\"','\"bottom\"','\"middle\"'),exprAlign='datum.vgrad \\x26\\x26 item.orient \\x3d\\x3d\\x3d \"right\" ? ('+anchorExpr('\"right\"','\"left\"','\"center\"')+') : ((item.orient \\x3d\\x3d\\x3d \"left\" || item.orient \\x3d\\x3d\\x3d \"right\") \\x26\\x26 !(datum.vgrad \\x26\\x26 item.orient \\x3d\\x3d\\x3d \"left\")) ? \"left\" : '+\nalignExpr,exprBaseline='(item.orient \\x3d\\x3d\\x3d \"left\" || item.orient \\x3d\\x3d\\x3d \"right\") ? (datum.vgrad ? (item.orient \\x3d\\x3d\\x3d \"right\" ? \"bottom\" : \"top\") : '+baseline+') : \"top\"';DataScope.fromEntries=function(scope,entries){var n=entries.length,values=entries[n-1],output=entries[n-2],input=entries[0],aggr=null,i=1;input&&\"load\"===input.type&&(input=entries[1]);for(scope.add(entries[0]);i<n;++i)entries[i].params.pulse=ref$jscomp$0(entries[i-1]),scope.add(entries[i]),\"aggregate\"===entries[i].type&&\n(aggr=entries[i]);return new DataScope(scope,input,output,values,aggr)};DataScope.prototype={countsRef:function(scope,field,sort){var cache=this.counts||(this.counts={}),k=fieldKey(field);if(null!=k){scope=this.scope;var v=cache[k]}v?sort&&sort.field&&addSortField(scope,v.agg.params,sort):(v={groupby:scope.fieldRef(field,\"key\"),pulse:ref$jscomp$0(this.output)},sort&&sort.field&&addSortField(scope,v,sort),sort=scope.add(Aggregate(v)),v=scope.add(Collect({pulse:ref$jscomp$0(sort)})),v={agg:sort,ref:ref$jscomp$0(v)},\nnull!=k&&(cache[k]=v));return v.ref},tuplesRef:function(){return ref$jscomp$0(this.values)},extentRef:function(scope,field){return cache$jscomp$0(scope,this,\"extent\",\"extent\",field,!1)},domainRef:function(scope,field){return cache$jscomp$0(scope,this,\"domain\",\"values\",field,!1)},valuesRef:function(scope,field,sort){return cache$jscomp$0(scope,this,\"vals\",\"values\",field,sort||!0)},lookupRef:function(scope,field){return cache$jscomp$0(scope,this,\"lookup\",\"tupleindex\",field,!1)},indataRef:function(scope,\nfield){return cache$jscomp$0(scope,this,\"indata\",\"tupleindex\",field,!0,!0)}};var getSign=function(orient,a,b){isSignal(orient)?(orient=orient.signal,a=ifExpr(orient+\" \\x3d\\x3d\\x3d 'left' || \"+orient+\" \\x3d\\x3d\\x3d 'top'\",a,b)):a=\"left\"===orient||\"top\"===orient?a:b;return a},ifX=function(orient,a,b){isSignal(orient)?(orient=orient.signal,a=ifEnc(orient+\" \\x3d\\x3d\\x3d 'top' || \"+orient+\" \\x3d\\x3d\\x3d 'bottom'\",a,b)):a=\"bottom\"===orient||\"top\"===orient?a:b;return a},ifY=function(orient,a,b){isSignal(orient)?\n(orient=orient.signal,a=ifEnc(orient+\" !\\x3d\\x3d 'top' \\x26\\x26 \"+orient+\" !\\x3d\\x3d 'bottom'\",a,b)):a=\"bottom\"===orient||\"top\"===orient?b:a;return a},ifTop=function(orient,a,b){return isSignal(orient)?ifExpr(orient.signal+\" \\x3d\\x3d\\x3d 'top'\",a,b):\"top\"===orient?{value:a}:{value:b}},ifEnc=function(test,a,b){a=null!=a?encoder(a):a;b=null!=b?encoder(b):b;if(null!=a&&1!==Object.keys(a).length||null!=b&&1!==Object.keys(b).length)return[vegaUtil.extend({test:test},a)].concat(b||[]);a=a?a.signal||vegaUtil.stringValue(a.value):\nnull;b=b?b.signal||vegaUtil.stringValue(b.value):null;return{signal:test+\" ? (\"+a+\") : (\"+b+\")\"}},ifExpr=function(test,a,b){return{signal:test+\" ? (\"+toExpr(a)+\") : (\"+toExpr(b)+\")\"}},toExpr=function(v){return isSignal(v)?v.signal:null==v?null:vegaUtil.stringValue(v)},patch=function(value,base){var s=value.signal;return s&&s.endsWith(\"(null)\")?{signal:s.slice(0,-6)+base.signal}:value};Scope$1.prototype=Subscope.prototype={parse:function(spec){return parseScope(spec,this)},fork:function(){return new Subscope(this)},\nisSubscope:function(){return 0<this._subid},toRuntime:function(){this.finish();return{description:this.description,operators:this.operators,streams:this.streams,updates:this.updates,bindings:this.bindings,eventConfig:this.eventConfig,locale:this.locale}},id:function(){return(this._subid?this._subid+\":\":0)+this._id++},add:function(op){this.operators.push(op);op.id=this.id();op.refs&&(op.refs.forEach(function(ref){ref.$ref=op.id}),op.refs=null);return op},proxy:function(op){op=op instanceof Entry?ref$jscomp$0(op):\nop;return this.add(Proxy({value:op}))},addStream:function(stream){this.streams.push(stream);stream.id=this.id();return stream},addUpdate:function(update){this.updates.push(update);return update},finish:function(){function annotate(op,name,type){op&&(op=op.data||(op.data={}),name=op[name]||(op[name]=[]),name.push(type))}var name$jscomp$0;this.root&&(this.root.root=!0);for(name$jscomp$0 in this.signals)this.signals[name$jscomp$0].signal=name$jscomp$0;for(name$jscomp$0 in this.scales)this.scales[name$jscomp$0].scale=\nname$jscomp$0;for(name$jscomp$0 in this.data){var ds=this.data[name$jscomp$0];annotate(ds.input,name$jscomp$0,\"input\");annotate(ds.output,name$jscomp$0,\"output\");annotate(ds.values,name$jscomp$0,\"values\");for(var field$395 in ds.index)annotate(ds.index[field$395],name$jscomp$0,\"index:\"+field$395)}return this},pushState:function(encode,parent,lookup){this._encode.push(ref$jscomp$0(this.add(Sieve({pulse:encode}))));this._parent.push(parent);this._lookup.push(lookup?ref$jscomp$0(this.proxy(lookup)):\nnull);this._markpath.push(-1)},popState:function(){this._encode.pop();this._parent.pop();this._lookup.pop();this._markpath.pop()},parent:function(){return vegaUtil.peek(this._parent)},encode:function(){return vegaUtil.peek(this._encode)},lookup:function(){return vegaUtil.peek(this._lookup)},markpath:function(){var p=this._markpath;return++p[p.length-1]},fieldRef:function(field,name){if(vegaUtil.isString(field))return fieldRef(field,name);field.signal||vegaUtil.error(\"Unsupported field reference: \"+\nvegaUtil.stringValue(field));field=field.signal;var f=this.field[field];f||(f={name:this.signalRef(field)},name&&(f.as=name),this.field[field]=f=ref$jscomp$0(this.add(Field(f))));return f},compareRef:function(cmp){var $jscomp$this=this,signal=!1,check=function(_){return isSignal(_)?(signal=!0,$jscomp$this.signalRef(_.signal)):_&&_.expr?(signal=!0,$jscomp$this.exprRef(_.expr)):_},fields=vegaUtil.array(cmp.field).map(check);cmp=vegaUtil.array(cmp.order).map(check);return signal?ref$jscomp$0(this.add(Compare({fields:fields,\norders:cmp}))):{$compare:fields,$order:cmp}},keyRef:function(fields,flat){var signal=!1,sig=this.signals;fields=vegaUtil.array(fields).map(function(_){return isSignal(_)?(signal=!0,ref$jscomp$0(sig[_.signal])):_});return signal?ref$jscomp$0(this.add(Key({fields:fields,flat:flat}))):keyRef(fields,flat)},sortRef:function(sort){if(!sort)return sort;var a=aggrField(sort.op,sort.field);sort=sort.order||\"ascending\";return sort.signal?ref$jscomp$0(this.add(Compare({fields:a,orders:this.signalRef(sort.signal)}))):\n{$compare:a,$order:sort}},event:function(source,type){var key=source+\":\"+type;if(!this.events[key]){var id=this.id();this.streams.push({id:id,source:source,type:type});this.events[key]=id}return this.events[key]},hasOwnSignal:function(name){return vegaUtil.hasOwnProperty(this.signals,name)},addSignal:function(name,value){this.hasOwnSignal(name)&&vegaUtil.error(\"Duplicate signal name: \"+vegaUtil.stringValue(name));value=value instanceof Entry?value:this.add(new Entry(\"operator\",value,void 0,void 0));\nreturn this.signals[name]=value},getSignal:function(name){this.signals[name]||vegaUtil.error(\"Unrecognized signal name: \"+vegaUtil.stringValue(name));return this.signals[name]},signalRef:function(s){if(this.signals[s])return ref$jscomp$0(this.signals[s]);vegaUtil.hasOwnProperty(this.lambdas,s)||(this.lambdas[s]=this.add(new Entry(\"operator\",null,void 0,void 0)));return ref$jscomp$0(this.lambdas[s])},parseLambdas:function(){for(var code=Object.keys(this.lambdas),i=0,n=code.length;i<n;++i){var s=code[i],\ne=vegaFunctions.parseExpression(s,this);s=this.lambdas[s];s.params=e.$params;s.update=e.$expr}},property:function(spec){return spec&&spec.signal?this.signalRef(spec.signal):spec},objectProperty:function(spec){return spec&&vegaUtil.isObject(spec)?this.signalRef(spec.signal||propertyLambda(spec)):spec},exprRef:function(code,name){code={expr:vegaFunctions.parseExpression(code,this)};name&&(code.expr.$name=name);return ref$jscomp$0(this.add(Expression(code)))},addBinding:function(name,bind){this.bindings||\nvegaUtil.error(\"Nested signals do not support binding: \"+vegaUtil.stringValue(name));this.bindings.push(vegaUtil.extend({signal:name},bind))},addScaleProj:function(name,transform){vegaUtil.hasOwnProperty(this.scales,name)&&vegaUtil.error(\"Duplicate scale or projection name: \"+vegaUtil.stringValue(name));this.scales[name]=this.add(transform)},addScale:function(name,params){this.addScaleProj(name,Scale(params))},addProjection:function(name,params){this.addScaleProj(name,Projection(params))},getScale:function(name){this.scales[name]||\nvegaUtil.error(\"Unrecognized scale name: \"+vegaUtil.stringValue(name));return this.scales[name]},scaleRef:function(name){return ref$jscomp$0(this.getScale(name))},scaleType:function(name){return this.getScale(name).params.type},projectionRef:function(name){return this.scaleRef(name)},projectionType:function(name){return this.scaleType(name)},addData:function(name,dataScope){vegaUtil.hasOwnProperty(this.data,name)&&vegaUtil.error(\"Duplicate data set name: \"+vegaUtil.stringValue(name));return this.data[name]=\ndataScope},getData:function(name){this.data[name]||vegaUtil.error(\"Undefined data set name: \"+vegaUtil.stringValue(name));return this.data[name]},addDataPipeline:function(name,entries){vegaUtil.hasOwnProperty(this.data,name)&&vegaUtil.error(\"Duplicate data set name: \"+vegaUtil.stringValue(name));return this.addData(name,DataScope.fromEntries(this,entries))}};exports.AxisDomainRole=\"axis-domain\";exports.AxisGridRole=\"axis-grid\";exports.AxisLabelRole=\"axis-label\";exports.AxisRole=\"axis\";exports.AxisTickRole=\n\"axis-tick\";exports.AxisTitleRole=\"axis-title\";exports.DataScope=DataScope;exports.FrameRole=\"frame\";exports.LegendEntryRole=\"legend-entry\";exports.LegendLabelRole=\"legend-label\";exports.LegendRole=\"legend\";exports.LegendSymbolRole=\"legend-symbol\";exports.LegendTitleRole=\"legend-title\";exports.MarkRole=\"mark\";exports.Scope=Scope$1;exports.ScopeRole=\"scope\";exports.config=defaults;exports.parse=function(spec,config,options){vegaUtil.isObject(spec)||vegaUtil.error(\"Input Vega specification must be an object.\");\nconfig=vegaUtil.mergeConfig(defaults(),config,spec.config);return parseView(spec,new Scope$1(config,options)).toRuntime()};exports.signal=parseSignal;exports.signalUpdates=parseSignalUpdates;exports.stream=parseStream;Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_parser$build$vega_parser\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-functions'), require('vega-event-selector'), require('vega-scale'), require('vega-dataflow')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-functions', 'vega-event-selector', 'vega-scale', 'vega-dataflow'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega, global.vega, global.vega, global.vega));\n}(this, (function (exports, vegaUtil, vegaFunctions, vegaEventSelector, vegaScale, vegaDataflow) { 'use strict';\n\n  function parseAutosize(spec) {\n    return vegaUtil.isObject(spec) ? spec : {type: spec || 'pad'};\n  }\n\n  const number = _ => +_ || 0;\n\n  const paddingObject = _ => ({top: _, bottom: _, left: _, right: _});\n\n  function parsePadding(spec) {\n    return !vegaUtil.isObject(spec) ? paddingObject(number(spec))\n      : spec.signal ? spec\n      : {\n          top:    number(spec.top),\n          bottom: number(spec.bottom),\n          left:   number(spec.left),\n          right:  number(spec.right)\n        };\n  }\n\n  const encoder = _ => vegaUtil.isObject(_) && !vegaUtil.isArray(_)\n    ? vegaUtil.extend({}, _)\n    : {value: _};\n\n  function addEncode(object, name, value, set) {\n    if (value != null) {\n      const isEncoder = (\n        (vegaUtil.isObject(value) && !vegaUtil.isArray(value)) ||\n        (vegaUtil.isArray(value) && value.length && vegaUtil.isObject(value[0]))\n      );\n\n      // Always assign signal to update, even if the signal is from the enter block\n      if (isEncoder) {\n        object.update[name] = value;\n      } else {\n        object[set || 'enter'][name] = {value: value};\n      }\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n  function addEncoders(object, enter, update) {\n    for (const name in enter) {\n      addEncode(object, name, enter[name]);\n    }\n    for (const name in update) {\n      addEncode(object, name, update[name], 'update');\n    }\n  }\n\n  function extendEncode(encode, extra, skip) {\n    for (const name in extra) {\n      if (skip && vegaUtil.hasOwnProperty(skip, name)) continue;\n      encode[name] = vegaUtil.extend(encode[name] || {}, extra[name]);\n    }\n    return encode;\n  }\n\n  function has(key, encode) {\n    return encode && (\n      (encode.enter && encode.enter[key]) ||\n      (encode.update && encode.update[key])\n    );\n  }\n\n  const MarkRole = 'mark';\n  const FrameRole = 'frame';\n  const ScopeRole = 'scope';\n\n  const AxisRole = 'axis';\n  const AxisDomainRole = 'axis-domain';\n  const AxisGridRole = 'axis-grid';\n  const AxisLabelRole = 'axis-label';\n  const AxisTickRole = 'axis-tick';\n  const AxisTitleRole = 'axis-title';\n\n  const LegendRole = 'legend';\n  const LegendBandRole = 'legend-band';\n  const LegendEntryRole = 'legend-entry';\n  const LegendGradientRole = 'legend-gradient';\n  const LegendLabelRole = 'legend-label';\n  const LegendSymbolRole = 'legend-symbol';\n  const LegendTitleRole = 'legend-title';\n\n  const TitleRole = 'title';\n  const TitleTextRole = 'title-text';\n  const TitleSubtitleRole = 'title-subtitle';\n\n  function applyDefaults(encode, type, role, style, config) {\n    const defaults = {}, enter = {};\n    let update, key, skip, props;\n\n    // if text mark, apply global lineBreak settings (#2370)\n    key = 'lineBreak';\n    if (type === 'text' && config[key] != null && !has(key, encode)) {\n      applyDefault(defaults, key, config[key]);\n    }\n\n    // ignore legend and axis roles\n    if (role == 'legend' || String(role).startsWith('axis')) {\n      role = null;\n    }\n\n    // resolve mark config\n    props = role === FrameRole ? config.group\n      : (role === MarkRole) ? vegaUtil.extend({}, config.mark, config[type])\n      : null;\n\n    for (key in props) {\n      // do not apply defaults if relevant fields are defined\n      skip = has(key, encode)\n        || (key === 'fill' || key === 'stroke')\n        && (has('fill', encode) || has('stroke', encode));\n\n      if (!skip) applyDefault(defaults, key, props[key]);\n    }\n\n    // resolve styles, apply with increasing precedence\n    vegaUtil.array(style).forEach(name => {\n      const props = config.style && config.style[name];\n      for (const key in props) {\n        if (!has(key, encode)) {\n          applyDefault(defaults, key, props[key]);\n        }\n      }\n    });\n\n    encode = vegaUtil.extend({}, encode); // defensive copy\n    for (key in defaults) {\n      props = defaults[key];\n      if (props.signal) {\n        (update = update || {})[key] = props;\n      } else {\n        enter[key] = props;\n      }\n    }\n\n    encode.enter = vegaUtil.extend(enter, encode.enter);\n    if (update) encode.update = vegaUtil.extend(update, encode.update);\n\n    return encode;\n  }\n\n  function applyDefault(defaults, key, value) {\n    defaults[key] = value && value.signal\n      ? {signal: value.signal}\n      : {value: value};\n  }\n\n  const scaleRef = scale => vegaUtil.isString(scale) ? vegaUtil.stringValue(scale)\n    : scale.signal ? `(${scale.signal})`\n    : field(scale);\n\n  function entry(enc) {\n    if (enc.gradient != null) {\n      return gradient(enc);\n    }\n\n    let value = enc.signal ? `(${enc.signal})`\n      : enc.color ? color(enc.color)\n      : enc.field != null ? field(enc.field)\n      : enc.value !== undefined ? vegaUtil.stringValue(enc.value)\n      : undefined;\n\n    if (enc.scale != null) {\n      value = scale(enc, value);\n    }\n\n    if (value === undefined) {\n      value = null;\n    }\n\n    if (enc.exponent != null) {\n      value = `pow(${value},${property(enc.exponent)})`;\n    }\n\n    if (enc.mult != null) {\n      value += `*${property(enc.mult)}`;\n    }\n\n    if (enc.offset != null) {\n      value += `+${property(enc.offset)}`;\n    }\n\n    if (enc.round) {\n      value = `round(${value})`;\n    }\n\n    return value;\n  }\n\n  const _color = (type, x, y, z) =>\n    `(${type}(${[x, y, z].map(entry).join(',')})+'')`;\n\n  function color(enc) {\n    return (enc.c) ? _color('hcl', enc.h, enc.c, enc.l)\n      : (enc.h || enc.s) ? _color('hsl', enc.h, enc.s, enc.l)\n      : (enc.l || enc.a) ? _color('lab', enc.l, enc.a, enc.b)\n      : (enc.r || enc.g || enc.b) ? _color('rgb', enc.r, enc.g, enc.b)\n      : null;\n  }\n\n  function gradient(enc) {\n    // map undefined to null; expression lang does not allow undefined\n    const args = [enc.start, enc.stop, enc.count]\n      .map(_ => _ == null ? null : vegaUtil.stringValue(_));\n\n    // trim null inputs from the end\n    while (args.length && vegaUtil.peek(args) == null) args.pop();\n\n    args.unshift(scaleRef(enc.gradient));\n    return `gradient(${args.join(',')})`;\n  }\n\n  function property(property) {\n    return vegaUtil.isObject(property) ? '(' + entry(property) + ')' : property;\n  }\n\n  function field(ref) {\n    return resolveField(vegaUtil.isObject(ref) ? ref : {datum: ref});\n  }\n\n  function resolveField(ref) {\n    let object, level, field;\n\n    if (ref.signal) {\n      object = 'datum';\n      field = ref.signal;\n    } else if (ref.group || ref.parent) {\n      level = Math.max(1, ref.level || 1);\n      object = 'item';\n\n      while (level-- > 0) {\n        object += '.mark.group';\n      }\n\n      if (ref.parent) {\n        field = ref.parent;\n        object += '.datum';\n      } else {\n        field = ref.group;\n      }\n    } else if (ref.datum) {\n      object = 'datum';\n      field = ref.datum;\n    } else {\n      vegaUtil.error('Invalid field reference: ' + vegaUtil.stringValue(ref));\n    }\n\n    if (!ref.signal) {\n      field = vegaUtil.isString(field)\n        ? vegaUtil.splitAccessPath(field).map(vegaUtil.stringValue).join('][')\n        : resolveField(field);\n    }\n\n    return object + '[' + field + ']';\n  }\n\n  function scale(enc, value) {\n    const scale = scaleRef(enc.scale);\n\n    if (enc.range != null) {\n      // pull value from scale range\n      value = `lerp(_range(${scale}), ${+enc.range})`;\n    } else {\n      // run value through scale and/or pull scale bandwidth\n      if (value !== undefined) value = `_scale(${scale}, ${value})`;\n\n      if (enc.band) {\n        value = (value ? value + '+' : '')\n          + `_bandwidth(${scale})`\n          + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n        if (enc.extra) {\n          // include logic to handle extraneous elements\n          value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n        }\n      }\n\n      if (value == null) value = '0';\n    }\n\n    return value;\n  }\n\n  function rule(enc) {\n    let code = '';\n\n    enc.forEach(rule => {\n      const value = entry(rule);\n      code += rule.test ? `(${rule.test})?${value}:` : value;\n    });\n\n    // if no else clause, terminate with null (#1366)\n    if (vegaUtil.peek(code) === ':') {\n      code += 'null';\n    }\n\n    return code;\n  }\n\n  function parseEncode(encode, type, role, style, scope, params) {\n    const enc = {};\n    params = params || {};\n    params.encoders = {$encode: enc};\n\n    encode = applyDefaults(encode, type, role, style, scope.config);\n    for (const key in encode) {\n      enc[key] = parseBlock(encode[key], type, params, scope);\n    }\n\n    return params;\n  }\n\n  function parseBlock(block, marktype, params, scope) {\n    const channels = {},\n          fields = {};\n\n    for (const name in block) {\n      if (block[name] != null) { // skip any null entries\n        channels[name] = parse(expr(block[name]), scope, params, fields);\n      }\n    }\n\n    return {\n      $expr:   {marktype, channels},\n      $fields: Object.keys(fields),\n      $output: Object.keys(block)\n    };\n  }\n\n  function expr(enc) {\n    return vegaUtil.isArray(enc) ? rule(enc) : entry(enc);\n  }\n\n  function parse(code, scope, params, fields) {\n    const expr = vegaFunctions.parseExpression(code, scope);\n    expr.$fields.forEach(name => fields[name] = 1);\n    vegaUtil.extend(params, expr.$params);\n    return expr.$expr;\n  }\n\n  const OUTER = 'outer',\n        OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\n  function outerError(prefix, name) {\n    vegaUtil.error(prefix + ' for \"outer\" push: ' + vegaUtil.stringValue(name));\n  }\n\n  function parseSignal(signal, scope) {\n    const name = signal.name;\n\n    if (signal.push === OUTER) {\n      // signal must already be defined, raise error if not\n      if (!scope.signals[name]) outerError('No prior signal definition', name);\n      // signal push must not use properties reserved for standard definition\n      OUTER_INVALID.forEach(prop => {\n        if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n      });\n    } else {\n      // define a new signal in the current scope\n      const op = scope.addSignal(name, signal.value);\n      if (signal.react === false) op.react = false;\n      if (signal.bind) scope.addBinding(name, signal.bind);\n    }\n  }\n\n  function Entry(type, value, params, parent) {\n    this.id = -1;\n    this.type = type;\n    this.value = value;\n    this.params = params;\n    if (parent) this.parent = parent;\n  }\n\n  function entry$1(type, value, params, parent) {\n    return new Entry(type, value, params, parent);\n  }\n\n  function operator(value, params) {\n    return entry$1('operator', value, params);\n  }\n\n  // -----\n\n  function ref(op) {\n    const ref = {$ref: op.id};\n    // if operator not yet registered, cache ref to resolve later\n    if (op.id < 0) (op.refs = op.refs || []).push(ref);\n    return ref;\n  }\n\n  function fieldRef(field, name) {\n    return name ? {$field: field, $name: name} : {$field: field};\n  }\n\n  const keyFieldRef = fieldRef('key');\n\n  function compareRef(fields, orders) {\n    return {$compare: fields, $order: orders};\n  }\n\n  function keyRef(fields, flat) {\n    const ref = {$key: fields};\n    if (flat) ref.$flat = true;\n    return ref;\n  }\n\n  // -----\n\n  const Ascending  = 'ascending';\n\n  const Descending = 'descending';\n\n  function sortKey(sort) {\n    return !vegaUtil.isObject(sort) ? ''\n      : (sort.order === Descending ? '-' : '+')\n        + aggrField(sort.op, sort.field);\n  }\n\n  function aggrField(op, field) {\n    return (op && op.signal ? '$' + op.signal : op || '')\n      + (op && field ? '_' : '')\n      + (field && field.signal ? '$' + field.signal : field || '');\n  }\n\n  // -----\n\n  const Scope = 'scope';\n\n  const View = 'view';\n\n  function isSignal(_) {\n    return _ && _.signal;\n  }\n\n  function isExpr(_) {\n    return _ && _.expr;\n  }\n\n  function hasSignal(_) {\n    if (isSignal(_)) return true;\n    if (vegaUtil.isObject(_)) for (const key in _) {\n      if (hasSignal(_[key])) return true;\n    }\n    return false;\n  }\n\n  function value(specValue, defaultValue) {\n    return specValue != null ? specValue : defaultValue;\n  }\n\n  function deref(v) {\n    return v && v.signal || v;\n  }\n\n  const Timer = 'timer';\n\n  function parseStream(stream, scope) {\n    const method = stream.merge ? mergeStream\n      : stream.stream ? nestedStream\n      : stream.type ? eventStream\n      : vegaUtil.error('Invalid stream specification: ' + vegaUtil.stringValue(stream));\n\n    return method(stream, scope);\n  }\n\n  function eventSource(source) {\n     return source === Scope ? View : (source || View);\n  }\n\n  function mergeStream(stream, scope) {\n    const list = stream.merge.map(s => parseStream(s, scope)),\n          entry = streamParameters({merge: list}, stream, scope);\n    return scope.addStream(entry).id;\n  }\n\n  function nestedStream(stream, scope) {\n    const id = parseStream(stream.stream, scope),\n          entry = streamParameters({stream: id}, stream, scope);\n    return scope.addStream(entry).id;\n  }\n\n  function eventStream(stream, scope) {\n    let id;\n    if (stream.type === Timer) {\n      id = scope.event(Timer, stream.throttle);\n      stream = {between: stream.between, filter: stream.filter};\n    } else {\n      id = scope.event(eventSource(stream.source), stream.type);\n    }\n\n    const entry = streamParameters({stream: id}, stream, scope);\n    return Object.keys(entry).length === 1\n      ? id\n      : scope.addStream(entry).id;\n  }\n\n  function streamParameters(entry, stream, scope) {\n    let param = stream.between;\n\n    if (param) {\n      if (param.length !== 2) {\n        vegaUtil.error('Stream \"between\" parameter must have 2 entries: ' + vegaUtil.stringValue(stream));\n      }\n      entry.between = [\n        parseStream(param[0], scope),\n        parseStream(param[1], scope)\n      ];\n    }\n\n    param = stream.filter ? [].concat(stream.filter) : [];\n    if (stream.marktype || stream.markname || stream.markrole) {\n      // add filter for mark type, name and/or role\n      param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n    }\n    if (stream.source === Scope) {\n      // add filter to limit events from sub-scope only\n      param.push('inScope(event.item)');\n    }\n    if (param.length) {\n      entry.filter = vegaFunctions.parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n    }\n\n    if ((param = stream.throttle) != null) {\n      entry.throttle = +param;\n    }\n\n    if ((param = stream.debounce) != null) {\n      entry.debounce = +param;\n    }\n\n    if (stream.consume) {\n      entry.consume = true;\n    }\n\n    return entry;\n  }\n\n  function filterMark(type, name, role) {\n    const item = 'event.item';\n    return item\n      + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '')\n      + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '')\n      + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n  }\n\n  // bypass expression parser for internal operator references\n  const OP_VALUE_EXPR = {\n    code: '_.$value',\n    ast: {type: 'Identifier', value: 'value'}\n  };\n\n  function parseUpdate(spec, scope, target) {\n    const encode = spec.encode,\n          entry = {target: target};\n\n    let events = spec.events,\n        update = spec.update,\n        sources = [];\n\n    if (!events) {\n      vegaUtil.error('Signal update missing events specification.');\n    }\n\n    // interpret as an event selector string\n    if (vegaUtil.isString(events)) {\n      events = vegaEventSelector.selector(events, scope.isSubscope() ? Scope : View);\n    }\n\n    // separate event streams from signal updates\n    events = vegaUtil.array(events)\n      .filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1);\n\n    // merge internal operator listeners\n    if (sources.length > 1) {\n      sources = [mergeSources(sources)];\n    }\n\n    // merge event streams, include as source\n    if (events.length) {\n      sources.push(events.length > 1 ? {merge: events} : events[0]);\n    }\n\n    if (encode != null) {\n      if (update) vegaUtil.error('Signal encode and update are mutually exclusive.');\n      update = 'encode(item(),' + vegaUtil.stringValue(encode) + ')';\n    }\n\n    // resolve update value\n    entry.update = vegaUtil.isString(update) ? vegaFunctions.parseExpression(update, scope)\n      : update.expr != null ? vegaFunctions.parseExpression(update.expr, scope)\n      : update.value != null ? update.value\n      : update.signal != null ? {\n          $expr:   OP_VALUE_EXPR,\n          $params: {$value: scope.signalRef(update.signal)}\n        }\n      : vegaUtil.error('Invalid signal update specification.');\n\n    if (spec.force) {\n      entry.options = {force: true};\n    }\n\n    sources.forEach(source =>\n      scope.addUpdate(vegaUtil.extend(streamSource(source, scope), entry))\n    );\n  }\n\n  function streamSource(stream, scope) {\n    return {\n      source: stream.signal ? scope.signalRef(stream.signal)\n            : stream.scale ? scope.scaleRef(stream.scale)\n            : parseStream(stream, scope)\n    };\n  }\n\n  function mergeSources(sources) {\n    return {\n      signal: '['\n        + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal)\n        + ']'\n    };\n  }\n\n  function parseSignalUpdates(signal, scope) {\n    const op = scope.getSignal(signal.name);\n    let expr = signal.update;\n\n    if (signal.init) {\n      if (expr) {\n        vegaUtil.error('Signals can not include both init and update expressions.');\n      } else {\n        expr = signal.init;\n        op.initonly = true;\n      }\n    }\n\n    if (expr) {\n      expr = vegaFunctions.parseExpression(expr, scope);\n      op.update = expr.$expr;\n      op.params = expr.$params;\n    }\n\n    if (signal.on) {\n      signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n    }\n  }\n\n  const transform = name => (params, value, parent) =>\n    entry$1(name, value, params || undefined, parent);\n\n  const Aggregate = transform('aggregate');\n  const AxisTicks = transform('axisticks');\n  const Bound = transform('bound');\n  const Collect = transform('collect');\n  const Compare = transform('compare');\n  const DataJoin = transform('datajoin');\n  const Encode = transform('encode');\n  const Expression = transform('expression');\n  const Facet = transform('facet');\n  const Field = transform('field');\n  const Key = transform('key');\n  const LegendEntries = transform('legendentries');\n  const Load = transform('load');\n  const Mark = transform('mark');\n  const MultiExtent = transform('multiextent');\n  const MultiValues = transform('multivalues');\n  const Overlap = transform('overlap');\n  const Params = transform('params');\n  const PreFacet = transform('prefacet');\n  const Projection = transform('projection');\n  const Proxy = transform('proxy');\n  const Relay = transform('relay');\n  const Render = transform('render');\n  const Scale = transform('scale');\n  const Sieve = transform('sieve');\n  const SortItems = transform('sortitems');\n  const ViewLayout = transform('viewlayout');\n  const Values = transform('values');\n\n  let FIELD_REF_ID = 0;\n\n  const MULTIDOMAIN_SORT_OPS  = {min: 'min', max: 'max', count: 'sum'};\n\n  function initScale(spec, scope) {\n    const type = spec.type || 'linear';\n\n    if (!vegaScale.isValidScaleType(type)) {\n      vegaUtil.error('Unrecognized scale type: ' + vegaUtil.stringValue(type));\n    }\n\n    scope.addScale(spec.name, {\n      type,\n      domain: undefined\n    });\n  }\n\n  function parseScale(spec, scope) {\n    const params = scope.getScale(spec.name).params;\n    let key;\n\n    params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n    if (spec.range != null) {\n      params.range = parseScaleRange(spec, scope, params);\n    }\n\n    if (spec.interpolate != null) {\n      parseScaleInterpolate(spec.interpolate, params);\n    }\n\n    if (spec.nice != null) {\n      params.nice = parseScaleNice(spec.nice);\n    }\n\n    if (spec.bins != null) {\n      params.bins = parseScaleBins(spec.bins, scope);\n    }\n\n    for (key in spec) {\n      if (vegaUtil.hasOwnProperty(params, key) || key === 'name') continue;\n      params[key] = parseLiteral(spec[key], scope);\n    }\n  }\n\n  function parseLiteral(v, scope) {\n    return !vegaUtil.isObject(v) ? v\n      : v.signal ? scope.signalRef(v.signal)\n      : vegaUtil.error('Unsupported object: ' + vegaUtil.stringValue(v));\n  }\n\n  function parseArray(v, scope) {\n    return v.signal\n      ? scope.signalRef(v.signal)\n      : v.map(v => parseLiteral(v, scope));\n  }\n\n  function dataLookupError(name) {\n    vegaUtil.error('Can not find data set: ' + vegaUtil.stringValue(name));\n  }\n\n  // -- SCALE DOMAIN ----\n\n  function parseScaleDomain(domain, spec, scope) {\n    if (!domain) {\n      if (spec.domainMin != null || spec.domainMax != null) {\n        vegaUtil.error('No scale domain defined for domainMin/domainMax to override.');\n      }\n      return; // default domain\n    }\n\n    return domain.signal ? scope.signalRef(domain.signal)\n      : (vegaUtil.isArray(domain) ? explicitDomain\n      : domain.fields ? multipleDomain\n      : singularDomain)(domain, spec, scope);\n  }\n\n  function explicitDomain(domain, spec, scope) {\n    return domain.map(v => parseLiteral(v, scope));\n  }\n\n  function singularDomain(domain, spec, scope) {\n    const data = scope.getData(domain.data);\n    if (!data) dataLookupError(domain.data);\n\n    return vegaScale.isDiscrete(spec.type)\n        ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false))\n        : vegaScale.isQuantile(spec.type) ? data.domainRef(scope, domain.field)\n        : data.extentRef(scope, domain.field);\n  }\n\n  function multipleDomain(domain, spec, scope) {\n    const data = domain.data,\n          fields = domain.fields.reduce((dom, d) => {\n            d = vegaUtil.isString(d) ? {data: data, field: d}\n              : (vegaUtil.isArray(d) || d.signal) ? fieldRef$1(d, scope)\n              : d;\n            dom.push(d);\n            return dom;\n          }, []);\n\n    return (vegaScale.isDiscrete(spec.type) ? ordinalMultipleDomain\n      : vegaScale.isQuantile(spec.type) ? quantileMultipleDomain\n      : numericMultipleDomain)(domain, scope, fields);\n  }\n\n  function fieldRef$1(data, scope) {\n    const name = '_:vega:_' + (FIELD_REF_ID++),\n          coll = Collect({});\n\n    if (vegaUtil.isArray(data)) {\n      coll.value = {$ingest: data};\n    } else if (data.signal) {\n      const code = 'setdata(' + vegaUtil.stringValue(name) + ',' + data.signal + ')';\n      coll.params.input = scope.signalRef(code);\n    }\n    scope.addDataPipeline(name, [coll, Sieve({})]);\n    return {data: name, field: 'data'};\n  }\n\n  function ordinalMultipleDomain(domain, scope, fields) {\n    const sort = parseSort(domain.sort, true);\n    let a, v;\n\n    // get value counts for each domain field\n    const counts = fields.map(f => {\n      const data = scope.getData(f.data);\n      if (!data) dataLookupError(f.data);\n      return data.countsRef(scope, f.field, sort);\n    });\n\n    // aggregate the results from each domain field\n    const p = {groupby: keyFieldRef, pulse: counts};\n    if (sort) {\n      a = sort.op || 'count';\n      v = sort.field ? aggrField(a, sort.field) : 'count';\n      p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n      p.fields = [scope.fieldRef(v)];\n      p.as = [v];\n    }\n    a = scope.add(Aggregate(p));\n\n    // collect aggregate output\n    const c = scope.add(Collect({pulse: ref(a)}));\n\n    // extract values for combined domain\n    v = scope.add(Values({\n      field: keyFieldRef,\n      sort:  scope.sortRef(sort),\n      pulse: ref(c)\n    }));\n\n    return ref(v);\n  }\n\n  function parseSort(sort, multidomain) {\n    if (sort) {\n      if (!sort.field && !sort.op) {\n        if (vegaUtil.isObject(sort)) sort.field = 'key';\n        else sort = {field: 'key'};\n      } else if (!sort.field && sort.op !== 'count') {\n        vegaUtil.error('No field provided for sort aggregate op: ' + sort.op);\n      } else if (multidomain && sort.field) {\n        if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n          vegaUtil.error('Multiple domain scales can not be sorted using ' + sort.op);\n        }\n      }\n    }\n    return sort;\n  }\n\n  function quantileMultipleDomain(domain, scope, fields) {\n    // get value arrays for each domain field\n    const values = fields.map(f => {\n      const data = scope.getData(f.data);\n      if (!data) dataLookupError(f.data);\n      return data.domainRef(scope, f.field);\n    });\n\n    // combine value arrays\n    return ref(scope.add(MultiValues({values: values})));\n  }\n\n  function numericMultipleDomain(domain, scope, fields) {\n    // get extents for each domain field\n    const extents = fields.map(f => {\n      const data = scope.getData(f.data);\n      if (!data) dataLookupError(f.data);\n      return data.extentRef(scope, f.field);\n    });\n\n    // combine extents\n    return ref(scope.add(MultiExtent({extents: extents})));\n  }\n\n  // -- SCALE BINS -----\n\n  function parseScaleBins(v, scope) {\n    return v.signal || vegaUtil.isArray(v)\n      ? parseArray(v, scope)\n      : scope.objectProperty(v);\n  }\n\n  // -- SCALE NICE -----\n\n  function parseScaleNice(nice) {\n    return vegaUtil.isObject(nice)\n      ? {\n          interval: parseLiteral(nice.interval),\n          step: parseLiteral(nice.step)\n        }\n      : parseLiteral(nice);\n  }\n\n  // -- SCALE INTERPOLATION -----\n\n  function parseScaleInterpolate(interpolate, params) {\n    params.interpolate = parseLiteral(interpolate.type || interpolate);\n    if (interpolate.gamma != null) {\n      params.interpolateGamma = parseLiteral(interpolate.gamma);\n    }\n  }\n\n  // -- SCALE RANGE -----\n\n  function parseScaleRange(spec, scope, params) {\n    const config = scope.config.range;\n    let range = spec.range;\n\n    if (range.signal) {\n      return scope.signalRef(range.signal);\n    } else if (vegaUtil.isString(range)) {\n      if (config && vegaUtil.hasOwnProperty(config, range)) {\n        spec = vegaUtil.extend({}, spec, {range: config[range]});\n        return parseScaleRange(spec, scope, params);\n      } else if (range === 'width') {\n        range = [0, {signal: 'width'}];\n      } else if (range === 'height') {\n        range = vegaScale.isDiscrete(spec.type)\n          ? [0, {signal: 'height'}]\n          : [{signal: 'height'}, 0];\n      } else {\n        vegaUtil.error('Unrecognized scale range value: ' + vegaUtil.stringValue(range));\n      }\n    } else if (range.scheme) {\n      params.scheme = vegaUtil.isArray(range.scheme)\n        ? parseArray(range.scheme, scope)\n        : parseLiteral(range.scheme, scope);\n      if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n      if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n      return;\n    } else if (range.step) {\n      params.rangeStep = parseLiteral(range.step, scope);\n      return;\n    } else if (vegaScale.isDiscrete(spec.type) && !vegaUtil.isArray(range)) {\n      return parseScaleDomain(range, spec, scope);\n    } else if (!vegaUtil.isArray(range)) {\n      vegaUtil.error('Unsupported range type: ' + vegaUtil.stringValue(range));\n    }\n\n    return range.map(v => (vegaUtil.isArray(v) ? parseArray : parseLiteral)(v, scope));\n  }\n\n  function parseProjection(proj, scope) {\n    const config = scope.config.projection || {},\n          params = {};\n\n    for (const name in proj) {\n      if (name === 'name') continue;\n      params[name] = parseParameter(proj[name], name, scope);\n    }\n\n    // apply projection defaults from config\n    for (const name in config) {\n      if (params[name] == null) {\n        params[name] = parseParameter(config[name], name, scope);\n      }\n    }\n\n    scope.addProjection(proj.name, params);\n  }\n\n  function parseParameter(_, name, scope) {\n    return vegaUtil.isArray(_) ? _.map(_ => parseParameter(_, name, scope))\n      : !vegaUtil.isObject(_) ? _\n      : _.signal ? scope.signalRef(_.signal)\n      : name === 'fit' ? _\n      : vegaUtil.error('Unsupported parameter object: ' + vegaUtil.stringValue(_));\n  }\n\n  const Top = 'top';\n  const Left = 'left';\n  const Right = 'right';\n  const Bottom = 'bottom';\n  const Center = 'center';\n\n  const Vertical = 'vertical';\n\n  const Start = 'start';\n  const Middle = 'middle';\n  const End = 'end';\n\n  const Index  = 'index';\n  const Label  = 'label';\n  const Offset = 'offset';\n  const Perc   = 'perc';\n  const Perc2  = 'perc2';\n  const Value  = 'value';\n\n  const GuideLabelStyle = 'guide-label';\n  const GuideTitleStyle = 'guide-title';\n  const GroupTitleStyle = 'group-title';\n  const GroupSubtitleStyle = 'group-subtitle';\n\n  const Symbols = 'symbol';\n  const Gradient = 'gradient';\n  const Discrete = 'discrete';\n\n  const Size = 'size';\n  const Shape = 'shape';\n  const Fill = 'fill';\n  const Stroke = 'stroke';\n  const StrokeWidth = 'strokeWidth';\n  const StrokeDash = 'strokeDash';\n  const Opacity = 'opacity';\n\n  // Encoding channels supported by legends\n  // In priority order of 'canonical' scale\n  const LegendScales = [\n    Size,\n    Shape,\n    Fill,\n    Stroke,\n    StrokeWidth,\n    StrokeDash,\n    Opacity\n  ];\n\n  const Skip = {\n    name: 1,\n    style: 1,\n    interactive: 1\n  };\n\n  const zero = {value: 0};\n  const one = {value: 1};\n\n  const GroupMark = 'group';\n  const RectMark = 'rect';\n  const RuleMark = 'rule';\n  const SymbolMark = 'symbol';\n  const TextMark = 'text';\n\n  function guideGroup(mark) {\n    mark.type = GroupMark;\n    mark.interactive = mark.interactive || false;\n    return mark;\n  }\n\n  function lookup(spec, config) {\n    const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n    _.isVertical = s => Vertical === value(\n      spec.direction,\n      config.direction || (s ? config.symbolDirection : config.gradientDirection)\n    );\n\n    _.gradientLength = () => value(\n      spec.gradientLength,\n      config.gradientLength || config.gradientWidth\n    );\n\n    _.gradientThickness = () => value(\n      spec.gradientThickness,\n      config.gradientThickness || config.gradientHeight\n    );\n\n    _.entryColumns = () => value(\n      spec.columns,\n      value(config.columns, +_.isVertical(true))\n    );\n\n    return _;\n  }\n\n  function getEncoding(name, encode) {\n    const v = encode && (\n      (encode.update && encode.update[name]) ||\n      (encode.enter && encode.enter[name])\n    );\n    return v && v.signal ? v : v ? v.value : null;\n  }\n\n  function getStyle(name, scope, style) {\n    const s = scope.config.style[style];\n    return s && s[name];\n  }\n\n  function anchorExpr(s, e, m) {\n    return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n  }\n\n  const alignExpr = anchorExpr(\n    vegaUtil.stringValue(Left),\n    vegaUtil.stringValue(Right),\n    vegaUtil.stringValue(Center)\n  );\n\n  function tickBand(_) {\n    const v = _('tickBand');\n    let offset = _('tickOffset'),\n        band, extra;\n\n    if (!v) {\n      // if no tick band entry, fall back on other properties\n      band = _('bandPosition');\n      extra = _('tickExtra');\n    } else if (v.signal) {\n      // if signal, augment code to interpret values\n      band = {signal: `(${v.signal}) === 'extent' ? 1 : 0.5`};\n      extra = {signal: `(${v.signal}) === 'extent'`};\n      if (!vegaUtil.isObject(offset)) {\n        offset = {signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`};\n      }\n    } else if (v === 'extent') {\n      // if constant, simply set values\n      band = 1;\n      extra = true;\n      offset = 0;\n    } else {\n      band = 0.5;\n      extra = false;\n    }\n\n    return {extra, band, offset};\n  }\n\n  function extendOffset(value, offset) {\n    return !offset ? value\n      : !value ? offset\n      : !vegaUtil.isObject(value) ? { value, offset }\n      : Object.assign({}, value, { offset: extendOffset(value.offset, offset) });\n  }\n\n  function guideMark(mark, extras) {\n    if (extras) {\n      mark.name = extras.name;\n      mark.style = extras.style || mark.style;\n      mark.interactive = !!extras.interactive;\n      mark.encode = extendEncode(mark.encode, extras, Skip);\n    } else {\n      mark.interactive = false;\n    }\n    return mark;\n  }\n\n  function legendGradient(spec, scale, config, userEncode) {\n    const _ = lookup(spec, config),\n          vertical = _.isVertical(),\n          thickness = _.gradientThickness(),\n          length = _.gradientLength();\n\n    let enter, start, stop, width, height;\n\n    if (vertical) {\n      start = [0, 1];\n      stop = [0, 0];\n      width = thickness;\n      height = length;\n    } else {\n      start = [0, 0];\n      stop = [1, 0];\n      width = length;\n      height = thickness;\n    }\n\n    const encode = {\n      enter: enter = {\n        opacity: zero,\n        x: zero,\n        y: zero,\n        width: encoder(width),\n        height: encoder(height)\n      },\n      update: vegaUtil.extend({}, enter, {\n        opacity: one,\n        fill: {gradient: scale, start: start, stop: stop}\n      }),\n      exit: {\n        opacity: zero\n      }\n    };\n\n    addEncoders(encode, {\n      stroke:      _('gradientStrokeColor'),\n      strokeWidth: _('gradientStrokeWidth')\n    }, { // update\n      opacity:     _('gradientOpacity')\n    });\n\n    return guideMark({\n      type: RectMark,\n      role: LegendGradientRole,\n      encode\n    }, userEncode);\n  }\n\n  function legendGradientDiscrete(spec, scale, config, userEncode, dataRef) {\n    const _ = lookup(spec, config),\n          vertical = _.isVertical(),\n          thickness = _.gradientThickness(),\n          length = _.gradientLength();\n\n    let u, v, uu, vv, adjust = '';\n\n    vertical\n      ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-')\n      : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n\n    const enter = {\n      opacity: zero,\n      fill: {scale: scale, field: Value}\n    };\n    enter[u]  = {signal: adjust + 'datum.' + Perc, mult: length};\n    enter[v]  = zero;\n    enter[uu] = {signal: adjust + 'datum.' + Perc2, mult: length};\n    enter[vv] = encoder(thickness);\n\n    const encode = {\n      enter: enter,\n      update: vegaUtil.extend({}, enter, {opacity: one}),\n      exit: {opacity: zero}\n    };\n\n    addEncoders(encode, {\n      stroke:      _('gradientStrokeColor'),\n      strokeWidth: _('gradientStrokeWidth')\n    }, { // update\n      opacity:     _('gradientOpacity')\n    });\n\n    return guideMark({\n      type: RectMark,\n      role: LegendBandRole,\n      key:  Value,\n      from: dataRef,\n      encode\n    }, userEncode);\n  }\n\n  const alignExpr$1 = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n        baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\n\n  function legendGradientLabels(spec, config, userEncode, dataRef) {\n    const _ = lookup(spec, config),\n          vertical = _.isVertical(),\n          thickness = encoder(_.gradientThickness()),\n          length = _.gradientLength();\n\n    let overlap = _('labelOverlap'),\n        enter, update, u, v, adjust = '';\n\n    const encode = {\n      enter: enter = {\n        opacity: zero\n      },\n      update: update = {\n        opacity: one,\n        text: {field: Label}\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n\n    addEncoders(encode, {\n      fill:        _('labelColor'),\n      fillOpacity: _('labelOpacity'),\n      font:        _('labelFont'),\n      fontSize:    _('labelFontSize'),\n      fontStyle:   _('labelFontStyle'),\n      fontWeight:  _('labelFontWeight'),\n      limit:       value(spec.labelLimit, config.gradientLabelLimit)\n    });\n\n    if (vertical) {\n      enter.align = {value: 'left'};\n      enter.baseline = update.baseline = {signal: baselineExpr};\n      u = 'y'; v = 'x'; adjust = '1-';\n    } else {\n      enter.align = update.align = {signal: alignExpr$1};\n      enter.baseline = {value: 'top'};\n      u = 'x'; v = 'y';\n    }\n\n    enter[u] = update[u] = {signal: adjust + 'datum.' + Perc, mult: length};\n\n    enter[v] = update[v] = thickness;\n    thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n\n    overlap = overlap ? {\n      separation: _('labelSeparation'),\n      method: overlap,\n      order: 'datum.' + Index\n    } : undefined;\n\n    // type, role, style, key, dataRef, encode, extras\n    return guideMark({\n      type:  TextMark,\n      role:  LegendLabelRole,\n      style: GuideLabelStyle,\n      key:   Value,\n      from: dataRef,\n      encode,\n      overlap\n    }, userEncode);\n  }\n\n  // userEncode is top-level, includes entries, symbols, labels\n  function legendSymbolGroups(spec, config, userEncode, dataRef, columns) {\n    const _ = lookup(spec, config),\n          entries = userEncode.entries,\n          interactive = !!(entries && entries.interactive),\n          name = entries ? entries.name : undefined,\n          height = _('clipHeight'),\n          symbolOffset = _('symbolOffset'),\n          valueRef = {data: 'value'},\n          xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n          yEncode = height ? encoder(height) : {field: Size},\n          index = `datum.${Index}`,\n          ncols = `max(1, ${columns})`;\n\n    let encode, enter, update, nrows, sort;\n\n    yEncode.mult = 0.5;\n\n    // -- LEGEND SYMBOLS --\n    encode = {\n      enter:  enter = {\n        opacity: zero,\n        x: {signal: xSignal, mult: 0.5, offset: symbolOffset},\n        y: yEncode\n      },\n      update: update = {\n        opacity: one,\n        x: enter.x,\n        y: enter.y\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n\n    let baseFill = null,\n        baseStroke = null;\n    if (!spec.fill) {\n      baseFill = config.symbolBaseFillColor;\n      baseStroke = config.symbolBaseStrokeColor;\n    }\n\n    addEncoders(encode, {\n      fill:             _('symbolFillColor', baseFill),\n      shape:            _('symbolType'),\n      size:             _('symbolSize'),\n      stroke:           _('symbolStrokeColor', baseStroke),\n      strokeDash:       _('symbolDash'),\n      strokeDashOffset: _('symbolDashOffset'),\n      strokeWidth:      _('symbolStrokeWidth')\n    }, { // update\n      opacity:          _('symbolOpacity')\n    });\n\n    LegendScales.forEach(scale => {\n      if (spec[scale]) {\n        update[scale] = enter[scale] = {scale: spec[scale], field: Value};\n      }\n    });\n\n    const symbols = guideMark({\n      type: SymbolMark,\n      role: LegendSymbolRole,\n      key:  Value,\n      from: valueRef,\n      clip: height ? true : undefined,\n      encode\n    }, userEncode.symbols);\n\n    // -- LEGEND LABELS --\n    const labelOffset = encoder(symbolOffset);\n    labelOffset.offset = _('labelOffset');\n\n    encode = {\n      enter:  enter = {\n        opacity: zero,\n        x: {signal: xSignal, offset: labelOffset},\n        y: yEncode\n      },\n      update: update = {\n        opacity: one,\n        text: {field: Label},\n        x: enter.x,\n        y: enter.y\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n\n    addEncoders(encode, {\n      align:       _('labelAlign'),\n      baseline:    _('labelBaseline'),\n      fill:        _('labelColor'),\n      fillOpacity: _('labelOpacity'),\n      font:        _('labelFont'),\n      fontSize:    _('labelFontSize'),\n      fontStyle:   _('labelFontStyle'),\n      fontWeight:  _('labelFontWeight'),\n      limit:       _('labelLimit')\n    });\n\n    const labels = guideMark({\n      type:  TextMark,\n      role:  LegendLabelRole,\n      style: GuideLabelStyle,\n      key:   Value,\n      from:  valueRef,\n      encode\n    }, userEncode.labels);\n\n    // -- LEGEND ENTRY GROUPS --\n    encode = {\n      enter: {\n        noBound: {value: !height}, // ignore width/height in bounds calc\n        width: zero,\n        height: height ? encoder(height) : zero,\n        opacity: zero\n      },\n      exit: {opacity: zero},\n      update: update = {\n        opacity: one,\n        row: {signal: null},\n        column: {signal: null}\n      }\n    };\n\n    // annotate and sort groups to ensure correct ordering\n    if (_.isVertical(true)) {\n      nrows = `ceil(item.mark.items.length / ${ncols})`;\n      update.row.signal = `${index}%${nrows}`;\n      update.column.signal = `floor(${index} / ${nrows})`;\n      sort = {field: ['row', index]};\n    } else {\n      update.row.signal = `floor(${index} / ${ncols})`;\n      update.column.signal = `${index} % ${ncols}`;\n      sort = {field: index};\n    }\n    // handle zero column case (implies infinite columns)\n    update.column.signal = `(${columns})?${update.column.signal}:${index}`;\n\n    // facet legend entries into sub-groups\n    dataRef = {facet: {data: dataRef, name: 'value', groupby: Index}};\n\n    return guideGroup({\n      role:   ScopeRole,\n      from:   dataRef,\n      encode: extendEncode(encode, entries, Skip),\n      marks:  [symbols, labels],\n      name,\n      interactive,\n      sort\n    });\n  }\n\n  function legendSymbolLayout(spec, config) {\n    const _ = lookup(spec, config);\n\n    // layout parameters for legend entries\n    return {\n      align:   _('gridAlign'),\n      columns: _.entryColumns(),\n      center:  {\n        row: true,\n        column: false\n      },\n      padding: {\n        row:    _('rowPadding'),\n        column: _('columnPadding')\n      }\n    };\n  }\n\n  // expression logic for align, anchor, angle, and baseline calculation\n  const isL = 'item.orient === \"left\"',\n        isR = 'item.orient === \"right\"',\n        isLR = `(${isL} || ${isR})`,\n        isVG = `datum.vgrad && ${isLR}`,\n        baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n        alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n        exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr}`,\n        exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n        exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n        exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\n\n  function legendTitle(spec, config, userEncode, dataRef) {\n    const _ = lookup(spec, config);\n\n    const encode = {\n      enter: {opacity: zero},\n      update: {\n        opacity: one,\n        x: {field: {group: 'padding'}},\n        y: {field: {group: 'padding'}}\n      },\n      exit: {opacity: zero}\n    };\n\n    addEncoders(encode, {\n      orient:      _('titleOrient'),\n      _anchor:     _('titleAnchor'),\n      anchor:      {signal: exprAnchor},\n      angle:       {signal: exprAngle},\n      align:       {signal: exprAlign},\n      baseline:    {signal: exprBaseline},\n      text:        spec.title,\n      fill:        _('titleColor'),\n      fillOpacity: _('titleOpacity'),\n      font:        _('titleFont'),\n      fontSize:    _('titleFontSize'),\n      fontStyle:   _('titleFontStyle'),\n      fontWeight:  _('titleFontWeight'),\n      limit:       _('titleLimit'),\n      lineHeight:  _('titleLineHeight')\n    }, { // require update\n      align:       _('titleAlign'),\n      baseline:    _('titleBaseline')\n    });\n\n    return guideMark({\n      type:  TextMark,\n      role:  LegendTitleRole,\n      style: GuideTitleStyle,\n      from:  dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function clip(clip, scope) {\n    let expr;\n\n    if (vegaUtil.isObject(clip)) {\n      if (clip.signal) {\n        expr = clip.signal;\n      } else if (clip.path) {\n        expr = 'pathShape(' + param(clip.path) + ')';\n      } else if (clip.sphere) {\n        expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n      }\n    }\n\n    return expr\n      ? scope.signalRef(expr)\n      : !!clip;\n  }\n\n  function param(value) {\n    return vegaUtil.isObject(value) && value.signal\n      ? value.signal\n      : vegaUtil.stringValue(value);\n  }\n\n  function getRole(spec) {\n    const role = spec.role || '';\n    return (!role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title'))\n      ? role\n      : spec.type === GroupMark ? ScopeRole : (role || MarkRole);\n  }\n\n  function definition(spec) {\n    return {\n      marktype:     spec.type,\n      name:         spec.name || undefined,\n      role:         spec.role || getRole(spec),\n      zindex:       +spec.zindex || undefined,\n      aria:         spec.aria,\n      description:  spec.description\n    };\n  }\n\n  function interactive(spec, scope) {\n    return spec && spec.signal ? scope.signalRef(spec.signal)\n      : spec === false ? false\n      : true;\n  }\n\n  /**\n   * Parse a data transform specification.\n   */\n  function parseTransform(spec, scope) {\n    const def = vegaDataflow.definition(spec.type);\n    if (!def) vegaUtil.error('Unrecognized transform type: ' + vegaUtil.stringValue(spec.type));\n\n    const t = entry$1(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n    if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n    t.metadata = def.metadata || {};\n\n    return t;\n  }\n\n  /**\n   * Parse all parameters of a data transform.\n   */\n  function parseParameters(def, spec, scope) {\n    const params = {},\n          n = def.params.length;\n\n    for (let i = 0; i < n; ++i) {\n      const pdef = def.params[i];\n      params[pdef.name] = parseParameter$1(pdef, spec, scope);\n    }\n    return params;\n  }\n\n  /**\n   * Parse a data transform parameter.\n   */\n  function parseParameter$1(def, spec, scope) {\n    const type = def.type,\n          value = spec[def.name];\n\n    if (type === 'index') {\n      return parseIndexParameter(def, spec, scope);\n    } else if (value === undefined) {\n      if (def.required) {\n        vegaUtil.error('Missing required ' + vegaUtil.stringValue(spec.type)\n            + ' parameter: ' + vegaUtil.stringValue(def.name));\n      }\n      return;\n    } else if (type === 'param') {\n      return parseSubParameters(def, spec, scope);\n    } else if (type === 'projection') {\n      return scope.projectionRef(spec[def.name]);\n    }\n\n    return def.array && !isSignal(value)\n      ? value.map(v => parameterValue(def, v, scope))\n      : parameterValue(def, value, scope);\n  }\n\n  /**\n   * Parse a single parameter value.\n   */\n  function parameterValue(def, value, scope) {\n    const type = def.type;\n\n    if (isSignal(value)) {\n      return isExpr$1(type) ? vegaUtil.error('Expression references can not be signals.')\n           : isField(type) ? scope.fieldRef(value)\n           : isCompare(type) ? scope.compareRef(value)\n           : scope.signalRef(value.signal);\n    } else {\n      const expr = def.expr || isField(type);\n      return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as)\n           : expr && outerField(value) ? fieldRef(value.field, value.as)\n           : isExpr$1(type) ? vegaFunctions.parseExpression(value, scope)\n           : isData(type) ? ref(scope.getData(value).values)\n           : isField(type) ? fieldRef(value)\n           : isCompare(type) ? scope.compareRef(value)\n           : value;\n    }\n  }\n\n  /**\n   * Parse parameter for accessing an index of another data set.\n   */\n  function parseIndexParameter(def, spec, scope) {\n    if (!vegaUtil.isString(spec.from)) {\n      vegaUtil.error('Lookup \"from\" parameter must be a string literal.');\n    }\n    return scope.getData(spec.from).lookupRef(scope, spec.key);\n  }\n\n  /**\n   * Parse a parameter that contains one or more sub-parameter objects.\n   */\n  function parseSubParameters(def, spec, scope) {\n    const value = spec[def.name];\n\n    if (def.array) {\n      if (!vegaUtil.isArray(value)) { // signals not allowed!\n        vegaUtil.error('Expected an array of sub-parameters. Instead: ' + vegaUtil.stringValue(value));\n      }\n      return value.map(v => parseSubParameter(def, v, scope));\n    } else {\n      return parseSubParameter(def, value, scope);\n    }\n  }\n\n  /**\n   * Parse a sub-parameter object.\n   */\n  function parseSubParameter(def, value, scope) {\n    const n =def.params.length;\n    let pdef;\n\n    // loop over defs to find matching key\n    for (let i = 0; i < n; ++i) {\n      pdef = def.params[i];\n      for (const k in pdef.key) {\n        if (pdef.key[k] !== value[k]) { pdef = null; break; }\n      }\n      if (pdef) break;\n    }\n    // raise error if matching key not found\n    if (!pdef) vegaUtil.error('Unsupported parameter: ' + vegaUtil.stringValue(value));\n\n    // parse params, create Params transform, return ref\n    const params = vegaUtil.extend(parseParameters(pdef, value, scope), pdef.key);\n    return ref(scope.add(Params(params)));\n  }\n\n  // -- Utilities -----\n\n  const outerExpr = _ => _ && _.expr;\n\n  const outerField = _ => _ && _.field;\n\n  const isData = _ => _ === 'data';\n\n  const isExpr$1 = _ => _ === 'expr';\n\n  const isField = _ => _ === 'field';\n\n  const isCompare = _ => _ === 'compare';\n\n  function parseData(from, group, scope) {\n    let facet, key, op, dataRef, parent;\n\n    // if no source data, generate singleton datum\n    if (!from) {\n      dataRef = ref(scope.add(Collect(null, [{}])));\n    }\n\n    // if faceted, process facet specification\n    else if (facet = from.facet) {\n      if (!group) vegaUtil.error('Only group marks can be faceted.');\n\n      // use pre-faceted source data, if available\n      if (facet.field != null) {\n        dataRef = parent = getDataRef(facet, scope);\n      } else {\n        // generate facet aggregates if no direct data specification\n        if (!from.data) {\n          op = parseTransform(vegaUtil.extend({\n            type:    'aggregate',\n            groupby: vegaUtil.array(facet.groupby)\n          }, facet.aggregate), scope);\n          op.params.key = scope.keyRef(facet.groupby);\n          op.params.pulse = getDataRef(facet, scope);\n          dataRef = parent = ref(scope.add(op));\n        } else {\n          parent = ref(scope.getData(from.data).aggregate);\n        }\n\n        key = scope.keyRef(facet.groupby, true);\n      }\n    }\n\n    // if not yet defined, get source data reference\n    if (!dataRef) {\n      dataRef = getDataRef(from, scope);\n    }\n\n    return {\n      key: key,\n      pulse: dataRef,\n      parent: parent\n    };\n  }\n\n  function getDataRef(from, scope) {\n    return from.$ref ? from\n      : from.data && from.data.$ref ? from.data\n      : ref(scope.getData(from.data).output);\n  }\n\n  function DataScope(scope, input, output, values, aggr) {\n    this.scope = scope;   // parent scope object\n    this.input = input;   // first operator in pipeline (tuple input)\n    this.output = output; // last operator in pipeline (tuple output)\n    this.values = values; // operator for accessing tuples (but not tuple flow)\n\n    // last aggregate in transform pipeline\n    this.aggregate = aggr;\n\n    // lookup table of field indices\n    this.index = {};\n  }\n\n  DataScope.fromEntries = function(scope, entries) {\n    const n = entries.length,\n          values = entries[n-1],\n          output = entries[n-2];\n\n    let input = entries[0],\n        aggr = null,\n        i = 1;\n\n    if (input && input.type === 'load') {\n      input = entries[1];\n    }\n\n    // add operator entries to this scope, wire up pulse chain\n    scope.add(entries[0]);\n    for (; i<n; ++i) {\n      entries[i].params.pulse = ref(entries[i-1]);\n      scope.add(entries[i]);\n      if (entries[i].type === 'aggregate') aggr = entries[i];\n    }\n\n    return new DataScope(scope, input, output, values, aggr);\n  };\n\n  function fieldKey(field) {\n    return vegaUtil.isString(field) ? field : null;\n  }\n\n  function addSortField(scope, p, sort) {\n    const as = aggrField(sort.op, sort.field);\n    let s;\n\n    if (p.ops) {\n      for (let i = 0, n = p.as.length; i < n; ++i) {\n        if (p.as[i] === as) return;\n      }\n    } else {\n      p.ops = ['count'];\n      p.fields = [null];\n      p.as = ['count'];\n    }\n    if (sort.op) {\n      p.ops.push((s=sort.op.signal) ? scope.signalRef(s) : sort.op);\n      p.fields.push(scope.fieldRef(sort.field));\n      p.as.push(as);\n    }\n  }\n\n  function cache(scope, ds, name, optype, field, counts, index) {\n    const cache = ds[name] || (ds[name] = {}),\n          sort = sortKey(counts);\n\n    let k = fieldKey(field),\n        v, op;\n\n    if (k != null) {\n      scope = ds.scope;\n      k = k + (sort ? '|' + sort : '');\n      v = cache[k];\n    }\n\n    if (!v) {\n      const params = counts\n        ? {field: keyFieldRef, pulse: ds.countsRef(scope, field, counts)}\n        : {field: scope.fieldRef(field), pulse: ref(ds.output)};\n      if (sort) params.sort = scope.sortRef(counts);\n      op = scope.add(entry$1(optype, undefined, params));\n      if (index) ds.index[field] = op;\n      v = ref(op);\n      if (k != null) cache[k] = v;\n    }\n    return v;\n  }\n\n  DataScope.prototype = {\n    countsRef(scope, field, sort) {\n      const ds = this,\n            cache = ds.counts || (ds.counts = {}),\n            k = fieldKey(field);\n\n      let v, a, p;\n\n      if (k != null) {\n        scope = ds.scope;\n        v = cache[k];\n      }\n\n      if (!v) {\n        p = {\n          groupby: scope.fieldRef(field, 'key'),\n          pulse: ref(ds.output)\n        };\n        if (sort && sort.field) addSortField(scope, p, sort);\n        a = scope.add(Aggregate(p));\n        v = scope.add(Collect({pulse: ref(a)}));\n        v = {agg: a, ref: ref(v)};\n        if (k != null) cache[k] = v;\n      } else if (sort && sort.field) {\n        addSortField(scope, v.agg.params, sort);\n      }\n\n      return v.ref;\n    },\n\n    tuplesRef() {\n      return ref(this.values);\n    },\n\n    extentRef(scope, field) {\n      return cache(scope, this, 'extent', 'extent', field, false);\n    },\n\n    domainRef(scope, field) {\n      return cache(scope, this, 'domain', 'values', field, false);\n    },\n\n    valuesRef(scope, field, sort) {\n      return cache(scope, this, 'vals', 'values', field, sort || true);\n    },\n\n    lookupRef(scope, field) {\n      return cache(scope, this, 'lookup', 'tupleindex', field, false);\n    },\n\n    indataRef(scope, field) {\n      return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n    }\n  };\n\n  function parseFacet(spec, scope, group) {\n    const facet = spec.from.facet,\n          name = facet.name,\n          data = getDataRef(facet, scope);\n    let op;\n\n    if (!facet.name) {\n      vegaUtil.error('Facet must have a name: ' + vegaUtil.stringValue(facet));\n    }\n    if (!facet.data) {\n      vegaUtil.error('Facet must reference a data set: ' + vegaUtil.stringValue(facet));\n    }\n\n    if (facet.field) {\n      op = scope.add(PreFacet({\n        field: scope.fieldRef(facet.field),\n        pulse: data\n      }));\n    } else if (facet.groupby) {\n      op = scope.add(Facet({\n        key:   scope.keyRef(facet.groupby),\n        group: ref(scope.proxy(group.parent)),\n        pulse: data\n      }));\n    } else {\n      vegaUtil.error('Facet must specify groupby or field: ' + vegaUtil.stringValue(facet));\n    }\n\n    // initialize facet subscope\n    const subscope = scope.fork(),\n          source = subscope.add(Collect()),\n          values = subscope.add(Sieve({pulse: ref(source)}));\n    subscope.addData(name, new DataScope(subscope, source, source, values));\n    subscope.addSignal('parent', null);\n\n    // parse faceted subflow\n    op.params.subflow = {\n      $subflow: subscope.parse(spec).toRuntime()\n    };\n  }\n\n  function parseSubflow(spec, scope, input) {\n    const op = scope.add(PreFacet({pulse: input.pulse})),\n          subscope = scope.fork();\n\n    subscope.add(Sieve());\n    subscope.addSignal('parent', null);\n\n    // parse group mark subflow\n    op.params.subflow = {\n      $subflow: subscope.parse(spec).toRuntime()\n    };\n  }\n\n  function parseTrigger(spec, scope, name) {\n    const remove = spec.remove,\n          insert = spec.insert,\n          toggle = spec.toggle,\n          modify = spec.modify,\n          values = spec.values,\n          op = scope.add(operator());\n\n    const update = 'if(' + spec.trigger + ',modify(\"'\n      + name + '\",'\n      + [insert, remove, toggle, modify, values]\n          .map(_ => _ == null ? 'null' : _)\n          .join(',')\n      + '),0)';\n\n    const expr = vegaFunctions.parseExpression(update, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  function parseMark(spec, scope) {\n    const role = getRole(spec),\n          group = spec.type === GroupMark,\n          facet = spec.from && spec.from.facet,\n          overlap = spec.overlap;\n\n    let layout = spec.layout || role === ScopeRole || role === FrameRole,\n        ops, op, store, enc, name, layoutRef, boundRef;\n\n    const nested = role === MarkRole || layout || facet;\n\n    // resolve input data\n    const input = parseData(spec.from, group, scope);\n\n    // data join to map tuples to visual items\n    op = scope.add(DataJoin({\n      key:   input.key || (spec.key ? fieldRef(spec.key) : undefined),\n      pulse: input.pulse,\n      clean: !group\n    }));\n    const joinRef = ref(op);\n\n    // collect visual items\n    op = store = scope.add(Collect({pulse: joinRef}));\n\n    // connect visual items to scenegraph\n    op = scope.add(Mark({\n      markdef:     definition(spec),\n      interactive: interactive(spec.interactive, scope),\n      clip:        clip(spec.clip, scope),\n      context:     {$context: true},\n      groups:      scope.lookup(),\n      parent:      scope.signals.parent ? scope.signalRef('parent') : null,\n      index:       scope.markpath(),\n      pulse:       ref(op)\n    }));\n    const markRef = ref(op);\n\n    // add visual encoders\n    op = enc = scope.add(Encode(parseEncode(\n      spec.encode, spec.type, role, spec.style, scope,\n      {mod: false, pulse: markRef}\n    )));\n\n    // monitor parent marks to propagate changes\n    op.params.parent = scope.encode();\n\n    // add post-encoding transforms, if defined\n    if (spec.transform) {\n      spec.transform.forEach(_ => {\n        const tx = parseTransform(_, scope),\n              md = tx.metadata;\n        if (md.generates || md.changes) {\n          vegaUtil.error('Mark transforms should not generate new data.');\n        }\n        if (!md.nomod) enc.params.mod = true; // update encode mod handling\n        tx.params.pulse = ref(op);\n        scope.add(op = tx);\n      });\n    }\n\n    // if item sort specified, perform post-encoding\n    if (spec.sort) {\n      op = scope.add(SortItems({\n        sort:  scope.compareRef(spec.sort),\n        pulse: ref(op)\n      }));\n    }\n\n    const encodeRef = ref(op);\n\n    // add view layout operator if needed\n    if (facet || layout) {\n      layout = scope.add(ViewLayout({\n        layout:   scope.objectProperty(spec.layout),\n        legends:  scope.legends,\n        mark:     markRef,\n        pulse:    encodeRef\n      }));\n      layoutRef = ref(layout);\n    }\n\n    // compute bounding boxes\n    const bound = scope.add(Bound({mark: markRef, pulse: layoutRef || encodeRef}));\n    boundRef = ref(bound);\n\n    // if group mark, recurse to parse nested content\n    if (group) {\n      // juggle layout & bounds to ensure they run *after* any faceting transforms\n      if (nested) { ops = scope.operators; ops.pop(); if (layout) ops.pop(); }\n\n      scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n      facet ? parseFacet(spec, scope, input)          // explicit facet\n          : nested ? parseSubflow(spec, scope, input) // standard mark group\n          : scope.parse(spec); // guide group, we can avoid nested scopes\n      scope.popState();\n\n      if (nested) { if (layout) ops.push(layout); ops.push(bound); }\n    }\n\n    // if requested, add overlap removal transform\n    if (overlap) {\n      boundRef = parseOverlap(overlap, boundRef, scope);\n    }\n\n    // render / sieve items\n    const render = scope.add(Render({pulse: boundRef})),\n          sieve = scope.add(Sieve({pulse: ref(render)}, undefined, scope.parent()));\n\n    // if mark is named, make accessible as reactive geometry\n    // add trigger updates if defined\n    if (spec.name != null) {\n      name = spec.name;\n      scope.addData(name, new DataScope(scope, store, render, sieve));\n      if (spec.on) spec.on.forEach(on => {\n        if (on.insert || on.remove || on.toggle) {\n          vegaUtil.error('Marks only support modify triggers.');\n        }\n        parseTrigger(on, scope, name);\n      });\n    }\n  }\n\n  function parseOverlap(overlap, source, scope) {\n    const method = overlap.method,\n          bound = overlap.bound,\n          sep = overlap.separation;\n\n    const params = {\n      separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n      method: isSignal(method) ? scope.signalRef(method.signal) : method,\n      pulse:  source\n    };\n\n    if (overlap.order) {\n      params.sort = scope.compareRef({field: overlap.order});\n    }\n\n    if (bound) {\n      const tol = bound.tolerance;\n      params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n      params.boundScale = scope.scaleRef(bound.scale);\n      params.boundOrient = bound.orient;\n    }\n\n    return ref(scope.add(Overlap(params)));\n  }\n\n  function parseLegend(spec, scope) {\n    const config = scope.config.legend,\n          encode = spec.encode || {},\n          _ = lookup(spec, config),\n          legendEncode = encode.legend || {},\n          name = legendEncode.name || undefined,\n          interactive = legendEncode.interactive,\n          style = legendEncode.style,\n          scales = {};\n\n    let scale = 0, entryLayout, params, children;\n\n    // resolve scales and 'canonical' scale name\n    LegendScales.forEach(s => spec[s]\n      ? (scales[s] = spec[s], scale = scale || spec[s]) : 0\n    );\n    if (!scale) vegaUtil.error('Missing valid scale for legend.');\n\n    // resolve legend type (symbol, gradient, or discrete gradient)\n    const type = legendType(spec, scope.scaleType(scale));\n\n    // single-element data source for legend group\n    const datum = {\n      title:  spec.title != null,\n      scales: scales,\n      type:   type,\n      vgrad:  type !== 'symbol' &&  _.isVertical()\n    };\n    const dataRef = ref(scope.add(Collect(null, [datum])));\n\n    // encoding properties for legend entry sub-group\n    const entryEncode = {enter: {x: {value: 0}, y: {value: 0}}};\n\n    // data source for legend values\n    const entryRef = ref(scope.add(LegendEntries(params = {\n      type:    type,\n      scale:   scope.scaleRef(scale),\n      count:   scope.objectProperty(_('tickCount')),\n      limit:   scope.property(_('symbolLimit')),\n      values:  scope.objectProperty(spec.values),\n      minstep: scope.property(spec.tickMinStep),\n      formatType: scope.property(spec.formatType),\n      formatSpecifier: scope.property(spec.format)\n    })));\n\n    // continuous gradient legend\n    if (type === Gradient) {\n      children = [\n        legendGradient(spec, scale, config, encode.gradient),\n        legendGradientLabels(spec, config, encode.labels, entryRef)\n      ];\n      // adjust default tick count based on the gradient length\n      params.count = params.count || scope.signalRef(\n        `max(2,2*floor((${deref(_.gradientLength())})/100))`\n      );\n    }\n\n    // discrete gradient legend\n    else if (type === Discrete) {\n      children = [\n        legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef),\n        legendGradientLabels(spec, config, encode.labels, entryRef)\n      ];\n    }\n\n    // symbol legend\n    else {\n      // determine legend symbol group layout\n      entryLayout = legendSymbolLayout(spec, config);\n      children = [\n        legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))\n      ];\n      // pass symbol size information to legend entry generator\n      params.size = sizeExpression(spec, scope, children[0].marks);\n    }\n\n    // generate legend marks\n    children = [\n      guideGroup({\n        role: LegendEntryRole,\n        from: dataRef,\n        encode: entryEncode,\n        marks: children,\n        layout: entryLayout,\n        interactive\n      })\n    ];\n\n    // include legend title if defined\n    if (datum.title) {\n      children.push(legendTitle(spec, config, encode.title, dataRef));\n    }\n\n    // parse legend specification\n    return parseMark(\n      guideGroup({\n        role:        LegendRole,\n        from:        dataRef,\n        encode:      extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n        marks:       children,\n        aria:        _('aria'),\n        description: _('description'),\n        zindex:      _('zindex'),\n        name,\n        interactive,\n        style\n      }),\n      scope\n    );\n  }\n\n  function legendType(spec, scaleType) {\n    let type = spec.type || Symbols;\n\n    if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n      type = vegaScale.isContinuous(scaleType) ? Gradient\n        : vegaScale.isDiscretizing(scaleType) ? Discrete\n        : Symbols;\n    }\n\n    return type !== Gradient ? type\n      : vegaScale.isDiscretizing(scaleType) ? Discrete\n      : Gradient;\n  }\n\n  function scaleCount(spec) {\n    return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n  }\n\n  function buildLegendEncode(_, spec, config) {\n    const encode = {enter: {}, update: {}};\n\n    addEncoders(encode, {\n      orient:       _('orient'),\n      offset:       _('offset'),\n      padding:      _('padding'),\n      titlePadding: _('titlePadding'),\n      cornerRadius: _('cornerRadius'),\n      fill:         _('fillColor'),\n      stroke:       _('strokeColor'),\n      strokeWidth:  config.strokeWidth,\n      strokeDash:   config.strokeDash,\n      x:            _('legendX'),\n      y:            _('legendY'),\n\n      // accessibility support\n      format:       spec.format,\n      formatType:   spec.formatType\n    });\n\n    return encode;\n  }\n\n  function sizeExpression(spec, scope, marks) {\n    const size = deref(getChannel('size', spec, marks)),\n          strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n          fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n\n    return vegaFunctions.parseExpression(\n      `max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`,\n      scope\n    );\n  }\n\n  function getChannel(name, spec, marks) {\n    return spec[name]\n      ? `scale(\"${spec[name]}\",datum)`\n      : getEncoding(name, marks[0].encode);\n  }\n\n  function getFontSize(encode, scope, style) {\n    return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n  }\n\n  const angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\n\n  function parseTitle(spec, scope) {\n    spec = vegaUtil.isString(spec) ? {text: spec} : spec;\n\n    const _ = lookup(spec, scope.config.title),\n          encode = spec.encode || {},\n          userEncode = encode.group || {},\n          name = userEncode.name || undefined,\n          interactive = userEncode.interactive,\n          style = userEncode.style,\n          children = [];\n\n    // single-element data source for group title\n    const datum = {},\n          dataRef = ref(scope.add(Collect(null, [datum])));\n\n    // include title text\n    children.push(buildTitle(spec, _, titleEncode(spec), dataRef));\n\n    // include subtitle text\n    if (spec.subtitle) {\n      children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n    }\n\n    // parse title specification\n    return parseMark(\n      guideGroup({\n        role:        TitleRole,\n        from:        dataRef,\n        encode:      groupEncode(_, userEncode),\n        marks:       children,\n        aria:        _('aria'),\n        description: _('description'),\n        zindex:      _('zindex'),\n        name,\n        interactive,\n        style\n      }),\n      scope\n    );\n  }\n\n  // provide backwards-compatibility for title custom encode;\n  // the top-level encode block has been *deprecated*.\n  function titleEncode(spec) {\n    const encode = spec.encode;\n    return (encode && encode.title) || vegaUtil.extend({\n      name: spec.name,\n      interactive: spec.interactive,\n      style: spec.style\n    }, encode);\n  }\n\n  function groupEncode(_, userEncode) {\n    const encode = {enter: {}, update: {}};\n\n    addEncoders(encode, {\n      orient:      _('orient'),\n      anchor:      _('anchor'),\n      align:       {signal: alignExpr},\n      angle:       {signal: angleExpr},\n      limit:       _('limit'),\n      frame:       _('frame'),\n      offset:      _('offset') || 0,\n      padding:     _('subtitlePadding')\n    });\n\n    return extendEncode(encode, userEncode, Skip);\n  }\n\n  function buildTitle(spec, _, userEncode, dataRef) {\n    const zero = {value: 0},\n          text = spec.text,\n          encode = {\n            enter: {opacity: zero},\n            update: {opacity: {value: 1}},\n            exit: {opacity: zero}\n          };\n\n    addEncoders(encode, {\n      text:       text,\n      align:      {signal: 'item.mark.group.align'},\n      angle:      {signal: 'item.mark.group.angle'},\n      limit:      {signal: 'item.mark.group.limit'},\n      baseline:   'top',\n      dx:         _('dx'),\n      dy:         _('dy'),\n      fill:       _('color'),\n      font:       _('font'),\n      fontSize:   _('fontSize'),\n      fontStyle:  _('fontStyle'),\n      fontWeight: _('fontWeight'),\n      lineHeight: _('lineHeight')\n    }, { // update\n      align:      _('align'),\n      angle:      _('angle'),\n      baseline:   _('baseline')\n    });\n\n    return guideMark({\n      type: TextMark,\n      role: TitleTextRole,\n      style: GroupTitleStyle,\n      from: dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function buildSubTitle(spec, _, userEncode, dataRef) {\n    const zero = {value: 0},\n          text = spec.subtitle,\n          encode = {\n            enter: {opacity: zero},\n            update: {opacity: {value: 1}},\n            exit: {opacity: zero}\n          };\n\n    addEncoders(encode, {\n      text:       text,\n      align:      {signal: 'item.mark.group.align'},\n      angle:      {signal: 'item.mark.group.angle'},\n      limit:      {signal: 'item.mark.group.limit'},\n      baseline:   'top',\n      dx:         _('dx'),\n      dy:         _('dy'),\n      fill:       _('subtitleColor'),\n      font:       _('subtitleFont'),\n      fontSize:   _('subtitleFontSize'),\n      fontStyle:  _('subtitleFontStyle'),\n      fontWeight: _('subtitleFontWeight'),\n      lineHeight: _('subtitleLineHeight')\n    }, { // update\n      align:      _('align'),\n      angle:      _('angle'),\n      baseline:   _('baseline')\n    });\n\n    return guideMark({\n      type:  TextMark,\n      role:  TitleSubtitleRole,\n      style: GroupSubtitleStyle,\n      from:  dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function parseData$1(data, scope) {\n    const transforms = [];\n\n    if (data.transform) {\n      data.transform.forEach(tx => {\n        transforms.push(parseTransform(tx, scope));\n      });\n    }\n\n    if (data.on) {\n      data.on.forEach(on => {\n        parseTrigger(on, scope, data.name);\n      });\n    }\n\n    scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n  }\n\n  /**\n   * Analyze a data pipeline, add needed operators.\n   */\n  function analyze(data, scope, ops) {\n    const output = [];\n    let source = null,\n        modify = false,\n        generate = false,\n        upstream, i, n, t, m;\n\n    if (data.values) {\n      // hard-wired input data set\n      if (hasSignal(data.values) || hasSignal(data.format)) {\n        // if either values or format has signal, use dynamic loader\n        output.push(load(scope, data));\n        output.push(source = collect());\n      } else {\n        // otherwise, ingest upon dataflow init\n        output.push(source = collect({\n          $ingest: data.values,\n          $format: data.format\n        }));\n      }\n    } else if (data.url) {\n      // load data from external source\n      if (hasSignal(data.url) || hasSignal(data.format)) {\n        // if either url or format has signal, use dynamic loader\n        output.push(load(scope, data));\n        output.push(source = collect());\n      } else {\n        // otherwise, request load upon dataflow init\n        output.push(source = collect({\n          $request: data.url,\n          $format: data.format\n        }));\n      }\n    } else if (data.source) {\n      // derives from one or more other data sets\n      source = upstream = vegaUtil.array(data.source)\n        .map(d => ref(scope.getData(d).output));\n      output.push(null); // populate later\n    }\n\n    // scan data transforms, add collectors as needed\n    for (i=0, n=ops.length; i<n; ++i) {\n      t = ops[i];\n      m = t.metadata;\n\n      if (!source && !m.source) {\n        output.push(source = collect());\n      }\n      output.push(t);\n\n      if (m.generates) generate = true;\n      if (m.modifies && !generate) modify = true;\n\n      if (m.source) source = t;\n      else if (m.changes) source = null;\n    }\n\n    if (upstream) {\n      n = upstream.length - 1;\n      output[0] = Relay({\n        derive: modify,\n        pulse: n ? upstream : upstream[0]\n      });\n      if (modify || n) {\n        // collect derived and multi-pulse tuples\n        output.splice(1, 0, collect());\n      }\n    }\n\n    if (!source) output.push(collect());\n    output.push(Sieve({}));\n    return output;\n  }\n\n  function collect(values) {\n    const s = Collect({}, values);\n    s.metadata = {source: true};\n    return s;\n  }\n\n  function load(scope, data) {\n    return Load({\n      url:    data.url ? scope.property(data.url) : undefined,\n      async:  data.async ? scope.property(data.async) : undefined,\n      values: data.values ? scope.property(data.values) : undefined,\n      format: scope.objectProperty(data.format)\n    });\n  }\n\n  const isX = orient => orient === Bottom || orient === Top;\n\n  // get sign coefficient based on axis orient\n  const getSign = (orient, a, b) => isSignal(orient)\n    ? ifLeftTopExpr(orient.signal, a, b)\n    : orient === Left || orient === Top ? a : b;\n\n  // condition on axis x-direction\n  const ifX = (orient, a, b) => isSignal(orient)\n    ? ifXEnc(orient.signal, a, b)\n    : isX(orient) ? a : b;\n\n  // condition on axis y-direction\n  const ifY = (orient, a, b) => isSignal(orient)\n    ? ifYEnc(orient.signal, a, b)\n    : isX(orient) ? b : a;\n\n  const ifTop = (orient, a, b) => isSignal(orient)\n    ? ifTopExpr(orient.signal, a, b)\n    : orient === Top ? {value: a} : {value: b};\n\n  const ifRight = (orient, a, b) => isSignal(orient)\n    ? ifRightExpr(orient.signal, a, b)\n    : orient === Right ? {value: a} : {value: b};\n\n  const ifXEnc = ($orient, a, b) => ifEnc(\n    `${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b\n  );\n\n  const ifYEnc = ($orient, a, b) => ifEnc(\n    `${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b\n  );\n\n  const ifLeftTopExpr = ($orient, a, b) => ifExpr(\n    `${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b\n  );\n\n  const ifTopExpr = ($orient, a, b) => ifExpr(\n    `${$orient} === '${Top}'`, a, b\n  );\n\n  const ifRightExpr = ($orient, a, b) => ifExpr(\n    `${$orient} === '${Right}'`, a, b\n  );\n\n  const ifEnc = (test, a, b) => {\n    // ensure inputs are encoder objects (or null)\n    a = a != null ? encoder(a) : a;\n    b = b != null ? encoder(b) : b;\n\n    if (isSimple(a) && isSimple(b)) {\n      // if possible generate simple signal expression\n      a = a ? (a.signal || vegaUtil.stringValue(a.value)) : null;\n      b = b ? (b.signal || vegaUtil.stringValue(b.value)) : null;\n      return {signal: `${test} ? (${a}) : (${b})`};\n    } else {\n      // otherwise generate rule set\n      return [vegaUtil.extend({test}, a)].concat(b || []);\n    }\n  };\n\n  const isSimple = enc => (\n    enc == null || Object.keys(enc).length === 1\n  );\n\n  const ifExpr = (test, a, b) => ({\n    signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n  });\n\n  const ifOrient = ($orient, t, b, l, r) => ({\n    signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '')\n          + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '')\n          + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '')\n          + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '')\n          + '(null)'\n  });\n\n  const toExpr = v => isSignal(v)\n    ? v.signal\n    : v == null ? null : vegaUtil.stringValue(v);\n\n  const mult = (sign, value) => value === 0 ? 0 : isSignal(sign)\n    ? {signal: `(${sign.signal}) * ${value}`}\n    : {value: sign * value};\n\n  const patch = (value, base) => {\n    const s = value.signal;\n    return s && s.endsWith('(null)')\n      ? {signal: s.slice(0, -6) + base.signal}\n      : value;\n  };\n\n  function fallback(prop, config, axisConfig, style) {\n    let styleProp;\n\n    if (config && vegaUtil.hasOwnProperty(config, prop)) {\n      return config[prop];\n    }\n    else if (vegaUtil.hasOwnProperty(axisConfig, prop)) {\n      return axisConfig[prop];\n    }\n    else if (prop.startsWith('title')) {\n      switch (prop) {\n        case 'titleColor':\n          styleProp = 'fill';\n          break;\n        case 'titleFont':\n        case 'titleFontSize':\n        case 'titleFontWeight':\n          styleProp = prop[5].toLowerCase() + prop.slice(6);\n      }\n      return style[GuideTitleStyle][styleProp];\n    }\n    else if (prop.startsWith('label')) {\n      switch (prop) {\n        case 'labelColor':\n          styleProp = 'fill';\n          break;\n        case 'labelFont':\n        case 'labelFontSize':\n          styleProp = prop[5].toLowerCase() + prop.slice(6);\n      }\n      return style[GuideLabelStyle][styleProp];\n    }\n\n    return null;\n  }\n\n  function keys(objects) {\n    const map = {};\n    for (const obj of objects) {\n      if (!obj) continue;\n      for (const key in obj) map[key] = 1;\n    }\n    return Object.keys(map);\n  }\n\n  function axisConfig(spec, scope) {\n    var config = scope.config,\n        style = config.style,\n        axis = config.axis,\n        band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n        orient = spec.orient,\n        xy, or, key;\n\n    if (isSignal(orient)) {\n      const xyKeys = keys([\n              config.axisX, config.axisY\n            ]),\n            orientKeys = keys([\n              config.axisTop, config.axisBottom,\n              config.axisLeft, config.axisRight\n            ]);\n\n      xy = {};\n      for (key of xyKeys) {\n        xy[key] = ifX(\n          orient,\n          fallback(key, config.axisX, axis, style),\n          fallback(key, config.axisY, axis, style)\n        );\n      }\n\n      or = {};\n      for (key of orientKeys) {\n        or[key] = ifOrient(\n          orient.signal,\n          fallback(key, config.axisTop, axis, style),\n          fallback(key, config.axisBottom, axis, style),\n          fallback(key, config.axisLeft, axis, style),\n          fallback(key, config.axisRight, axis, style)\n        );\n      }\n    } else {\n      xy = (orient === Top || orient === Bottom) ? config.axisX : config.axisY;\n      or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n    }\n\n    var result = (xy || or || band)\n      ? vegaUtil.extend({}, axis, xy, or, band)\n      : axis;\n\n    return result;\n  }\n\n  function axisDomain(spec, config, userEncode, dataRef) {\n    const _ = lookup(spec, config),\n          orient = spec.orient;\n\n    let enter, update;\n    const encode = {\n      enter: enter = {opacity: zero},\n      update: update = {opacity: one},\n      exit: {opacity: zero}\n    };\n\n    addEncoders(encode, {\n      stroke:           _('domainColor'),\n      strokeCap:        _('domainCap'),\n      strokeDash:       _('domainDash'),\n      strokeDashOffset: _('domainDashOffset'),\n      strokeWidth:      _('domainWidth'),\n      strokeOpacity:    _('domainOpacity')\n    });\n\n    const pos0 = position(spec, 0);\n    const pos1 = position(spec, 1);\n\n    enter.x = update.x = ifX(orient, pos0, zero);\n    enter.x2 = update.x2 = ifX(orient, pos1);\n\n    enter.y = update.y = ifY(orient, pos0, zero);\n    enter.y2 = update.y2 = ifY(orient, pos1);\n\n    return guideMark({\n      type: RuleMark,\n      role: AxisDomainRole,\n      from: dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function position(spec, pos) {\n    return {scale: spec.scale, range: pos};\n  }\n\n  function axisGrid(spec, config, userEncode, dataRef, band) {\n    const _ = lookup(spec, config),\n          orient = spec.orient,\n          vscale = spec.gridScale,\n          sign = getSign(orient, 1, -1),\n          offset = offsetValue(spec.offset, sign);\n\n    let enter, exit, update;\n    const encode = {\n      enter: enter = {opacity: zero},\n      update: update = {opacity: one},\n      exit: exit = {opacity: zero}\n    };\n\n    addEncoders(encode, {\n      stroke:           _('gridColor'),\n      strokeCap:        _('gridCap'),\n      strokeDash:       _('gridDash'),\n      strokeDashOffset: _('gridDashOffset'),\n      strokeOpacity:    _('gridOpacity'),\n      strokeWidth:      _('gridWidth')\n    });\n\n    const tickPos = {\n      scale:  spec.scale,\n      field:  Value,\n      band:   band.band,\n      extra:  band.extra,\n      offset: band.offset,\n      round:  _('tickRound')\n    };\n\n    const sz = ifX(orient, {signal: 'height'}, {signal: 'width'});\n\n    const gridStart = vscale\n      ? {scale: vscale, range: 0, mult: sign, offset: offset}\n      : {value: 0, offset: offset};\n\n    const gridEnd = vscale\n      ? {scale: vscale, range: 1, mult: sign, offset: offset}\n      : vegaUtil.extend(sz, {mult: sign, offset: offset});\n\n    enter.x = update.x = ifX(orient, tickPos, gridStart);\n    enter.y = update.y = ifY(orient, tickPos, gridStart);\n    enter.x2 = update.x2 = ifY(orient, gridEnd);\n    enter.y2 = update.y2 = ifX(orient, gridEnd);\n    exit.x = ifX(orient, tickPos);\n    exit.y = ifY(orient, tickPos);\n\n    return guideMark({\n      type: RuleMark,\n      role: AxisGridRole,\n      key:  Value,\n      from: dataRef,\n      encode\n     }, userEncode);\n  }\n\n  function offsetValue(offset, sign)  {\n    if (sign === 1) ; else if (!vegaUtil.isObject(offset)) {\n      offset = isSignal(sign)\n        ? {signal: `(${sign.signal}) * (${offset || 0})`}\n        : sign * (offset || 0);\n    } else {\n      let entry = offset = vegaUtil.extend({}, offset);\n      while (entry.mult != null) {\n        if (!vegaUtil.isObject(entry.mult)) {\n          entry.mult = isSignal(sign) // no offset if sign === 1\n            ? {signal: `(${entry.mult}) * (${sign.signal})`}\n            : entry.mult * sign;\n          return offset;\n        } else {\n          entry = entry.mult = vegaUtil.extend({}, entry.mult);\n        }\n      }\n      entry.mult = sign;\n    }\n\n    return offset;\n  }\n\n  function axisTicks(spec, config, userEncode, dataRef, size, band) {\n    const _ = lookup(spec, config),\n          orient = spec.orient,\n          sign = getSign(orient, -1, 1);\n\n    let enter, exit, update;\n    const encode = {\n      enter: enter = {opacity: zero},\n      update: update = {opacity: one},\n      exit: exit = {opacity: zero}\n    };\n\n    addEncoders(encode, {\n      stroke:           _('tickColor'),\n      strokeCap:        _('tickCap'),\n      strokeDash:       _('tickDash'),\n      strokeDashOffset: _('tickDashOffset'),\n      strokeOpacity:    _('tickOpacity'),\n      strokeWidth:      _('tickWidth')\n    });\n\n    const tickSize = encoder(size);\n    tickSize.mult = sign;\n\n    const tickPos = {\n      scale:  spec.scale,\n      field:  Value,\n      band:   band.band,\n      extra:  band.extra,\n      offset: band.offset,\n      round:  _('tickRound')\n    };\n\n    update.y = enter.y = ifX(orient, zero, tickPos);\n    update.y2 = enter.y2 = ifX(orient, tickSize);\n    exit.x = ifX(orient, tickPos);\n\n    update.x = enter.x = ifY(orient, zero, tickPos);\n    update.x2 = enter.x2 = ifY(orient, tickSize);\n    exit.y = ifY(orient, tickPos);\n\n    return guideMark({\n      type: RuleMark,\n      role: AxisTickRole,\n      key:  Value,\n      from: dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function flushExpr(scale, threshold, a, b, c) {\n    return {\n      signal: 'flush(range(\"' + scale + '\"), '\n        + 'scale(\"' + scale + '\", datum.value), '\n        + threshold + ',' + a + ',' + b + ',' + c + ')'\n    };\n  }\n\n  function axisLabels(spec, config, userEncode, dataRef, size, band) {\n    const _ = lookup(spec, config),\n          orient = spec.orient,\n          scale = spec.scale,\n          sign = getSign(orient, -1, 1),\n          flush = deref(_('labelFlush')),\n          flushOffset = deref(_('labelFlushOffset')),\n          labelAlign = _('labelAlign'),\n          labelBaseline = _('labelBaseline');\n\n    let flushOn = flush === 0 || !!flush,\n        update;\n\n    const tickSize = encoder(size);\n    tickSize.mult = sign;\n    tickSize.offset = encoder(_('labelPadding') || 0);\n    tickSize.offset.mult = sign;\n\n    const tickPos = {\n      scale:  scale,\n      field:  Value,\n      band:   0.5,\n      offset: extendOffset(band.offset, _('labelOffset'))\n    };\n\n    const align = ifX(orient,\n      flushOn\n        ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"')\n        : {value: 'center'},\n      ifRight(orient, 'left', 'right')\n    );\n\n    const baseline = ifX(orient,\n      ifTop(orient, 'bottom', 'top'),\n      flushOn\n        ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"')\n        : {value: 'middle'}\n    );\n\n    const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n    flushOn = flushOn && flushOffset;\n\n    const enter = {\n      opacity: zero,\n      x: ifX(orient, tickPos, tickSize),\n      y: ifY(orient, tickPos, tickSize)\n    };\n\n    const encode = {\n      enter: enter,\n      update: update = {\n        opacity: one,\n        text: {field: Label},\n        x: enter.x,\n        y: enter.y,\n        align,\n        baseline\n      },\n      exit: {\n        opacity: zero,\n        x: enter.x,\n        y: enter.y\n      }\n    };\n\n    addEncoders(encode, {\n      dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n      dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n    });\n\n    addEncoders(encode, {\n      angle:       _('labelAngle'),\n      fill:        _('labelColor'),\n      fillOpacity: _('labelOpacity'),\n      font:        _('labelFont'),\n      fontSize:    _('labelFontSize'),\n      fontWeight:  _('labelFontWeight'),\n      fontStyle:   _('labelFontStyle'),\n      limit:       _('labelLimit'),\n      lineHeight:  _('labelLineHeight')\n    }, {\n      align:       labelAlign,\n      baseline:    labelBaseline\n    });\n\n    const bound   = _('labelBound');\n    let overlap = _('labelOverlap');\n\n    // if overlap method or bound defined, request label overlap removal\n    overlap = overlap || bound ? {\n      separation: _('labelSeparation'),\n      method: overlap,\n      order: 'datum.index',\n      bound: bound ? {scale, orient, tolerance: bound} : null\n    } : undefined;\n\n    if (update.align !== align) {\n      update.align = patch(update.align, align);\n    }\n    if (update.baseline !== baseline) {\n      update.baseline = patch(update.baseline, baseline);\n    }\n\n    return guideMark({\n      type:  TextMark,\n      role:  AxisLabelRole,\n      style: GuideLabelStyle,\n      key:   Value,\n      from:  dataRef,\n      encode,\n      overlap\n    }, userEncode);\n  }\n\n  function axisTitle(spec, config, userEncode, dataRef) {\n    const _ = lookup(spec, config),\n          orient = spec.orient,\n          sign = getSign(orient, -1, 1);\n\n    let enter, update;\n    const encode = {\n      enter: enter = {\n        opacity: zero,\n        anchor: encoder(_('titleAnchor', null)),\n        align: {signal: alignExpr}\n      },\n      update: update = vegaUtil.extend({}, enter, {\n        opacity: one,\n        text: encoder(spec.title)\n      }),\n      exit: {\n        opacity: zero\n      }\n    };\n\n    const titlePos = {\n      signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n    };\n\n    update.x = ifX(orient, titlePos);\n    update.y = ifY(orient, titlePos);\n    enter.angle = ifX(orient, zero, mult(sign, 90));\n    enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {value: Bottom});\n    update.angle = enter.angle;\n    update.baseline = enter.baseline;\n\n    addEncoders(encode, {\n      fill:        _('titleColor'),\n      fillOpacity: _('titleOpacity'),\n      font:        _('titleFont'),\n      fontSize:    _('titleFontSize'),\n      fontStyle:   _('titleFontStyle'),\n      fontWeight:  _('titleFontWeight'),\n      limit:       _('titleLimit'),\n      lineHeight:  _('titleLineHeight')\n    }, { // require update\n      align:       _('titleAlign'),\n      angle:       _('titleAngle'),\n      baseline:    _('titleBaseline')\n    });\n\n    autoLayout(_, orient, encode, userEncode);\n    encode.update.align = patch(encode.update.align, enter.align);\n    encode.update.angle = patch(encode.update.angle, enter.angle);\n    encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n\n    return guideMark({\n      type:  TextMark,\n      role:  AxisTitleRole,\n      style: GuideTitleStyle,\n      from:  dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function autoLayout(_, orient, encode, userEncode) {\n    const auto = (value, dim) => value != null\n      ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false)\n      : !has(dim, userEncode) ? true : false;\n\n    const autoY = auto(_('titleX'), 'x'),\n          autoX = auto(_('titleY'), 'y');\n\n    encode.enter.auto = autoX === autoY\n      ? encoder(autoX)\n      : ifX(orient, encoder(autoX), encoder(autoY));\n  }\n\n  function parseAxis(spec, scope) {\n    const config = axisConfig(spec, scope),\n          encode = spec.encode || {},\n          axisEncode = encode.axis || {},\n          name = axisEncode.name || undefined,\n          interactive = axisEncode.interactive,\n          style = axisEncode.style,\n          _ = lookup(spec, config),\n          band = tickBand(_);\n\n    // single-element data source for axis group\n    const datum = {\n      scale:  spec.scale,\n      ticks:  !!_('ticks'),\n      labels: !!_('labels'),\n      grid:   !!_('grid'),\n      domain: !!_('domain'),\n      title:  spec.title != null\n    };\n    const dataRef = ref(scope.add(Collect({}, [datum])));\n\n    // data source for axis ticks\n    const ticksRef = ref(scope.add(AxisTicks({\n      scale:   scope.scaleRef(spec.scale),\n      extra:   scope.property(band.extra),\n      count:   scope.objectProperty(spec.tickCount),\n      values:  scope.objectProperty(spec.values),\n      minstep: scope.property(spec.tickMinStep),\n      formatType: scope.property(spec.formatType),\n      formatSpecifier: scope.property(spec.format)\n    })));\n\n    // generate axis marks\n    const children = [];\n    let size;\n\n    // include axis gridlines if requested\n    if (datum.grid) {\n      children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n    }\n\n    // include axis ticks if requested\n    if (datum.ticks) {\n      size = _('tickSize');\n      children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n    }\n\n    // include axis labels if requested\n    if (datum.labels) {\n      size = datum.ticks ? size : 0;\n      children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n    }\n\n    // include axis domain path if requested\n    if (datum.domain) {\n      children.push(axisDomain(spec, config, encode.domain, dataRef));\n    }\n\n    // include axis title if defined\n    if (datum.title) {\n      children.push(axisTitle(spec, config, encode.title, dataRef));\n    }\n\n    // parse axis specification\n    return parseMark(\n      guideGroup({\n        role:        AxisRole,\n        from:        dataRef,\n        encode:      extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n        marks:       children,\n        aria:        _('aria'),\n        description: _('description'),\n        zindex:      _('zindex'),\n        name,\n        interactive,\n        style\n      }),\n      scope\n    );\n  }\n\n  function buildAxisEncode(_, spec) {\n    const encode = {enter: {}, update: {}};\n\n    addEncoders(encode, {\n      orient:       _('orient'),\n      offset:       _('offset') || 0,\n      position:     value(spec.position, 0),\n      titlePadding: _('titlePadding'),\n      minExtent:    _('minExtent'),\n      maxExtent:    _('maxExtent'),\n      range:        {signal: `abs(span(range(\"${spec.scale}\")))`},\n      translate:    _('translate'),\n\n      // accessibility support\n      format:       spec.format,\n      formatType:   spec.formatType\n    });\n\n    return encode;\n  }\n\n  function parseScope(spec, scope, preprocessed) {\n    const signals = vegaUtil.array(spec.signals),\n          scales = vegaUtil.array(spec.scales);\n\n    // parse signal definitions, if not already preprocessed\n    if (!preprocessed) signals.forEach(_ => parseSignal(_, scope));\n\n    // parse cartographic projection definitions\n    vegaUtil.array(spec.projections).forEach(_ => parseProjection(_, scope));\n\n    // initialize scale references\n    scales.forEach(_ => initScale(_, scope));\n\n    // parse data sources\n    vegaUtil.array(spec.data).forEach(_ => parseData$1(_, scope));\n\n    // parse scale definitions\n    scales.forEach(_ => parseScale(_, scope));\n\n    // parse signal updates\n    (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope));\n\n    // parse axis definitions\n    vegaUtil.array(spec.axes).forEach(_ => parseAxis(_, scope));\n\n    // parse mark definitions\n    vegaUtil.array(spec.marks).forEach(_ => parseMark(_, scope));\n\n    // parse legend definitions\n    vegaUtil.array(spec.legends).forEach(_ => parseLegend(_, scope));\n\n    // parse title, if defined\n    if (spec.title) parseTitle(spec.title, scope);\n\n    // parse collected lambda (anonymous) expressions\n    scope.parseLambdas();\n\n    return scope;\n  }\n\n  const rootEncode = spec => extendEncode(\n    {\n      enter: {\n        x: {value: 0},\n        y: {value: 0}\n      },\n      update: {\n        width: {signal: 'width'},\n        height: {signal: 'height'}\n      }\n    },\n    spec\n  );\n\n  function parseView(spec, scope) {\n    const config = scope.config;\n\n    // add scenegraph root\n    const root = ref(scope.root = scope.add(operator()));\n\n    // parse top-level signal definitions\n    const signals = collectSignals(spec, config);\n    signals.forEach(_ => parseSignal(_, scope));\n\n    // assign description, event, legend, and locale configuration\n    scope.description = spec.description || config.description;\n    scope.eventConfig = config.events;\n    scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n    scope.locale = config.locale;\n\n    // store root group item\n    const input = scope.add(Collect());\n\n    // encode root group item\n    const encode = scope.add(Encode(parseEncode(\n      rootEncode(spec.encode), GroupMark, FrameRole,\n      spec.style, scope, {pulse: ref(input)}\n    )));\n\n    // perform view layout\n    const parent = scope.add(ViewLayout({\n      layout:   scope.objectProperty(spec.layout),\n      legends:  scope.legends,\n      autosize: scope.signalRef('autosize'),\n      mark:     root,\n      pulse:    ref(encode)\n    }));\n    scope.operators.pop();\n\n    // parse remainder of specification\n    scope.pushState(ref(encode), ref(parent), null);\n    parseScope(spec, scope, signals);\n    scope.operators.push(parent);\n\n    // bound / render / sieve root item\n    let op = scope.add(Bound({mark: root, pulse: ref(parent)}));\n    op = scope.add(Render({pulse: ref(op)}));\n    op = scope.add(Sieve({pulse: ref(op)}));\n\n    // track metadata for root item\n    scope.addData('root', new DataScope(scope, input, input, op));\n\n    return scope;\n  }\n\n  function signalObject(name, value) {\n    return value && value.signal\n      ? { name, update: value.signal }\n      : { name, value };\n  }\n\n  /**\n   * Collect top-level signals, merging values as needed. Signals\n   * defined in the config signals arrays are added only if that\n   * signal is not explicitly defined in the specification.\n   * Built-in signals (autosize, background, padding, width, height)\n   * receive special treatment. They are initialized using the\n   * top-level spec property, or, if undefined in the spec, using\n   * the corresponding top-level config property. If this property\n   * is a signal reference object, the signal expression maps to the\n   * signal 'update' property. If the spec's top-level signal array\n   * contains an entry that matches a built-in signal, that entry\n   * will be merged with the built-in specification, potentially\n   * overwriting existing 'value' or 'update' properties.\n   */\n  function collectSignals(spec, config) {\n    const _ = name => value(spec[name], config[name]),\n          signals = [\n            signalObject('background', _('background')),\n            signalObject('autosize', parseAutosize(_('autosize'))),\n            signalObject('padding', parsePadding(_('padding'))),\n            signalObject('width', _('width') || 0),\n            signalObject('height', _('height') || 0)\n          ],\n          pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n          map = {};\n\n    // add spec signal array\n    vegaUtil.array(spec.signals).forEach(s => {\n      if (vegaUtil.hasOwnProperty(pre, s.name)) {\n        // merge if built-in signal\n        s = vegaUtil.extend(pre[s.name], s);\n      } else {\n        // otherwise add to signal list\n        signals.push(s);\n      }\n      map[s.name] = s;\n    });\n\n    // add config signal array\n    vegaUtil.array(config.signals).forEach(s => {\n      if (!vegaUtil.hasOwnProperty(map, s.name) && !vegaUtil.hasOwnProperty(pre, s.name)) {\n        // add to signal list if not already defined\n        signals.push(s);\n      }\n    });\n\n    return signals;\n  }\n\n  function Scope$1(config, options) {\n    this.config = config || {};\n    this.options = options || {};\n\n    this.bindings = [];\n    this.field = {};\n    this.signals = {};\n    this.lambdas = {};\n    this.scales = {};\n    this.events = {};\n    this.data = {};\n\n    this.streams = [];\n    this.updates = [];\n    this.operators = [];\n    this.eventConfig = null;\n    this.locale = null;\n\n    this._id = 0;\n    this._subid = 0;\n    this._nextsub = [0];\n\n    this._parent = [];\n    this._encode = [];\n    this._lookup = [];\n    this._markpath = [];\n  }\n\n  function Subscope(scope) {\n    this.config = scope.config;\n    this.options = scope.options;\n    this.legends = scope.legends;\n\n    this.field = Object.create(scope.field);\n    this.signals = Object.create(scope.signals);\n    this.lambdas = Object.create(scope.lambdas);\n    this.scales = Object.create(scope.scales);\n    this.events = Object.create(scope.events);\n    this.data = Object.create(scope.data);\n\n    this.streams = [];\n    this.updates = [];\n    this.operators = [];\n\n    this._id = 0;\n    this._subid = ++scope._nextsub[0];\n    this._nextsub = scope._nextsub;\n\n    this._parent = scope._parent.slice();\n    this._encode = scope._encode.slice();\n    this._lookup = scope._lookup.slice();\n    this._markpath = scope._markpath;\n  }\n\n  Scope$1.prototype = Subscope.prototype = {\n    parse(spec) {\n      return parseScope(spec, this);\n    },\n\n    fork() {\n      return new Subscope(this);\n    },\n\n    isSubscope() {\n      return this._subid > 0;\n    },\n\n    toRuntime() {\n      this.finish();\n      return {\n        description: this.description,\n        operators:   this.operators,\n        streams:     this.streams,\n        updates:     this.updates,\n        bindings:    this.bindings,\n        eventConfig: this.eventConfig,\n        locale:      this.locale\n      };\n    },\n\n    id() {\n      return (this._subid ? this._subid + ':' : 0) + this._id++;\n    },\n\n    add(op) {\n      this.operators.push(op);\n      op.id = this.id();\n      // if pre-registration references exist, resolve them now\n      if (op.refs) {\n        op.refs.forEach(ref => { ref.$ref = op.id; });\n        op.refs = null;\n      }\n      return op;\n    },\n\n    proxy(op) {\n      const vref = op instanceof Entry ? ref(op) : op;\n      return this.add(Proxy({value: vref}));\n    },\n\n    addStream(stream) {\n      this.streams.push(stream);\n      stream.id = this.id();\n      return stream;\n    },\n\n    addUpdate(update) {\n      this.updates.push(update);\n      return update;\n    },\n\n    // Apply metadata\n    finish() {\n      let name, ds;\n\n      // annotate root\n      if (this.root) this.root.root = true;\n\n      // annotate signals\n      for (name in this.signals) {\n        this.signals[name].signal = name;\n      }\n\n      // annotate scales\n      for (name in this.scales) {\n        this.scales[name].scale = name;\n      }\n\n      // annotate data sets\n      function annotate(op, name, type) {\n        let data, list;\n        if (op) {\n          data = op.data || (op.data = {});\n          list = data[name] || (data[name] = []);\n          list.push(type);\n        }\n      }\n      for (name in this.data) {\n        ds = this.data[name];\n        annotate(ds.input,  name, 'input');\n        annotate(ds.output, name, 'output');\n        annotate(ds.values, name, 'values');\n        for (const field in ds.index) {\n          annotate(ds.index[field], name, 'index:' + field);\n        }\n      }\n\n      return this;\n    },\n\n    // ----\n\n    pushState(encode, parent, lookup) {\n      this._encode.push(ref(this.add(Sieve({pulse: encode}))));\n      this._parent.push(parent);\n      this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n      this._markpath.push(-1);\n    },\n\n    popState() {\n      this._encode.pop();\n      this._parent.pop();\n      this._lookup.pop();\n      this._markpath.pop();\n    },\n\n    parent() {\n      return vegaUtil.peek(this._parent);\n    },\n\n    encode() {\n      return vegaUtil.peek(this._encode);\n    },\n\n    lookup() {\n      return vegaUtil.peek(this._lookup);\n    },\n\n    markpath() {\n      const p = this._markpath;\n      return ++p[p.length-1];\n    },\n\n    // ----\n\n    fieldRef(field, name) {\n      if (vegaUtil.isString(field)) return fieldRef(field, name);\n      if (!field.signal) {\n        vegaUtil.error('Unsupported field reference: ' + vegaUtil.stringValue(field));\n      }\n\n      const s = field.signal;\n      let f = this.field[s];\n\n      if (!f) {\n        const params = {name: this.signalRef(s)};\n        if (name) params.as = name;\n        this.field[s] = f = ref(this.add(Field(params)));\n      }\n      return f;\n    },\n\n    compareRef(cmp) {\n      let signal = false;\n\n      const check = _ => isSignal(_)\n        ? (signal = true, this.signalRef(_.signal))\n        : isExpr(_) ? (signal = true, this.exprRef(_.expr))\n        : _;\n\n      const fields = vegaUtil.array(cmp.field).map(check),\n            orders = vegaUtil.array(cmp.order).map(check);\n\n      return signal\n        ? ref(this.add(Compare({fields: fields, orders: orders})))\n        : compareRef(fields, orders);\n    },\n\n    keyRef(fields, flat) {\n      let signal = false;\n\n      const check = _ => isSignal(_)\n        ? (signal = true, ref(sig[_.signal]))\n        : _;\n\n      const sig = this.signals;\n      fields = vegaUtil.array(fields).map(check);\n\n      return signal\n        ? ref(this.add(Key({fields: fields, flat: flat})))\n        : keyRef(fields, flat);\n    },\n\n    sortRef(sort) {\n      if (!sort) return sort;\n\n      // including id ensures stable sorting\n      const a = aggrField(sort.op, sort.field),\n           o = sort.order || Ascending;\n\n      return o.signal\n        ? ref(this.add(Compare({\n            fields: a,\n            orders: this.signalRef(o.signal)\n          })))\n        : compareRef(a, o);\n    },\n\n    // ----\n\n    event(source, type) {\n      const key = source + ':' + type;\n      if (!this.events[key]) {\n        const id = this.id();\n        this.streams.push({\n          id: id,\n          source: source,\n          type: type\n        });\n        this.events[key] = id;\n      }\n      return this.events[key];\n    },\n\n    // ----\n\n    hasOwnSignal(name) {\n      return vegaUtil.hasOwnProperty(this.signals, name);\n    },\n\n    addSignal(name, value) {\n      if (this.hasOwnSignal(name)) {\n        vegaUtil.error('Duplicate signal name: ' + vegaUtil.stringValue(name));\n      }\n      const op = value instanceof Entry ? value : this.add(operator(value));\n      return this.signals[name] = op;\n    },\n\n    getSignal(name) {\n      if (!this.signals[name]) {\n        vegaUtil.error('Unrecognized signal name: ' + vegaUtil.stringValue(name));\n      }\n      return this.signals[name];\n    },\n\n    signalRef(s) {\n      if (this.signals[s]) {\n        return ref(this.signals[s]);\n      } else if (!vegaUtil.hasOwnProperty(this.lambdas, s)) {\n        this.lambdas[s] = this.add(operator(null));\n      }\n      return ref(this.lambdas[s]);\n    },\n\n    parseLambdas() {\n      const code = Object.keys(this.lambdas);\n      for (let i=0, n=code.length; i<n; ++i) {\n        const s = code[i],\n              e = vegaFunctions.parseExpression(s, this),\n              op = this.lambdas[s];\n        op.params = e.$params;\n        op.update = e.$expr;\n      }\n    },\n\n    property(spec) {\n      return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n    },\n\n    objectProperty(spec) {\n      return (!spec || !vegaUtil.isObject(spec)) ? spec\n        : this.signalRef(spec.signal || propertyLambda(spec));\n    },\n\n    exprRef(code, name) {\n      const params = {expr: vegaFunctions.parseExpression(code, this)};\n      if (name) params.expr.$name = name;\n      return ref(this.add(Expression(params)));\n    },\n\n    addBinding(name, bind) {\n      if (!this.bindings) {\n        vegaUtil.error('Nested signals do not support binding: ' + vegaUtil.stringValue(name));\n      }\n      this.bindings.push(vegaUtil.extend({signal: name}, bind));\n    },\n\n    // ----\n\n    addScaleProj(name, transform) {\n      if (vegaUtil.hasOwnProperty(this.scales, name)) {\n        vegaUtil.error('Duplicate scale or projection name: ' + vegaUtil.stringValue(name));\n      }\n      this.scales[name] = this.add(transform);\n    },\n\n    addScale(name, params) {\n      this.addScaleProj(name, Scale(params));\n    },\n\n    addProjection(name, params) {\n      this.addScaleProj(name, Projection(params));\n    },\n\n    getScale(name) {\n      if (!this.scales[name]) {\n        vegaUtil.error('Unrecognized scale name: ' + vegaUtil.stringValue(name));\n      }\n      return this.scales[name];\n    },\n\n    scaleRef(name) {\n      return ref(this.getScale(name));\n    },\n\n    scaleType(name) {\n      return this.getScale(name).params.type;\n    },\n\n    projectionRef(name) {\n      return this.scaleRef(name);\n    },\n\n    projectionType(name) {\n      return this.scaleType(name);\n    },\n\n    // ----\n\n    addData(name, dataScope) {\n      if (vegaUtil.hasOwnProperty(this.data, name)) {\n        vegaUtil.error('Duplicate data set name: ' + vegaUtil.stringValue(name));\n      }\n      return (this.data[name] = dataScope);\n    },\n\n    getData(name) {\n      if (!this.data[name]) {\n        vegaUtil.error('Undefined data set name: ' + vegaUtil.stringValue(name));\n      }\n      return this.data[name];\n    },\n\n    addDataPipeline(name, entries) {\n      if (vegaUtil.hasOwnProperty(this.data, name)) {\n        vegaUtil.error('Duplicate data set name: ' + vegaUtil.stringValue(name));\n      }\n      return this.addData(name, DataScope.fromEntries(this, entries));\n    }\n  };\n\n  function propertyLambda(spec) {\n    return (vegaUtil.isArray(spec) ? arrayLambda : objectLambda)(spec);\n  }\n\n  function arrayLambda(array) {\n    const n = array.length;\n    let code = '[';\n\n    for (let i = 0; i<n; ++i) {\n      const value = array[i];\n      code += (i > 0 ? ',' : '')\n        + (vegaUtil.isObject(value)\n          ? (value.signal || propertyLambda(value))\n          : vegaUtil.stringValue(value));\n    }\n    return code + ']';\n  }\n\n  function objectLambda(obj) {\n    let code = '{',\n        i = 0,\n        key, value;\n\n    for (key in obj) {\n      value = obj[key];\n      code += (++i > 1 ? ',' : '')\n        + vegaUtil.stringValue(key) + ':'\n        + (vegaUtil.isObject(value)\n          ? (value.signal || propertyLambda(value))\n          : vegaUtil.stringValue(value));\n    }\n    return code + '}';\n  }\n\n  /**\n   * Standard configuration defaults for Vega specification parsing.\n   * Users can provide their own (sub-)set of these default values\n   * by passing in a config object to the top-level parse method.\n   */\n  function defaults() {\n    const defaultFont = 'sans-serif',\n          defaultSymbolSize = 30,\n          defaultStrokeWidth = 2,\n          defaultColor = '#4c78a8',\n          black = '#000',\n          gray = '#888',\n          lightGray = '#ddd';\n\n    return {\n      // default visualization description\n      description: 'Vega visualization',\n\n      // default padding around visualization\n      padding: 0,\n\n      // default for automatic sizing; options: 'none', 'pad', 'fit'\n      // or provide an object (e.g., {'type': 'pad', 'resize': true})\n      autosize: 'pad',\n\n      // default view background color\n      // covers the entire view component\n      background: null,\n\n      // default event handling configuration\n      // preventDefault for view-sourced event types except 'wheel'\n      events: {\n        defaults: {allow: ['wheel']}\n      },\n\n      // defaults for top-level group marks\n      // accepts mark properties (fill, stroke, etc)\n      // covers the data rectangle within group width/height\n      group: null,\n\n      // defaults for basic mark types\n      // each subset accepts mark properties (fill, stroke, etc)\n      mark: null,\n      arc: {\n        fill: defaultColor\n      },\n      area: {\n        fill: defaultColor\n      },\n      image: null,\n      line: {\n        stroke: defaultColor,\n        strokeWidth: defaultStrokeWidth\n      },\n      path: {\n        stroke: defaultColor\n      },\n      rect: {\n        fill: defaultColor\n      },\n      rule: {\n        stroke: black\n      },\n      shape: {\n        stroke: defaultColor\n      },\n      symbol: {\n        fill: defaultColor,\n        size: 64\n      },\n      text: {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11\n      },\n      trail: {\n        fill: defaultColor,\n        size: defaultStrokeWidth\n      },\n\n      // style definitions\n      style: {\n        // axis & legend labels\n        'guide-label': {\n          fill: black,\n          font: defaultFont,\n          fontSize: 10\n        },\n        // axis & legend titles\n        'guide-title': {\n          fill: black,\n          font: defaultFont,\n          fontSize: 11,\n          fontWeight: 'bold'\n        },\n        // headers, including chart title\n        'group-title': {\n          fill: black,\n          font: defaultFont,\n          fontSize: 13,\n          fontWeight: 'bold'\n        },\n        // chart subtitle\n        'group-subtitle': {\n          fill: black,\n          font: defaultFont,\n          fontSize: 12\n        },\n        // defaults for styled point marks in Vega-Lite\n        point: {\n          size: defaultSymbolSize,\n          strokeWidth: defaultStrokeWidth,\n          shape: 'circle'\n        },\n        circle: {\n          size: defaultSymbolSize,\n          strokeWidth: defaultStrokeWidth\n        },\n        square: {\n          size: defaultSymbolSize,\n          strokeWidth: defaultStrokeWidth,\n          shape: 'square'\n        },\n        // defaults for styled group marks in Vega-Lite\n        cell: {\n          fill: 'transparent',\n          stroke: lightGray\n        }\n      },\n\n      // defaults for title\n      title: {\n        orient: 'top',\n        anchor: 'middle',\n        offset: 4,\n        subtitlePadding: 3\n      },\n\n      // defaults for axes\n      axis: {\n        minExtent: 0,\n        maxExtent: 200,\n        bandPosition: 0.5,\n        domain: true,\n        domainWidth: 1,\n        domainColor: gray,\n        grid: false,\n        gridWidth: 1,\n        gridColor: lightGray,\n        labels: true,\n        labelAngle: 0,\n        labelLimit: 180,\n        labelOffset: 0,\n        labelPadding: 2,\n        ticks: true,\n        tickColor: gray,\n        tickOffset: 0,\n        tickRound: true,\n        tickSize: 5,\n        tickWidth: 1,\n        titlePadding: 4\n      },\n\n      // correction for centering bias\n      axisBand: {\n        tickOffset: -0.5\n      },\n\n      // defaults for cartographic projection\n      projection: {\n        type: 'mercator'\n      },\n\n      // defaults for legends\n      legend: {\n        orient: 'right',\n        padding: 0,\n        gridAlign: 'each',\n        columnPadding: 10,\n        rowPadding: 2,\n        symbolDirection: 'vertical',\n        gradientDirection: 'vertical',\n        gradientLength: 200,\n        gradientThickness: 16,\n        gradientStrokeColor: lightGray,\n        gradientStrokeWidth: 0,\n        gradientLabelOffset: 2,\n        labelAlign: 'left',\n        labelBaseline: 'middle',\n        labelLimit: 160,\n        labelOffset: 4,\n        labelOverlap: true,\n        symbolLimit: 30,\n        symbolType: 'circle',\n        symbolSize: 100,\n        symbolOffset: 0,\n        symbolStrokeWidth: 1.5,\n        symbolBaseFillColor: 'transparent',\n        symbolBaseStrokeColor: gray,\n        titleLimit: 180,\n        titleOrient: 'top',\n        titlePadding: 5,\n        layout: {\n          offset: 18,\n          direction: 'horizontal',\n          left:   { direction: 'vertical' },\n          right:  { direction: 'vertical' }\n        }\n      },\n\n      // defaults for scale ranges\n      range: {\n        category: {\n          scheme: 'tableau10'\n        },\n        ordinal: {\n          scheme: 'blues'\n        },\n        heatmap: {\n          scheme: 'yellowgreenblue'\n        },\n        ramp: {\n          scheme: 'blues'\n        },\n        diverging: {\n          scheme: 'blueorange',\n          extent: [1, 0]\n        },\n        symbol: [\n          'circle',\n          'square',\n          'triangle-up',\n          'cross',\n          'diamond',\n          'triangle-right',\n          'triangle-down',\n          'triangle-left'\n        ]\n      }\n    };\n  }\n\n  function parse$1(spec, config, options) {\n    if (!vegaUtil.isObject(spec)) {\n      vegaUtil.error('Input Vega specification must be an object.');\n    }\n\n    config = vegaUtil.mergeConfig(defaults(), config, spec.config);\n    return parseView(spec, new Scope$1(config, options)).toRuntime();\n  }\n\n  exports.AxisDomainRole = AxisDomainRole;\n  exports.AxisGridRole = AxisGridRole;\n  exports.AxisLabelRole = AxisLabelRole;\n  exports.AxisRole = AxisRole;\n  exports.AxisTickRole = AxisTickRole;\n  exports.AxisTitleRole = AxisTitleRole;\n  exports.DataScope = DataScope;\n  exports.FrameRole = FrameRole;\n  exports.LegendEntryRole = LegendEntryRole;\n  exports.LegendLabelRole = LegendLabelRole;\n  exports.LegendRole = LegendRole;\n  exports.LegendSymbolRole = LegendSymbolRole;\n  exports.LegendTitleRole = LegendTitleRole;\n  exports.MarkRole = MarkRole;\n  exports.Scope = Scope$1;\n  exports.ScopeRole = ScopeRole;\n  exports.config = defaults;\n  exports.parse = parse$1;\n  exports.signal = parseSignal;\n  exports.signalUpdates = parseSignalUpdates;\n  exports.stream = parseStream;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vega_dataflow$build$vega_dataflow","~$module$node_modules$vega_event_selector$build$vega_event_selector","~$module$node_modules$vega_scale$build$vega_scale","~$shadow.js","~$module$node_modules$vega_util$build$vega_util","~$module$node_modules$vega_functions$build$vega_functions"]],"~:properties",["^5",["tickColor","trail","stop","interactive","role","schemeExtent","range","consume","symbolOffset","separation","stream","$field","values","$value","min","bindings","boundScale","hasOwnSignal","lambdas","width","rule","domainWidth","rangeStep","url","debounce","right","expr","getData","$compare","align","columnPadding","top","addUpdate","output","symbolStrokeWidth","interpolate","legends","gradient","index","config","subflow","ordinal","aria","offset","translate","strokeDashOffset","$output","$params","$ingest","params","labelOverlap","columns","minstep","strokeCap","parseLambdas","prototype","height","labelBaseline","exprRef","LegendSymbolRole","initonly","compareRef","vgrad","shape","scale","grid","area","_parent","markpath","_anchor","_lookup","group","titlePadding","clip","_nextsub","image","symbolBaseStrokeColor","autosize","MarkRole","updates","keyRef","signalUpdates","fontStyle","AxisTickRole","fontWeight","$name","ops","method","cornerRadius","lineHeight","key","parent","gridWidth","tickOffset","gradientStrokeWidth","x","overlap","AxisDomainRole","__esModule","dx","force","labelOffset","flat","getSignal","max","path","gridColor","LegendRole","padding","$fields","strokeDash","axis","cell","orient","addSignal","groupby","id","datum","$expr","legend","lookup","gradientLabelOffset","root","projectionRef","vega","addProjection","event","band","count","update","counts","derive","gradientStrokeColor","domainRef","mult","marks","markdef","sort","async","agg","anchor","operators","allow","signal","angle","heatmap","position","pulse","name","$order","locale","limit","scales","stroke","style","$ref","_markpath","labels","signals","value","interval","center","eventConfig","aggregate","auto","AxisLabelRole","symbolSize","signalRef","encoders","context","direction","AxisGridRole","getScale","field","finish","start","axisBand","labelAlign","text","$context","fill","$format","fontSize","fieldRef","strokeWidth","layout","scope","scaleType","minExtent","formatSpecifier","ScopeRole","tolerance","boundOrient","domain","strokeOpacity","baseline","symbolLimit","gradientDirection","filter","symbol","property","interpolateGamma","bandPosition","metadata","diverging","font","addStream","sortRef","tickSize","gradientLength","arc","addDataPipeline","events","input","addScale","line","titleLimit","LegendLabelRole","ticks","projectionType","order","column","mod","title","$flat","square","labelLimit","source","symbolDirection","type","row","projection","extents","y","schemeCount","between","LegendEntryRole","AxisRole","lookupRef","$key","x2","ref","fields","_id","from","marktype","target","addScaleProj","AxisTitleRole","dy","tuplesRef","isVertical","_encode","bound","parse","exit","isSubscope","y2","gradientThickness","extra","$subflow","entryColumns","add","fillOpacity","extentRef","noBound","bottom","bins","rect","symbolType","clean","category","facet","size","fork","subtitlePadding","indataRef","popState","titleOrient","pushState","formatType","frame","proxy","tickWidth","DataScope","maxExtent","mark","options","fromEntries","valuesRef","toRuntime","$request","addBinding","circle","round","LegendTitleRole","react","tickRound","ast","rowPadding","data","background","merge","throttle","boundTolerance","labelAngle","extent","encode","enter","scheme","$encode","objectProperty","addData","as","countsRef","code","opacity","groups","Scope","defaults","gridAlign","FrameRole","point","_subid","zindex","left","description","streams","orders","labelPadding","ramp","symbolBaseFillColor","test","nice","format","domainColor","scaleRef","channels","step","refs"]],"~:compiled-at",1600144480050,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_parser$build$vega_parser.js\",\n\"lineCount\":148,\n\"mappings\":\"AAAAA,cAAA,CAAe,iDAAf,CAAsE,QAAQ,CAACC,eAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,gBAAvB,CAAgC,CAC7G,SAAS,CAACH,MAAD,CAASI,OAAT,CAAkB,CACP,QAAnB,GAAA,MAAOD,iBAAP,EAAiD,WAAjD,GAA+B,MAAOD,OAAtC,CAA+DE,OAAA,CAAQD,gBAAR,CAAiBF,OAAA,CAAQ,+CAAR,CAAjB,CAAuCA,OAAA,CAAQ,yDAAR,CAAvC,CAAkEA,OAAA,CAAQ,mEAAR,CAAlE,CAAkGA,OAAA,CAAQ,iDAAR,CAAlG,CAAyHA,OAAA,CAAQ,uDAAR,CAAzH,CAA/D;AACkB,UAAlB,GAAA,MAAOI,OAAP,EAAgCA,MAAhC,CAAuCC,GAAvC,CAA6CD,MAAA,CAAO,+EAAA,CAAA,KAAA,CAAA,GAAA,CAAP,CAAyGD,OAAzG,CAA7C,EACCJ,MAAA,CAA+B,WAAtB,GAAA,MAAOO,WAAP,CAAoCA,UAApC,CAAiDP,MAAjD,EAA2DQ,IAApE,CAA0EJ,OAAA,CAAQJ,MAAR,CAAeS,IAAf,CAAsB,EAAtB,CAA0BT,MAA1B,CAAiCS,IAAjC,CAAuCT,MAAvC,CAA8CS,IAA9C,CAAoDT,MAApD,CAA2DS,IAA3D,CAAiET,MAAjE,CAAwES,IAAxE,CAA8ET,MAA9E,CAAqFS,IAArF,CAD3E,CAF0B,CAA3B,CAAA,CAIC,IAJD,CAIQ,QAAS,CAACN,OAAD,CAAUO,QAAV,CAAoBC,aAApB,CAAmCC,iBAAnC,CAAsDC,SAAtD,CAAiEC,YAAjE,CAA+E,CAE/FC,QAASA,cAAa,CAACC,IAAD,CAAO,CAC3B,MAAON,SAAA,CAASO,QAAT,CAAkBD,IAAlB,CAAA,CAA0BA,IAA1B,CAAiC,CAACE,KAAMF,IAANE,EAAc,KAAf,CADb,CAQ7BC,QAASA,aAAY,CAACH,IAAD,CAAO,CAClBN,QAAA,CAASO,QAAT,CAAkBD,IAAlB,CAAD;AACH,IADG,CACH,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAAA,IANc,CAMd,IANc,CAMdI,GAAA,EANoB,CAMpB,CAAA,OANc,CAMd,IANc,CAMdA,MAAA,EANoB,CAMpB,CAAA,KANc,CAMd,IANc,CAMdA,IAAA,EANoB,CAMpB,CAAA,MANc,CAMd,IANc,CAMdA,KAAA,EANoB,CAMpB,CADG,EALW,IAEQ,CAFR,CAKgBA,IAHR,EAFF,CAEE,CAAA,IAAA,CAAA,CAACC,IAAKD,IAAN,CAASE,OAAQF,IAAjB,CAAoBG,KAAMH,IAA1B,CAA6BI,MAAOJ,IAApC,CAGnB,CAAP,OAAO,KADmB,CAe5BK,QAASA,UAAS,CAACC,MAAD,CAASC,IAAT,CAAeC,KAAf,CAAsBC,GAAtB,CAA2B,CAC3C,MAAa,KAAb,EAAID,KAAJ,EAEKlB,QAAA,CAASO,QAAT,CAAkBW,KAAlB,CAKH,EAL+B,CAAClB,QAAA,CAASoB,OAAT,CAAiBF,KAAjB,CAKhC,EAJGlB,QAAA,CAASoB,OAAT,CAAiBF,KAAjB,CAIH,EAJ8BA,KAI9B,CAJoCG,MAIpC,EAJ8CrB,QAAA,CAASO,QAAT,CAAkBW,KAAA,CAAM,CAAN,CAAlB,CAI9C,CACEF,MAAA,CAAOM,MAAP,CAAcL,IAAd,CADF,CACwBC,KADxB,CAGEF,MAAA,CAAOG,GAAP,EAAc,OAAd,CAAA,CAAuBF,IAAvB,CAHF,CAGiC,CAACC,MAAOA,KAAR,CAE1B,CAAA,CAZT,EAcS,CAfkC,CAmB7CK,QAASA,YAAW,CAACP,MAAD,CAASQ,KAAT,CAAgBF,MAAhB,CAAwB,CAC1C,IAAKL,IAAMA,IAAX,GAAmBO,MAAnB,CACET,SAAA,CAAUC,MAAV;AAAkBC,IAAlB,CAAwBO,KAAA,CAAMP,IAAN,CAAxB,CAEF,KAAKA,IAAMA,QAAX,GAAmBK,OAAnB,CACEP,SAAA,CAAUC,MAAV,CAAkBC,QAAlB,CAAwBK,MAAA,CAAOL,QAAP,CAAxB,CAAsC,QAAtC,CALwC,CAS5CQ,QAASA,aAAY,CAACC,MAAD,CAASC,KAAT,CAAgBC,IAAhB,CAAsB,CACzC,IAAKX,IAAMA,IAAX,GAAmBU,MAAnB,CACMC,IAAJ,EAAY5B,QAAA,CAAS6B,cAAT,CAAwBD,IAAxB,CAA8BX,IAA9B,CAAZ,GACAS,MAAA,CAAOT,IAAP,CADA,CACejB,QAAA,CAAS8B,MAAT,CAAgBJ,MAAA,CAAOT,IAAP,CAAhB,EAAgC,EAAhC,CAAoCU,KAAA,CAAMV,IAAN,CAApC,CADf,CAGF,OAAOS,OALkC,CAQ3CK,QAASA,IAAG,CAACC,GAAD,CAAMN,MAAN,CAAc,CACxB,MAAOA,OAAP,GACGA,MADH,CACUF,KADV,EACmBE,MAAA,CAAOF,KAAP,CAAaQ,GAAb,CADnB,EAEGN,MAFH,CAEUJ,MAFV,EAEoBI,MAAA,CAAOJ,MAAP,CAAcU,GAAd,CAFpB,CADwB,CA8B1BC,QAASA,cAAa,CAACP,MAAD,CAASlB,IAAT,CAAe0B,IAAf,CAAqBC,KAArB,CAA4BC,MAA5B,CAAoC,CACxD,IAAMC,SAAW,EAAjB,CAAqBb,MAAQ,EAA7B,CACIF,MAGJ,KAAAU,IAAM,WACO,OAAb;AAAIxB,IAAJ,EAAsC,IAAtC,EAAuB4B,MAAA,CAAOJ,GAAP,CAAvB,EAA+CD,GAAA,CAAIC,GAAJ,CAASN,MAAT,CAA/C,EACEY,YAAA,CAAaD,QAAb,CAAuBL,GAAvB,CAA4BI,MAAA,CAAOJ,GAAP,CAA5B,CAIF,IAAY,QAAZ,EAAIE,IAAJ,EAAwBK,MAAA,CAAOL,IAAP,CAAA,CAAaM,UAAb,CAAwB,MAAxB,CAAxB,CACEN,IAAA,CAAO,IAITO,KAAA,CAtCgBC,OAsCR,GAAAR,IAAA,CAAqBE,MAArB,CAA4BO,KAA5B,CAvCOC,MAwCX,GAACV,IAAD,CAAsBlC,QAAA,CAAS8B,MAAT,CAAgB,EAAhB,CAAoBM,MAApB,CAA2BS,IAA3B,CAAiCT,MAAA,CAAO5B,IAAP,CAAjC,CAAtB,CACA,IAEJ,KAAKwB,GAAL,GAAYS,KAAZ,CAME,CAJAb,IAIA,CAJOG,GAAA,CAAIC,GAAJ,CAASN,MAAT,CAIP,GAHc,MAGd,GAHMM,GAGN,EAHgC,QAGhC,GAHwBA,GAGxB,IAFMD,GAAA,CAAI,MAAJ,CAAYL,MAAZ,CAEN,EAF6BK,GAAA,CAAI,QAAJ,CAAcL,MAAd,CAE7B,IAAWY,YAAA,CAAaD,QAAb,CAAuBL,GAAvB,CAA4BS,IAAA,CAAMT,GAAN,CAA5B,CAIbhC,SAAA,CAAS8C,KAAT,CAAeX,KAAf,CAAA,CAAsBY,OAAtB,CAA8B,QAAA,CAAA9B,IAAA,CAAQ,CAC9BwB,IAAAA,CAAQL,MAARK,CAAeN,KAAfM,EAAwBL,MAAA,CAAOD,KAAP,CAAalB,IAAb,CAC9B,KAAKe,IAAMA,OAAX,GAAkBS,KAAlB,CACOV,GAAA,CAAIC,OAAJ;AAASN,MAAT,CAAL,EACEY,YAAA,CAAaD,QAAb,CAAuBL,OAAvB,CAA4BS,IAAA,CAAMT,OAAN,CAA5B,CAJgC,CAAtC,CASAN,OAAA,CAAS1B,QAAA,CAAS8B,MAAT,CAAgB,EAAhB,CAAoBJ,MAApB,CACT,KAAKM,GAAL,GAAYK,SAAZ,CACEI,IACA,CADQJ,QAAA,CAASL,GAAT,CACR,CAAIS,IAAJ,CAAUO,MAAV,CACE,CAAC1B,MAAD,CAAUA,MAAV,EAAoB,EAApB,EAAwBU,GAAxB,CADF,CACiCS,IADjC,CAGEjB,KAAA,CAAMQ,GAAN,CAHF,CAGeS,IAIjBf,OAAA,CAAOF,KAAP,CAAexB,QAAA,CAAS8B,MAAT,CAAgBN,KAAhB,CAAuBE,MAAvB,CAA8BF,KAA9B,CACXF,OAAJ,GAAYI,MAAZ,CAAmBJ,MAAnB,CAA4BtB,QAAA,CAAS8B,MAAT,CAAgBR,MAAhB,CAAwBI,MAAxB,CAA+BJ,MAA/B,CAA5B,CAEA,OAAOI,OApDiD,CAuD1DY,QAASA,aAAY,CAACD,QAAD,CAAWL,GAAX,CAAgBd,KAAhB,CAAuB,CAC1CmB,QAAA,CAASL,GAAT,CAAA,CAAgBd,KAAA,EAASA,KAAT,CAAe8B,MAAf,CACZ,CAACA,OAAQ9B,KAAR8B,CAAcA,MAAf,CADY,CAEZ,CAAC9B,MAAOA,KAAR,CAHsC,CAU5C+B,QAASA,eAAK,CAACC,GAAD,CAAM,CAClB,GAAoB,IAApB,EAAIA,GAAJ,CAAQC,QAAR,CACE,MAAOA,SAAA,CAASD,GAAT,CAGG,IAAAA,GAAA,CAAIF,MAAJ,CAAa,IAAA;AAAA,GAAA,CAAA,GAAA,CAAA,MAAA,CAAA,GAAb,KACR,IAAA,CAAA,KAAA,EAAA,eAoCJ,CApCI,GAoCJ,CApCI,KAoCJ,CAAA,eAAA,CAAQE,eAAD,CAAKE,CAAL,CAAUC,MAAA,CAAO,KAAP,CAAcH,eAAd,CAAkBI,CAAlB,CAAqBJ,eAArB,CAAyBE,CAAzB,CAA4BF,eAA5B,CAAgCK,CAAhC,CAAV,CACFL,eAAD,CAAKI,CAAL,EAAUJ,eAAV,CAAcM,CAAd,CAAmBH,MAAA,CAAO,KAAP,CAAcH,eAAd,CAAkBI,CAAlB,CAAqBJ,eAArB,CAAyBM,CAAzB,CAA4BN,eAA5B,CAAgCK,CAAhC,CAAnB,CACCL,eAAD,CAAKK,CAAL,EAAUL,eAAV,CAAcO,CAAd,CAAmBJ,MAAA,CAAO,KAAP,CAAcH,eAAd,CAAkBK,CAAlB,CAAqBL,eAArB,CAAyBO,CAAzB,CAA4BP,eAA5B,CAAgCQ,CAAhC,CAAnB,CACCR,eAAD,CAAKS,CAAL,EAAUT,eAAV,CAAcU,CAAd,EAAmBV,eAAnB,CAAuBQ,CAAvB,CAA4BL,MAAA,CAAO,KAAP,CAAcH,eAAd,CAAkBS,CAAlB,CAAqBT,eAArB,CAAyBU,CAAzB,CAA4BV,eAA5B,CAAgCQ,CAAhC,CAA5B,CACA,IAxCA;AAAA,eAAA,CAAA,IAAA,EAAA,GAAA,CAAA,KAAA,CAAA,cAAA,CAAA,GAAA,CAAA,KAAA,CAAA,CAAA,IAAA,EAAA,GAAA,GAAA,CAAA,KAAA,CAAA,QAAA,CAAA,WAAA,CAAA,GAAA,CAAA,KAAA,CAAA,CAAA,IAAA,EAKJ,IAAiB,IAAjB,EAAIR,GAAJ,CAAQW,KAAR,CAAuB,CA+FvB,IAAMA,MAAQC,QAAA,CA9FEZ,GA8FF,CAAaW,KAAb,CAEG,KAAjB,EAhGgBX,GAgGhB,CAAQa,KAAR,CAEE7C,eAFF,CAEU,cAFV,CAEyB2C,KAFzB,CAEU,KAFV,CAEoC,EAlGpBX,GAkGoB,CAAKa,KAFzC,CAEU,GAFV,EAKgBC,IAAAA,EAad,GAbI9C,eAaJ,GAbyBA,eAazB,CAbiC,SAajC,CAb2C2C,KAa3C,CAbiC,IAajC,CAbqD3C,eAarD,CAbiC,GAajC,EAlHcgC,GAkHd,CAXQe,IAWR,GAVE/C,eAIA,EAJSA,eAAA,CAAQA,eAAR,CAAgB,GAAhB,CAAsB,EAI/B,GAHI,aAGJ,CAHkB2C,KAGlB,CAHI,GAGJ,GAFmB,CAAd,GAAA,CA1GOX,GA0GP,CAAKe,IAAL,CAAkB,EAAlB,CAAuB,GAAvB,CAA6BC,iBAAA,CA1GtBhB,GA0GsB,CAAae,IAAb,CAElC,EA5GYf,GA4GZ,CAAQvB,KAAR,GAEET,eAFF,CAEU,wBAFV;AAEmC2C,KAFnC,CAEU,yBAFV,CAEkE3C,eAFlE,CAEU,GAFV,CAMF,EAAa,IAAb,EAAIA,eAAJ,GAAmBA,eAAnB,CAA2B,GAA3B,CAlBF,CAjGuB,CAIT8C,IAAAA,EAAd,GAAI9C,eAAJ,GACEA,eADF,CACU,IADV,CAIoB,KAApB,EAAIgC,GAAJ,CAAQiB,QAAR,GACEjD,eADF,CACU,MADV,CACiBA,eADjB,CACU,GADV,CAC0BgD,iBAAA,CAAShB,GAAT,CAAaiB,QAAb,CAD1B,CACU,GADV,CAIgB,KAAhB,EAAIjB,GAAJ,CAAQkB,IAAR,GACElD,eADF,EACW,GADX,CACegD,iBAAA,CAAShB,GAAT,CAAakB,IAAb,CADf,CAIkB,KAAlB,EAAIlB,GAAJ,CAAQmB,MAAR,GACEnD,eADF,EACW,GADX,CACegD,iBAAA,CAAShB,GAAT,CAAamB,MAAb,CADf,CAIInB,IAAJ,CAAQoB,KAAR,GACEpD,eADF,CACU,QADV,CACmBA,eADnB,CACU,GADV,CAIA,OAAOA,gBAnCW,CAiDpBiC,QAASA,SAAQ,CAACD,GAAD,CAAM,CAMrB,IAJA,IAAMqB;AAAO,CAACrB,GAAD,CAAKsB,KAAL,CAAYtB,GAAZ,CAAgBuB,IAAhB,CAAsBvB,GAAtB,CAA0BwB,KAA1B,CAAA,CACVC,GADU,CACN,QAAA,CAAAjE,CAAA,CAAK,CAAA,MAAK,KAAL,EAAAA,CAAA,CAAY,IAAZ,CAAmBV,QAAA,CAAS4E,WAAT,CAAqBlE,CAArB,CAAnB,CADC,CAIb,CAAO6D,IAAP,CAAYlD,MAAZ,EAA6C,IAA7C,EAAsBrB,QAAA,CAAS6E,IAAT,CAAcN,IAAd,CAAtB,CAAA,CAAmDA,IAAA,CAAKO,GAAL,EAEnDP,KAAA,CAAKQ,OAAL,CAAajB,QAAA,CAASZ,GAAT,CAAaC,QAAb,CAAb,CACA,OAAO,WAAP,CAAmBoB,IAAA,CAAKS,IAAL,CAAU,GAAV,CAAnB,CAAO,GATc,CAYvBd,QAASA,kBAAQ,CAACA,QAAD,CAAW,CAC1B,MAAOlE,SAAA,CAASO,QAAT,CAAkB2D,QAAlB,CAAA,CAA8B,GAA9B,CAAoCjB,cAAA,CAAMiB,QAAN,CAApC,CAAsD,GAAtD,CAA4DA,QADzC,CAI5Be,QAASA,eAAK,CAACC,GAAD,CAAM,CAClB,MAAOC,aAAA,CAAanF,QAAA,CAASO,QAAT,CAAkB2E,GAAlB,CAAA,CAAyBA,GAAzB,CAA+B,CAACE,MAAOF,GAAR,CAA5C,CADW,CAIpBC,QAASA,aAAY,CAACD,GAAD,CAAM,CAGzB,GAAIA,GAAJ,CAAQlC,MAAR,CAAgB,CACd,IAAAhC,OAAS,OACT,KAAAiE,MAAQC,GAARD,CAAYjC,MAFE,CAAhB,IAGO,IAAIkC,GAAJ,CAAQvC,KAAR;AAAiBuC,GAAjB,CAAqBG,MAArB,CAA6B,CAClCC,KAAA,CAAQC,IAAA,CAAKC,GAAL,CAAS,CAAT,CAAYN,GAAZ,CAAgBI,KAAhB,EAAyB,CAAzB,CAGR,KAFAtE,MAEA,CAFS,MAET,CAAiB,CAAjB,CAAOsE,KAAA,EAAP,CAAA,CACEtE,MAAA,EAAU,aAGRkE,IAAJ,CAAQG,MAAR,EACEJ,KACA,CADQC,GACR,CADYG,MACZ,CAAArE,MAAA,EAAU,QAFZ,EAIEiE,KAJF,CAIUC,GAJV,CAIcvC,KAZoB,CAA7B,IAcIuC,IAAJ,CAAQE,KAAR,EACLpE,MACA,CADS,OACT,CAAAiE,KAAA,CAAQC,GAAR,CAAYE,KAFP,EAILpF,QAAA,CAASyF,KAAT,CAAe,2BAAf,CAA6CzF,QAAA,CAAS4E,WAAT,CAAqBM,GAArB,CAA7C,CAGGA,IAAL,CAASlC,MAAT,GACEiC,KADF,CACUjF,QAAA,CAAS0F,QAAT,CAAkBT,KAAlB,CAAA,CACJjF,QAAA,CAAS2F,eAAT,CAAyBV,KAAzB,CAAA,CAAgCN,GAAhC,CAAoC3E,QAApC,CAA6C4E,WAA7C,CAAA,CAA0DI,IAA1D,CAA+D,IAA/D,CADI,CAEJG,YAAA,CAAaF,KAAb,CAHN,CAMA,OAAOjE,OAAP,CAAgB,GAAhB,CAAsBiE,KAAtB,CAA8B,GAjCL,CA+D3BW,QAASA,cAAI,CAAC1C,GAAD,CAAM,CACjB,IAAI2C,KAAO,EAEX3C,IAAA,CAAIH,OAAJ,CAAY,QAAA,CAAA6C,IAAA,CAAQ,CAClB,IAAM1E;AAAQ+B,cAAA,CAAM2C,IAAN,CACdC,KAAA,EAAQD,IAAA,CAAKE,IAAL,CAAY,GAAZ,CAAgBF,IAAhB,CAAqBE,IAArB,CAAY,IAAZ,CAA8B5E,KAA9B,CAAY,GAAZ,CAAyCA,KAF/B,CAApB,CAM4B,IAA5B,GAAIlB,QAAA,CAAS6E,IAAT,CAAcgB,IAAd,CAAJ,GACEA,IADF,EACU,MADV,CAIA,OAAOA,KAbU,CAgBnBE,QAASA,YAAW,CAACrE,MAAD,CAASlB,IAAT,CAAe0B,IAAf,CAAqBC,KAArB,CAA4B6D,cAA5B,CAAmCC,eAAnC,CAA2C,CAC7D,IAAM/C,IAAM,EACZ+C,gBAAA,CAASA,eAAT,EAAmB,EACnBA,gBAAA,CAAOC,QAAP,CAAkB,CAACC,QAASjD,GAAV,CAElBxB,OAAA,CAASO,aAAA,CAAcP,MAAd,CAAsBlB,IAAtB,CAA4B0B,IAA5B,CAAkCC,KAAlC,CAAyC6D,cAAzC,CAA+C5D,MAA/C,CACT,KAAKJ,IAAMA,GAAX,GAAkBN,OAAlB,CAA0B,CAWfT,IAAAA,CAAAA,IAAAA,EAVa,MAAA,CAAAS,MAAA,CAAOM,GAAP,CAAaxB,KAAAA,SAAAA,IAAAA,CAAMyF,OAAAA,eAANzF,CAAcwF,MAAAA,cAAdxF,CAO/B4F,SAAW,EAPoB5F,CAQ/B6F,OAAS,EAEf,KAAWpF,IAAX,GAAmBqF,MAAnB,CACE,GAAmB,IAAnB;AAAIA,KAAA,CAAMrF,IAAN,CAAJ,CAAA,CAC8B,IAAA,yBAAAqF,KAAA,CAAMrF,IAAN,CAYhC,yBAAA,CAAOjB,QAAA,CAASoB,OAAT,CAAiB8B,wBAAjB,CAAA,CAAwB0C,aAAA,CAAK1C,wBAAL,CAAxB,CAAoCD,cAAA,CAAMC,wBAAN,CAZvCkD,SAAA,CAASnF,IAAT,CAAA,CAAiBsF,KAAA,CAAM,wBAAN,CAAyBP,KAAzB,CAAgCC,MAAhC,CAAwCI,MAAxC,CADnB,CAKF,IAAA,CAAO,CACLG,MAAS,CAACC,SAAAA,QAAD,CAAWL,SAAAA,QAAX,CADJ,CAELM,QAASC,MAAA,CAAOC,IAAP,CAAYP,MAAZ,CAFJ,CAGLQ,QAASF,MAAA,CAAOC,IAAP,CAAYN,KAAZ,CAHJ,CAhBLpD,IAAA,CAAIlB,GAAJ,CAAA,CAAW,IADa,CAI1B,MAAOiE,gBAVsD,CAkC/DM,QAASA,MAAK,CAACV,IAAD,CAAOG,KAAP,CAAcC,MAAd,CAAsBI,MAAtB,CAA8B,CACpCS,IAAAA,CAAO7G,aAAA,CAAc8G,eAAd,CAA8BlB,IAA9B,CAAoCG,KAApC,CACbc;IAAA,CAAKJ,OAAL,CAAa3D,OAAb,CAAqB,QAAA,CAAA9B,IAAA,CAAQ,CAAA,MAAAoF,OAAA,CAAOpF,IAAP,CAAA,CAAe,CAAf,CAA7B,CACAjB,SAAA,CAAS8B,MAAT,CAAgBmE,MAAhB,CAAwBa,IAAxB,CAA6BE,OAA7B,CACA,OAAOF,KAAP,CAAYN,KAJ8B,CAU5CS,QAASA,WAAU,CAACC,MAAD,CAASjG,IAAT,CAAe,CAChCjB,QAAA,CAASyF,KAAT,CAAeyB,MAAf,CAAwB,qBAAxB,CAAgDlH,QAAA,CAAS4E,WAAT,CAAqB3D,IAArB,CAAhD,CADgC,CAIlCkG,QAASA,YAAW,CAACnE,MAAD,CAASgD,KAAT,CAAgB,CAClC,IAAM/E,KAAO+B,MAAP/B,CAAcA,IAEpB,IAVYmG,OAUZ,GAAIpE,MAAJ,CAAWqE,IAAX,CAEOrB,KAAA,CAAMsB,OAAN,CAAcrG,IAAd,CAEL,EAF0BgG,UAAA,CAAW,4BAAX,CAAyChG,IAAzC,CAE1B,CAAAsG,aAAA,CAAcxE,OAAd,CAAsB,QAAA,CAAAyE,IAAA,CAAQ,CACPxD,IAAAA,EAArB,GAAIhB,MAAA,CAAOwE,IAAP,CAAJ,EAAgCP,UAAA,CAAW,mBAAX,CAAgCO,IAAhC,CADJ,CAA9B,CAJF,KAOO,CAEL,IAAMC,GAAKzB,KAAA,CAAM0B,SAAN,CAAgBzG,IAAhB,CAAsB+B,MAAtB,CAA6B9B,KAA7B,CACU;CAAA,CAArB,GAAI8B,MAAJ,CAAW2E,KAAX,GAA4BF,EAA5B,CAA+BE,KAA/B,CAAuC,CAAA,CAAvC,CACI3E,OAAJ,CAAW4E,IAAX,EAAiB5B,KAAA,CAAM6B,UAAN,CAAiB5G,IAAjB,CAAuB+B,MAAvB,CAA8B4E,IAA9B,CAJZ,CAV2B,CAkBpCE,QAASA,MAAK,CAACtH,IAAD,CAAOU,KAAP,CAAc+E,MAAd,CAAsBZ,MAAtB,CAA8B,CAC1C,IAAA,CAAK0C,EAAL,CAAU,EACV,KAAA,CAAKvH,IAAL,CAAYA,IACZ,KAAA,CAAKU,KAAL,CAAaA,KACb,KAAA,CAAK+E,MAAL,CAAcA,MACVZ,OAAJ,GAAY,IAAZ,CAAiBA,MAAjB,CAA0BA,MAA1B,CAL0C,CAkB5CH,QAASA,aAAG,CAACuC,EAAD,CAAK,CACf,IAAMvC,IAAM,CAAC8C,KAAMP,EAANO,CAASD,EAAV,CAEA,EAAZ,CAAIN,EAAJ,CAAOM,EAAP,EAAe,CAACN,EAAD,CAAIQ,IAAJ,CAAWR,EAAX,CAAcQ,IAAd,EAAsB,EAAtB,EAA0BZ,IAA1B,CAA+BnC,GAA/B,CACf,OAAOA,IAJQ,CAOjBgD,QAASA,SAAQ,CAACjD,KAAD,CAAQhE,IAAR,CAAc,CAC7B,MAAOA,KAAA,CAAO,CAACkH,OAAQlD,KAAT,CAAgBmD,MAAOnH,IAAvB,CAAP,CAAsC,CAACkH,OAAQlD,KAAT,CADhB,CAU/BoD,QAASA,OAAM,CAAChC,MAAD,CAASiC,IAAT,CAAe,CACtBpD,MAAAA,CAAM,CAACqD,KAAMlC,MAAP,CACRiC,KAAJ,GAAUpD,MAAV,CAAcsD,KAAd,CAAsB,CAAA,CAAtB,CACA,OAAOtD,OAHqB,CAkB9BuD,QAASA,UAAS,CAAChB,EAAD;AAAKxC,KAAL,CAAY,CAC5B,OAAQwC,EAAA,EAAMA,EAAN,CAASzE,MAAT,CAAkB,GAAlB,CAAwByE,EAAxB,CAA2BzE,MAA3B,CAAoCyE,EAApC,EAA0C,EAAlD,GACKA,EAAA,EAAMxC,KAAN,CAAc,GAAd,CAAoB,EADzB,GAEKA,KAAA,EAASA,KAAT,CAAejC,MAAf,CAAwB,GAAxB,CAA8BiC,KAA9B,CAAoCjC,MAApC,CAA6CiC,KAA7C,EAAsD,EAF3D,CAD4B,CAY9ByD,QAASA,SAAQ,CAAChI,CAAD,CAAI,CACnB,MAAOA,EAAP,EAAYA,CAAZ,CAAcsC,MADK,CAQrB2F,QAASA,UAAS,CAACjI,CAAD,CAAI,CACpB,GAAIgI,QAAA,CAAShI,CAAT,CAAJ,CAAiB,MAAO,CAAA,CACxB,IAAIV,QAAA,CAASO,QAAT,CAAkBG,CAAlB,CAAJ,CAA0B,IAAKsB,IAAMA,GAAX,GAAkBtB,EAAlB,CACxB,GAAIiI,SAAA,CAAUjI,CAAA,CAAEsB,GAAF,CAAV,CAAJ,CAAuB,MAAO,CAAA,CAEhC,OAAO,CAAA,CALa,CAQtBd,QAASA,eAAK,CAAC0H,SAAD,CAAYC,YAAZ,CAA0B,CACtC,MAAoB,KAAb,EAAAD,SAAA,CAAoBA,SAApB,CAAgCC,YADD,CAIxCC,QAASA,MAAK,CAACC,CAAD,CAAI,CAChB,MAAOA,EAAP,EAAYA,CAAZ,CAAc/F,MAAd,EAAwB+F,CADR,CAMlBC,QAASA,YAAW,CAACC,MAAD,CAASjD,KAAT,CAAgB,CAMlC,MAAO,CALQiD,MAAAC,CAAOC,KAAPD,CAAeE,WAAfF,CACXD,MAAA,CAAOA,MAAP,CAAgBI,YAAhB;AACAJ,MAAA,CAAOzI,IAAP,CAAc8I,WAAd,CACAtJ,QAAA,CAASyF,KAAT,CAAe,gCAAf,CAAkDzF,QAAA,CAAS4E,WAAT,CAAqBqE,MAArB,CAAlD,CAEG,EAAOA,MAAP,CAAejD,KAAf,CAN2B,CASpCuD,QAASA,YAAW,CAACC,MAAD,CAAS,CAC1B,MAxCWC,OAwCJ,GAAAD,MAAA,CAtCGE,MAsCH,CAA2BF,MAA3B,EAtCGE,MAqCgB,CAI7BN,QAASA,YAAW,CAACH,MAAD,CAASjD,KAAT,CAAgB,CAClC,IAAM2D,KAAOV,MAAA,CAAOE,KAAP,CAAaxE,GAAb,CAAiB,QAAA,CAAAnB,CAAA,CAAK,CAAA,MAAAwF,YAAA,CAAYxF,CAAZ,CAAewC,KAAf,CAAA,CAAtB,CACP/C,OAAAA,CAAQ2G,gBAAA,CAAiB,CAACT,MAAOQ,IAAR,CAAjB,CAAgCV,MAAhC,CAAwCjD,KAAxC,CACd,OAAOA,MAAA,CAAM6D,SAAN,CAAgB5G,MAAhB,CAAP,CAA8B8E,EAHI,CAMpCsB,QAASA,aAAY,CAACJ,MAAD,CAASjD,KAAT,CAAgB,CACnC,IAAM+B,GAAKiB,WAAA,CAAYC,MAAZ,CAAmBA,MAAnB,CAA2BjD,KAA3B,CACL/C,OAAAA,CAAQ2G,gBAAA,CAAiB,CAACX,OAAQlB,EAAT,CAAjB,CAA+BkB,MAA/B,CAAuCjD,KAAvC,CACd;MAAOA,MAAA,CAAM6D,SAAN,CAAgB5G,MAAhB,CAAP,CAA8B8E,EAHK,CAMrCuB,QAASA,YAAW,CAACL,MAAD,CAASjD,KAAT,CAAgB,CAElC,GA7BY8D,OA6BZ,GAAIb,MAAJ,CAAWzI,IAAX,CAA2B,CACzB,IAAAuH,GAAK/B,KAAA,CAAM+D,KAAN,CA9BKD,OA8BL,CAAmBb,MAAnB,CAA0Be,QAA1B,CACLf,OAAA,CAAS,CAACgB,QAAShB,MAATgB,CAAgBA,OAAjB,CAA0BC,OAAQjB,MAARiB,CAAeA,MAAzC,CAFgB,CAA3B,IAIEnC,GAAA,CAAK/B,KAAA,CAAM+D,KAAN,CAAYR,WAAA,CAAYN,MAAZ,CAAmBO,MAAnB,CAAZ,CAAwCP,MAAxC,CAA+CzI,IAA/C,CAGDyC,OAAAA,CAAQ2G,gBAAA,CAAiB,CAACX,OAAQlB,EAAT,CAAjB,CAA+BkB,MAA/B,CAAuCjD,KAAvC,CACd,OAAqC,EAA9B,GAAAW,MAAA,CAAOC,IAAP,CAAY3D,MAAZ,CAAA,CAAmB5B,MAAnB,CACH0G,EADG,CAEH/B,KAAA,CAAM6D,SAAN,CAAgB5G,MAAhB,CAFG,CAEoB8E,EAZO,CAepC6B,QAASA,iBAAgB,CAAC3G,KAAD,CAAQgG,MAAR,CAAgBjD,KAAhB,CAAuB,CAC9C,IAAImE,MAAQlB,MAARkB,CAAeF,OAEfE,MAAJ,GACuB,CAGrB,GAHIA,KAGJ,CAHU9I,MAGV,EAFErB,QAAA,CAASyF,KAAT,CAAe,kDAAf;AAAoEzF,QAAA,CAAS4E,WAAT,CAAqBqE,MAArB,CAApE,CAEF,CAAAhG,KAAA,CAAMgH,OAAN,CAAgB,CACdjB,WAAA,CAAYmB,KAAA,CAAM,CAAN,CAAZ,CAAsBnE,KAAtB,CADc,CAEdgD,WAAA,CAAYmB,KAAA,CAAM,CAAN,CAAZ,CAAsBnE,KAAtB,CAFc,CAJlB,CAUAmE,MAAA,CAAQlB,MAAA,CAAOiB,MAAP,CAAgB,EAAA,CAAGE,MAAH,CAAUnB,MAAV,CAAiBiB,MAAjB,CAAhB,CAA2C,EACnD,EAAIjB,MAAJ,CAAWxC,QAAX,EAAuBwC,MAAvB,CAA8BoB,QAA9B,EAA0CpB,MAA1C,CAAiDqB,QAAjD,GAEEH,KAAA,CAAM9C,IAAN,CAAWkD,UAAA,CAAWtB,MAAX,CAAkBxC,QAAlB,CAA4BwC,MAA5B,CAAmCoB,QAAnC,CAA6CpB,MAA7C,CAAoDqB,QAApD,CAAX,CAtFUb,QAwFZ,GAAIR,MAAJ,CAAWO,MAAX,EAEEW,KAAA,CAAM9C,IAAN,CAAW,qBAAX,CAEE8C,MAAJ,CAAU9I,MAAV,GACE4B,KADF,CACQiH,MADR,CACiBjK,aAAA,CAAc8G,eAAd,CAA8B,GAA9B,CAAoCoD,KAAA,CAAMnF,IAAN,CAAW,YAAX,CAApC,CAAyD,GAAzD,CAA8DgB,KAA9D,CADjB,CACsFQ,KADtF,CAIiC,KAAjC,GAAK2D,KAAL,CAAalB,MAAb,CAAoBe,QAApB,IACE/G,KADF,CACQ+G,QADR,CACmB,CAACG,KADpB,CAIiC,KAAjC;CAAKA,KAAL,CAAalB,MAAb,CAAoBuB,QAApB,IACEvH,KADF,CACQuH,QADR,CACmB,CAACL,KADpB,CAIIlB,OAAJ,CAAWwB,OAAX,GACExH,KADF,CACQwH,OADR,CACkB,CAAA,CADlB,CAIA,OAAOxH,MAtCuC,CAyChDsH,QAASA,WAAU,CAAC/J,IAAD,CAAOS,IAAP,CAAaiB,IAAb,CAAmB,CAEpC,MADawI,YACb,EACKlK,IAAA,EAAiB,GAAjB,GAAQA,IAAR,CAAuB,+CAAvB,CAA6DA,IAA7D,CAAoE,GAApE,CAA2E,EADhF,GAEK0B,IAAA,CAAO,2CAAP,CAAyCA,IAAzC,CAAgD,GAAhD,CAAuD,EAF5D,GAGKjB,IAAA,CAAO,2CAAP,CAAyCA,IAAzC,CAAgD,GAAhD,CAAuD,EAH5D,CAFoC,CActC0J,QAASA,YAAW,CAACrK,IAAD,CAAO0F,KAAP,CAAc4E,MAAd,CAAsB,CACxC,IAAMlJ,OAASpB,IAAToB,CAAcA,MAApB,CACMuB,MAAQ,CAAC2H,OAAQA,MAAT,CAEVC,OAAAA,CAASvK,IAATuK,CAAcA,MAJsB,KAKpCvJ,OAAShB,IAATgB,CAAcA,MALsB,CAMpCwJ,QAAU,EAETD,OAAL;AACE7K,QAAA,CAASyF,KAAT,CAAe,6CAAf,CAIEzF,SAAA,CAAS0F,QAAT,CAAkBmF,MAAlB,CAAJ,GACEA,MADF,CACW3K,iBAAA,CAAkB6K,QAAlB,CAA2BF,MAA3B,CAAmC7E,KAAA,CAAMgF,UAAN,EAAA,CA3IlCvB,OA2IkC,CAzInCC,MAyIA,CADX,CAKAmB,OAAA,CAAS7K,QAAA,CAAS8C,KAAT,CAAe+H,MAAf,CAAA,CACNX,MADM,CACC,QAAA,CAAA1G,CAAA,CAAK,CAAA,MAAAA,EAAA,CAAER,MAAF,EAAYQ,CAAZ,CAAcK,KAAd,EAAuBiH,OAAA,CAAQzD,IAAR,CAAa7D,CAAb,CAAA,CAAiB,CAAxC,EAA6C,CAA7C,CADN,CAIY,EAArB,CAAIsH,OAAJ,CAAYzJ,MAAZ,GACEyJ,OADF,CACY,CAACG,YAAA,CAAaH,OAAb,CAAD,CADZ,CAKID,OAAJ,CAAWxJ,MAAX,EACEyJ,OAAA,CAAQzD,IAAR,CAA6B,CAAhB,CAAAwD,MAAA,CAAOxJ,MAAP,CAAoB,CAAC8H,MAAO0B,MAAR,CAApB,CAAsCA,MAAA,CAAO,CAAP,CAAnD,CAGY,KAAd,EAAInJ,MAAJ,GACMJ,MACJ,EADYtB,QAAA,CAASyF,KAAT,CAAe,kDAAf,CACZ,CAAAnE,MAAA,CAAS,gBAAT;AAA4BtB,QAAA,CAAS4E,WAAT,CAAqBlD,MAArB,CAA5B,CAA2D,GAF7D,CAMAuB,MAAA,CAAM3B,MAAN,CAAetB,QAAA,CAAS0F,QAAT,CAAkBpE,MAAlB,CAAA,CAA4BrB,aAAA,CAAc8G,eAAd,CAA8BzF,MAA9B,CAAsC0E,KAAtC,CAA5B,CACI,IAAf,EAAA1E,MAAA,CAAOwF,IAAP,CAAsB7G,aAAA,CAAc8G,eAAd,CAA8BzF,MAA9B,CAAqCwF,IAArC,CAA2Cd,KAA3C,CAAtB,CACgB,IAAhB,EAAA1E,MAAA,CAAOJ,KAAP,CAAuBI,MAAvB,CAA8BJ,KAA9B,CACiB,IAAjB,EAAAI,MAAA,CAAO0B,MAAP,CAAwB,CACtBwD,MAAS0E,aADa,CAEtBlE,QAAS,CAACmE,OAAQnF,KAAA,CAAMoF,SAAN,CAAgB9J,MAAhB,CAAuB0B,MAAvB,CAAT,CAFa,CAAxB,CAIAhD,QAAA,CAASyF,KAAT,CAAe,sCAAf,CAEAnF,KAAJ,CAAS+K,KAAT,GACEpI,KADF,CACQqI,OADR,CACkB,CAACD,MAAO,CAAA,CAAR,CADlB,CAIAP,QAAA,CAAQ/H,OAAR,CAAgB,QAAA,CAAAyG,MAAA,CACd,CAAA,MAAAxD,MAAA,CAAMuF,SAAN,CAAgBvL,QAAA,CAAS8B,MAAT,CAAgB0J,YAAA,CAAahC,MAAb,CAAqBxD,KAArB,CAAhB,CAA6C/C,KAA7C,CAAhB,CAAA,CADF,CAlDwC;AAuD1CuI,QAASA,aAAY,CAACvC,MAAD,CAASjD,KAAT,CAAgB,CACnC,MAAO,CACLwD,OAAQP,MAAA,CAAOjG,MAAP,CAAgBgD,KAAA,CAAMoF,SAAN,CAAgBnC,MAAhB,CAAuBjG,MAAvB,CAAhB,CACAiG,MAAA,CAAOpF,KAAP,CAAemC,KAAA,CAAMlC,QAAN,CAAemF,MAAf,CAAsBpF,KAAtB,CAAf,CACAmF,WAAA,CAAYC,MAAZ,CAAoBjD,KAApB,CAHH,CAD4B,CAQrCiF,QAASA,aAAY,CAACH,OAAD,CAAU,CAC7B,MAAO,CACL9H,OAAQ,GAARA,CACI8H,OAAA,CAAQnG,GAAR,CAAY,QAAA,CAAAnB,CAAA,CAAK,CAAA,MAAAA,EAAA,CAAEK,KAAF,CAAU,SAAV,CAAsBL,CAAtB,CAAwBK,KAAxB,CAAgC,IAAhC,CAAuCL,CAAvC,CAAyCR,MAAzC,CAAjB,CADJA,CAEI,GAHC,CADsB,CAQ/ByI,QAASA,mBAAkB,CAACzI,MAAD,CAASgD,KAAT,CAAgB,CACzC,IAAMyB,GAAKzB,KAAA,CAAM0F,SAAN,CAAgB1I,MAAhB,CAAuB/B,IAAvB,CAAX,CACI6F,KAAO9D,MAAP8D,CAAcxF,MAEd0B,OAAJ,CAAW2I,IAAX,GACM7E,IAAJ,CACE9G,QAAA,CAASyF,KAAT,CAAe,2DAAf,CADF,EAGEqB,IACA,CADO9D,MACP,CADc2I,IACd;AAAAlE,EAAA,CAAGmE,QAAH,CAAc,CAAA,CAJhB,CADF,CASI9E,KAAJ,GACEA,IAEA,CAFO7G,aAAA,CAAc8G,eAAd,CAA8BD,IAA9B,CAAoCd,KAApC,CAEP,CADAyB,EACA,CADGnG,MACH,CADYwF,IACZ,CADiBN,KACjB,CAAAiB,EAAA,CAAGxB,MAAH,CAAYa,IAAZ,CAAiBE,OAHnB,CAMIhE,OAAJ,CAAW6I,EAAX,EACE7I,MAAA,CAAO6I,EAAP,CAAU9I,OAAV,CAAkB,QAAA,CAAArC,CAAA,CAAK,CAAA,MAAAiK,YAAA,CAAYjK,CAAZ,CAAesF,KAAf,CAAsByB,EAAtB,CAAyBM,EAAzB,CAAA,CAAvB,CApBuC,CAqG3C+D,QAASA,aAAY,CAAC/C,CAAD,CAAI/C,KAAJ,CAAW,CAC9B,MAAQhG,SAAA,CAASO,QAAT,CAAkBwI,CAAlB,CAAD,CACHA,CAAA,CAAE/F,MAAF,CAAWgD,KAAA,CAAMoF,SAAN,CAAgBrC,CAAhB,CAAkB/F,MAAlB,CAAX,CACAhD,QAAA,CAASyF,KAAT,CAAe,sBAAf,CAAwCzF,QAAA,CAAS4E,WAAT,CAAqBmE,CAArB,CAAxC,CAFG,CAAwBA,CADD,CAMhCgD,QAASA,WAAU,CAAChD,UAAD,CAAI/C,KAAJ,CAAW,CAC5B,MAAO+C,WAAA,CAAE/F,MAAF,CACHgD,KAAA,CAAMoF,SAAN,CAAgBrC,UAAhB,CAAkB/F,MAAlB,CADG,CAEH+F,UAAA,CAAEpE,GAAF,CAAM,QAAA,CAAAoE,CAAA,CAAK,CAAA,MAAA+C,aAAA,CAAa/C,CAAb,CAAgB/C,KAAhB,CAAA,CAAX,CAHwB;AAM9BgG,QAASA,gBAAe,CAAC/K,IAAD,CAAO,CAC7BjB,QAAA,CAASyF,KAAT,CAAe,yBAAf,CAA2CzF,QAAA,CAAS4E,WAAT,CAAqB3D,IAArB,CAA3C,CAD6B,CAM/BgL,QAASA,iBAAgB,CAACC,MAAD,CAAS5L,IAAT,CAAe0F,KAAf,CAAsB,CAC7C,GAAKkG,MAAL,CAOA,MAAOA,OAAA,CAAOlJ,MAAP,CAAgBgD,KAAA,CAAMoF,SAAN,CAAgBc,MAAhB,CAAuBlJ,MAAvB,CAAhB,CACH,CAAChD,QAAA,CAASoB,OAAT,CAAiB8K,MAAjB,CAAA,CAA2BC,cAA3B,CACDD,MAAA,CAAO7F,MAAP,CAAgB+F,cAAhB,CACAC,cAFA,EAEgBH,MAFhB,CAEwB5L,IAFxB,CAE8B0F,KAF9B,CAPoB,KAAtB,EAAI1F,IAAJ,CAASgM,SAAT,EAAgD,IAAhD,EAA8BhM,IAA9B,CAAmCiM,SAAnC,EACEvM,QAAA,CAASyF,KAAT,CAAe,8DAAf,CAHyC,CAc/C0G,QAASA,eAAc,CAACD,MAAD,CAAS5L,IAAT,CAAe0F,KAAf,CAAsB,CAC3C,MAAOkG,OAAA,CAAOvH,GAAP,CAAW,QAAA,CAAAoE,CAAA,CAAK,CAAA,MAAA+C,aAAA,CAAa/C,CAAb;AAAgB/C,KAAhB,CAAA,CAAhB,CADoC,CAI7CqG,QAASA,eAAc,CAACH,MAAD,CAAS5L,IAAT,CAAe0F,KAAf,CAAsB,CAC3C,IAAMwG,KAAOxG,KAAA,CAAMyG,OAAN,CAAcP,MAAd,CAAqBM,IAArB,CACRA,KAAL,EAAWR,eAAA,CAAgBE,MAAhB,CAAuBM,IAAvB,CAEX,OAAOrM,UAAA,CAAUuM,UAAV,CAAqBpM,IAArB,CAA0BE,IAA1B,CAAA,CACDgM,IAAA,CAAKG,SAAL,CAAe3G,KAAf,CAAsBkG,MAAtB,CAA6BjH,KAA7B,CAAoC2H,SAAA,CAAUV,MAAV,CAAiBW,IAAjB,CAAuB,CAAA,CAAvB,CAApC,CADC,CAED1M,SAAA,CAAU2M,UAAV,CAAqBxM,IAArB,CAA0BE,IAA1B,CAAA,CAAkCgM,IAAA,CAAKO,SAAL,CAAe/G,KAAf,CAAsBkG,MAAtB,CAA6BjH,KAA7B,CAAlC,CACAuH,IAAA,CAAKQ,SAAL,CAAehH,KAAf,CAAsBkG,MAAtB,CAA6BjH,KAA7B,CAPqC,CAU7CmH,QAASA,eAAc,CAACF,MAAD,CAAS5L,IAAT,CAAe0F,KAAf,CAAsB,CAC3C,IAAMwG,cAAON,MAAPM,CAAcA,IAApB,CACMnG,OAAS6F,MAAA,CAAO7F,MAAP,CAAc4G,MAAd,CAAqB,QAAA,CAACC,GAAD,CAAMC,CAAN,CAAY,CACpC,GAAAnN,QAAA,CAAS0F,QAAT,CAAkByH,CAAlB,CAAA,CAAuB,CAAA,CAAA,CAAA,KAAA,aAAA,CAAA,MAAA,CAAA,CAAvB,KACA,IAAA,QAAA,CAAA,OAAA,CAAA,CAAA,CAAA;AAAA,CAAA,CAAA,MAAA,CAAA,CAAA,IAAA,KAAA,CAYNlM,EAAAA,CAAO,UAAPA,CAAqBmM,YAAA,EAA3B,KACMC,KAAOC,OAAA,CAAQ,EAAR,CAETtN,SAAA,CAASoB,OAAT,CAAiBoL,IAAjB,CAAJ,CACEa,IADF,CACOnM,KADP,CACe,CAACqM,QAASf,IAAV,CADf,CAEWA,IAFX,CAEgBxJ,MAFhB,GAGQ6C,IACN,CADa,UACb,CAD0B7F,QAAA,CAAS4E,WAAT,CAAqB3D,CAArB,CAC1B,CADuD,GACvD,CAD6DuL,IAC7D,CADkExJ,MAClE,CAD2E,GAC3E,CAAAqK,IAAA,CAAKpH,MAAL,CAAYuH,KAAZ,CAnBUxH,KAmBU,CAAMoF,SAAN,CAAgBvF,IAAhB,CAJtB,CAfYG,MAqBZ,CAAMyH,eAAN,CAAsBxM,CAAtB,CAA4B,CAACoM,IAAD,CAAOK,KAAA,CAAM,EAAN,CAAP,CAA5B,CACA,EAAA,CAAO,CAAClB,KAAMvL,CAAP,CAAagE,MAAO,MAApB,CAtBK,CAEJiI,GAAA,CAAI7F,IAAJ,CAHI8F,CAGJ,CACA,OAAOD,IALiC,CAAjC,CAMN,EANM,CAQf,OAAO,CAAC/M,SAAA,CAAUuM,UAAV,CAAqBpM,IAArB,CAA0BE,IAA1B,CAAA,CAAkCmN,qBAAlC,CACJxN,SAAA,CAAU2M,UAAV,CAAqBxM,IAArB,CAA0BE,IAA1B,CAAA,CAAkCoN,sBAAlC,CACAC,qBAFG,EAEoB3B,MAFpB,CAE4BlG,KAF5B,CAEmCK,MAFnC,CAVoC,CA6B7CsH,QAASA,sBAAqB,CAACzB,MAAD;AAASlG,KAAT,CAAgBK,MAAhB,CAAwB,CACpD,IAAMwG,KAAOD,SAAA,CAAUV,MAAV,CAAiBW,IAAjB,CAAuB,CAAA,CAAvB,CAIPiB,OAAAA,CAASzH,MAAA,CAAO1B,GAAP,CAAW,QAAA,CAAAoJ,CAAA,CAAK,CAC7B,IAAMvB,KAAOxG,KAAA,CAAMyG,OAAN,CAAcsB,CAAd,CAAgBvB,IAAhB,CACRA,KAAL,EAAWR,eAAA,CAAgB+B,CAAhB,CAAkBvB,IAAlB,CACX,OAAOA,KAAA,CAAKwB,SAAL,CAAehI,KAAf,CAAsB+H,CAAtB,CAAwB9I,KAAxB,CAA+B4H,IAA/B,CAHsB,CAAhB,CAOf,KAAMoB,EAAI,CAACC,QAASC,WAAV,CAAuBC,MAAON,MAA9B,CACNjB,KAAJ,GACEpJ,MAIA,CAJIoJ,IAIJ,CAJSpF,EAIT,EAJe,OAIf,CAHAsB,MAGA,CAHI8D,IAAA,CAAK5H,KAAL,CAAawD,SAAA,CAAUhF,MAAV,CAAaoJ,IAAb,CAAkB5H,KAAlB,CAAb,CAAwC,OAG5C,CAFAgJ,CAEA,CAFEI,GAEF,CAFQ,CAACC,oBAAA,CAAqB7K,MAArB,CAAD,CAER,CADAwK,CACA,CADE5H,MACF,CADW,CAACL,KAAA,CAAMkC,QAAN,CAAea,MAAf,CAAD,CACX,CAAAkF,CAAA,CAAEM,EAAF,CAAO,CAACxF,MAAD,CALT,CAOAtF,OAAA,CAAIuC,KAAA,CAAMwI,GAAN,CAAUC,SAAA,CAAUR,CAAV,CAAV,CAGE7K,OAAAA,CAAI4C,KAAA,CAAMwI,GAAN,CAAUlB,OAAA,CAAQ,CAACc,MAAOlJ,YAAA,CAAIzB,MAAJ,CAAR,CAAR,CAAV,CAGVsF,OAAA,CAAI/C,KAAA,CAAMwI,GAAN,CAAUE,MAAA,CAAO,CACnBzJ,MAAOkJ,WADY;AAEnBtB,KAAO7G,KAAA,CAAM2I,OAAN,CAAc9B,IAAd,CAFY,CAGnBuB,MAAOlJ,YAAA,CAAI9B,MAAJ,CAHY,CAAP,CAAV,CAMJ,OAAO8B,aAAA,CAAI6D,MAAJ,CAhC6C,CAmCtD6D,QAASA,UAAS,CAACC,IAAD,CAAO+B,WAAP,CAAoB,CAChC/B,IAAJ,GACOA,IAAL,CAAU5H,KAAV,EAAoB4H,IAApB,CAAyBpF,EAAzB,CAGYoF,IAAL,CAAU5H,KAAV,EAA+B,OAA/B,GAAmB4H,IAAnB,CAAwBpF,EAAxB,CAEImH,WAFJ,EAEmB/B,IAFnB,CAEwB5H,KAFxB,EAGD4H,IAHC,CAGIpF,EAHJ,EAGU,CAAC6G,oBAAA,CAAqBzB,IAArB,CAA0BpF,EAA1B,CAHX,EAIHzH,QAAA,CAASyF,KAAT,CAAe,iDAAf,CAAmEoH,IAAnE,CAAwEpF,EAAxE,CAJG,CACLzH,QAAA,CAASyF,KAAT,CAAe,2CAAf,CAA6DoH,IAA7D,CAAkEpF,EAAlE,CAJF,CACMzH,QAAA,CAASO,QAAT,CAAkBsM,IAAlB,CAAJ,CAA6BA,IAA7B,CAAkC5H,KAAlC,CAA0C,KAA1C,CACK4H,IADL,CACY,CAAC5H,MAAO,KAAR,CAHhB,CAYA,OAAO4H,KAb6B,CAgBtCe,QAASA,uBAAsB,CAAC1B,MAAD,CAASlG,KAAT;AAAgBK,MAAhB,CAAwB,CAE/CwI,MAAAA,CAASxI,MAAA,CAAO1B,GAAP,CAAW,QAAA,CAAAoJ,CAAA,CAAK,CAC7B,IAAMvB,KAAOxG,KAAA,CAAMyG,OAAN,CAAcsB,CAAd,CAAgBvB,IAAhB,CACRA,KAAL,EAAWR,eAAA,CAAgB+B,CAAhB,CAAkBvB,IAAlB,CACX,OAAOA,KAAA,CAAKO,SAAL,CAAe/G,KAAf,CAAsB+H,CAAtB,CAAwB9I,KAAxB,CAHsB,CAAhB,CAOf,OAAOC,aAAA,CAAIc,KAAA,CAAMwI,GAAN,CAAUM,WAAA,CAAY,CAACD,OAAQA,MAAT,CAAZ,CAAV,CAAJ,CAT8C,CAYvDhB,QAASA,sBAAqB,CAAC3B,MAAD,CAASlG,KAAT,CAAgBK,MAAhB,CAAwB,CAE9C0I,MAAAA,CAAU1I,MAAA,CAAO1B,GAAP,CAAW,QAAA,CAAAoJ,CAAA,CAAK,CAC9B,IAAMvB,KAAOxG,KAAA,CAAMyG,OAAN,CAAcsB,CAAd,CAAgBvB,IAAhB,CACRA,KAAL,EAAWR,eAAA,CAAgB+B,CAAhB,CAAkBvB,IAAlB,CACX,OAAOA,KAAA,CAAKQ,SAAL,CAAehH,KAAf,CAAsB+H,CAAtB,CAAwB9I,KAAxB,CAHuB,CAAhB,CAOhB,OAAOC,aAAA,CAAIc,KAAA,CAAMwI,GAAN,CAAUQ,WAAA,CAAY,CAACD,QAASA,MAAV,CAAZ,CAAV,CAAJ,CAT6C,CA0CtDE,QAASA,gBAAe,CAAC3O,IAAD,CAAO0F,KAAP,CAAcC,MAAd,CAAsB,CAC5C,IAAM7D,OAAS4D,KAAT5D,CAAeA,MAAfA,CAAsB2B,KAA5B;AACIA,MAAQzD,IAARyD,CAAaA,KAEjB,IAAIA,KAAJ,CAAUf,MAAV,CACE,MAAOgD,MAAA,CAAMoF,SAAN,CAAgBrH,KAAhB,CAAsBf,MAAtB,CACF,IAAIhD,QAAA,CAAS0F,QAAT,CAAkB3B,KAAlB,CAAJ,CAA8B,CACnC,GAAI3B,MAAJ,EAAcpC,QAAA,CAAS6B,cAAT,CAAwBO,MAAxB,CAAgC2B,KAAhC,CAAd,CAEE,MADAzD,KACO,CADAN,QAAA,CAAS8B,MAAT,CAAgB,EAAhB,CAAoBxB,IAApB,CAA0B,CAACyD,MAAO3B,MAAA,CAAO2B,KAAP,CAAR,CAA1B,CACA,CAAAkL,eAAA,CAAgB3O,IAAhB,CAAsB0F,KAAtB,CAA6BC,MAA7B,CACY,QAAd,GAAIlC,KAAJ,CACLA,KADK,CACG,CAAC,CAAD,CAAI,CAACf,OAAQ,OAAT,CAAJ,CADH,CAEc,QAAd,GAAIe,KAAJ,CACLA,KADK,CACG5D,SAAA,CAAUuM,UAAV,CAAqBpM,IAArB,CAA0BE,IAA1B,CAAA,CACJ,CAAC,CAAD,CAAI,CAACwC,OAAQ,QAAT,CAAJ,CADI,CAEJ,CAAC,CAACA,OAAQ,QAAT,CAAD,CAAqB,CAArB,CAHC,CAKLhD,QAAA,CAASyF,KAAT,CAAe,kCAAf,CAAoDzF,QAAA,CAAS4E,WAAT,CAAqBb,KAArB,CAApD,CAXiC,CAA9B,IAaA,CAAA,GAAIA,KAAJ,CAAUmL,MAAV,CAAkB,CACvBjJ,MAAA,CAAOiJ,MAAP,CAAgBlP,QAAA,CAASoB,OAAT,CAAiB2C,KAAjB,CAAuBmL,MAAvB,CAAA;AACZnD,UAAA,CAAWhI,KAAX,CAAiBmL,MAAjB,CAAyBlJ,KAAzB,CADY,CAEZ8F,YAAA,CAAa/H,KAAb,CAAmBmL,MAAnB,CAA2BlJ,KAA3B,CACAjC,MAAJ,CAAUoL,MAAV,GAAkBlJ,MAAlB,CAAyBmJ,YAAzB,CAAwCrD,UAAA,CAAWhI,KAAX,CAAiBoL,MAAjB,CAAyBnJ,KAAzB,CAAxC,CACIjC,MAAJ,CAAUW,KAAV,GAAiBuB,MAAjB,CAAwBoJ,WAAxB,CAAsCvD,YAAA,CAAa/H,KAAb,CAAmBW,KAAnB,CAA0BsB,KAA1B,CAAtC,CACA,OANuB,CAOlB,GAAIjC,KAAJ,CAAUuL,IAAV,CAAgB,CACrBrJ,MAAA,CAAOsJ,SAAP,CAAmBzD,YAAA,CAAa/H,KAAb,CAAmBuL,IAAnB,CAAyBtJ,KAAzB,CACnB,OAFqB,CAGhB,GAAI7F,SAAA,CAAUuM,UAAV,CAAqBpM,IAArB,CAA0BE,IAA1B,CAAJ,EAAuC,CAACR,QAAA,CAASoB,OAAT,CAAiB2C,KAAjB,CAAxC,CACL,MAAOkI,iBAAA,CAAiBlI,KAAjB,CAAwBzD,IAAxB,CAA8B0F,KAA9B,CACGhG,SAAA,CAASoB,OAAT,CAAiB2C,KAAjB,CAAL,EACL/D,QAAA,CAASyF,KAAT,CAAe,0BAAf,CAA4CzF,QAAA,CAAS4E,WAAT,CAAqBb,KAArB,CAA5C,CAbK,CAgBP,MAAOA,MAAA,CAAMY,GAAN,CAAU,QAAA,CAAAoE,CAAA,CAAK,CAAA,MAAA,CAAC/I,QAAA,CAASoB,OAAT,CAAiB2H,CAAjB,CAAA;AAAsBgD,UAAtB,CAAmCD,YAApC,EAAkD/C,CAAlD,CAAqD/C,KAArD,CAAA,CAAf,CAnCqC,CAyD9CwJ,QAASA,eAAc,CAAC9O,UAAD,CAAIO,IAAJ,CAAU+E,KAAV,CAAiB,CACtC,MAAOhG,SAAA,CAASoB,OAAT,CAAiBV,UAAjB,CAAA,CAAsBA,UAAA,CAAEiE,GAAF,CAAM,QAAA,CAAAjE,CAAA,CAAK,CAAA,MAAA8O,eAAA,CAAe9O,CAAf,CAAkBO,IAAlB,CAAwB+E,KAAxB,CAAA,CAAX,CAAtB,CACFhG,QAAA,CAASO,QAAT,CAAkBG,UAAlB,CAAD,CACAA,UAAA,CAAEsC,MAAF,CAAWgD,KAAA,CAAMoF,SAAN,CAAgB1K,UAAhB,CAAkBsC,MAAlB,CAAX,CACS,KAAT,GAAA/B,IAAA,CAAiBP,UAAjB,CACAV,QAAA,CAASyF,KAAT,CAAe,gCAAf,CAAkDzF,QAAA,CAAS4E,WAAT,CAAqBlE,UAArB,CAAlD,CAHA,CAAwBA,UAFU,CAuExC+O,QAASA,WAAU,CAAC5M,IAAD,CAAO,CACxBA,IAAA,CAAKrC,IAAL,CAPgBkP,OAQhB7M,KAAA,CAAK8M,WAAL,CAAmB9M,IAAnB,CAAwB8M,WAAxB,EAAuC,CAAA,CACvC,OAAO9M,KAHiB,CAM1B+M,QAASA,gBAAM,CAACtP,IAAD;AAAO8B,MAAP,CAAe,CAC5B,IAAM1B,EAAIA,QAAA,CAACO,IAAD,CAAO4O,IAAP,CAAgB,CAAA,MAAA3O,eAAA,CAAMZ,IAAA,CAAKW,IAAL,CAAN,CAAkBC,cAAA,CAAMkB,MAAA,CAAOnB,IAAP,CAAN,CAAoB4O,IAApB,CAAlB,CAAA,CAE1BnP,EAAA,CAAEoP,UAAF,CAAeC,QAAA,CAAAvM,CAAA,CAAK,CAAA,MAlELwM,UAkEK,GAAa9O,cAAA,CAC/BZ,IAD+B,CAC1B2P,SAD0B,CAE/B7N,MAF+B,CAExB6N,SAFwB,GAEVzM,CAAA,CAAIpB,MAAJ,CAAW8N,eAAX,CAA6B9N,MAA7B,CAAoC+N,iBAF1B,EAAb,CAKpBzP,EAAA,CAAE0P,cAAF,CAAmBC,QAAA,EAAM,CAAA,MAAAnP,eAAA,CACvBZ,IADuB,CAClB8P,cADkB,CAEvBhO,MAFuB,CAEhBgO,cAFgB,EAEEhO,MAFF,CAESkO,aAFT,CAAA,CAKzB5P,EAAA,CAAE6P,iBAAF,CAAsBC,QAAA,EAAM,CAAA,MAAAtP,eAAA,CAC1BZ,IAD0B,CACrBiQ,iBADqB,CAE1BnO,MAF0B,CAEnBmO,iBAFmB,EAEEnO,MAFF,CAESqO,cAFT,CAAA,CAK5B/P,EAAA,CAAEgQ,YAAF;AAAiBC,QAAA,EAAM,CAAA,MAAAzP,eAAA,CACrBZ,IADqB,CAChBsQ,OADgB,CAErB1P,cAAA,CAAMkB,MAAN,CAAawO,OAAb,CAAsB,CAAClQ,CAAA,CAAEoP,UAAF,CAAa,CAAA,CAAb,CAAvB,CAFqB,CAAA,CAKvB,OAAOpP,EAvBqB,CA0B9BmQ,QAASA,YAAW,CAAC5P,IAAD,CAAOS,MAAP,CAAe,CAKjC,MAAO,CAJDqH,IAIC,CAJGrH,MAIH,GAHJA,MAGI,CAHGJ,MAGH,EAHaI,MAAA,CAAOJ,MAAP,CAAcL,IAAd,CAGb,EAFJS,MAEI,CAFGF,KAEH,EAFYE,MAAA,CAAOF,KAAP,CAAaP,IAAb,CAEZ,IAAK8H,IAAL,CAAO/F,MAAP,CAAgB+F,IAAhB,CAAoBA,IAAA,CAAIA,IAAJ,CAAM7H,KAAN,CAAc,IALR,CAanC4P,QAASA,WAAU,CAACtN,CAAD,CAAIuN,CAAJ,CAAOC,CAAP,CAAU,CAC3B,MAAO,qCAAP,CAAuCxN,CAAvC,CAAO,sCAAP,CAAyEuN,CAAzE,CAAO,KAAP,CAAgFC,CADrD,CAuC7BC,QAASA,aAAY,CAAC/P,KAAD,CAAQmD,MAAR,CAAgB,CACnC,MAAQA,OAAD,CACFnD,KAAD,CACClB,QAAA,CAASO,QAAT,CAAkBW,KAAlB,CAAD,CACAyF,MAAA,CAAOuK,MAAP,CAAc,EAAd,CAAkBhQ,KAAlB,CAAyB,CAAEmD,OAAQ4M,YAAA,CAAa/P,KAAb,CAAmBmD,MAAnB;AAA2BA,MAA3B,CAAV,CAAzB,CADA,CAA4B,CAAEnD,MAAAA,KAAF,CAASmD,OAAAA,MAAT,CAD5B,CAASA,MADN,CAAUnD,KADkB,CAOrCiQ,QAASA,UAAS,CAACtO,IAAD,CAAOuO,MAAP,CAAe,CAC3BA,MAAJ,EACEvO,IAGA,CAHK5B,IAGL,CAHYmQ,MAGZ,CAHmBnQ,IAGnB,CAFA4B,IAEA,CAFKV,KAEL,CAFaiP,MAEb,CAFoBjP,KAEpB,EAF6BU,IAE7B,CAFkCV,KAElC,CADAU,IACA,CADK8M,WACL,CADmB,CAAC,CAACyB,MAAD,CAAQzB,WAC5B,CAAA9M,IAAA,CAAKnB,MAAL,CAAcD,YAAA,CAAaoB,IAAb,CAAkBnB,MAAlB,CAA0B0P,MAA1B,CAAkCC,IAAlC,CAJhB,EAMExO,IANF,CAMO8M,WANP,CAMqB,CAAA,CAErB,OAAO9M,KATwB,CAYjCyO,QAASA,eAAc,CAAChR,IAAD,CAAOuD,KAAP,CAAczB,MAAd,CAAsBmP,UAAtB,CAAkC,CACjD7Q,IAAAA,CAAIkP,eAAA,CAAOtP,IAAP,CAAa8B,MAAb,CAAV,KACMoP,SAAW9Q,IAAA,CAAEoP,UAAF,EACX2B,OAAAA,CAAY/Q,IAAA,CAAE6P,iBAAF,EAFlB,KAGMlP,OAASX,IAAA,CAAE0P,cAAF,EAHf,CAKI5O,KAEJ,IAAIgQ,QAAJ,CAAc,CACZhN,QAAA,CAAQ,CAAC,CAAD,CAAI,CAAJ,CACR,KAAAC,KAAO,CAAC,CAAD,CAAI,CAAJ,CACP;IAAAiN,MAAQD,MACRE,OAAA,CAAStQ,MAJG,CAAd,IAMEmD,SAEA,CAFQ,CAAC,CAAD,CAAI,CAAJ,CAER,CADAC,IACA,CADO,CAAC,CAAD,CAAI,CAAJ,CACP,CAAAiN,KAAA,CAAQrQ,MAIJK,MAAAA,CAAS,CACbF,MAAOA,KAAPA,CAAe,CACboQ,QAASC,aADI,CAEbC,EAAGD,aAFU,CAGbE,EAAGF,aAHU,CAIbH,MAAOM,OAAA,CAAQN,KAAR,CAJM,CAKbC,OAAQK,OAAA,CAAQL,MAAR,CALK,CADF,CAQbrQ,OAAQtB,QAAA,CAAS8B,MAAT,CAAgB,EAAhB,CAAoBN,KAApB,CAA2B,CACjCoQ,QAASK,GADwB,CAEjCC,KAAM,CAAC/O,SAAUU,KAAX,CAAkBW,MAAOA,QAAzB,CAAgCC,KAAMA,IAAtC,CAF2B,CAA3B,CARK,CAYb0N,KAAM,CACJP,QAASC,aADL,CAZO,CAiBftQ,YAAA,CAAYG,KAAZ,CAAoB,CAClB0Q,OAAa1R,IAAA,CAAE,qBAAF,CADK,CAElB2R,YAAa3R,IAAA,CAAE,qBAAF,CAFK,CAApB,CAGG,CACDkR,QAAalR,IAAA,CAAE,iBAAF,CADZ,CAHH,CAOA,OAAOyQ,UAAA,CAAU,CACf3Q,KAzJa8R,MAwJE,CAEfpQ,KA/kCuBqQ,iBA6kCR;AAGf7Q,OAAAA,KAHe,CAAV,CAIJ6P,UAJI,CA5CgD,CAmDzDiB,QAASA,uBAAsB,CAAClS,IAAD,CAAOuD,KAAP,CAAczB,MAAd,CAAsBmP,UAAtB,CAAkCkB,OAAlC,CAA2C,CAClE/R,IAAAA,CAAIkP,eAAA,CAAOtP,IAAP,CAAa8B,MAAb,CAAV,KACMoP,SAAW9Q,IAAA,CAAEoP,UAAF,EACX2B,OAAAA,CAAY/Q,IAAA,CAAE6P,iBAAF,EAFlB,KAGMlP,OAASX,IAAA,CAAE0P,cAAF,EAHf,CAKIsC,CALJ,CAKO3J,CALP,CAKU4J,EALV,CAKcC,EALd,CAKkBC,OAAS,EAE3BrB,SAAA,EACKkB,CAAA,CAAI,GAAJ,CAASC,EAAT,CAAc,IAAd,CAAoB5J,CAApB,CAAwB,GAAxB,CAA6B6J,EAA7B,CAAkC,OAAlC,CAA2CC,MAA3C,CAAoD,IADzD,GAEKH,CAAA,CAAI,GAAJ,CAASC,EAAT,CAAc,IAAd,CAAoB5J,CAApB,CAAwB,GAAxB,CAA6B6J,EAA7B,CAAkC,QAFvC,CAIMpR,MAAAA,CAAQ,CACZoQ,QAASC,aADG,CAEZK,KAAM,CAACrO,MAAOA,KAAR,CAAeoB,MAtNV6N,OAsNL,CAFM,CAIdtR,MAAA,CAAMkR,CAAN,CAAA,CAAY,CAAC1P,OAAQ6P,MAAR7P,CAAiB,YAAlB,CAAmCoB,KAAM/C,MAAzC,CACZG,MAAA,CAAMuH,CAAN,CAAA,CAAY8I,aACZrQ,MAAA,CAAMmR,EAAN,CAAA,CAAY,CAAC3P,OAAQ6P,MAAR7P,CAAiB,aAAlB;AAAoCoB,KAAM/C,MAA1C,CACZG,MAAA,CAAMoR,EAAN,CAAA,CAAYZ,OAAA,CAAQP,MAAR,CAEN/P,EAAAA,CAAS,CACbF,MAAOA,KADM,CAEbF,OAAQtB,QAAA,CAAS8B,MAAT,CAAgB,EAAhB,CAAoBN,KAApB,CAA2B,CAACoQ,QAASK,GAAV,CAA3B,CAFK,CAGbE,KAAM,CAACP,QAASC,aAAV,CAHO,CAMftQ,YAAA,CAAYG,CAAZ,CAAoB,CAClB0Q,OAAa1R,IAAA,CAAE,qBAAF,CADK,CAElB2R,YAAa3R,IAAA,CAAE,qBAAF,CAFK,CAApB,CAGG,CACDkR,QAAalR,IAAA,CAAE,iBAAF,CADZ,CAHH,CAOA,OAAOyQ,UAAA,CAAU,CACf3Q,KAlMa8R,MAiME,CAEfpQ,KA1nCmB6Q,aAwnCJ,CAGf/Q,IA7OW8Q,OA0OI,CAIfE,KAAMP,OAJS,CAKf/Q,OAAAA,CALe,CAAV,CAMJ6P,UANI,CAlCiE,CA8C1E0B,QAASA,qBAAoB,CAAC3S,IAAD,CAAO8B,MAAP,CAAemP,UAAf,CAA2BkB,OAA3B,CAAoC,CAC/D,IAAM/R,EAAIkP,eAAA,CAAOtP,IAAP,CAAa8B,MAAb,CAAV,CACMoP,SAAW9Q,CAAA,CAAEoP,UAAF,EADjB,CAEM2B,UAAYO,OAAA,CAAQtR,CAAA,CAAE6P,iBAAF,EAAR,CAFlB;AAGMlP,OAASX,CAAA,CAAE0P,cAAF,EAHf,CAKI8C,QAAUxS,CAAA,CAAE,cAAF,CALd,CAMIc,KANJ,CAMWF,MANX,CAMyBuR,OAAS,EANlC,CAQMnR,OAAS,CACbF,MAAOA,KAAPA,CAAe,CACboQ,QAASC,aADI,CADF,CAIbvQ,OAAQA,MAARA,CAAiB,CACfsQ,QAASK,GADM,CAEfkB,KAAM,CAAClO,MAzQEmO,OAyQH,CAFS,CAJJ,CAQbjB,KAAM,CACJP,QAASC,aADL,CARO,CAaftQ,YAAA,CAAYG,MAAZ,CAAoB,CAClBwQ,KAAaxR,CAAA,CAAE,YAAF,CADK,CAElB2S,YAAa3S,CAAA,CAAE,cAAF,CAFK,CAGlB4S,KAAa5S,CAAA,CAAE,WAAF,CAHK,CAIlB6S,SAAa7S,CAAA,CAAE,eAAF,CAJK,CAKlB8S,UAAa9S,CAAA,CAAE,gBAAF,CALK,CAMlB+S,WAAa/S,CAAA,CAAE,iBAAF,CANK,CAOlBgT,MAAaxS,cAAA,CAAMZ,IAAN,CAAWqT,UAAX,CAAuBvR,MAAvB,CAA8BwR,kBAA9B,CAPK,CAApB,CAUA,IAAIpC,QAAJ,CAAc,CACZhQ,KAAA,CAAMqS,KAAN,CAAc,CAAC3S,MAAO,MAAR,CACdM,MAAA,CAAMsS,QAAN,CAAiBxS,MAAjB,CAAwBwS,QAAxB;AAAmC,CAAC9Q,OApCnB+Q,iEAoCkB,CACnCrB,SAAA,CAAI,GAAK,KAAA3J,EAAI,GAAK8J,OAAA,CAAS,IAHf,CAAd,IAKErR,MAES,CAFHqS,KAEG,CAFKvS,MAEL,CAFYuS,KAEZ,CAFoB,CAAC7Q,OAxCdgR,iEAwCa,CAEpB,CADTxS,KACS,CADHsS,QACG,CADQ,CAAC5S,MAAO,KAAR,CACR,CAATwR,QAAS,CAAL,GAAK,CAAA3J,CAAA,CAAI,GAGfvH,MAAA,CAAMkR,QAAN,CAAA,CAAWpR,MAAA,CAAOoR,QAAP,CAAX,CAAuB,CAAC1P,OAAQ6P,MAAR7P,CAAiB,YAAlB,CAAmCoB,KAAM/C,MAAzC,CAEvBG,MAAA,CAAMuH,CAAN,CAAA,CAAWzH,MAAA,CAAOyH,CAAP,CAAX,CAAuB0I,SACvBA,UAAA,CAAUpN,MAAV,CAAmBnD,cAAA,CAAMZ,IAAN,CAAW2T,WAAX,CAAwB7R,MAAxB,CAA+B8R,mBAA/B,CAAnB,EAA0E,CAE1EhB,QAAA,CAAUA,OAAA,CAAU,CAClBiB,WAAYzT,CAAA,CAAE,iBAAF,CADM,CAElBwI,OAAQgK,OAFU;AAGlBkB,MAAO,aAHW,CAAV,CAINpQ,IAAAA,EAGJ,OAAOmN,UAAA,CAAU,CACf3Q,KAjQa6T,MAgQE,CAEfnS,KAzrCoBoS,cAurCL,CAGfnS,MA7SoBoS,aA0SL,CAIfvS,IAhTW8Q,OA4SI,CAKfE,KAAMP,OALS,CAMf/Q,OAAAA,MANe,CAOfwR,QAAAA,OAPe,CAAV,CAQJ3B,UARI,CAtDwD,CAkEjEiD,QAASA,mBAAkB,CAAClU,IAAD,CAAO8B,MAAP,CAAemP,UAAf,CAA2BkB,OAA3B,CAAoC7B,OAApC,CAA6C,CACtE,IAAMlQ,EAAIkP,eAAA,CAAOtP,IAAP,CAAa8B,MAAb,CAAV,CACMqS,QAAUlD,UAAVkD,CAAqBA,OAD3B,CAEM9E,YAAc,EAAG8E,CAAAA,OAAH,EAAc9E,CAAA8E,OAAA9E,CAAQA,WAAtB,CAFpB,CAGM1O,KAAOwT,OAAA,CAAUA,OAAV,CAAkBxT,IAAlB,CAAyB+C,IAAAA,EAHtC,CAIM2N,OAASjR,CAAA,CAAE,YAAF,CAJf,CAKMgU,aAAehU,CAAA,CAAE,cAAF,CALrB,CAMMiU,SAAW,CAACnI,KAAM,OAAP,CANjB,CAOMoI,QAAU,GAAVA,CAAchE,OAAdgE,CAAU,+BAPhB;AAQMC,QAAUlD,MAAA,CAASK,OAAA,CAAQL,MAAR,CAAT,CAA2B,CAAC1M,MAtTjC6P,MAsTgC,CAR3C,CAUMC,MAAQ,SAARA,CAAkBnE,OAAlBmE,CAAQ,GAVd,CAYYvT,KAZZ,CAYmBF,MAEnBuT,QAAA,CAAQzQ,IAAR,CAAe,EAGf,KAAA1C,OAAS,CACPF,MAAQA,KAARA,CAAgB,CACdoQ,QAASC,aADK,CAEdC,EAAG,CAAC9O,OAAQ4R,OAAT,CAAkBxQ,KAAM,EAAxB,CAA6BC,OAAQqQ,YAArC,CAFW,CAGd3C,EAAG8C,OAHW,CADT,CAMPvT,OAAQA,MAARA,CAAiB,CACfsQ,QAASK,GADM,CAEfH,EAAGtQ,KAAHsQ,CAASA,CAFM,CAGfC,EAAGvQ,KAAHuQ,CAASA,CAHM,CANV,CAWPI,KAAM,CACJP,QAASC,aADL,CAXC,CAlB6D,KAkClEmD,SAAW,IAlCuD,CAmClEC,WAAa,IACZ3U,KAAL,CAAU4R,IAAV,GACE8C,QACA,CADW5S,MACX,CADkB8S,mBAClB,CAAAD,UAAA,CAAa7S,MAAb,CAAoB+S,qBAFtB,CAKA5T,YAAA,CAAYG,MAAZ,CAAoB,CAClBwQ,KAAkBxR,CAAA,CAAE,iBAAF,CAAqBsU,QAArB,CADA,CAElBI,MAAkB1U,CAAA,CAAE,YAAF,CAFA,CAGlB2U,KAAkB3U,CAAA,CAAE,YAAF,CAHA;AAIlB0R,OAAkB1R,CAAA,CAAE,mBAAF,CAAuBuU,UAAvB,CAJA,CAKlBK,WAAkB5U,CAAA,CAAE,YAAF,CALA,CAMlB6U,iBAAkB7U,CAAA,CAAE,kBAAF,CANA,CAOlB2R,YAAkB3R,CAAA,CAAE,mBAAF,CAPA,CAApB,CAQG,CACDkR,QAAkBlR,CAAA,CAAE,eAAF,CADjB,CARH,CAYA8U,aAAA,CAAazS,OAAb,CAAqB,QAAA,CAAAc,KAAA,CAAS,CACxBvD,IAAA,CAAKuD,KAAL,CAAJ,GACEvC,MAAA,CAAOuC,KAAP,CADF,CACkBrC,KAAA,CAAMqC,KAAN,CADlB,CACiC,CAACA,MAAOvD,IAAA,CAAKuD,KAAL,CAAR,CAAqBoB,MA/W3C6N,OA+WsB,CADjC,CAD4B,CAA9B,CAMM2C,OAAAA,CAAUtE,SAAA,CAAU,CACxB3Q,KAzUekV,QAwUS,CAExBxT,KA/vCqByT,eA6vCG,CAGxB3T,IAtXW8Q,OAmXa,CAIxBE,KAAM2B,QAJkB,CAKxBiB,KAAMjE,MAAA,CAAS,CAAA,CAAT,CAAgB3N,IAAAA,EALE,CAMxBtC,OAAAA,MANwB,CAAV,CAOb6P,UAPa,CAOFkE,OAPE,CAUVxB,OAAAA,CAAcjC,OAAA,CAAQ0C,YAAR,CACpBT,OAAA,CAAY5P,MAAZ,CAAqB3D,CAAA,CAAE,aAAF,CAErBgB,OAAA,CAAS,CACPF,MAAQA,KAARA;AAAgB,CACdoQ,QAASC,aADK,CAEdC,EAAG,CAAC9O,OAAQ4R,OAAT,CAAkBvQ,OAAQ4P,MAA1B,CAFW,CAGdlC,EAAG8C,OAHW,CADT,CAMPvT,OAAQA,MAARA,CAAiB,CACfsQ,QAASK,GADM,CAEfkB,KAAM,CAAClO,MA5YEmO,OA4YH,CAFS,CAGftB,EAAGtQ,KAAHsQ,CAASA,CAHM,CAIfC,EAAGvQ,KAAHuQ,CAASA,CAJM,CANV,CAYPI,KAAM,CACJP,QAASC,aADL,CAZC,CAiBTtQ,YAAA,CAAYG,MAAZ,CAAoB,CAClBmS,MAAanT,CAAA,CAAE,YAAF,CADK,CAElBoT,SAAapT,CAAA,CAAE,eAAF,CAFK,CAGlBwR,KAAaxR,CAAA,CAAE,YAAF,CAHK,CAIlB2S,YAAa3S,CAAA,CAAE,cAAF,CAJK,CAKlB4S,KAAa5S,CAAA,CAAE,WAAF,CALK,CAMlB6S,SAAa7S,CAAA,CAAE,eAAF,CANK,CAOlB8S,UAAa9S,CAAA,CAAE,gBAAF,CAPK,CAQlB+S,WAAa/S,CAAA,CAAE,iBAAF,CARK,CASlBgT,MAAahT,CAAA,CAAE,YAAF,CATK,CAApB,CAYMmV,WAAAA,CAAS1E,SAAA,CAAU,CACvB3Q,KAlXa6T,MAiXU,CAEvBnS,KA1yCoBoS,cAwyCG,CAGvBnS,MA9ZoBoS,aA2ZG,CAIvBvS,IAjaW8Q,OA6ZY;AAKvBE,KAAO2B,QALgB,CAMvBjT,OAAAA,MANuB,CAAV,CAOZ6P,UAPY,CAODsE,MAPC,CAUfnU,OAAA,CAAS,CACPF,MAAO,CACLsU,QAAS,CAAC5U,MAAO,CAACyQ,MAAT,CADJ,CAELD,MAAOG,aAFF,CAGLF,OAAQA,MAAA,CAASK,OAAA,CAAQL,MAAR,CAAT,CAA2BE,aAH9B,CAILD,QAASC,aAJJ,CADA,CAOPM,KAAM,CAACP,QAASC,aAAV,CAPC,CAQPvQ,OAAQA,MAARA,CAAiB,CACfsQ,QAASK,GADM,CAEf8D,IAAK,CAAC/S,OAAQ,IAAT,CAFU,CAGfgT,OAAQ,CAAChT,OAAQ,IAAT,CAHO,CARV,CAgBLtC,EAAA,CAAEoP,UAAF,CAAa,CAAA,CAAb,CAAJ,EACEmG,CAGA,CAHQ,gCAGR,CAHyClB,KAGzC,CAHQ,GAGR,CAFAzT,MAEA,CAFOyU,GAEP,CAFW/S,MAEX,CAFoB,cAEpB,CAFgCiT,CAEhC,CADA3U,MACA,CADO0U,MACP,CADchT,MACd,CADuB,sBACvB,CAD2CiT,CAC3C,CADuB,GACvB,CAAApJ,CAAA,CAAO,CAAC5H,MAAO,CAAC,KAAD,CAzHHiR,aAyHG,CAAR,CAJT,GAME5U,MAEA,CAFOyU,GAEP,CAFW/S,MAEX,CAFoB,sBAEpB,CAFwC+R,KAExC,CAFoB,GAEpB;AADAzT,MACA,CADO0U,MACP,CADchT,MACd,CADuB,gBACvB,CADqC+R,KACrC,CAAAlI,CAAA,CAAO,CAAC5H,MA7HIiR,aA6HL,CART,CAWA5U,OAAA,CAAO0U,MAAP,CAAchT,MAAd,CAAuB,GAAvB,CAA2B4N,OAA3B,CAAuB,IAAvB,CAAuCtP,MAAvC,CAA8C0U,MAA9C,CAAqDhT,MAArD,CAAuB,cAGvByP,QAAA,CAAU,CAAC0D,MAAO,CAAC3J,KAAMiG,OAAP,CAAgBxR,KAAM,OAAtB,CAA+BiN,QA1cpCkI,OA0cK,CAAR,CAEV,OAAO3G,WAAA,CAAW,CAChBvN,KAh2CcmU,OA+1CE,CAEhBrD,KAAQP,OAFQ,CAGhB/Q,OAAQD,YAAA,CAAaC,MAAb,CAAqB+S,OAArB,CAA8BpD,IAA9B,CAHQ,CAIhBiF,MAAQ,CAACb,MAAD,CAAUI,UAAV,CAJQ,CAKhB5U,KAAAA,IALgB,CAMhB0O,YAAAA,WANgB,CAOhB9C,KAAAA,CAPgB,CAAX,CA/I+D,CA0JxE0J,QAASA,mBAAkB,CAACjW,IAAD,CAAO8B,MAAP,CAAe,CAClC1B,IAAAA,CAAIkP,eAAA,CAAOtP,IAAP,CAAa8B,MAAb,CAGV,OAAO,CACLyR,MAASnT,IAAA,CAAE,WAAF,CADJ,CAELkQ,QAASlQ,IAAA,CAAEgQ,YAAF,EAFJ,CAGL8F,OAAS,CACPT,IAAK,CAAA,CADE;AAEPC,OAAQ,CAAA,CAFD,CAHJ,CAOLS,QAAS,CACPV,IAAQrV,IAAA,CAAE,YAAF,CADD,CAEPsV,OAAQtV,IAAA,CAAE,eAAF,CAFD,CAPJ,CAJiC,CA8B1CgW,QAASA,YAAW,CAACpW,IAAD,CAAO8B,MAAP,CAAemP,UAAf,CAA2BkB,OAA3B,CAAoC,CAChD/R,MAAAA,CAAIkP,eAAA,CAAOtP,IAAP,CAAa8B,MAAb,CAEV,KAAMV,OAAS,CACbF,MAAO,CAACoQ,QAASC,aAAV,CADM,CAEbvQ,OAAQ,CACNsQ,QAASK,GADH,CAENH,EAAG,CAAC7M,MAAO,CAACtC,MAAO,SAAR,CAAR,CAFG,CAGNoP,EAAG,CAAC9M,MAAO,CAACtC,MAAO,SAAR,CAAR,CAHG,CAFK,CAObwP,KAAM,CAACP,QAASC,aAAV,CAPO,CAUftQ,YAAA,CAAYG,MAAZ,CAAoB,CAClBiV,OAAajW,MAAA,CAAE,aAAF,CADK,CAElBkW,QAAalW,MAAA,CAAE,aAAF,CAFK,CAGlBmW,OAAa,CAAC7T,OApBC8T,8GAoBF,CAHK;AAIlBC,MAAa,CAAC/T,OApBAgU,+IAoBD,CAJK,CAKlBnD,MAAa,CAAC7Q,OAAQiU,SAAT,CALK,CAMlBnD,SAAa,CAAC9Q,OAAQkU,YAAT,CANK,CAOlB/D,KAAa7S,IAAb6S,CAAkBgE,KAPA,CAQlBjF,KAAaxR,MAAA,CAAE,YAAF,CARK,CASlB2S,YAAa3S,MAAA,CAAE,cAAF,CATK,CAUlB4S,KAAa5S,MAAA,CAAE,WAAF,CAVK,CAWlB6S,SAAa7S,MAAA,CAAE,eAAF,CAXK,CAYlB8S,UAAa9S,MAAA,CAAE,gBAAF,CAZK,CAalB+S,WAAa/S,MAAA,CAAE,iBAAF,CAbK,CAclBgT,MAAahT,MAAA,CAAE,YAAF,CAdK,CAelB0W,WAAa1W,MAAA,CAAE,iBAAF,CAfK,CAApB,CAgBG,CACDmT,MAAanT,MAAA,CAAE,YAAF,CADZ;AAEDoT,SAAapT,MAAA,CAAE,eAAF,CAFZ,CAhBH,CAqBA,OAAOyQ,UAAA,CAAU,CACf3Q,KAvea6T,MAseE,CAEfnS,KA75CoBmV,cA25CL,CAGflV,MAlhBoBmV,aA+gBL,CAIftE,KAAOP,OAJQ,CAKf/Q,OAAAA,MALe,CAAV,CAMJ6P,UANI,CAlC+C,CA2CxDqE,QAASA,cAAI,CAACA,IAAD,CAAO5P,KAAP,CAAc,CACzB,IAAIc,IAEA9G,SAAA,CAASO,QAAT,CAAkBqV,IAAlB,CAAJ,GACMA,IAAJ,CAAS5S,MAAT,CACE8D,IADF,CACS8O,IADT,CACc5S,MADd,CAEW4S,IAAJ,CAAS2B,IAAT,CACLzQ,IADK,CACE,YADF,CACiBqD,cAAA,CAAMyL,IAAN,CAAW2B,IAAX,CADjB,CACoC,GADpC,CAEI3B,IAFJ,CAES4B,MAFT,GAGL1Q,IAHK,CAGE,WAHF,CAGgBqD,cAAA,CAAMyL,IAAN,CAAW4B,MAAX,CAHhB,CAGqC,qBAHrC,CAHT,CAUA,OAAO1Q,KAAA,CACHd,KAAA,CAAMoF,SAAN,CAAgBtE,IAAhB,CADG,CAEH,CAAC,CAAC8O,IAfmB,CAkB3BzL,QAASA,eAAK,CAACjJ,KAAD,CAAQ,CACpB,MAAOlB,SAAA,CAASO,QAAT,CAAkBW,KAAlB,CAAA,EAA4BA,KAA5B,CAAkC8B,MAAlC;AACH9B,KADG,CACG8B,MADH,CAEHhD,QAAA,CAAS4E,WAAT,CAAqB1D,KAArB,CAHgB,CAMtBuW,QAASA,QAAO,CAACnX,IAAD,CAAO,CACrB,IAAM4B,KAAO5B,IAAP4B,CAAYA,IAAZA,EAAoB,EAC1B,OAASA,KAAA,CAAKwV,OAAL,CAAa,MAAb,CAAF,EAA2BxV,IAAA,CAAKwV,OAAL,CAAa,QAAb,CAA3B,EAAsDxV,IAAA,CAAKwV,OAAL,CAAa,OAAb,CAAtD,CA7gBShI,OA+gBZ,GAAApP,IAAA,CAAKE,IAAL,CA/8CY6V,OA+8CZ,CAAuCnU,IAAvC,EAj9CWU,MA+8CR,CACHV,IAHiB,CAOvByV,QAASA,WAAU,CAACrX,IAAD,CAAO,CACxB,MAAO,CACLmG,SAAcnG,IAAdmG,CAAmBjG,IADd,CAELS,KAAcX,IAAdW,CAAmBA,IAAnBA,EAA2B+C,IAAAA,EAFtB,CAGL9B,KAAc5B,IAAd4B,CAAmBA,IAAnBA,EAA2BuV,OAAA,CAAQnX,IAAR,CAHtB,CAILsX,OAAc,CAACtX,IAAD,CAAMsX,MAApBA,EAA8B5T,IAAAA,EAJzB,CAKL6T,KAAcvX,IAAduX,CAAmBA,IALd,CAMLC,YAAcxX,IAAdwX,CAAmBA,WANd,CADiB,CAW1BnI,QAASA,YAAW,CAACrP,IAAD,CAAO0F,KAAP,CAAc,CAChC,MAAO1F,KAAA,EAAQA,IAAR,CAAa0C,MAAb,CAAsBgD,KAAA,CAAMoF,SAAN,CAAgB9K,IAAhB,CAAqB0C,MAArB,CAAtB,CACM,CAAA,CAAT,GAAA1C,IAAA,CAAiB,CAAA,CAAjB,CACA,CAAA,CAH4B,CASlCyX,QAASA,eAAc,CAACzX,IAAD;AAAO0F,KAAP,CAAc,CACnC,IAAMgS,IAAM5X,YAAA,CAAauX,UAAb,CAAwBrX,IAAxB,CAA6BE,IAA7B,CACPwX,IAAL,EAAUhY,QAAA,CAASyF,KAAT,CAAe,+BAAf,CAAiDzF,QAAA,CAAS4E,WAAT,CAAqBtE,IAArB,CAA0BE,IAA1B,CAAjD,CAEQ,KAAA,yBAAAwX,GAAA,CAAIxX,IAAJ,CAASyX,WAAT,EAA8B,KAAA,OAAAC,eAAA,CAAgBF,GAAhB,CAAqB1X,IAArB,CAA2B0F,KAA3B,CArrChD,yBAAA,CAAO,IAAI8B,KAAJ,CAAUtH,wBAAV,CAqrCmCU,IArrCnC,CAAuB+E,MAAvB,CAqrCGZ,IAAA,EArrCH,CAsrCH/E,KAAJ,CAAS0C,MAAT,EAAiBgD,KAAA,CAAM0B,SAAN,CAAgBpH,IAAhB,CAAqB0C,MAArB,CAA6BgD,KAAA,CAAMmS,KAAN,CADpCC,wBACoC,CAA7B,CADPA,yBAEV,CAAEC,QAAF,CAAaL,GAAb,CAAiBK,QAAjB,EAA6B,EAE7B,OAJUD,yBAJyB,CAcrCF,QAASA,gBAAe,CAACF,GAAD;AAAM1X,IAAN,CAAY0F,KAAZ,CAAmB,CAIzC,IAHA,IAAMC,OAAS,EAAf,CACMqS,EAAIN,GAAJM,CAAQrS,MAARqS,CAAejX,MADrB,CAGSkX,EAAI,CAAb,CAAgBA,CAAhB,CAAoBD,CAApB,CAAuB,EAAEC,CAAzB,CAA4B,CAC1B,IAAMC,KAAOR,GAAA,CAAI/R,MAAJ,CAAWsS,CAAX,CACbtS,OAAA,CAAOuS,IAAP,CAAYvX,IAAZ,CAAA,CAAoBwX,gBAAA,CAAiBD,IAAjB,CAAuBlY,IAAvB,CAA6B0F,KAA7B,CAFM,CAI5B,MAAOC,OARkC,CAc3CwS,QAASA,iBAAgB,CAACT,GAAD,CAAM1X,IAAN,CAAY0F,KAAZ,CAAmB,CAC1C,IAAMxF,KAAOwX,GAAPxX,CAAWA,IAAjB,CACMU,MAAQZ,IAAA,CAAK0X,GAAL,CAAS/W,IAAT,CAEd,IAAa,OAAb,GAAIT,IAAJ,CACE,MAAOkY,oBAAA,CAAoBV,GAApB,CAAyB1X,IAAzB,CAA+B0F,KAA/B,CACF,IAAchC,IAAAA,EAAd,GAAI9C,KAAJ,CACD8W,GAAJ,CAAQW,QAAR,EACE3Y,QAAA,CAASyF,KAAT,CAAe,mBAAf,CAAqCzF,QAAA,CAAS4E,WAAT,CAAqBtE,IAArB,CAA0BE,IAA1B,CAArC,CACM,cADN,CACuBR,QAAA,CAAS4E,WAAT,CAAqBoT,GAArB,CAAyB/W,IAAzB,CADvB,CAFG,KAMA,OAAa,OAAb,GAAIT,IAAJ,CACEoY,kBAAA,CAAmBZ,GAAnB,CAAwB1X,IAAxB,CAA8B0F,KAA9B,CADF;AAEa,YAAb,GAAIxF,IAAJ,CACEwF,KAAA,CAAM6S,aAAN,CAAoBvY,IAAA,CAAK0X,GAAL,CAAS/W,IAAT,CAApB,CADF,CAIA+W,GAAA,CAAIlV,KAAJ,EAAa,CAAC4F,QAAA,CAASxH,KAAT,CAAd,CACHA,KAAA,CAAMyD,GAAN,CAAU,QAAA,CAAAoE,CAAA,CAAK,CAAA,MAAA+P,eAAA,CAAed,GAAf,CAAoBjP,CAApB,CAAuB/C,KAAvB,CAAA,CAAf,CADG,CAEH8S,cAAA,CAAed,GAAf,CAAoB9W,KAApB,CAA2B8E,KAA3B,CApBsC,CA0B5C8S,QAASA,eAAc,CAACd,GAAD,CAAM9W,KAAN,CAAa8E,KAAb,CAAoB,CACzC,IAAMxF,KAAOwX,GAAPxX,CAAWA,IAEjB,OAAIkI,SAAA,CAASxH,KAAT,CAAJ,CA0E0B,MAzEjB,GAASV,IAAT,CAAiBR,QAAA,CAASyF,KAAT,CAAe,2CAAf,CAAjB,CA2EgB,OA1EhB,GAAQjF,IAAR,CAAgBwF,KAAA,CAAMkC,QAAN,CAAehH,KAAf,CAAhB,CA4EkB,SA3ElB,GAAUV,IAAV,CAAkBwF,KAAA,CAAM+S,UAAN,CAAiB7X,KAAjB,CAAlB,CACA8E,KAAA,CAAMoF,SAAN,CAAgBlK,KAAhB,CAAsB8B,MAAtB,CAJT,CAOS,CADD8D,GACC,CADMkR,GACN,CADUlR,IACV,EAqEgB,OArEhB,GAD0BtG,IAC1B,GAAkBU,KAAlB,EAAkBA,KAAlB,CA6DmB4F,IA7DnB,CAA2Bd,KAAA,CAAMgT,OAAN,CAAc9X,KAAd,CAAoB4F,IAApB;AAA0B5F,KAA1B,CAAgCqN,EAAhC,CAA3B,CACAzH,GAAA,EAAmB5F,KAAnB,EAAmBA,KAAnB,CA8DoB+D,KA9DpB,CAA4BiD,QAAA,CAAShH,KAAT,CAAe+D,KAAf,CAAsB/D,KAAtB,CAA4BqN,EAA5B,CAA5B,CAkEiB,MAjEjB,GAAS/N,IAAT,CAAiBP,aAAA,CAAc8G,eAAd,CAA8B7F,KAA9B,CAAqC8E,KAArC,CAAjB,CA+De,MA9Df,GAAOxF,IAAP,CAAe0E,YAAA,CAAIc,KAAA,CAAMyG,OAAN,CAAcvL,KAAd,CAAJ,CAAyB2N,MAAzB,CAAf,CAkEgB,OAjEhB,GAAQrO,IAAR,CAAgB0H,QAAA,CAAShH,KAAT,CAAhB,CAmEkB,SAlElB,GAAUV,IAAV,CAAkBwF,KAAA,CAAM+S,UAAN,CAAiB7X,KAAjB,CAAlB,CACAA,KAhBgC,CAuB3CwX,QAASA,oBAAmB,CAACV,GAAD,CAAM1X,IAAN,CAAY0F,KAAZ,CAAmB,CACxChG,QAAA,CAAS0F,QAAT,CAAkBpF,IAAlB,CAAuB0S,IAAvB,CAAL,EACEhT,QAAA,CAASyF,KAAT,CAAe,mDAAf,CAEF,OAAOO,MAAA,CAAMyG,OAAN,CAAcnM,IAAd,CAAmB0S,IAAnB,CAAA,CAAyBiG,SAAzB,CAAmCjT,KAAnC,CAA0C1F,IAA1C,CAA+C0B,GAA/C,CAJsC,CAU/C4W,QAASA,mBAAkB,CAACZ,GAAD,CAAM1X,IAAN,CAAY0F,KAAZ,CAAmB,CACtC9E,IAAAA;AAAQZ,IAAA,CAAK0X,GAAL,CAAS/W,IAAT,CAEd,OAAI+W,IAAJ,CAAQlV,KAAR,EACO9C,QAAA,CAASoB,OAAT,CAAiBF,IAAjB,CAGE,EAFLlB,QAAA,CAASyF,KAAT,CAAe,gDAAf,CAAkEzF,QAAA,CAAS4E,WAAT,CAAqB1D,IAArB,CAAlE,CAEK,CAAAA,IAAA,CAAMyD,GAAN,CAAU,QAAA,CAAAoE,CAAA,CAAK,CAAA,MAAAmQ,kBAAA,CAAkBlB,GAAlB,CAAuBjP,CAAvB,CAA0B/C,KAA1B,CAAA,CAAf,CAJT,EAMSkT,iBAAA,CAAkBlB,GAAlB,CAAuB9W,IAAvB,CAA8B8E,KAA9B,CATmC,CAgB9CkT,QAASA,kBAAiB,CAAClB,GAAD,CAAM9W,KAAN,CAAa8E,KAAb,CAAoB,CAK5C,IAJA,IAAMsS,EAAGN,GAAHM,CAAOrS,MAAPqS,CAAcjX,MAApB,CACImX,IADJ,CAISD,EAAI,CAAb,CAAgBA,CAAhB,CAAoBD,CAApB,CAAuB,EAAEC,CAAzB,CAA4B,CAC1BC,IAAA,CAAOR,GAAA,CAAI/R,MAAJ,CAAWsS,CAAX,CACP,KAAKY,IAAMA,CAAX,GAAgBX,KAAhB,CAAqBxW,GAArB,CACE,GAAIwW,IAAA,CAAKxW,GAAL,CAASmX,CAAT,CAAJ,GAAoBjY,KAAA,CAAMiY,CAAN,CAApB,CAA8B,CAAEX,IAAA,CAAO,IAAM,MAAf,CAEhC,GAAIA,IAAJ,CAAU,KALgB,CAQvBA,IAAL,EAAWxY,QAAA,CAASyF,KAAT,CAAe,yBAAf,CAA2CzF,QAAA,CAAS4E,WAAT,CAAqB1D,KAArB,CAA3C,CAGL+E;GAAAA,CAASjG,QAAA,CAAS8B,MAAT,CAAgBoW,eAAA,CAAgBM,IAAhB,CAAsBtX,KAAtB,CAA6B8E,KAA7B,CAAhB,CAAqDwS,IAArD,CAA0DxW,GAA1D,CACf,OAAOkD,aAAA,CAAIc,KAAA,CAAMwI,GAAN,CAAU4K,MAAA,CAAOnT,GAAP,CAAV,CAAJ,CAjBqC,CAkC9CoT,QAASA,UAAS,CAACrG,IAAD,CAAOrQ,KAAP,CAAcqD,KAAd,CAAqB,CAAA,IACjCmQ,KADiC,CACR9Q,MAG7B,IAAI,CAAC2N,IAAL,CACE,IAAAP,QAAUvN,YAAA,CAAIc,KAAA,CAAMwI,GAAN,CAAUlB,OAAA,CAAQ,IAAR,CAAc,CAAC,EAAD,CAAd,CAAV,CAAJ,CADZ,KAKK,IAAI6I,KAAJ,CAAYnD,IAAZ,CAAiBmD,KAAjB,CAIH,GAHKxT,KAGD,EAHQ3C,QAAA,CAASyF,KAAT,CAAe,kCAAf,CAGR,CAAe,IAAf,EAAA0Q,KAAA,CAAMlR,KAAV,CACEwN,OAAA,CAAUpN,MAAV,CAAmBiU,UAAA,CAAWnD,KAAX,CAAkBnQ,KAAlB,CADrB,KAEO,CAEAgN,IAAL,CAAUxG,IAAV,CASEnH,MATF,CASWH,YAAA,CAAIc,KAAA,CAAMyG,OAAN,CAAcuG,IAAd,CAAmBxG,IAAnB,CAAJ,CAA6B+M,SAA7B,CATX,EACE9R,KAMA,CANKsQ,cAAA,CAAe/X,QAAA,CAAS8B,MAAT,CAAgB,CAClCtB,KAAS,WADyB,CAElC0N,QAASlO,QAAA,CAAS8C,KAAT,CAAeqT,KAAf,CAAqBjI,OAArB,CAFyB,CAAhB;AAGjBiI,KAHiB,CAGXoD,SAHW,CAAf,CAGgBvT,KAHhB,CAML,CAFAyB,KAEA,CAFGxB,MAEH,CAFUjE,GAEV,CAFgBgE,KAAA,CAAMqC,MAAN,CAAa8N,KAAb,CAAmBjI,OAAnB,CAEhB,CADAzG,KACA,CADGxB,MACH,CADUmI,KACV,CADkBkL,UAAA,CAAWnD,KAAX,CAAkBnQ,KAAlB,CAClB,CAAAyM,OAAA,CAAUpN,MAAV,CAAmBH,YAAA,CAAIc,KAAA,CAAMwI,GAAN,CAAU/G,KAAV,CAAJ,CAPrB,CAYA,KAAAzF,IAAMgE,KAAA,CAAMqC,MAAN,CAAa8N,KAAb,CAAmBjI,OAAnB,CAA4B,CAAA,CAA5B,CAdD,CAmBJuE,OAAL,GACEA,OADF,CACY6G,UAAA,CAAWtG,IAAX,CAAiBhN,KAAjB,CADZ,CAIA,OAAO,CACLhE,IAAKA,GADA,CAELoM,MAAOqE,OAFF,CAGLpN,OAAQA,MAHH,CAtC8B,CA6CvCiU,QAASA,WAAU,CAACtG,IAAD,CAAOhN,KAAP,CAAc,CAC/B,MAAOgN,KAAA,CAAKhL,IAAL,CAAYgL,IAAZ,CACHA,IAAA,CAAKxG,IAAL,EAAawG,IAAb,CAAkBxG,IAAlB,CAAuBxE,IAAvB,CAA8BgL,IAA9B,CAAmCxG,IAAnC,CACAtH,YAAA,CAAIc,KAAA,CAAMyG,OAAN,CAAcuG,IAAd,CAAmBxG,IAAnB,CAAJ,CAA6BgN,MAA7B,CAH2B,CAMjCC,QAASA,UAAS,CAACzT,KAAD,CAAQwH,KAAR,CAAegM,MAAf,CAAuB3K,MAAvB,CAA+B6K,IAA/B,CAAqC,CACrD,IAAA,CAAK1T,KAAL,CAAaA,KACb,KAAA,CAAKwH,KAAL,CAAaA,KACb;IAAA,CAAKgM,MAAL,CAAcA,MACd,KAAA,CAAK3K,MAAL,CAAcA,MAGd,KAAA,CAAK0K,SAAL,CAAiBG,IAGjB,KAAA,CAAKxD,KAAL,CAAa,EAVwC,CAqCvDyD,QAASA,SAAQ,CAAC1U,KAAD,CAAQ,CACvB,MAAOjF,SAAA,CAAS0F,QAAT,CAAkBT,KAAlB,CAAA,CAA2BA,KAA3B,CAAmC,IADnB,CAIzB2U,QAASA,aAAY,CAAC5T,KAAD,CAAQiI,CAAR,CAAWpB,IAAX,CAAiB,CACpC,IAAM0B,GAAK9F,SAAA,CAAUoE,IAAV,CAAepF,EAAf,CAAmBoF,IAAnB,CAAwB5H,KAAxB,CAAX,CACIzB,CAEJ,IAAIyK,CAAJ,CAAMI,GAAN,CACE,IADS,IACAkK,EAAI,CADJ,CACOD,EAAIrK,CAAJqK,CAAM/J,EAAN+J,CAASjX,MAAzB,CAAiCkX,CAAjC,CAAqCD,CAArC,CAAwC,EAAEC,CAA1C,CACE,IAAItK,CAAA,CAAEM,EAAF,CAAKgK,CAAL,CAAJ,GAAgBhK,EAAhB,CAAoB,MAApB,CAFJ,IAKEN,EAEA,CAFEI,GAEF,CAFQ,CAAC,OAAD,CAER,CADAJ,CACA,CADE5H,MACF,CADW,CAAC,IAAD,CACX,CAAA4H,CAAA,CAAEM,EAAF,CAAO,CAAC,OAAD,CAEL1B,KAAJ,CAASpF,EAAT,GACEwG,CAAA,CAAEI,GAAF,CAAMhH,IAAN,CAAW,CAAC7D,CAAD,CAAGqJ,IAAH,CAAQpF,EAAR,CAAWzE,MAAX,EAAqBgD,KAAA,CAAMoF,SAAN,CAAgB5H,CAAhB,CAArB,CAA0CqJ,IAA1C,CAA+CpF,EAA1D,CAEA,CADAwG,CAAA,CAAE5H,MAAF,CAASgB,IAAT,CAAcrB,KAAA,CAAMkC,QAAN,CAAe2E,IAAf,CAAoB5H,KAApB,CAAd,CACA,CAAAgJ,CAAA,CAAEM,EAAF,CAAKlH,IAAL,CAAUkH,EAAV,CAHF,CAboC,CAoBtCsL,QAASA,eAAK,CAAC7T,KAAD,CAAQ8T,EAAR,CAAY7Y,IAAZ,CAAkB8Y,MAAlB;AAA0B9U,KAA1B,CAAiC6I,MAAjC,CAAyCoI,KAAzC,CAAgD,CACtD2D,IAAAA,CAAQC,EAAA,CAAG7Y,IAAH,CAAR4Y,GAAqBC,EAAA,CAAG7Y,IAAH,CAArB4Y,CAAgC,EAAhCA,CAp4CN,KAAA,yBAAQ7Z,QAAA,CAASO,QAAT,CAq4CauN,MAr4Cb,CAAD,EAHUkM,YAIZ,GAo4CgBlM,MAp4ChB,CAAKsG,KAAL,CAA4B,GAA5B,CAAkC,GADhC,EAED3L,SAAA,CAm4CeqF,MAn4Cf,CAAerG,EAAf,CAm4CeqG,MAn4Cf,CAAwB7I,KAAxB,CAFC,CAA2B,EAm4C0B,KAIxDkU,EAAIQ,QAAA,CAAS1U,KAAT,CAGR,IAAS,IAAT,EAAIkU,CAAJ,CAAe,CACbnT,KAAA,CAAQ8T,EAAR,CAAW9T,KACPmT,EAAJ,EAPWtM,wBAOF,CAAO,GAAP,CAPEA,wBAOF,CAAoB,EAC7B,KAAA9D,EAAI8Q,IAAA,CAAMV,CAAN,CAHS,CAMVpQ,CAAL,GACQ9C,CAON,CAPe6H,MAAA,CACX,CAAC7I,MAAOkJ,WAAR,CAAqBC,MAAO0L,EAAA,CAAG9L,SAAH,CAAahI,KAAb,CAAoBf,KAApB,CAA2B6I,MAA3B,CAA5B,CADW,CAEX,CAAC7I,MAAOe,KAAA,CAAMkC,QAAN,CAAejD,KAAf,CAAR,CAA+BmJ,MAAOlJ,YAAA,CAAI4U,EAAJ,CAAON,MAAP,CAAtC,CAKJ,CAnBW3M,wBAmBX,GAJU5G,CAIV,CAJiB4G,IAIjB,CAJwB7G,KAAA,CAAM2I,OAAN,CAAcb,MAAd,CAIxB,EAHArG,KAGA,CAHKzB,KAAA,CAAMwI,GAAN,CA57CA,IAAI1G,KAAJ,CA47CkBiS,MA57ClB;AA47C0B/V,IAAAA,EA57C1B,CA47CqCiC,CA57CrC,CA47CUZ,IAAA,EA57CV,CA47CA,CAGL,CAFI6Q,KAEJ,GAFW4D,EAAA,CAAG5D,KAAH,CAASjR,KAAT,CAEX,CAF6BwC,KAE7B,EADAsB,CACA,CADI7D,YAAA,CAAIuC,KAAJ,CACJ,CAAS,IAAT,EAAI0R,CAAJ,GAAeU,IAAA,CAAMV,CAAN,CAAf,CAA0BpQ,CAA1B,CARF,CAUA,OAAOA,EAvBqD,CAiF9DkR,QAASA,WAAU,CAAC3Z,IAAD,CAAO0F,KAAP,CAAcrD,KAAd,CAAqB,CACtC,IAAMwT,MAAQ7V,IAAR6V,CAAanD,IAAbmD,CAAkBA,KAAxB,CACMlV,KAAOkV,KAAPlV,CAAaA,IADnB,CAEMuL,KAAO8M,UAAA,CAAWnD,KAAX,CAAkBnQ,KAAlB,CAFb,CAGIyB,EAEC0O,MAAL,CAAWlV,IAAX,EACEjB,QAAA,CAASyF,KAAT,CAAe,0BAAf,CAA4CzF,QAAA,CAAS4E,WAAT,CAAqBuR,KAArB,CAA5C,CAEGA,MAAL,CAAW3J,IAAX,EACExM,QAAA,CAASyF,KAAT,CAAe,mCAAf,CAAqDzF,QAAA,CAAS4E,WAAT,CAAqBuR,KAArB,CAArD,CAGEA,MAAJ,CAAUlR,KAAV,CACEwC,EADF,CACOzB,KAAA,CAAMwI,GAAN,CAAU0L,QAAA,CAAS,CACtBjV,MAAOe,KAAA,CAAMkC,QAAN,CAAeiO,KAAf,CAAqBlR,KAArB,CADe,CAEtBmJ,MAAO5B,IAFe,CAAT,CAAV,CADP,CAKW2J,KAAJ,CAAUjI,OAAV,CACLzG,EADK,CACAzB,KAAA,CAAMwI,GAAN,CAAU2L,KAAA,CAAM,CACnBnY,IAAOgE,KAAA,CAAMqC,MAAN,CAAa8N,KAAb,CAAmBjI,OAAnB,CADY;AAEnBvL,MAAOuC,YAAA,CAAIc,KAAA,CAAMmS,KAAN,CAAYxV,KAAZ,CAAkB0C,MAAlB,CAAJ,CAFY,CAGnB+I,MAAO5B,IAHY,CAAN,CAAV,CADA,CAOLxM,QAAA,CAASyF,KAAT,CAAe,uCAAf,CAAyDzF,QAAA,CAAS4E,WAAT,CAAqBuR,KAArB,CAAzD,CAIIiE,MAAAA,CAAWpU,KAAA,CAAMqU,IAAN,EACX7Q,MAAAA,CAAS4Q,KAAA,CAAS5L,GAAT,CAAalB,OAAA,EAAb,CACTuB,MAAAA,CAASuL,KAAA,CAAS5L,GAAT,CAAad,KAAA,CAAM,CAACU,MAAOlJ,YAAA,CAAIsE,KAAJ,CAAR,CAAN,CAAb,CACf4Q,MAAA,CAASE,OAAT,CAAiBrZ,IAAjB,CAAuB,IAAIwY,SAAJ,CAAcW,KAAd,CAAwB5Q,KAAxB,CAAgCA,KAAhC,CAAwCqF,KAAxC,CAAvB,CACAuL,MAAA,CAAS1S,SAAT,CAAmB,QAAnB,CAA6B,IAA7B,CAGAD,GAAA,CAAGxB,MAAH,CAAUsU,OAAV,CAAoB,CAClBC,SAAUJ,KAAA,CAAS7T,KAAT,CAAejG,IAAf,CAAA,CAAqBma,SAArB,EADQ,CApCkB,CAyCxCC,QAASA,aAAY,CAACpa,IAAD,CAAO0F,KAAP,CAAcwH,KAAd,CAAqB,CAClC/F,KAAAA,CAAKzB,KAAA,CAAMwI,GAAN,CAAU0L,QAAA,CAAS,CAAC9L,MAAOZ,KAAPY,CAAaA,KAAd,CAAT,CAAV,CACLgM,MAAAA,CAAWpU,KAAA,CAAMqU,IAAN,EAEjBD,MAAA,CAAS5L,GAAT,CAAad,KAAA,EAAb,CACA0M;KAAA,CAAS1S,SAAT,CAAmB,QAAnB,CAA6B,IAA7B,CAGAD,MAAA,CAAGxB,MAAH,CAAUsU,OAAV,CAAoB,CAClBC,SAAUJ,KAAA,CAAS7T,KAAT,CAAejG,IAAf,CAAA,CAAqBma,SAArB,EADQ,CARoB,CAa1CE,QAASA,aAAY,CAACra,IAAD,CAAO0F,KAAP,CAAc/E,IAAd,CAAoB,CACvC,IAAM2Z,OAASta,IAATsa,CAAcA,MAApB,CACMC,OAASva,IAATua,CAAcA,MADpB,CAEMC,OAASxa,IAATwa,CAAcA,MAFpB,CAGMC,OAASza,IAATya,CAAcA,MAHpB,CAIMlM,OAASvO,IAATuO,CAAcA,MAJpB,CAKMpH,GAAKzB,KAAA,CAAMwI,GAAN,CAvjDJ,IAAI1G,KAAJ,CAIQtH,UAJR,CAujDcU,IAAA,EAvjDd,CAujDc+E,IAAA,EAvjDd,CAIAZ,IAAA,EAJA,CAujDI,CAEL/D,KAAAA,CAAS,KAATA,CAAiBhB,IAAjBgB,CAAsB0Z,OAAtB1Z,CAAgC,WAAhCA,CACFL,IADEK,CACK,IADLA,CAEF,CAACuZ,MAAD,CAASD,MAAT,CAAiBE,MAAjB,CAAyBC,MAAzB,CAAiClM,MAAjC,CAAA,CACGlK,GADH,CACO,QAAA,CAAAjE,CAAA,CAAK,CAAA,MAAK,KAAL,EAAAA,CAAA,CAAY,MAAZ,CAAqBA,CAArB,CADZ,CAAA,CAEGsE,IAFH,CAEQ,GAFR,CAFE1D,CAKF,MAEEwF,MAAAA,CAAO7G,aAAA,CAAc8G,eAAd,CAA8BzF,IAA9B,CAAsC0E,KAAtC,CACbyB,GAAA,CAAGnG,MAAH,CAAYwF,KAAZ,CAAiBN,KACjBiB,GAAA,CAAGxB,MAAH;AAAYa,KAAZ,CAAiBE,OAjBsB,CAoBzCiU,QAASA,UAAS,CAAC3a,IAAD,CAAO0F,KAAP,CAAc,CAC9B,IAAM9D,KAAOuV,OAAA,CAAQnX,IAAR,CAAb,CACMqC,MA57BU+M,OA47BV/M,GAAQrC,IAARqC,CAAanC,IADnB,CAEM2V,MAAQ7V,IAAR6V,CAAanD,IAAbmD,EAAqB7V,IAArB6V,CAA0BnD,IAA1BmD,CAA+BA,KAFrC,CAGMjD,QAAU5S,IAAV4S,CAAeA,OAHrB,CAKIgI,OAAS5a,IAAT4a,CAAcA,MAAdA,EAh4DY7E,OAg4DZ6E,GAAwBhZ,IAAxBgZ,EAj4DYxY,OAi4DZwY,GAA8ChZ,IALlD,CAMaiZ,KANb,CAMoBjY,GANpB,CAQMkY,OAr4DSxY,MAq4DTwY,GAASlZ,IAATkZ,EAA8BF,MAA9BE,EAAwCjF,KAR9C,CAWM3I,MAAQ6L,SAAA,CAAU/Y,IAAV,CAAe0S,IAAf,CAAqBrQ,KAArB,CAA4BqD,KAA5B,CAGd,KAAAyB,GAAKzB,KAAA,CAAMwI,GAAN,CAAU6M,QAAA,CAAS,CACtBrZ,IAAOwL,KAAPxL,CAAaA,GAAbA,GAAqB1B,IAAA,CAAK0B,GAAL,CAAWkG,QAAA,CAAS5H,IAAT,CAAc0B,GAAd,CAAX,CAAgCgC,IAAAA,EAArDhC,CADsB,CAEtBoM,MAAOZ,KAAPY,CAAaA,KAFS,CAGtBkN,MAAO,CAAC3Y,KAHc,CAAT,CAAV,CAKL,KAAM4Y,QAAUrW,YAAA,CAAIuC,EAAJ,CAGhBA,GAAA,CAAK0T,KAAL,CAAanV,KAAA,CAAMwI,GAAN,CAAUlB,OAAA,CAAQ,CAACc,MAAOmN,OAAR,CAAR,CAAV,CAGb9T,GAAA,CAAKzB,KAAA,CAAMwI,GAAN,CAAUgN,IAAA,CAAK,CAClBC,QAAa9D,UAAA,CAAWrX,IAAX,CADK;AAElBqP,YAAaA,WAAA,CAAYrP,IAAZ,CAAiBqP,WAAjB,CAA8B3J,KAA9B,CAFK,CAGlB4P,KAAaA,aAAA,CAAKtV,IAAL,CAAUsV,IAAV,CAAgB5P,KAAhB,CAHK,CAIlB0V,QAAa,CAACC,SAAU,CAAA,CAAX,CAJK,CAKlBC,OAAa5V,KAAA,CAAM4J,MAAN,EALK,CAMlBvK,OAAaW,KAAA,CAAMsB,OAAN,CAAcjC,MAAd,CAAuBW,KAAA,CAAMoF,SAAN,CAAgB,QAAhB,CAAvB,CAAmD,IAN9C,CAOlB8K,MAAalQ,KAAA,CAAM6V,QAAN,EAPK,CAQlBzN,MAAalJ,YAAA,CAAIuC,EAAJ,CARK,CAAL,CAAV,CAUCqU,KAAAA,SAAU5W,YAAA,CAAIuC,EAAJ,CAGhBA,GAAA,CAAKvE,GAAL,CAAW8C,KAAA,CAAMwI,GAAN,CAAUuN,MAAA,CAAOhW,WAAA,CAC1BzF,IAD0B,CACrBoB,MADqB,CACbpB,IADa,CACRE,IADQ,CACF0B,IADE,CACI5B,IADJ,CACS6B,KADT,CACgB6D,KADhB,CAE1B,CAACgW,IAAK,CAAA,CAAN,CAAa5N,MAAO0N,QAApB,CAF0B,CAAP,CAAV,CAMXrU,GAAA,CAAGxB,MAAH,CAAUZ,MAAV,CAAmBW,KAAA,CAAMtE,MAAN,EAGfpB,KAAJ,CAAS2b,SAAT,EACE3b,IAAA,CAAK2b,SAAL,CAAelZ,OAAf,CAAuB,QAAA,CAAArC,CAAA,CAAK,CACpBwb,CAAAA,CAAKnE,cAAA,CAAerX,CAAf,CAAkBsF,KAAlB,CAAX,KACMmW,GAAKD,CAALC,CAAQ9D,QACd,EAAI8D,EAAJ,CAAOC,SAAP;AAAoBD,EAApB,CAAuBE,OAAvB,GACErc,QAAA,CAASyF,KAAT,CAAe,+CAAf,CAEG0W,GAAL,CAAQG,KAAR,GAAepZ,GAAf,CAAmB+C,MAAnB,CAA0B+V,GAA1B,CAAgC,CAAA,CAAhC,CACAE,EAAA,CAAGjW,MAAH,CAAUmI,KAAV,CAAkBlJ,YAAA,CAAIuC,EAAJ,CAClBzB,MAAA,CAAMwI,GAAN,CAAU/G,EAAV,CAAeyU,CAAf,CAR0B,CAA5B,CAaE5b,KAAJ,CAASuM,IAAT,GACEpF,EADF,CACOzB,KAAA,CAAMwI,GAAN,CAAU+N,SAAA,CAAU,CACvB1P,KAAO7G,KAAA,CAAM+S,UAAN,CAAiBzY,IAAjB,CAAsBuM,IAAtB,CADgB,CAEvBuB,MAAOlJ,YAAA,CAAIuC,EAAJ,CAFgB,CAAV,CAAV,CADP,CAOM+U,KAAAA,CAAYtX,YAAA,CAAIuC,EAAJ,CAGlB,IAAI0O,KAAJ,EAAa+E,MAAb,CAAqB,CACnBA,MAAA,CAASlV,KAAA,CAAMwI,GAAN,CAAUiO,UAAA,CAAW,CAC5BvB,OAAUlV,KAAA,CAAM0W,cAAN,CAAqBpc,IAArB,CAA0B4a,MAA1B,CADkB,CAE5ByB,QAAU3W,KAAV2W,CAAgBA,OAFY,CAG5B9Z,KAAUiZ,QAHkB,CAI5B1N,MAAUoO,IAJkB,CAAX,CAAV,CAMT,KAAAI,UAAY1X,YAAA,CAAIgW,MAAJ,CAPO,CAWrB,IAAM2B,MAAQ7W,KAAA,CAAMwI,GAAN,CAAUsO,KAAA,CAAM,CAACja,KAAMiZ,QAAP,CAAgB1N,MAAOwO,SAAPxO;AAAoBoO,IAApC,CAAN,CAAV,CACdO,SAAA,CAAW7X,YAAA,CAAI2X,KAAJ,CAGX,IAAIla,KAAJ,CAAW,CAET,GAAIyY,MAAJ,CAAY,CAAE,IAAA/M,IAAMrI,KAANqI,CAAY2O,SAAW3O,IAAA,CAAIvJ,GAAJ,EAAeoW,OAAJ,EAAY7M,GAAA,CAAIvJ,GAAJ,EAAhD,CAEZkB,KAAA,CAAMiX,SAAN,CAAgBT,IAAhB,CAA2BI,SAA3B,EAAwCG,QAAxC,CAAkDxB,OAAlD,CACApF,MAAA,CAAQ8D,UAAA,CAAW3Z,IAAX,CAAiB0F,KAAjB,CAAwBwH,KAAxB,CAAR,CACM4N,MAAA,CAASV,YAAA,CAAapa,IAAb,CAAmB0F,KAAnB,CAA0BwH,KAA1B,CAAT,CACAxH,KAAA,CAAMO,KAAN,CAAYjG,IAAZ,CACN0F,MAAA,CAAMkX,QAAN,EAEI9B,OAAJ,GAAkBF,MAA0B,EAAlB7M,GAAA,CAAIhH,IAAJ,CAAS6T,MAAT,CAAkB,CAAA7M,GAAA,CAAIhH,IAAJ,CAASwV,KAAT,CAA5C,CAVS,CAcP3J,OAAJ,GACE6J,QADF,CACaI,YAAA,CAAajK,OAAb,CAAsB6J,QAAtB,CAAgC/W,KAAhC,CADb,CAKMoX,MAAAA,CAASpX,KAAA,CAAMwI,GAAN,CAAU6O,MAAA,CAAO,CAACjP,MAAO2O,QAAR,CAAP,CAAV,CACTO,MAAAA,CAAQtX,KAAA,CAAMwI,GAAN,CAAUd,KAAA,CAAM,CAACU,MAAOlJ,YAAA,CAAIkY,KAAJ,CAAR,CAAN,CAA4BpZ,IAAAA,EAA5B,CAAuCgC,KAAA,CAAMX,MAAN,EAAvC,CAAV,CAId,IAAiB,IAAjB;AAAI/E,IAAJ,CAASW,IAAT,CAAuB,CACrB,IAAAA,KAAOX,IAAPW,CAAYA,IACZ+E,MAAA,CAAMsU,OAAN,CAAcrZ,IAAd,CAAoB,IAAIwY,SAAJ,CAAczT,KAAd,CAAqBmV,KAArB,CAA4BiC,KAA5B,CAAoCE,KAApC,CAApB,CACIhd,KAAJ,CAASuL,EAAT,EAAavL,IAAA,CAAKuL,EAAL,CAAQ9I,OAAR,CAAgB,QAAA,CAAA8I,EAAA,CAAM,CACjC,CAAIA,EAAJ,CAAOgP,MAAP,EAAiBhP,EAAjB,CAAoB+O,MAApB,EAA8B/O,EAA9B,CAAiCiP,MAAjC,GACE9a,QAAA,CAASyF,KAAT,CAAe,qCAAf,CAEFkV,aAAA,CAAa9O,EAAb,CAAiB7F,KAAjB,CAAwB/E,IAAxB,CAJiC,CAAtB,CAHQ,CA/GO,CA2HhCkc,QAASA,aAAY,CAACjK,OAAD,CAAU1J,MAAV,CAAkBxD,KAAlB,CAAyB,CAC5C,IAAMkD,OAASgK,OAAThK,CAAiBA,MAAvB,CACM2T,MAAQ3J,OAAR2J,CAAgBA,KADtB,CAEMU,IAAMrK,OAANqK,CAAcpJ,UAEdlO,OAAAA,CAAS,CACbkO,WAAYzL,QAAA,CAAS6U,GAAT,CAAA,CAAgBvX,KAAA,CAAMoF,SAAN,CAAgBmS,GAAhB,CAAoBva,MAApB,CAAhB,CAA8Cua,GAD7C,CAEbrU,OAAQR,QAAA,CAASQ,MAAT,CAAA,CAAmBlD,KAAA,CAAMoF,SAAN,CAAgBlC,MAAhB,CAAuBlG,MAAvB,CAAnB,CAAoDkG,MAF/C,CAGbkF,MAAQ5E,MAHK,CAMX0J;OAAJ,CAAYkB,KAAZ,GACEnO,MADF,CACS4G,IADT,CACgB7G,KAAA,CAAM+S,UAAN,CAAiB,CAAC9T,MAAOiO,OAAPjO,CAAemP,KAAhB,CAAjB,CADhB,CAIIyI,MAAJ,GACQW,OAGN,CAHYX,KAGZ,CAHkBY,SAGlB,CAFAxX,MAEA,CAFOyX,cAEP,CAFwBhV,QAAA,CAAS8U,OAAT,CAAA,CAAgBxX,KAAA,CAAMoF,SAAN,CAAgBoS,OAAhB,CAAoBxa,MAApB,CAAhB,CAA8C,CAACwa,OAEvE,CADAvX,MACA,CADO0X,UACP,CADoB3X,KAAA,CAAMlC,QAAN,CAAe+Y,KAAf,CAAqBhZ,KAArB,CACpB,CAAAoC,MAAA,CAAO2X,WAAP,CAAqBf,KAArB,CAA2BlG,MAJ7B,CAOA,OAAOzR,aAAA,CAAIc,KAAA,CAAMwI,GAAN,CAAUqP,OAAA,CAAQ5X,MAAR,CAAV,CAAJ,CAtBqC,CAyB9C6X,QAASA,YAAW,CAACxd,IAAD,CAAO0F,KAAP,CAAc,CAChC,IAAM5D,OAAS4D,KAAT5D,CAAeA,MAAfA,CAAsB2b,MAA5B,CACMrc,OAASpB,IAAToB,CAAcA,MAAdA,EAAwB,EAD9B,CAEMhB,EAAIkP,eAAA,CAAOtP,IAAP,CAAa8B,MAAb,CAFV,CAGM4b,aAAetc,MAAfsc,CAAsBD,MAAtBC,EAAgC,EAHtC,CAIM/c,KAAO+c,YAAP/c,CAAoBA,IAApBA,EAA4B+C,IAAAA,EAJlC,CAKM2L;AAAcqO,YAAdrO,CAA2BA,WALjC,CAMMxN,MAAQ6b,YAAR7b,CAAqBA,KAN3B,CAOM8b,OAAS,EAPf,CASIpa,MAAQ,CATZ,CAS4BoC,MAG5BuP,aAAA,CAAazS,OAAb,CAAqB,QAAA,CAAAS,CAAA,CAAK,CAAA,MAAAlD,KAAA,CAAKkD,CAAL,CAAA,EACrBya,MAAA,CAAOza,CAAP,CAAA,CAAYlD,IAAA,CAAKkD,CAAL,CAAZ,CAAqBK,KAArB,CAA6BA,KAA7B,EAAsCvD,IAAA,CAAKkD,CAAL,CADjB,EAC4B,CAD5B,CAA1B,CAGKK,MAAL,EAAY7D,QAAA,CAASyF,KAAT,CAAe,iCAAf,CAGNjF,KAAAA,SAAO0d,UAAA,CAAW5d,IAAX,CAAiB0F,KAAA,CAAMmY,SAAN,CAAgBta,KAAhB,CAAjB,CAGb,KAAMuB,MAAQ,CACZ+R,MAAsB,IAAtBA,EAAQ7W,IAAR6W,CAAaA,KADD,CAEZ8G,OAAQA,MAFI,CAGZzd,KAAQA,QAHI,CAIZ4d,MAAiB,QAAjBA,GAAQ5d,QAAR4d,EAA8B1d,CAAA,CAAEoP,UAAF,EAJlB,CAAd,CAMM2C,QAAUvN,YAAA,CAAIc,KAAA,CAAMwI,GAAN,CAAUlB,OAAA,CAAQ,IAAR,CAAc,CAAClI,KAAD,CAAd,CAAV,CAAJ,CANhB,CAYMiZ,SAAWnZ,YAAA,CAAIc,KAAA,CAAMwI,GAAN,CAAU8P,aAAA,CAAcrY,MAAd,CAAuB,CACpDzF,KAASA,QAD2C;AAEpDqD,MAASmC,KAAA,CAAMlC,QAAN,CAAeD,KAAf,CAF2C,CAGpDa,MAASsB,KAAA,CAAM0W,cAAN,CAAqBhc,CAAA,CAAE,WAAF,CAArB,CAH2C,CAIpDgT,MAAS1N,KAAA,CAAM9B,QAAN,CAAexD,CAAA,CAAE,aAAF,CAAf,CAJ2C,CAKpDmO,OAAS7I,KAAA,CAAM0W,cAAN,CAAqBpc,IAArB,CAA0BuO,MAA1B,CAL2C,CAMpD0P,QAASvY,KAAA,CAAM9B,QAAN,CAAe5D,IAAf,CAAoBke,WAApB,CAN2C,CAOpDC,WAAYzY,KAAA,CAAM9B,QAAN,CAAe5D,IAAf,CAAoBme,UAApB,CAPwC,CAQpDC,gBAAiB1Y,KAAA,CAAM9B,QAAN,CAAe5D,IAAf,CAAoBqe,MAApB,CARmC,CAAvB,CAAV,CAAJ,CAYjB,IA5pCeC,UA4pCf,GAAIpe,QAAJ,CACEqe,QAKA,CALW,CACTvN,cAAA,CAAehR,IAAf,CAAqBuD,KAArB,CAA4BzB,MAA5B,CAAoCV,MAApC,CAA2CyB,QAA3C,CADS,CAET8P,oBAAA,CAAqB3S,IAArB,CAA2B8B,MAA3B,CAAmCV,MAAnC,CAA0CmU,MAA1C,CAAkDwI,QAAlD,CAFS,CAKX,CAAApY,MAAA,CAAOvB,KAAP,CAAeuB,MAAf,CAAsBvB,KAAtB,EAA+BsB,KAAA,CAAMoF,SAAN,CAC7B,iBAD6B,CACXtC,KAAA,CAAMpI,CAAA,CAAE0P,cAAF,EAAN,CADW;AAC7B,SAD6B,CANjC,KAYK,IAvqCU0O,UAuqCV,GAAIte,QAAJ,CACHqe,QAAA,CAAW,CACTrM,sBAAA,CAAuBlS,IAAvB,CAA6BuD,KAA7B,CAAoCzB,MAApC,CAA4CV,MAA5C,CAAmDyB,QAAnD,CAA6Dkb,QAA7D,CADS,CAETpL,oBAAA,CAAqB3S,IAArB,CAA2B8B,MAA3B,CAAmCV,MAAnC,CAA0CmU,MAA1C,CAAkDwI,QAAlD,CAFS,CADR,KAQA,CAEH,IAAAU,YAAcxI,kBAAA,CAAmBjW,IAAnB,CAAyB8B,MAAzB,CACdyc,SAAA,CAAW,CACTrK,kBAAA,CAAmBlU,IAAnB,CAAyB8B,MAAzB,CAAiCV,MAAjC,CAAyC2c,QAAzC,CAAmDvV,KAAA,CAAMiW,WAAN,CAAkBnO,OAAlB,CAAnD,CADS,CAIX3K,OAAA,CAAOoP,IAAP,CAAc2J,cAAA,CAAe1e,IAAf,CAAqB0F,KAArB,CAA4B6Y,QAAA,CAAS,CAAT,CAA5B,CAAwCvI,KAAxC,CAPX,CAWLuI,QAAA,CAAW,CACTpP,UAAA,CAAW,CACTvN,KAllEkB+c,cAilET,CAETjM,KAAMP,OAFG,CAGT/Q,OAlDgBwd,CAAC1d,MAAO,CAACsQ,EAAG,CAAC5Q,MAAO,CAAR,CAAJ,CAAgB6Q,EAAG,CAAC7Q,MAAO,CAAR,CAAnB,CAARge,CA+CP,CAIT5I,MAAOuI,QAJE,CAKT3D,OAAQ6D,WALC;AAMTpP,YAAAA,WANS,CAAX,CADS,CAYPvK,MAAJ,CAAU+R,KAAV,EACE0H,QAAA,CAASxX,IAAT,CAAcqP,WAAA,CAAYpW,IAAZ,CAAkB8B,MAAlB,CAA0BV,MAA1B,CAAiCyV,KAAjC,CAAwC1E,OAAxC,CAAd,CAIF,OAAOwI,UAAA,CACLxL,UAAA,CAAW,CACTvN,KArmEaid,QAomEJ,CAETnM,KAAaP,OAFJ,CAGT/Q,OAAaD,YAAA,CAAa2d,iBAAA,CAAkB1e,CAAlB,CAAqBJ,IAArB,CAA2B8B,MAA3B,CAAb,CAAiD4b,YAAjD,CAA+D3M,IAA/D,CAHJ,CAITiF,MAAauI,QAJJ,CAKThH,KAAanX,CAAA,CAAE,MAAF,CALJ,CAMToX,YAAapX,CAAA,CAAE,aAAF,CANJ,CAOTkX,OAAalX,CAAA,CAAE,QAAF,CAPJ,CAQTO,KAAAA,IARS,CAST0O,YAAAA,WATS,CAUTxN,MAAAA,KAVS,CAAX,CADK,CAaL6D,KAbK,CA9FyB,CA+GlCkY,QAASA,WAAU,CAAC5d,IAAD,CAAO6d,SAAP,CAAkB,CACnC,IAAI3d,KAAOF,IAAPE,CAAYA,IAAZA,EA/tCU6e,QAiuCT/e,KAAL,CAAUE,IAAV,EAAuC,CAAvC,GAAkB8e,UAAA,CAAWhf,IAAX,CAAlB,EAA6C4R,CAAA5R,IAAA4R,CAAKA,IAAlD,EAA0DE,CAAA9R,IAAA8R,CAAKA,MAA/D,GACE5R,IADF,CACSL,SAAA,CAAUof,YAAV,CAAuBpB,SAAvB,CAAA;AAjuCMS,UAiuCN,CACHze,SAAA,CAAUqf,cAAV,CAAyBrB,SAAzB,CAAA,CAjuCSW,UAiuCT,CAnuCQO,QAiuCd,CAMA,OAtuCeT,UAsuCR,GAAApe,IAAA,CAAoBA,IAApB,CACHL,SAAA,CAAUqf,cAAV,CAAyBrB,SAAzB,CAAA,CAtuCWW,UAsuCX,CAvuCWF,UA6tCoB,CAcrCU,QAASA,WAAU,CAAChf,IAAD,CAAO,CACxB,MAAOkV,aAAA,CAAavI,MAAb,CAAoB,QAAA,CAACvI,KAAD,CAAQlE,IAAR,CAAiB,CAAA,MAAAkE,MAAA,EAASpE,IAAA,CAAKE,IAAL,CAAA,CAAa,CAAb,CAAiB,CAA1B,CAAA,CAArC,CAAmE,CAAnE,CADiB,CAI1B4e,QAASA,kBAAiB,CAAC1e,CAAD,CAAIJ,IAAJ,CAAU8B,MAAV,CAAkB,CAC1C,IAAMV,OAAS,CAACF,MAAO,EAAR,CAAYF,OAAQ,EAApB,CAEfC,YAAA,CAAYG,MAAZ,CAAoB,CAClBiV,OAAcjW,CAAA,CAAE,QAAF,CADI,CAElB2D,OAAc3D,CAAA,CAAE,QAAF,CAFI,CAGlB+V,QAAc/V,CAAA,CAAE,SAAF,CAHI,CAIlB+e,aAAc/e,CAAA,CAAE,cAAF,CAJI,CAKlBgf,aAAchf,CAAA,CAAE,cAAF,CALI,CAMlBwR,KAAcxR,CAAA,CAAE,WAAF,CANI,CAOlB0R,OAAc1R,CAAA,CAAE,aAAF,CAPI;AAQlB2R,YAAcjQ,MAAdiQ,CAAqBA,WARH,CASlBiD,WAAclT,MAAdkT,CAAqBA,UATH,CAUlBxD,EAAcpR,CAAA,CAAE,SAAF,CAVI,CAWlBqR,EAAcrR,CAAA,CAAE,SAAF,CAXI,CAclBie,OAAcre,IAAdqe,CAAmBA,MAdD,CAelBF,WAAcne,IAAdme,CAAmBA,UAfD,CAApB,CAkBA,OAAO/c,OArBmC,CAwB5Csd,QAASA,eAAc,CAAC1e,IAAD,CAAO0F,KAAP,CAAcsQ,KAAd,CAAqB,CAC1C,IAAMjB,KAAOvM,KAAA,CAAM6W,UAAA,CAAW,MAAX,CAAmBrf,IAAnB,CAAyBgW,KAAzB,CAAN,CACPjE,KAAAA,CAAcvJ,KAAA,CAAM6W,UAAA,CAAW,aAAX,CAA0Brf,IAA1B,CAAgCgW,KAAhC,CAAN,CAgBb,EAAA,KAAA,CAAA,WAAA,CAAA,UAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,IAzsCP,KAysCO,EA1sCD9S,KA0sCC,CAAmCwC,KA1sChC,CAAM5D,MAAN,CAAaD,KAAb,CA0sCgCA,aA1sChC,CA0sCH,GAzsCKqB,KAysCL,CAAmCvC,QAAnC,CAfDsS,MAAAA,CAAWzK,KAAA,CAeV,KAfU,CAEjB,OAAO7I,cAAA,CAAc8G,eAAd,CACL,gBADK,CACYsO,IADZ,CACL,IADK,CACqBhD,IADrB,CACL,IADK,CACqCkB,KADrC;AACL,GADK,CAELvN,KAFK,CALmC,CAW5C2Z,QAASA,WAAU,CAAC1e,IAAD,CAAOX,IAAP,CAAagW,KAAb,CAAoB,CACrC,MAAOhW,KAAA,CAAKW,IAAL,CAAA,CACH,SADG,CACOX,IAAA,CAAKW,IAAL,CADP,CACH,UADG,CAEH4P,WAAA,CAAY5P,IAAZ,CAAkBqV,KAAA,CAAM,CAAN,CAAlB,CAA2B5U,MAA3B,CAHiC,CAYvCke,QAASA,WAAU,CAACtf,IAAD,CAAO0F,KAAP,CAAc,CAC/B1F,IAAA,CAAON,QAAA,CAAS0F,QAAT,CAAkBpF,IAAlB,CAAA,CAA0B,CAAC6S,KAAM7S,IAAP,CAA1B,CAAyCA,IAEhD,KAAMI,EAAIkP,eAAA,CAAOtP,IAAP,CAAa0F,KAAb,CAAmB5D,MAAnB,CAA0B+U,KAA1B,CAAV,CACMzV,OAASpB,IAAToB,CAAcA,MAAdA,EAAwB,EAD9B,CAEM6P,WAAa7P,MAAb6P,CAAoB5O,KAApB4O,EAA6B,EAFnC,CAGMtQ,KAAOsQ,UAAPtQ,CAAkBA,IAAlBA,EAA0B+C,IAAAA,EAHhC,CAIM2L,YAAc4B,UAAd5B,CAAyBA,WAJ/B,CAKMxN,MAAQoP,UAARpP,CAAmBA,KALzB,CAMM0c,SAAW,EANjB,CAUMpM,QAAUvN,YAAA,CAAIc,KAAA,CAAMwI,GAAN,CAAUlB,OAAA,CAAQ,IAAR,CAAc,CAD9BlI,EAC8B,CAAd,CAAV,CAAJ,CAGhByZ,SAAA,CAASxX,IAAT,CAAcwY,UAAA,CAAWvf,IAAX,CAAiBI,CAAjB,CAAoBof,WAAA,CAAYxf,IAAZ,CAApB;AAAuCmS,OAAvC,CAAd,CAGInS,KAAJ,CAASyf,QAAT,EACElB,QAAA,CAASxX,IAAT,CAAc2Y,aAAA,CAAc1f,IAAd,CAAoBI,CAApB,CAAuBgB,MAAvB,CAA8Bqe,QAA9B,CAAwCtN,OAAxC,CAAd,CAiCI/Q,KAAAA,CAAS,CAACF,MAAO,EAAR,CAAYF,OAAQ,EAApB,CAEfC,YAAA,CAAYG,IAAZ,CAAoB,CAClBiV,OA5B2BjW,CA4Bd,CAAE,QAAF,CADK,CAElBmW,OA7B2BnW,CA6Bd,CAAE,QAAF,CAFK,CAGlBmT,MAAa,CAAC7Q,OAAQid,SAAT,CAHK,CAIlBlJ,MAAa,CAAC/T,OA7DAkd,uEA6DD,CAJK,CAKlBxM,MAhC2BhT,CAgCd,CAAE,OAAF,CALK,CAMlByf,MAjC2Bzf,CAiCd,CAAE,OAAF,CANK,CAOlB2D,OAlC2B3D,CAkCd,CAAE,QAAF,CAAb2D,EAA4B,CAPV,CAQlBoS,QAnC2B/V,CAmCd,CAAE,iBAAF,CARK,CAApB,CAWA,WAAA,CAAOe,YAAA,CAAaC,IAAb,CAtCyB6P,UAsCzB,CAAiCF,IAAjC,CA1CP,OAAO4J,UAAA,CACLxL,UAAA,CAAW,CACTvN,KAvsEYke,OAssEH,CAETpN,KAAaP,OAFJ,CAGT/Q,OAAa,UAHJ,CAIT4U,MAAauI,QAJJ;AAKThH,KAAanX,CAAA,CAAE,MAAF,CALJ,CAMToX,YAAapX,CAAA,CAAE,aAAF,CANJ,CAOTkX,OAAalX,CAAA,CAAE,QAAF,CAPJ,CAQTO,KAAAA,IARS,CAST0O,YAAAA,WATS,CAUTxN,MAAAA,KAVS,CAAX,CADK,CAaL6D,KAbK,CAxBwB,CA2CjC8Z,QAASA,YAAW,CAACxf,IAAD,CAAO,CACzB,IAAMoB,OAASpB,IAAToB,CAAcA,MACpB,OAAQA,OAAR,EAAkBA,MAAlB,CAAyByV,KAAzB,EAAmCnX,QAAA,CAAS8B,MAAT,CAAgB,CACjDb,KAAMX,IAANW,CAAWA,IADsC,CAEjD0O,YAAarP,IAAbqP,CAAkBA,WAF+B,CAGjDxN,MAAO7B,IAAP6B,CAAYA,KAHqC,CAAhB,CAIhCT,MAJgC,CAFV,CA0B3Bme,QAASA,WAAU,CAACvf,IAAD,CAAOI,CAAP,CAAU6Q,UAAV,CAAsBkB,OAAtB,CAA+B,CAChD,IAAMZ,KAAO,CAAC3Q,MAAO,CAAR,CAEPQ,KAAAA,CAAS,CACPF,MAAO,CAACoQ,QAASC,IAAV,CADA,CAEPvQ,OAAQ,CAACsQ,QAAS,CAAC1Q,MAAO,CAAR,CAAV,CAFD,CAGPiR,KAAM,CAACP,QAASC,IAAV,CAHC,CAMftQ,YAAA,CAAYG,IAAZ,CAAoB,CAClByR,KARW7S,IAQX6S,CARgBA,IAOE,CAElBU,MAAY,CAAC7Q,OAAQ,uBAAT,CAFM,CAGlB+T,MAAY,CAAC/T,OAAQ,uBAAT,CAHM;AAIlB0Q,MAAY,CAAC1Q,OAAQ,uBAAT,CAJM,CAKlB8Q,SAAY,KALM,CAMlBuM,GAAY3f,CAAA,CAAE,IAAF,CANM,CAOlB4f,GAAY5f,CAAA,CAAE,IAAF,CAPM,CAQlBwR,KAAYxR,CAAA,CAAE,OAAF,CARM,CASlB4S,KAAY5S,CAAA,CAAE,MAAF,CATM,CAUlB6S,SAAY7S,CAAA,CAAE,UAAF,CAVM,CAWlB8S,UAAY9S,CAAA,CAAE,WAAF,CAXM,CAYlB+S,WAAY/S,CAAA,CAAE,YAAF,CAZM,CAalB0W,WAAY1W,CAAA,CAAE,YAAF,CAbM,CAApB,CAcG,CACDmT,MAAYnT,CAAA,CAAE,OAAF,CADX,CAEDqW,MAAYrW,CAAA,CAAE,OAAF,CAFX,CAGDoT,SAAYpT,CAAA,CAAE,UAAF,CAHX,CAdH,CAoBA,OAAOyQ,UAAA,CAAU,CACf3Q,KA71Ca6T,MA41CE,CAEfnS,KAhxEkBqe,YA8wEH,CAGfpe,MAv4CoBqe,aAo4CL,CAIfxN,KAAMP,OAJS,CAKf/Q,OAAAA,IALe,CAAV,CAMJ6P,UANI,CA7ByC,CAsClDyO,QAASA,cAAa,CAAC1f,IAAD,CAAOI,CAAP,CAAU6Q,UAAV,CAAsBkB,OAAtB,CAA+B,CACnD,IAAMZ,KAAO,CAAC3Q,MAAO,CAAR,CAEPQ,KAAAA,CAAS,CACPF,MAAO,CAACoQ,QAASC,IAAV,CADA,CAEPvQ,OAAQ,CAACsQ,QAAS,CAAC1Q,MAAO,CAAR,CAAV,CAFD,CAGPiR,KAAM,CAACP,QAASC,IAAV,CAHC,CAMftQ;WAAA,CAAYG,IAAZ,CAAoB,CAClByR,KARW7S,IAQX6S,CARgB4M,QAOE,CAElBlM,MAAY,CAAC7Q,OAAQ,uBAAT,CAFM,CAGlB+T,MAAY,CAAC/T,OAAQ,uBAAT,CAHM,CAIlB0Q,MAAY,CAAC1Q,OAAQ,uBAAT,CAJM,CAKlB8Q,SAAY,KALM,CAMlBuM,GAAY3f,CAAA,CAAE,IAAF,CANM,CAOlB4f,GAAY5f,CAAA,CAAE,IAAF,CAPM,CAQlBwR,KAAYxR,CAAA,CAAE,eAAF,CARM,CASlB4S,KAAY5S,CAAA,CAAE,cAAF,CATM,CAUlB6S,SAAY7S,CAAA,CAAE,kBAAF,CAVM,CAWlB8S,UAAY9S,CAAA,CAAE,mBAAF,CAXM,CAYlB+S,WAAY/S,CAAA,CAAE,oBAAF,CAZM,CAalB0W,WAAY1W,CAAA,CAAE,oBAAF,CAbM,CAApB,CAcG,CACDmT,MAAYnT,CAAA,CAAE,OAAF,CADX,CAEDqW,MAAYrW,CAAA,CAAE,OAAF,CAFX,CAGDoT,SAAYpT,CAAA,CAAE,UAAF,CAHX,CAdH,CAoBA,OAAOyQ,UAAA,CAAU,CACf3Q,KAn4Ca6T,MAk4CE,CAEfnS,KArzEsBue,gBAmzEP,CAGfte,MA56CuBue,gBAy6CR;AAIf1N,KAAOP,OAJQ,CAKf/Q,OAAAA,IALe,CAAV,CAMJ6P,UANI,CA7B4C,CAsCrDoP,QAASA,YAAW,CAACnU,IAAD,CAAOxG,KAAP,CAAc,CAChC,IAAM4a,WAAa,EAEfpU,KAAJ,CAASyP,SAAT,EACEzP,IAAA,CAAKyP,SAAL,CAAelZ,OAAf,CAAuB,QAAA,CAAAmZ,EAAA,CAAM,CAC3B0E,UAAA,CAAWvZ,IAAX,CAAgB0Q,cAAA,CAAemE,EAAf,CAAmBlW,KAAnB,CAAhB,CAD2B,CAA7B,CAKEwG,KAAJ,CAASX,EAAT,EACEW,IAAA,CAAKX,EAAL,CAAQ9I,OAAR,CAAgB,QAAA,CAAA8I,EAAA,CAAM,CACpB8O,YAAA,CAAa9O,EAAb,CAAiB7F,KAAjB,CAAwBwG,IAAxB,CAA6BvL,IAA7B,CADoB,CAAtB,CAKF+E,MAAA,CAAMyH,eAAN,CAAsBjB,IAAtB,CAA2BvL,IAA3B,CAAiC4f,OAAA,CAAQrU,IAAR,CAAcxG,KAAd,CAAqB4a,UAArB,CAAjC,CAfgC,CAqBlCC,QAASA,QAAO,CAACrU,IAAD,CAAOxG,KAAP,CAAcqI,GAAd,CAAmB,CACjC,IAAMmL,OAAS,EAAf,CACIhQ,OAAS,IADb,CAEIuR,OAAS,CAAA,CAFb,CAGI+F,SAAW,CAAA,CAHf,CAIIC,QAJJ,CAIiBzI,CAEb9L,KAAJ,CAASqC,MAAT,CAEMlG,SAAA,CAAU6D,IAAV,CAAeqC,MAAf,CAAJ,EAA8BlG,SAAA,CAAU6D,IAAV,CAAemS,MAAf,CAA9B,EAEEnF,MAAA,CAAOnS,IAAP,CAAY2Z,IAAA,CAAKhb,KAAL,CAAYwG,IAAZ,CAAZ,CACA;AAAAgN,MAAA,CAAOnS,IAAP,CAAYmC,MAAZ,CAAqByX,OAAA,EAArB,CAHF,EAMEzH,MAAA,CAAOnS,IAAP,CAAYmC,MAAZ,CAAqByX,OAAA,CAAQ,CAC3B1T,QAASf,IAATe,CAAcsB,MADa,CAE3BqS,QAAS1U,IAAT0U,CAAcvC,MAFa,CAAR,CAArB,CARJ,CAaWnS,IAAJ,CAAS2U,GAAT,CAEDxY,SAAA,CAAU6D,IAAV,CAAe2U,GAAf,CAAJ,EAA2BxY,SAAA,CAAU6D,IAAV,CAAemS,MAAf,CAA3B,EAEEnF,MAAA,CAAOnS,IAAP,CAAY2Z,IAAA,CAAKhb,KAAL,CAAYwG,IAAZ,CAAZ,CACA,CAAAgN,MAAA,CAAOnS,IAAP,CAAYmC,MAAZ,CAAqByX,OAAA,EAArB,CAHF,EAMEzH,MAAA,CAAOnS,IAAP,CAAYmC,MAAZ,CAAqByX,OAAA,CAAQ,CAC3BG,SAAU5U,IAAV4U,CAAeD,GADY,CAE3BD,QAAS1U,IAAT0U,CAAcvC,MAFa,CAAR,CAArB,CARG,CAaInS,IAbJ,CAaShD,MAbT,GAeLA,MAEA,CAFSuX,QAET,CAFoB/gB,QAAA,CAAS8C,KAAT,CAAe0J,IAAf,CAAoBhD,MAApB,CAAA,CACjB7E,GADiB,CACb,QAAA,CAAAwI,CAAA,CAAK,CAAA,MAAAjI,aAAA,CAAIc,KAAA,CAAMyG,OAAN,CAAcU,CAAd,CAAJ,CAAqBqM,MAArB,CAAA,CADQ,CAEpB,CAAAA,MAAA,CAAOnS,IAAP,CAAY,IAAZ,CAjBK,CAqBFkR,KAAA,CAAE,CAAP,KAAUD,CAAV,CAAYjK,GAAZ,CAAgBhN,MAAhB,CAAwBkX,IAAxB,CAA0BD,CAA1B,CAA6B,EAAEC,IAA/B,CAAkC,CAChC,IAAAH,EAAI/J,GAAA,CAAIkK,IAAJ,CACJ,KAAAvH,EAAIoH,CAAJpH,CAAMqH,QAED7O,OAAL;AAAgBwH,CAAhB,CAAkBxH,MAAlB,EACEgQ,MAAA,CAAOnS,IAAP,CAAYmC,MAAZ,CAAqByX,OAAA,EAArB,CAEFzH,OAAA,CAAOnS,IAAP,CAAY+Q,CAAZ,CAEIpH,EAAJ,CAAMoL,SAAN,GAAiB0E,QAAjB,CAA4B,CAAA,CAA5B,CACI9P,EAAJ,CAAMqQ,QAAN,EAAkB,CAACP,QAAnB,GAA6B/F,MAA7B,CAAsC,CAAA,CAAtC,CAEI/J,EAAJ,CAAMxH,MAAN,CAAcA,MAAd,CAAuB4O,CAAvB,CACSpH,CADT,CACWqL,OADX,GACoB7S,MADpB,CAC6B,IAD7B,CAZgC,CAgB9BuX,QAAJ,GACEzI,CAKA,CALIyI,QAKJ,CALa1f,MAKb,CALsB,CAKtB,CAJAmY,MAAA,CAAO,CAAP,CAIA,CAJY8H,KAAA,CAAM,CAChBC,OAAQxG,MADQ,CAEhB3M,MAAOkK,CAAA,CAAIyI,QAAJ,CAAeA,QAAA,CAAS,CAAT,CAFN,CAAN,CAIZ,EAAIhG,MAAJ,EAAczC,CAAd,GAEEkB,MAAA,CAAOgI,MAAP,CAAc,CAAd,CAAiB,CAAjB,CAAoBP,OAAA,EAApB,CARJ,CAYKzX,OAAL,EAAagQ,MAAA,CAAOnS,IAAP,CAAY4Z,OAAA,EAAZ,CACbzH,OAAA,CAAOnS,IAAP,CAAYqG,KAAA,CAAM,EAAN,CAAZ,CACA,OAAO8L,OAvE0B,CA0EnCyH,QAASA,QAAO,CAACpS,MAAD,CAAS,CACjBrL,MAAAA,CAAI8J,OAAA,CAAQ,EAAR,CAAYuB,MAAZ,CACVrL,OAAA,CAAE6U,QAAF,CAAa,CAAC7O,OAAQ,CAAA,CAAT,CACb,OAAOhG,OAHgB,CAMzBwd,QAASA,KAAI,CAAChb,KAAD,CAAQwG,IAAR,CAAc,CACzB,MAAOiV,KAAA,CAAK,CACVN,IAAQ3U,IAAA,CAAK2U,GAAL;AAAWnb,KAAA,CAAM9B,QAAN,CAAesI,IAAf,CAAoB2U,GAApB,CAAX,CAAsCnd,IAAAA,EADpC,CAEV0d,MAAQlV,IAAA,CAAKkV,KAAL,CAAa1b,KAAA,CAAM9B,QAAN,CAAesI,IAAf,CAAoBkV,KAApB,CAAb,CAA0C1d,IAAAA,EAFxC,CAGV6K,OAAQrC,IAAA,CAAKqC,MAAL,CAAc7I,KAAA,CAAM9B,QAAN,CAAesI,IAAf,CAAoBqC,MAApB,CAAd,CAA4C7K,IAAAA,EAH1C,CAIV2a,OAAQ3Y,KAAA,CAAM0W,cAAN,CAAqBlQ,IAArB,CAA0BmS,MAA1B,CAJE,CAAL,CADkB,CAqG3BgD,QAASA,SAAQ,CAACna,IAAD,CAAOpF,MAAP,CAAewf,UAAf,CAA2Bzf,KAA3B,CAAkC,CAGjD,GAAIC,MAAJ,EAAcpC,QAAA,CAAS6B,cAAT,CAAwBO,MAAxB,CAAgCoF,IAAhC,CAAd,CACE,MAAOpF,OAAA,CAAOoF,IAAP,CAEJ,IAAIxH,QAAA,CAAS6B,cAAT,CAAwB+f,UAAxB,CAAoCpa,IAApC,CAAJ,CACH,MAAOoa,WAAA,CAAWpa,IAAX,CAEJ,IAAIA,IAAA,CAAKhF,UAAL,CAAgB,OAAhB,CAAJ,CAA8B,CACjC,OAAQgF,IAAR,EACE,KAAK,YAAL,CACE,IAAAqa,UAAY,MACZ,MACF,MAAK,WAAL,CACA,KAAK,eAAL,CACA,KAAK,iBAAL,CACEA,SAAA;AAAYra,IAAA,CAAK,CAAL,CAAA,CAAQyQ,WAAR,EAAZ,CAAoCzQ,IAAA,CAAKsa,KAAL,CAAW,CAAX,CAPxC,CASA,MAAO3f,MAAA,CAjpDamV,aAipDb,CAAA,CAAuBuK,SAAvB,CAV0B,CAY9B,GAAIra,IAAA,CAAKhF,UAAL,CAAgB,OAAhB,CAAJ,CAA8B,CACjC,OAAQgF,IAAR,EACE,KAAK,YAAL,CACEqa,SAAA,CAAY,MACZ,MACF,MAAK,WAAL,CACA,KAAK,eAAL,CACEA,SAAA,CAAYra,IAAA,CAAK,CAAL,CAAA,CAAQyQ,WAAR,EAAZ,CAAoCzQ,IAAA,CAAKsa,KAAL,CAAW,CAAX,CANxC,CAQA,MAAO3f,MAAA,CA7pDaoS,aA6pDb,CAAA,CAAuBsN,SAAvB,CAT0B,CAYnC,MAAO,KAjC0C,CAoCnDjb,QAASA,KAAI,CAACmb,OAAD,CAAU,CACrB,IAAMpd,IAAM,EACZ,QAAA,CAAA,OAAA,CAAA,YAAA,CAAkBod,OAAlB,CAAA,KAAA,IAAA,gBAAA,OAAA,CAAA,IAAA,EAAA,CAAA,CAAA,eAAA,CAAA,IAAA,CAAA,eAAA,CAAA,OAAA,CAAA,IAAA,EAAA,CACE,GADSC,eACT,CADF,eACE,CADF,KACE,CACA,IAAKhgB,IAAMA,GAAX,GAAkBggB,gBAAlB,CAAuBrd,GAAA,CAAI3C,GAAJ,CAAA;AAAW,CAEpC,OAAO2E,OAAA,CAAOC,IAAP,CAAYjC,GAAZ,CANc,CAyDvBsd,QAASA,WAAU,CAAC3hB,IAAD,CAAO8B,MAAP,CAAemP,UAAf,CAA2BkB,OAA3B,CAAoC,CACrD,IAAM/R,EAAIkP,eAAA,CAAOtP,IAAP,CAAa8B,MAAb,CACJuU,OAAAA,CAASrW,IAATqW,CAAcA,MAFiC,KAIjDnV,KAJiD,CAI1CF,MAJ0C,CAK/CI,OAAS,CACbF,MAAOA,KAAPA,CAAe,CAACoQ,QAASC,aAAV,CADF,CAEbvQ,OAAQA,MAARA,CAAiB,CAACsQ,QAASK,GAAV,CAFJ,CAGbE,KAAM,CAACP,QAASC,aAAV,CAHO,CAMftQ,YAAA,CAAYG,MAAZ,CAAoB,CAClB0Q,OAAkB1R,CAAA,CAAE,aAAF,CADA,CAElBwhB,UAAkBxhB,CAAA,CAAE,WAAF,CAFA,CAGlB4U,WAAkB5U,CAAA,CAAE,YAAF,CAHA,CAIlB6U,iBAAkB7U,CAAA,CAAE,kBAAF,CAJA,CAKlB2R,YAAkB3R,CAAA,CAAE,aAAF,CALA,CAMlByhB,cAAkBzhB,CAAA,CAAE,eAAF,CANA,CAApB,CASM0hB,EAAAA,CAkBC,CAACve,MAlBcvD,IAkBduD,CAAYA,KAAb,CAAoBE,MAlBCse,CAkBrB,CAjBDC,KAAAA,CAiBC,CAACze,MAjBcvD,IAiBduD,CAAYA,KAAb;AAAoBE,MAjBCse,CAiBrB,CAfP7gB,MAAA,CAAMsQ,CAAN,CAAUxQ,MAAV,CAAiBwQ,CAAjB,CAAqByQ,GAAA,CAAI5L,MAAJ,CAAYyL,CAAZ,CAAkBvQ,aAAlB,CACrBrQ,MAAA,CAAMghB,EAAN,CAAWlhB,MAAX,CAAkBkhB,EAAlB,CAAuBD,GAAA,CAAI5L,MAAJ,CAAY2L,IAAZ,CAEvB9gB,MAAA,CAAMuQ,CAAN,CAAUzQ,MAAV,CAAiByQ,CAAjB,CAAqB0Q,GAAA,CAAI9L,MAAJ,CAAYyL,CAAZ,CAAkBvQ,aAAlB,CACrBrQ,MAAA,CAAMkhB,EAAN,CAAWphB,MAAX,CAAkBohB,EAAlB,CAAuBD,GAAA,CAAI9L,MAAJ,CAAY2L,IAAZ,CAEvB,OAAOnR,UAAA,CAAU,CACf3Q,KAltDamiB,MAitDE,CAEfzgB,KAlpFmB0gB,aAgpFJ,CAGf5P,KAAMP,OAHS,CAIf/Q,OAAAA,MAJe,CAAV,CAKJ6P,UALI,CA7B8C,CAyCvDsR,QAASA,SAAQ,CAACviB,IAAD,CAAO8B,MAAP,CAAemP,UAAf,CAA2BkB,OAA3B,CAAoCxO,IAApC,CAA0C,CACzD,IAAMvD,EAAIkP,eAAA,CAAOtP,IAAP,CAAa8B,MAAb,CACJuU,OAAAA,CAASrW,IAATqW,CAAcA,MADpB,KAEMmM,OAASxiB,IAATwiB,CAAcC,SAFpB,CAGMC,KAAOC,OAAA,CAAQtM,MAAR,CAAgB,CAAhB,CAAmB,EAAnB,CAsDqB,EAAA,CAAA,CArDPtS,IAAAA,yBAAA/D,IAAA+D,CAAKA,MAsDhC,IAAa,CAAb,GAtDwC2e,IAsDxC,CAAuB,GAAKhjB,QAAA,CAASO,QAAT,CAAkB8D,wBAAlB,CAAL,CAIhB,CAEL,IADA,IAAIpB;AAAQoB,wBAARpB,CAAiBjD,QAAA,CAAS8B,MAAT,CAAgB,EAAhB,CAAoBuC,wBAApB,CACrB,CAAqB,IAArB,EAAOpB,SAAP,CAAamB,IAAb,CAAA,CACE,GAAKpE,QAAA,CAASO,QAAT,CAAkB0C,SAAlB,CAAwBmB,IAAxB,CAAL,CAMEnB,SAAA,CAAQA,SAAR,CAAcmB,IAAd,CAAqBpE,QAAA,CAAS8B,MAAT,CAAgB,EAAhB,CAAoBmB,SAApB,CAA0BmB,IAA1B,CANvB,KAAoC,CAClCnB,SAAA,CAAMmB,IAAN,CAAasE,QAAA,CA9DqBsa,IA8DrB,CAAA,CACT,CAAChgB,OAAQ,GAARA,CAAYC,SAAZD,CAAkBoB,IAAlBpB,CAAQ,OAARA,CA/D6BggB,IA+D7BhgB,CAAmCA,MAAnCA,CAAQ,GAAT,CADS,CAETC,SAFS,CAEHmB,IAFG,CA9DqB4e,IAiElC,OAAA,CAJkC,CAStC/f,SAAA,CAAMmB,IAAN,CAtEsC4e,IA0DjC,CAJgB,IACrB3e,yBAAA,CAASqE,QAAA,CAvD6Bsa,IAuD7B,CAAA,CACL,CAAChgB,OAAQ,GAARA,CAxDiCggB,IAwDjChgB,CAAiBA,MAAjBA,CAAQ,OAARA,EAA+BqB,wBAA/BrB,EAAyC,CAAzCA,EAAQ,GAAT,CADK,CAvD6BggB,IAuD7B,EAEG3e,wBAFH,EAEa,CAFb,CAFuB,CAzDlC,IAIMA,OAAS,wBAJf;AAMiB/C,MANjB,CAOMI,OAAS,CACbF,MAAOA,wBAAPA,CAAe,CAACoQ,QAASC,aAAV,CADF,CAEbvQ,OAAQA,MAARA,CAAiB,CAACsQ,QAASK,GAAV,CAFJ,CAGbE,KAAMA,SAANA,CAAa,CAACP,QAASC,aAAV,CAHA,CAMftQ,YAAA,CAAYG,MAAZ,CAAoB,CAClB0Q,OAAkB1R,CAAA,CAAE,WAAF,CADA,CAElBwhB,UAAkBxhB,CAAA,CAAE,SAAF,CAFA,CAGlB4U,WAAkB5U,CAAA,CAAE,UAAF,CAHA,CAIlB6U,iBAAkB7U,CAAA,CAAE,gBAAF,CAJA,CAKlByhB,cAAkBzhB,CAAA,CAAE,aAAF,CALA,CAMlB2R,YAAkB3R,CAAA,CAAE,WAAF,CANA,CAApB,CASMwiB,KAAAA,CAAU,CACdrf,MAAQvD,IAARuD,CAAaA,KADC,CAEdoB,MAhyDW6N,OA8xDG,CAGd7O,KAAQA,IAARA,CAAaA,IAHC,CAIdtC,MAAQsC,IAARtC,CAAaA,KAJC,CAKd0C,OAAQJ,IAARI,CAAaA,MALC,CAMdC,MAAQ5D,CAAA,CAAE,WAAF,CANM,CASVyiB,EAAAA,CAAKZ,GAAA,CAAI5L,MAAJ,CAAY,CAAC3T,OAAQ,QAAT,CAAZ,CAAgC,CAACA,OAAQ,OAAT,CAAhC,CAELogB,KAAAA,CAAYN,MAAA,CACd,CAACjf,MAAOif,MAAR;AAAgB/e,MAAO,CAAvB,CAA0BK,KAAM4e,IAAhC,CAAsC3e,OAAQA,MAA9C,CADc,CAEd,CAACnD,MAAO,CAAR,CAAWmD,OAAQA,MAAnB,CAEEgf,OAAAA,CAAUP,MAAA,CACZ,CAACjf,MAAOif,MAAR,CAAgB/e,MAAO,CAAvB,CAA0BK,KAAM4e,IAAhC,CAAsC3e,OAAQA,MAA9C,CADY,CAEZrE,QAAA,CAAS8B,MAAT,CAAgBqhB,CAAhB,CAAoB,CAAC/e,KAAM4e,IAAP,CAAa3e,OAAQA,MAArB,CAApB,CAEJ7C,yBAAA,CAAMsQ,CAAN,CAAUxQ,MAAV,CAAiBwQ,CAAjB,CAAqByQ,GAAA,CAAI5L,MAAJ,CAAYuM,IAAZ,CAAqBE,IAArB,CACrB5hB,yBAAA,CAAMuQ,CAAN,CAAUzQ,MAAV,CAAiByQ,CAAjB,CAAqB0Q,GAAA,CAAI9L,MAAJ,CAAYuM,IAAZ,CAAqBE,IAArB,CACrB5hB,yBAAA,CAAMghB,EAAN,CAAWlhB,MAAX,CAAkBkhB,EAAlB,CAAuBC,GAAA,CAAI9L,MAAJ,CAAY0M,MAAZ,CACvB7hB,yBAAA,CAAMkhB,EAAN,CAAWphB,MAAX,CAAkBohB,EAAlB,CAAuBH,GAAA,CAAI5L,MAAJ,CAAY0M,MAAZ,CACvBlR,UAAA,CAAKL,CAAL,CAASyQ,GAAA,CAAI5L,MAAJ,CAAYuM,IAAZ,CACT/Q,UAAA,CAAKJ,CAAL,CAAS0Q,GAAA,CAAI9L,MAAJ,CAAYuM,IAAZ,CAET,OAAO/R,UAAA,CAAU,CACf3Q,KA/wDamiB,MA8wDE,CAEfzgB,KA9sFiBohB,WA4sFF,CAGfthB,IA3zDW8Q,OAwzDI;AAIfE,KAAMP,OAJS,CAKf/Q,OAAAA,MALe,CAAV,CAMH6P,UANG,CAjDkD,CAiF3DgS,QAASA,UAAS,CAACjjB,IAAD,CAAO8B,MAAP,CAAemP,UAAf,CAA2BkB,OAA3B,CAAoC4C,IAApC,CAA0CpR,IAA1C,CAAgD,CAChE,IAAMvD,EAAIkP,eAAA,CAAOtP,IAAP,CAAa8B,MAAb,CACJuU,OAAAA,CAASrW,IAATqW,CAAcA,MADpB,KAEMqM,KAAOC,OAAA,CAAQtM,MAAR,CAAgB,EAAhB,CAAoB,CAApB,CAFb,CAIInV,KAJJ,CAIW2Q,IAJX,CAIiB7Q,MAJjB,CAKMI,OAAS,CACbF,MAAOA,KAAPA,CAAe,CAACoQ,QAASC,aAAV,CADF,CAEbvQ,OAAQA,MAARA,CAAiB,CAACsQ,QAASK,GAAV,CAFJ,CAGbE,KAAMA,IAANA,CAAa,CAACP,QAASC,aAAV,CAHA,CAMftQ,YAAA,CAAYG,MAAZ,CAAoB,CAClB0Q,OAAkB1R,CAAA,CAAE,WAAF,CADA,CAElBwhB,UAAkBxhB,CAAA,CAAE,SAAF,CAFA,CAGlB4U,WAAkB5U,CAAA,CAAE,UAAF,CAHA,CAIlB6U,iBAAkB7U,CAAA,CAAE,gBAAF,CAJA,CAKlByhB,cAAkBzhB,CAAA,CAAE,aAAF,CALA,CAMlB2R,YAAkB3R,CAAA,CAAE,WAAF,CANA,CAApB,CASM8iB,KAAAA;AAAWxR,OAAA,CAAQqD,IAAR,CACjBmO,KAAA,CAASpf,IAAT,CAAgB4e,IAEVE,KAAAA,CAAU,CACdrf,MAAQvD,IAARuD,CAAaA,KADC,CAEdoB,MAl3DW6N,OAg3DG,CAGd7O,KAAQA,IAARA,CAAaA,IAHC,CAIdtC,MAAQsC,IAARtC,CAAaA,KAJC,CAKd0C,OAAQJ,IAARI,CAAaA,MALC,CAMdC,MAAQ5D,CAAA,CAAE,WAAF,CANM,CAShBY,OAAA,CAAOyQ,CAAP,CAAWvQ,KAAX,CAAiBuQ,CAAjB,CAAqBwQ,GAAA,CAAI5L,MAAJ,CAAY9E,aAAZ,CAAkBqR,IAAlB,CACrB5hB,OAAA,CAAOohB,EAAP,CAAYlhB,KAAZ,CAAkBkhB,EAAlB,CAAuBH,GAAA,CAAI5L,MAAJ,CAAY6M,IAAZ,CACvBrR,KAAA,CAAKL,CAAL,CAASyQ,GAAA,CAAI5L,MAAJ,CAAYuM,IAAZ,CAET5hB,OAAA,CAAOwQ,CAAP,CAAWtQ,KAAX,CAAiBsQ,CAAjB,CAAqB2Q,GAAA,CAAI9L,MAAJ,CAAY9E,aAAZ,CAAkBqR,IAAlB,CACrB5hB,OAAA,CAAOkhB,EAAP,CAAYhhB,KAAZ,CAAkBghB,EAAlB,CAAuBC,GAAA,CAAI9L,MAAJ,CAAY6M,IAAZ,CACvBrR,KAAA,CAAKJ,CAAL,CAAS0Q,GAAA,CAAI9L,MAAJ,CAAYuM,IAAZ,CAET,OAAO/R,UAAA,CAAU,CACf3Q,KAx1DamiB,MAu1DE,CAEfzgB,KArxFiBuhB,WAmxFF,CAGfzhB,IAp4DW8Q,OAi4DI,CAIfE,KAAMP,OAJS,CAKf/Q,OAAAA,MALe,CAAV,CAMJ6P,UANI,CAzCyD,CAkDlEmS,QAASA,UAAS,CAAC7f,KAAD,CAAQ8f,SAAR,CAAmBlgB,CAAnB,CAAsBC,CAAtB,CAAyBN,CAAzB,CAA4B,CAC5C,MAAO,CACLJ,OAAQ,eAARA;AAA0Ba,KAA1Bb,CAAkC,aAAlCA,CACgBa,KADhBb,CACwB,mBADxBA,CAEI2gB,SAFJ3gB,CAEgB,GAFhBA,CAEsBS,CAFtBT,CAE0B,GAF1BA,CAEgCU,CAFhCV,CAEoC,GAFpCA,CAE0CI,CAF1CJ,CAE8C,GAHzC,CADqC,CAQ9C4gB,QAASA,WAAU,CAACtjB,IAAD,CAAO8B,MAAP,CAAemP,UAAf,CAA2BkB,OAA3B,CAAoC4C,IAApC,CAA0CpR,IAA1C,CAAgD,CAC3DvD,MAAAA,CAAIkP,eAAA,CAAOtP,IAAP,CAAa8B,MAAb,CAAV,KACMuU,OAASrW,IAATqW,CAAcA,MACd9S,KAAAA,CAAQvD,IAARuD,CAAaA,KAFnB,KAGMmf,KAAOC,OAAA,CAAQtM,MAAR,CAAgB,EAAhB,CAAoB,CAApB,CAHb,CAIMkN,MAAQ/a,KAAA,CAAMpI,MAAA,CAAE,YAAF,CAAN,CAJd,CAKMojB,YAAchb,KAAA,CAAMpI,MAAA,CAAE,kBAAF,CAAN,CALpB,CAMMqjB,WAAarjB,MAAA,CAAE,YAAF,CANnB,CAOMsjB,cAAgBtjB,MAAA,CAAE,eAAF,CAPtB,CASIujB,QAAoB,CAApBA,GAAUJ,KAAVI,EAAyB,CAAC,CAACJ,KAT/B,CAYML,SAAWxR,OAAA,CAAQqD,IAAR,CACjBmO,SAAA,CAASpf,IAAT,CAAgB4e,IAChBQ,SAAA,CAASnf,MAAT,CAAkB2N,OAAA,CAAQtR,MAAA,CAAE,cAAF,CAAR;AAA6B,CAA7B,CAClB8iB,SAAA,CAASnf,MAAT,CAAgBD,IAAhB,CAAuB4e,IAEjBE,KAAAA,CAAU,CACdrf,MAAQA,IADM,CAEdoB,MAt6DW6N,OAo6DG,CAGd7O,KAAQ,EAHM,CAIdI,OAAQ4M,YAAA,CAAahN,IAAb,CAAkBI,MAAlB,CAA0B3D,MAAA,CAAE,aAAF,CAA1B,CAJM,CAQd,KAAA,CAAAujB,OAAA,CACIP,SAAA,CAAU7f,IAAV,CAAiBggB,KAAjB,CAAwB,QAAxB,CAAkC,SAAlC,CAA6C,UAA7C,CADJ,CAEI,CAAC3iB,MAAO,QAAR,CApX0B,KAAA,CAAAwH,QAAA,CAqXtBiO,MArXsB,CAAA,CAoBKuN,MAAA,CAiW3BvN,MAjW2B,CAnBhB3T,MAmBgB,CACrC,uBADqC,CAiWnBS,MAjWmB,CAiWXC,OAjWW,CApBL,CAzkDpBygB,OA2kDV,GAmXQxN,MAnXR,CAAmB,CAACzV,MAmXJuC,MAnXG,CAAnB,CAAgC,CAACvC,MAmXTwC,OAnXQ,CA+W5BmQ,KAAAA,CAAQ0O,GAAA,CAAI5L,MAAJ,CACZ,IADY,CAIZ,IAJY,CAOR7C,KAAAA,CAAWyO,GAAA,CAAI5L,MAAJ,CACfyN,KAAA,CAAMzN,MAAN,CAAc,QAAd,CAAwB,KAAxB,CADe,CAEfsN,OAAA,CACIP,SAAA,CAAU7f,IAAV,CAAiBggB,KAAjB,CAAwB,OAAxB,CAAiC,UAAjC,CAA6C,UAA7C,CADJ,CAEI,CAAC3iB,MAAO,QAAR,CAJW,CAOXmjB,MAAAA,CAAaX,SAAA,CAAU7f,IAAV;AAAiBggB,KAAjB,CAAwB,IAAxB,CAA6BC,WAA7B,CAAwB,GAAxB,CAA6CA,WAA7C,CAA0D,CAA1D,CACnBG,QAAA,CAAUA,OAAV,EAAqBH,WAEftiB,SAAAA,CAAQ,CACZoQ,QAASC,aADG,CAEZC,EAAGyQ,GAAA,CAAI5L,MAAJ,CAAYuM,IAAZ,CAAqBM,QAArB,CAFS,CAGZzR,EAAG0Q,GAAA,CAAI9L,MAAJ,CAAYuM,IAAZ,CAAqBM,QAArB,CAHS,CAMR9hB,SAAAA,CAAS,CACbF,MAAOA,QADM,CAEbF,OAAQA,WAARA,CAAiB,CACfsQ,QAASK,GADM,CAEfkB,KAAM,CAAClO,MA18DEmO,OA08DH,CAFS,CAGftB,EAAGtQ,QAAHsQ,CAASA,CAHM,CAIfC,EAAGvQ,QAAHuQ,CAASA,CAJM,CAKf8B,MAAAA,IALe,CAMfC,SAAAA,IANe,CAFJ,CAUb3B,KAAM,CACJP,QAASC,aADL,CAEJC,EAAGtQ,QAAHsQ,CAASA,CAFL,CAGJC,EAAGvQ,QAAHuQ,CAASA,CAHL,CAVO,CAiBfxQ,YAAA,CAAYG,QAAZ,CAAoB,CAClB2e,GAAI,CAAC0D,UAAD,EAAeE,OAAf,CAAyB1B,GAAA,CAAI5L,MAAJ,CAAY0N,KAAZ,CAAzB,CAAmD,IADrC,CAElB/D,GAAI,CAAC0D,aAAD,EAAkBC,OAAlB,CAA4BxB,GAAA,CAAI9L,MAAJ,CAAY0N,KAAZ,CAA5B,CAAsD,IAFxC,CAApB,CAKA9iB,YAAA,CAAYG,QAAZ,CAAoB,CAClBqV,MAAarW,MAAA,CAAE,YAAF,CADK;AAElBwR,KAAaxR,MAAA,CAAE,YAAF,CAFK,CAGlB2S,YAAa3S,MAAA,CAAE,cAAF,CAHK,CAIlB4S,KAAa5S,MAAA,CAAE,WAAF,CAJK,CAKlB6S,SAAa7S,MAAA,CAAE,eAAF,CALK,CAMlB+S,WAAa/S,MAAA,CAAE,iBAAF,CANK,CAOlB8S,UAAa9S,MAAA,CAAE,gBAAF,CAPK,CAQlBgT,MAAahT,MAAA,CAAE,YAAF,CARK,CASlB0W,WAAa1W,MAAA,CAAE,iBAAF,CATK,CAApB,CAUG,CACDmT,MAAakQ,UADZ,CAEDjQ,SAAakQ,aAFZ,CAVH,CAeMnH,WAAAA,CAAUnc,MAAA,CAAE,YAAF,CAIhBwS,cAAA,CAAU,CAHNA,aAGM,CAHIxS,MAAA,CAAE,cAAF,CAGJ,GAAWmc,UAAX,CAAmB,CAC3B1I,WAAYzT,MAAA,CAAE,iBAAF,CADe,CAE3BwI,OAAQgK,aAFmB,CAG3BkB,MAAO,aAHoB,CAI3ByI,MAAOA,UAAA,CAAQ,CAAChZ,MAAAA,IAAD;AAAQ8S,OAAAA,MAAR,CAAgB8G,UAAWZ,UAA3B,CAAR,CAA4C,IAJxB,CAAnB,CAKN7Y,IAAAA,EAEA1C,YAAJ,CAAWuS,KAAX,GAAqBA,IAArB,GACEvS,WADF,CACSuS,KADT,CACiByQ,KAAA,CAAMhjB,WAAN,CAAauS,KAAb,CAAoBA,IAApB,CADjB,CAGIvS,YAAJ,CAAWwS,QAAX,GAAwBA,IAAxB,GACExS,WADF,CACSwS,QADT,CACoBwQ,KAAA,CAAMhjB,WAAN,CAAawS,QAAb,CAAuBA,IAAvB,CADpB,CAIA,OAAO3C,UAAA,CAAU,CACf3Q,KA98Da6T,MA68DE,CAEfnS,KA94FkBqiB,YA44FH,CAGfpiB,MA1/DoBoS,aAu/DL,CAIfvS,IA7/DW8Q,OAy/DI,CAKfE,KAAOP,OALQ,CAMf/Q,OAAAA,QANe,CAOfwR,QAAAA,aAPe,CAAV,CAQJ3B,UARI,CAvG0D,CAkHnEiT,QAASA,UAAS,CAAClkB,IAAD,CAAO8B,MAAP,CAAemP,UAAf,CAA2BkB,OAA3B,CAAoC,CAC9C/R,MAAAA,CAAIkP,eAAA,CAAOtP,IAAP,CAAa8B,MAAb,CAAV,KACMuU,OAASrW,IAATqW,CAAcA,MADpB,CAEMqM,KAAOC,OAAA,CAAQtM,MAAR,CAAgB,EAAhB,CAAoB,CAApB,CAFb,CAIInV,KAJJ,CAIWF,MAJX;AAKMI,OAAS,CACbF,MAAOA,KAAPA,CAAe,CACboQ,QAASC,aADI,CAEbgF,OAAQ7E,OAAA,CAAQtR,MAAA,CAAE,aAAF,CAAiB,IAAjB,CAAR,CAFK,CAGbmT,MAAO,CAAC7Q,OAAQid,SAAT,CAHM,CADF,CAMb3e,OAAQA,MAARA,CAAiBtB,QAAA,CAAS8B,MAAT,CAAgB,EAAhB,CAAoBN,KAApB,CAA2B,CAC1CoQ,QAASK,GADiC,CAE1CkB,KAAMnB,OAAA,CAAQ1R,IAAR,CAAa6W,KAAb,CAFoC,CAA3B,CANJ,CAUbhF,KAAM,CACJP,QAASC,aADL,CAVO,CAeT4S,KAAAA,CAAW,CACfzhB,OAAQ,cAARA,CAAuB1C,IAAvB0C,CAA4Ba,KAA5Bb,CAAQ,MAARA,CAAwC8N,UAAA,CAAW,CAAX,CAAc,CAAd,CAAiB,EAAjB,CAAxC9N,CAAQ,GADO,CAIjB1B,OAAA,CAAOwQ,CAAP,CAAWyQ,GAAA,CAAI5L,MAAJ,CAAY8N,IAAZ,CACXnjB,OAAA,CAAOyQ,CAAP,CAAW0Q,GAAA,CAAI9L,MAAJ,CAAY8N,IAAZ,CACXjjB,MAAA,CAAMuV,KAAN,CAAcwL,GAAA,CAAI5L,MAAJ,CAAY9E,aAAZ,CAzagCnJ,QAAA,CAyaTsa,IAzaS,CAAA,CAC5C,CAAChgB,OAAQ,GAARA,CAwakCggB,IAxalChgB,CAAiBA,MAAjBA,CAAQ,QAAT,CAD4C,CAE5C,CAAC9B,MAuawCA,EAvaxCA,CAuakC8hB,IAvanC,CAuaY,CACdxhB,MAAA,CAAMsS,QAAN,CAAiByO,GAAA,CAAI5L,MAAJ,CAAYyN,KAAA,CAAMzN,MAAN,CA9iEhB+N,QA8iEgB,CAjjEnBC,KAijEmB,CAAZ;AAAwC,CAACzjB,MA9iE7CwjB,QA8iE4C,CAAxC,CACjBpjB,OAAA,CAAOyV,KAAP,CAAevV,KAAf,CAAqBuV,KACrBzV,OAAA,CAAOwS,QAAP,CAAkBtS,KAAlB,CAAwBsS,QAExBvS,YAAA,CAAYG,MAAZ,CAAoB,CAClBwQ,KAAaxR,MAAA,CAAE,YAAF,CADK,CAElB2S,YAAa3S,MAAA,CAAE,cAAF,CAFK,CAGlB4S,KAAa5S,MAAA,CAAE,WAAF,CAHK,CAIlB6S,SAAa7S,MAAA,CAAE,eAAF,CAJK,CAKlB8S,UAAa9S,MAAA,CAAE,gBAAF,CALK,CAMlB+S,WAAa/S,MAAA,CAAE,iBAAF,CANK,CAOlBgT,MAAahT,MAAA,CAAE,YAAF,CAPK,CAQlB0W,WAAa1W,MAAA,CAAE,iBAAF,CARK,CAApB,CASG,CACDmT,MAAanT,MAAA,CAAE,YAAF,CADZ,CAEDqW,MAAarW,MAAA,CAAE,YAAF,CAFZ,CAGDoT,SAAapT,MAAA,CAAE,eAAF,CAHZ,CATH,CAeAkkB,WAAA,CAAWlkB,MAAX,CAAciW,MAAd,CAAsBjV,MAAtB,CAA8B6P,UAA9B,CACA7P,OAAA,CAAOJ,MAAP,CAAcuS,KAAd;AAAsByQ,KAAA,CAAM5iB,MAAN,CAAaJ,MAAb,CAAoBuS,KAApB,CAA2BrS,KAA3B,CAAiCqS,KAAjC,CACtBnS,OAAA,CAAOJ,MAAP,CAAcyV,KAAd,CAAsBuN,KAAA,CAAM5iB,MAAN,CAAaJ,MAAb,CAAoByV,KAApB,CAA2BvV,KAA3B,CAAiCuV,KAAjC,CACtBrV,OAAA,CAAOJ,MAAP,CAAcwS,QAAd,CAAyBwQ,KAAA,CAAM5iB,MAAN,CAAaJ,MAAb,CAAoBwS,QAApB,CAA8BtS,KAA9B,CAAoCsS,QAApC,CAEzB,OAAO3C,UAAA,CAAU,CACf3Q,KA7gEa6T,MA4gEE,CAEfnS,KA38FkB2iB,YAy8FH,CAGf1iB,MAxjEoBmV,aAqjEL,CAIftE,KAAOP,OAJQ,CAKf/Q,OAAAA,MALe,CAAV,CAMJ6P,UANI,CApD6C,CA6DtDqT,QAASA,WAAU,CAAClkB,CAAD,CAAIiW,MAAJ,CAAYjV,MAAZ,CAAoB6P,UAApB,CAAgC,CACjD,IAAMuT,KAAOA,QAAA,CAAC5jB,KAAD,CAAQ6jB,GAAR,CAAgB,CAAA,MAAS,KAAT,EAAA7jB,KAAA,EACxBQ,MAAA,CAAOJ,MAAP,CAAcyjB,GAAd,CAAA,CAAqBT,KAAA,CAAMtS,OAAA,CAAQ9Q,KAAR,CAAN,CAAsBQ,MAAA,CAAOJ,MAAP,CAAcyjB,GAAd,CAAtB,CAArB,CAAgE,CAAA,CADxC,EAExBhjB,GAAA,CAAIgjB,GAAJ,CAASxT,UAAT,CAAD,CAA+B,CAAA,CAA/B,CAAwB,CAAA,CAFC,CAA7B,CAIMyT,MAAQF,IAAA,CAAKpkB,CAAA,CAAE,QAAF,CAAL,CAAkB,GAAlB,CACRukB,EAAAA,CAAQH,IAAA,CAAKpkB,CAAA,CAAE,QAAF,CAAL;AAAkB,GAAlB,CAEdgB,OAAA,CAAOF,KAAP,CAAasjB,IAAb,CAAoBG,CAAA,GAAUD,KAAV,CAChBhT,OAAA,CAAQiT,CAAR,CADgB,CAEhB1C,GAAA,CAAI5L,MAAJ,CAAY3E,OAAA,CAAQiT,CAAR,CAAZ,CAA4BjT,OAAA,CAAQgT,KAAR,CAA5B,CAV6C,CAmHnDE,QAASA,WAAU,CAAC5kB,IAAD,CAAO0F,KAAP,CAAcmf,YAAd,CAA4B,CAC7C,IAAM7d,QAAUtH,QAAA,CAAS8C,KAAT,CAAexC,IAAf,CAAoBgH,OAApB,CAAhB,CACM2W,OAASje,QAAA,CAAS8C,KAAT,CAAexC,IAAf,CAAoB2d,MAApB,CAGVkH,aAAL,EAAmB7d,OAAA,CAAQvE,OAAR,CAAgB,QAAA,CAAArC,CAAA,CAAK,CAAA,MAAAyG,YAAA,CAAYzG,CAAZ,CAAesF,KAAf,CAAA,CAArB,CAGnBhG,SAAA,CAAS8C,KAAT,CAAexC,IAAf,CAAoB8kB,WAApB,CAAA,CAAiCriB,OAAjC,CAAyC,QAAA,CAAArC,CAAA,CAAK,CAvuE9C,IAAM0B,OAuuE2D4D,KAvuE3D5D,CAAeA,MAAfA,CAAsBijB,UAAtBjjB,EAAoC,EAA1C,CACM6D,OAAS,EADf,CAGWhF,IAAX,KAAWA,IAAX,GAouE8DP,EApuE9D,CACe,MAAb,GAAIO,IAAJ,GACAgF,MAAA,CAAOhF,IAAP,CADA,CACeuO,cAAA,CAkuE6C9O,CAluE9B,CAAKO,IAAL,CAAf,CAA2BA,IAA3B,CAkuEgD+E,KAluEhD,CADf,CAKF,KAAK/E,IAAMA,QAAX,GAAmBmB,OAAnB,CACsB,IAApB,EAAI6D,MAAA,CAAOhF,QAAP,CAAJ;CACEgF,MAAA,CAAOhF,QAAP,CADF,CACiBuO,cAAA,CAAepN,MAAA,CAAOnB,QAAP,CAAf,CAA6BA,QAA7B,CA4tE8C+E,KA5tE9C,CADjB,CA6tE+DA,MAxtEjE,CAAMsf,aAAN,CAwtE8D5kB,CAxtE9D,CAAyBO,IAAzB,CAA+BgF,MAA/B,CAwtE8C,CAA9C,CAGAgY,OAAA,CAAOlb,OAAP,CAAe,QAAA,CAAArC,CAAA,CAAK,CA7+EpB,IAAMF,KA6+EwBE,CA7+ExBF,CAAYA,IAAZA,EAAoB,QAErBL,UAAA,CAAUolB,gBAAV,CAA2B/kB,IAA3B,CAAL,EACER,QAAA,CAASyF,KAAT,CAAe,2BAAf,CAA6CzF,QAAA,CAAS4E,WAAT,CAAqBpE,IAArB,CAA7C,CA0+E+BwF,MAv+EjC,CAAMwf,QAAN,CAu+E8B9kB,CAv+E9B,CAAoBO,IAApB,CAA0B,CACxBT,KAAAA,IADwB,CAExB0L,OAAQlI,IAAAA,EAFgB,CAA1B,CAu+EoB,CAApB,CAGAhE,SAAA,CAAS8C,KAAT,CAAexC,IAAf,CAAoBkM,IAApB,CAAA,CAA0BzJ,OAA1B,CAAkC,QAAA,CAAArC,CAAA,CAAK,CAAA,MAAAigB,YAAA,CAAYjgB,CAAZ,CAAesF,KAAf,CAAA,CAAvC,CAGAiY,OAAA,CAAOlb,OAAP,CAAe,QAAA,CAAArC,CAAA,CAAK,CAt+EpB,IAAMuF,OAs+E4BD,KAt+EnB,CAAMyf,QAAN,CAs+EgB/kB,CAt+EhB,CAAoBO,IAApB,CAATgF,CAAmCA,MAAzC,CACIjE,GAEJiE,OAAA,CAAOiG,MAAP,CAAgBD,gBAAA,CAm+EevL,CAn+Ef,CAAsBwL,MAAtB;AAm+EexL,CAn+Ef,CAm+EkBsF,KAn+ElB,CAEE,KAAlB,EAi+E+BtF,CAj+E/B,CAASqD,KAAT,GACEkC,MADF,CACSlC,KADT,CACiBkL,eAAA,CAg+EcvO,CAh+Ed,CAg+EiBsF,KAh+EjB,CAA6BC,MAA7B,CADjB,CAIA,IAAwB,IAAxB,EA69E+BvF,CA79E/B,CAASglB,WAAT,CAAA,CACwBA,IAAAA,YA49EOhlB,CA59EPglB,CAAKA,WAAazf,OA6L1C,CAAOyf,WAAP,CAAqB5Z,YAAA,CAAa4Z,WAAb,CAAyBllB,IAAzB,EAAiCklB,WAAjC,CACI,KAAzB,EAAIA,WAAJ,CAAgBC,KAAhB,GA9L0C1f,MA8L1C,CACS2f,gBADT,CAC4B9Z,YAAA,CAAa4Z,WAAb,CAAyBC,KAAzB,CAD5B,CA/LA,CAIiB,IAAjB,EAy9E+BjlB,CAz9E/B,CAASmlB,IAAT,GAC+BA,WAA7B,CAw9E6BnlB,CAx9E7B,CAAkCmlB,IAAlC,CA8KF,WA9KE,CA8KK7lB,QAAA,CAASO,QAAT,CAAkBslB,WAAlB,CAAA,CACH,CACEC,SAAUha,YAAA,CAAa+Z,WAAb,CAAkBC,QAAlB,CADZ,CAEExW,KAAMxD,YAAA,CAAa+Z,WAAb,CAAkBvW,IAAlB,CAFR,CADG,CAKHxD,YAAA,CAAa+Z,WAAb,CAnLF,CAAA5f,MAAA,CAAO4f,IAAP,CAAc,WADhB,CAIiB,KAAjB,EAq9E+BnlB,CAr9E/B,CAASqlB,IAAT,GAC+BA,WAA7B;AAo9E6BrlB,CAp9E7B,CAAkCqlB,IAAlC,CAkKF,WAlKE,CAkKKhd,WAAA,CAAE/F,MAAF,EAAYhD,QAAA,CAASoB,OAAT,CAAiB2H,WAAjB,CAAZ,CACHgD,UAAA,CAAWhD,WAAX,CAizE8B/C,KAjzE9B,CADG,CAkzE2BA,KAhzE9B,CAAM0W,cAAN,CAAqB3T,WAArB,CApKF,CAAA9C,MAAA,CAAO8f,IAAP,CAAc,WADhB,CAIA,KAAK/jB,GAAL,GAi9E+BtB,EAj9E/B,CACMV,QAAA,CAAS6B,cAAT,CAAwBoE,MAAxB,CAAgCjE,GAAhC,CAAJ,EAAoD,MAApD,GAA4CA,GAA5C,GACAiE,MAAA,CAAOjE,GAAP,CADA,CACc8J,YAAA,CA+8EepL,CA/8EF,CAAKsB,GAAL,CAAb,CA+8EkBgE,KA/8ElB,CADd,CAg9EkB,CAApB,CAGA,EAACmf,YAAD,EAAiB7d,OAAjB,EAA0BvE,OAA1B,CAAkC,QAAA,CAAArC,CAAA,CAAK,CAAA,MAAA+K,mBAAA,CAAmB/K,CAAnB,CAAsBsF,KAAtB,CAAA,CAAvC,CAGAhG,SAAA,CAAS8C,KAAT,CAAexC,IAAf,CAAoB0lB,IAApB,CAAA,CAA0BjjB,OAA1B,CAAkC,QAAA,CAAArC,CAAA,CAAK,CA5HxB,IAhaX0B,OA4hBgD4D,KA5hBhD5D,CAAeA,MAgaJ,CA/ZXD,MAAQC,MAARD,CAAeA,KA+ZJ,CA9ZX8jB,KAAO7jB,MAAP6jB,CAAcA,IA8ZH,CA7ZXhiB,KAAuC,MAAvCA,GAyhBgD+B,KAzhBzC,CAAMmY,SAAN,CAyhBsCzd,CAzhBtC,CAAqBmD,KAArB,CAAPI,EAAiD7B,MAAjD6B,CAAwDiiB,QA6Z7C;AA5ZXvP,OAwhB6CjW,CAxhB7CiW,CAAcA,MA4ZH,CA3ZH3U,GAEZ,IAAI0G,QAAA,CAASiO,MAAT,CAAJ,CAAsB,CACdwP,IAAAA,GAASvf,IAAA,CAAK,CACZxE,MADY,CACLgkB,KADK,CACEhkB,MADF,CACSikB,KADT,CAAL,CAAf,KAGMC,WAAa1f,IAAA,CAAK,CAChBxE,MADgB,CACTmkB,OADS,CACAnkB,MADA,CACOokB,UADP,CAEhBpkB,MAFgB,CAETqkB,QAFS,CAECrkB,MAFD,CAEQskB,SAFR,CAAL,CAKnB,KAAAC,yBAAK,EACL,GAAA,CAAA,OAAA,CAAA,YAAA,CAAYR,EAAZ,CAAA,KAAA,GAAA,CAAA,EAAA,CAAA,IAAA,EAAA,CAAA,CAAA,GAAA,CAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,IAAA,EAAA,CAAKnkB,GACH,CADF,GACE,CADF,KACE,CAAA2kB,wBAAA,CAAG3kB,GAAH,CAAA,CAAUugB,GAAA,CACR5L,MADQ,CAERgL,QAAA,CAAS3f,GAAT,CAAcI,MAAd,CAAqBgkB,KAArB,CAA4BH,IAA5B,CAAkC9jB,KAAlC,CAFQ,CAGRwf,QAAA,CAAS3f,GAAT,CAAcI,MAAd,CAAqBikB,KAArB,CAA4BJ,IAA5B,CAAkC9jB,KAAlC,CAHQ,CAOZykB,GAAA,CAAK,EACL,WAAA,CAAA,OAAA,CAAA,YAAA,CAAYN,UAAZ,CAAA,KAAA,GAAA,CAAA,UAAA,CAAA,IAAA,EAAA,CAAA,CAAA,GAAA,CAAA,IAAA,CAAA,GAAA,CAAA,UAAA,CAAA,IAAA,EAAA,CAAwB,CAAnBtkB,GAAL;AAAA,GAAA,CAAA,KACE4kB,KAAAA,sBAAAA,EAAAA,CAAG5kB,+BAAAA,GAAH4kB,CACE5jB,QAAA2T,MAAA3T,CAAOA,MADT4jB,CAEE,EAAAjF,QAAA,CAAS3f,GAAT,CAAcI,MAAd,CAAqBmkB,OAArB,CAA8BN,IAA9B,CAAoC9jB,KAApC,CAFFykB,CAGE,EAAAjF,QAAA,CAAS3f,GAAT,CAAcI,MAAd,CAAqBokB,UAArB,CAAiCP,IAAjC,CAAuC9jB,KAAvC,CAHFykB,CAIE,EAAAjF,QAAA,CAAS3f,GAAT,CAAcI,MAAd,CAAqBqkB,QAArB,CAA+BR,IAA/B,CAAqC9jB,KAArC,CACA,IAAA,CAAAwf,QAAA,CAAS3f,GAAT,CAAcI,MAAd,CAAqBskB,SAArB,CAAgCT,IAAhC,CAAsC9jB,KAAtC,CArGmC,IAAA,CAAA,CACzCa,QAAc,IAAL,EAAAO,CAAA,CAAesjB,OAAf,CAAY,0BAAZ,CAA2CC,MAAA,CAAOvjB,CAAP,CAA3C,CAAY,MAAZ,CAA6D,EAAtEP,GACc,IAAL,EAAAU,CAAA,CAAemjB,OAAf,CAAY,4BAAZ,CAA6CC,MAAA,CAAOpjB,CAAP,CAA7C,CAAY,MAAZ,CAA+D,EADxEV,GAEc,IAAL,EAAAW,GAAA,CAAekjB,OAAf,CAAY,2BAAZ,CAA4CC,MAAA,CAAOnjB,GAAP,CAA5C,CAAY,MAAZ,CAA8D,EAFvEX,GAGc,IAAL,EAAAoV,CAAA,CAAeyO,OAAf;AAAY,yBAAZ,CAA0CC,MAAA,CAAO1O,CAAP,CAA1C,CAAY,MAAZ,CAA4D,EAHrEpV,EAIQ,QALiC,CAgGrC4jB,sBAAA,CAAG5kB,8BAAH,CAAA,CAAU,GADY,CAnBJ,CAAtB,IA6BE2kB,yBACA,CAruDQhC,KAouDH,GAAChO,MAAD,EAjuDM+N,QAiuDN,GAAmB/N,MAAnB,CAAwCvU,MAAxC,CAA+CgkB,KAA/C,CAAuDhkB,MAAvD,CAA8DikB,KACnE,CAAAO,EAAA,CAAKxkB,MAAA,CAAO,MAAP,CAAgBuU,MAAA,CAAO,CAAP,CAAA,CAAUoQ,WAAV,EAAhB,CAA0CpQ,MAAA,CAAOmL,KAAP,CAAa,CAAb,CAA1C,CAOP,yBAAA,CAJc6E,wBAADK,EAAOJ,EAAPI,EAAa/iB,IAAb+iB,CACThnB,QAAA,CAAS8B,MAAT,CAAgB,EAAhB,CAAoBmkB,IAApB,CAA0BU,wBAA1B,CAA8BC,EAA9B,CAAkC3iB,IAAlC,CADS+iB,CAETf,IAuXEvkB,GAAAA,CA2H2ChB,CA3H3CgB,CAAcA,MAAdA,EAAwB,EACxBulB,OAAAA,CAAavlB,EAAbulB,CAAoBhB,IAApBgB,EAA4B,EAC5BhmB,MAAAA,CAAOgmB,MAAPhmB,CAAkBA,IAAlBA,EAA0B+C,IAAAA,EAC1B2L,KAAAA,CAAcsX,MAAdtX,CAAyBA,WACzBxN,KAAAA,CAAQ8kB,MAAR9kB,CAAmBA,KACnBzB,OAAAA,CAAIkP,eAAA,CAsHuClP,CAtHvC;AANK0B,wBAML,CA/+DJ2G,WAAAA,CAg/DgBrI,MAh/DZ,CAAE,UAAF,CACN2D,IAAAA,CA++DkB3D,MA/+DT,CAAE,YAAF,CAGRqI,WAAL,CAIWA,UAAJ,CAAM/F,MAAN,EAELiB,qBAEA,CAFO,CAACjB,OAAQ,GAARA,CAAY+F,UAAZ/F,CAAcA,MAAdA,CAAQ,mCAAT,CAEP,CADArB,8BACA,CADQ,CAACqB,OAAQ,GAARA,CAAY+F,UAAZ/F,CAAcA,MAAdA,CAAQ,yBAAT,CACR,CAAKhD,QAAA,CAASO,QAAT,CAAkB8D,GAAlB,CAAL,GACEA,GADF,CACW,CAACrB,OAAQ,GAARA,CAAY+F,UAAZ/F,CAAcA,MAAdA,CAAQ,gCAARA,CAA4CqB,GAA7C,CADX,CAJK,EAOU,QAAV,GAAI0E,UAAJ,EAEL9E,qBAEA,CAFO,CAEP,CADAtC,8BACA,CADQ,CAAA,CACR,CAAA0C,GAAA,CAAS,CAJJ,GAMLJ,qBACA,CADO,EACP;AAAAtC,8BAAA,CAAQ,CAAA,CAPH,CAXP,EAEEsC,qBACA,CAy+DoBvD,MA1+Db,CAAE,cAAF,CACP,CAAAiB,8BAAA,CAy+DoBjB,MAz+DZ,CAAE,WAAF,CAHV,CAqBA,sBAAA,CAAO,CAACiB,MAAAA,8BAAD,CAAQsC,KAAAA,qBAAR,CAAcI,OAAAA,GAAd,CA09DDe,+BAAAA,CAAQ,CACZvB,MAiH+CnD,CAjH/CmD,CAAaA,KADD,CAEZqjB,MAAQ,CAAC,CAACxmB,MAAA,CAAE,OAAF,CAFE,CAGZmV,OAAQ,CAAC,CAACnV,MAAA,CAAE,QAAF,CAHE,CAIZymB,KAAQ,CAAC,CAACzmB,MAAA,CAAE,MAAF,CAJE,CAKZwL,OAAQ,CAAC,CAACxL,MAAA,CAAE,QAAF,CALE,CAMZyW,MAAsB,IAAtBA,EA4G+CzW,CA5G/CyW,CAAaA,KAND,CAQR1E,WAAAA,CAAUvN,YAAA,CA0GoCc,KA1GhC,CAAMwI,GAAN,CAAUlB,OAAA,CAAQ,EAAR,CAAY,CAAClI,8BAAD,CAAZ,CAAV,CAAJ,CAGVgiB,QAAAA,CAAWliB,YAAA,CAuGmCc,KAvG/B,CAAMwI,GAAN,CAAU6Y,SAAA,CAAU,CACvCxjB,MAsGkDmC,KAtGzC,CAAMlC,QAAN,CAsGsCpD,CAtGtC,CAAoBmD,KAApB,CAD8B;AAEvClC,MAqGkDqE,KArGzC,CAAM9B,QAAN,CAhBED,qBAgBF,CAAoBtC,KAApB,CAF8B,CAGvC+C,MAoGkDsB,KApGzC,CAAM0W,cAAN,CAoGsChc,CApGtC,CAA0B4mB,SAA1B,CAH8B,CAIvCzY,OAmGkD7I,KAnGzC,CAAM0W,cAAN,CAmGsChc,CAnGtC,CAA0BmO,MAA1B,CAJ8B,CAKvC0P,QAkGkDvY,KAlGzC,CAAM9B,QAAN,CAkGsCxD,CAlGtC,CAAoB8d,WAApB,CAL8B,CAMvCC,WAiGkDzY,KAjGtC,CAAM9B,QAAN,CAiGmCxD,CAjGnC,CAAoB+d,UAApB,CAN2B,CAOvCC,gBAgGkD1Y,KAhGjC,CAAM9B,QAAN,CAgG8BxD,CAhG9B,CAAoBie,MAApB,CAPsB,CAAV,CAAV,CAAJ,CAWXE,IAAAA,CAAW,EAIbzZ,+BAAJ,CAAU+hB,IAAV,EACEtI,GAAA,CAASxX,IAAT,CAAcwb,QAAA,CAuFiCniB,CAvFjC,CArCD0B,wBAqCC,CAAuBV,EAAvB,CAA8BylB,IAA9B,CAAoCC,OAApC,CA9BHnjB,qBA8BG,CAAd,CAIF,IAAImB,8BAAJ,CAAU8hB,KAAV,CAAiB,CACf,IAAA7R,KAAO3U,MAAA,CAAE,UAAF,CACPme,IAAA,CAASxX,IAAT,CAAckc,SAAA,CAiFiC7iB,CAjFjC,CA3CD0B,wBA2CC,CAAwBV,EAAxB,CAA+BwlB,KAA/B;AAAsCE,OAAtC,CAAgD/R,IAAhD,CApCHpR,qBAoCG,CAAd,CAFe,CAMbmB,8BAAJ,CAAUyQ,MAAV,GACER,IACA,CADOjQ,8BAAA,CAAM8hB,KAAN,CAAc7R,IAAd,CAAqB,CAC5B,CAAAwJ,GAAA,CAASxX,IAAT,CAAcuc,UAAA,CA2EiCljB,CA3EjC,CAjDD0B,wBAiDC,CAAyBV,EAAzB,CAAgCmU,MAAhC,CAAwCuR,OAAxC,CAAkD/R,IAAlD,CA1CHpR,qBA0CG,CAAd,CAFF,CAMImB,+BAAJ,CAAU8G,MAAV,EACE2S,GAAA,CAASxX,IAAT,CAAc4a,UAAA,CAsEiCvhB,CAtEjC,CAtDD0B,wBAsDC,CAAyBV,EAAzB,CAAgCwK,MAAhC,CAAwCuG,UAAxC,CAAd,CAIErN,+BAAJ,CAAU+R,KAAV,EACE0H,GAAA,CAASxX,IAAT,CAAcmd,SAAA,CAiEiC9jB,CAjEjC,CA3DD0B,wBA2DC,CAAwBV,EAAxB,CAA+ByV,KAA/B,CAAsC1E,UAAtC,CAAd,CAsBI/Q,KAAAA,CAAS,CAACF,MAAO,EAAR,CAAYF,OAAQ,EAApB,CAEfC,YAAA,CAAYG,IAAZ,CAAoB,CAClBiV,OAjB4CjW,MAiB9B,CAAE,QAAF,CADI;AAElB2D,OAlB4C3D,MAkB9B,CAAE,QAAF,CAAd2D,EAA6B,CAFX,CAGlBkjB,SAAcrmB,cAAA,CAsCiCR,CAtCjC,CAAW6mB,QAAX,CAAqB,CAArB,CAHI,CAIlB9H,aApB4C/e,MAoB9B,CAAE,cAAF,CAJI,CAKlB8mB,UArB4C9mB,MAqB9B,CAAE,WAAF,CALI,CAMlB+mB,UAtB4C/mB,MAsB9B,CAAE,WAAF,CANI,CAOlBqD,MAAc,CAACf,OAAQ,kBAARA,CAkCgCtC,CAlChCsC,CAAgCa,KAAhCb,CAAQ,MAAT,CAPI,CAQlB0kB,UAxB4ChnB,MAwB9B,CAAE,WAAF,CARI,CAWlBie,OA8B+Cje,CA9B/Cie,CAAmBA,MAXD,CAYlBF,WA6B+C/d,CA7B/C+d,CAAmBA,UAZD,CAApB,CAyCuC,OA7DhCxD,UAAA,CACLxL,UAAA,CAAW,CACTvN,KAtiGWylB,MAqiGF,CAET3U,KAAaP,UAFJ,CAGT/Q,OAAaD,YAAA,CA+BVC,IA/BU,CAAuCulB,MAAvC,CAAmD5V,IAAnD,CAHJ,CAITiF,MAAauI,GAJJ,CAKThH,KAAanX,MAAA,CAAE,MAAF,CALJ,CAMToX,YAAapX,MAAA,CAAE,aAAF,CANJ,CAOTkX,OAAalX,MAAA,CAAE,QAAF,CAPJ,CAQTO,KAAAA,KARS,CAST0O,YAAAA,IATS,CAUTxN,MAAAA,IAVS,CAAX,CADK;AA6D6C6D,KA7D7C,CA6DgC,CAAvC,CAGAhG,SAAA,CAAS8C,KAAT,CAAexC,IAAf,CAAoBgW,KAApB,CAAA,CAA2BvT,OAA3B,CAAmC,QAAA,CAAArC,CAAA,CAAK,CAAA,MAAAua,UAAA,CAAUva,CAAV,CAAasF,KAAb,CAAA,CAAxC,CAGAhG,SAAA,CAAS8C,KAAT,CAAexC,IAAf,CAAoBqc,OAApB,CAAA,CAA6B5Z,OAA7B,CAAqC,QAAA,CAAArC,CAAA,CAAK,CAAA,MAAAod,YAAA,CAAYpd,CAAZ,CAAesF,KAAf,CAAA,CAA1C,CAGI1F,KAAJ,CAAS6W,KAAT,EAAgByI,UAAA,CAAWtf,IAAX,CAAgB6W,KAAhB,CAAuBnR,KAAvB,CAGhBA,MAAA,CAAM4hB,YAAN,EAEA,OAAO5hB,MArCsC,CAsD/C6hB,QAASA,UAAS,CAACvnB,IAAD,CAAO0F,KAAP,CAAc,CAC9B,IAAM5D,OAAS4D,KAAT5D,CAAeA,MAArB,CAGM0lB,KAAO5iB,YAAA,CAAIc,KAAJ,CAAU8hB,IAAV,CAAiB9hB,KAAA,CAAMwI,GAAN,CAj1FvB,IAAI1G,KAAJ,CAIQtH,UAJR,CAi1FiCU,IAAA,EAj1FjC,CAi1FiC+E,IAAA,EAj1FjC,CAIAZ,IAAA,EAJA,CAi1FuB,CAAjB,CAHb,CAMMiC,QAAUygB,cAAA,CAAeznB,IAAf,CAAqB8B,MAArB,CAChBkF,QAAA,CAAQvE,OAAR,CAAgB,QAAA,CAAArC,CAAA,CAAK,CAAA,MAAAyG,YAAA,CAAYzG,CAAZ,CAAesF,KAAf,CAAA,CAArB,CAGAA,MAAA,CAAM8R,WAAN,CAAoBxX,IAApB,CAAyBwX,WAAzB;AAAwC1V,MAAxC,CAA+C0V,WAC/C9R,MAAA,CAAMgiB,WAAN,CAAoB5lB,MAApB,CAA2ByI,MAC3B7E,MAAA,CAAM2W,OAAN,CAAgB3W,KAAA,CAAM0W,cAAN,CAAqBta,MAArB,CAA4B2b,MAA5B,EAAsC3b,MAAtC,CAA6C2b,MAA7C,CAAoD7C,MAApD,CAChBlV,MAAA,CAAMiiB,MAAN,CAAe7lB,MAAf,CAAsB6lB,MAGhBza,OAAAA,CAAQxH,KAAA,CAAMwI,GAAN,CAAUlB,OAAA,EAAV,CAGd,KAAM5L,OAASsE,KAAA,CAAMwI,GAAN,CAAUuN,MAAA,CAAOhW,WAAA,CAlCPtE,YAAA,CACzB,CACED,MAAO,CACLsQ,EAAG,CAAC5Q,MAAO,CAAR,CADE,CAEL6Q,EAAG,CAAC7Q,MAAO,CAAR,CAFE,CADT,CAKEI,OAAQ,CACNoQ,MAAO,CAAC1O,OAAQ,OAAT,CADD,CAEN2O,OAAQ,CAAC3O,OAAQ,QAAT,CAFF,CALV,CADyB,CAmCZ1C,IAnCY,CAmCPoB,MAnCO,CAkCO,CAttEhBgO,OAstEgB,CAvpGhBhN,OAupGgB,CAE9BpC,IAF8B,CAEzB6B,KAFyB,CAElB6D,KAFkB,CAEX,CAACoI,MAAOlJ,YAAA,CAAIsI,MAAJ,CAAR,CAFW,CAAP,CAAV,CAAf,CAMMnI,OAASW,KAAA,CAAMwI,GAAN,CAAUiO,UAAA,CAAW,CAClCvB,OAAUlV,KAAA,CAAM0W,cAAN,CAAqBpc,IAArB,CAA0B4a,MAA1B,CADwB,CAElCyB,QAAU3W,KAAV2W,CAAgBA,OAFkB,CAGlCuL,SAAUliB,KAAA,CAAMoF,SAAN,CAAgB,UAAhB,CAHwB;AAIlCvI,KAAUilB,IAJwB,CAKlC1Z,MAAUlJ,YAAA,CAAIxD,MAAJ,CALwB,CAAX,CAAV,CAOfsE,MAAA,CAAMgX,SAAN,CAAgBlY,GAAhB,EAGAkB,MAAA,CAAMiX,SAAN,CAAgB/X,YAAA,CAAIxD,MAAJ,CAAhB,CAA6BwD,YAAA,CAAIG,MAAJ,CAA7B,CAA0C,IAA1C,CACA6f,WAAA,CAAW5kB,IAAX,CAAiB0F,KAAjB,CAAwBsB,OAAxB,CACAtB,MAAA,CAAMgX,SAAN,CAAgB3V,IAAhB,CAAqBhC,MAArB,CAGIoC,KAAAA,CAAKzB,KAAA,CAAMwI,GAAN,CAAUsO,KAAA,CAAM,CAACja,KAAMilB,IAAP,CAAa1Z,MAAOlJ,YAAA,CAAIG,MAAJ,CAApB,CAAN,CAAV,CACToC,KAAA,CAAKzB,KAAA,CAAMwI,GAAN,CAAU6O,MAAA,CAAO,CAACjP,MAAOlJ,YAAA,CAAIuC,IAAJ,CAAR,CAAP,CAAV,CACLA,KAAA,CAAKzB,KAAA,CAAMwI,GAAN,CAAUd,KAAA,CAAM,CAACU,MAAOlJ,YAAA,CAAIuC,IAAJ,CAAR,CAAN,CAAV,CAGLzB,MAAA,CAAMsU,OAAN,CAAc,MAAd,CAAsB,IAAIb,SAAJ,CAAczT,KAAd,CAAqBwH,MAArB,CAA4BA,MAA5B,CAAmC/F,IAAnC,CAAtB,CAEA,OAAOzB,MAhDuB,CAmDhCmiB,QAASA,aAAY,CAAClnB,IAAD,CAAOC,KAAP,CAAc,CACjC,MAAOA,MAAA,EAASA,KAAT,CAAe8B,MAAf,CACH,CAAE/B,KAAAA,IAAF,CAAQK,OAAQJ,KAARI,CAAc0B,MAAtB,CADG;AAEH,CAAE/B,KAAAA,IAAF,CAAQC,MAAAA,KAAR,CAH6B,CAoBnC6mB,QAASA,eAAc,CAACznB,IAAD,CAAO8B,MAAP,CAAe,CACpC,IAAM1B,EAAIA,QAAA,CAAAO,IAAA,CAAQ,CAAA,MAAAC,eAAA,CAAMZ,IAAA,CAAKW,IAAL,CAAN,CAAkBmB,MAAA,CAAOnB,IAAP,CAAlB,CAAA,CAAlB,CACMqG,QAAU,CACR6gB,YAAA,CAAa,YAAb,CAA2BznB,CAAA,CAAE,YAAF,CAA3B,CADQ,CAERynB,YAAA,CAAa,UAAb,CAAyB9nB,aAAA,CAAcK,CAAA,CAAE,UAAF,CAAd,CAAzB,CAFQ,CAGRynB,YAAA,CAAa,SAAb,CAAwB1nB,YAAA,CAAaC,CAAA,CAAE,SAAF,CAAb,CAAxB,CAHQ,CAIRynB,YAAA,CAAa,OAAb,CAAsBznB,CAAA,CAAE,OAAF,CAAtB,EAAoC,CAApC,CAJQ,CAKRynB,YAAA,CAAa,QAAb,CAAuBznB,CAAA,CAAE,QAAF,CAAvB,EAAsC,CAAtC,CALQ,CADhB,CAQM0nB,IAAM9gB,OAAA,CAAQ2F,MAAR,CAAe,QAAA,CAACgB,CAAD,CAAIzK,CAAJ,CAAW,CAAA,MAAAyK,EAAA,CAAEzK,CAAF,CAAIvC,IAAJ,CAAA,CAAYuC,CAAZ,CAAeyK,CAAf,CAA1B,CAA6C,EAA7C,CARZ,CASMtJ,IAAM,EAGZ3E,SAAA,CAAS8C,KAAT,CAAexC,IAAf,CAAoBgH,OAApB,CAAA,CAA6BvE,OAA7B,CAAqC,QAAA,CAAAS,CAAA,CAAK,CACpCxD,QAAA,CAAS6B,cAAT,CAAwBumB,GAAxB;AAA6B5kB,CAA7B,CAA+BvC,IAA/B,CAAJ,CAEEuC,CAFF,CAEMxD,QAAA,CAAS8B,MAAT,CAAgBsmB,GAAA,CAAI5kB,CAAJ,CAAMvC,IAAN,CAAhB,CAA6BuC,CAA7B,CAFN,CAKE8D,OAAA,CAAQD,IAAR,CAAa7D,CAAb,CAEFmB,IAAA,CAAInB,CAAJ,CAAMvC,IAAN,CAAA,CAAcuC,CAR0B,CAA1C,CAYAxD,SAAA,CAAS8C,KAAT,CAAeV,MAAf,CAAsBkF,OAAtB,CAAA,CAA+BvE,OAA/B,CAAuC,QAAA,CAAAS,CAAA,CAAK,CACrCxD,QAAA,CAAS6B,cAAT,CAAwB8C,GAAxB,CAA6BnB,CAA7B,CAA+BvC,IAA/B,CAAL,EAA8CjB,QAAA,CAAS6B,cAAT,CAAwBumB,GAAxB,CAA6B5kB,CAA7B,CAA+BvC,IAA/B,CAA9C,EAEEqG,OAAA,CAAQD,IAAR,CAAa7D,CAAb,CAHwC,CAA5C,CAOA,OAAO8D,QAhC6B,CAmCtC+gB,QAASA,QAAO,CAACjmB,MAAD,CAASkJ,OAAT,CAAkB,CAChC,IAAA,CAAKlJ,MAAL,CAAcA,MAAd,EAAwB,EACxB,KAAA,CAAKkJ,OAAL,CAAeA,OAAf,EAA0B,EAE1B,KAAA,CAAKgd,QAAL,CAAgB,EAChB,KAAA,CAAKrjB,KAAL,CAAa,EACb,KAAA,CAAKqC,OAAL,CAAe,EACf,KAAA,CAAKihB,OAAL,CAAe,EACf,KAAA,CAAKtK,MAAL,CAAc,EACd,KAAA,CAAKpT,MAAL,CAAc,EACd,KAAA,CAAK2B,IAAL,CAAY,EAEZ,KAAA,CAAKgc,OAAL,CAAe,EACf,KAAA,CAAKC,OAAL,CAAe,EACf,KAAA,CAAKzL,SAAL,CAAiB,EAEjB,KAAA,CAAKiL,MAAL,CADA,IACA,CADKD,WACL,CADmB,IAInB;IAAA,CAAKU,MAAL,CADA,IACA,CADKC,GACL,CADW,CAEX,KAAA,CAAKC,QAAL,CAAgB,CAAC,CAAD,CAEhB,KAAA,CAAKC,OAAL,CAAe,EACf,KAAA,CAAKC,OAAL,CAAe,EACf,KAAA,CAAKC,OAAL,CAAe,EACf,KAAA,CAAKC,SAAL,CAAiB,EAzBe,CA4BlCC,QAASA,SAAQ,CAACjjB,KAAD,CAAQ,CACvB,IAAA,CAAK5D,MAAL,CAAc4D,KAAd,CAAoB5D,MACpB,KAAA,CAAKkJ,OAAL,CAAetF,KAAf,CAAqBsF,OACrB,KAAA,CAAKqR,OAAL,CAAe3W,KAAf,CAAqB2W,OAErB,KAAA,CAAK1X,KAAL,CAAa0B,MAAA,CAAOuiB,MAAP,CAAcljB,KAAd,CAAoBf,KAApB,CACb,KAAA,CAAKqC,OAAL,CAAeX,MAAA,CAAOuiB,MAAP,CAAcljB,KAAd,CAAoBsB,OAApB,CACf,KAAA,CAAKihB,OAAL,CAAe5hB,MAAA,CAAOuiB,MAAP,CAAcljB,KAAd,CAAoBuiB,OAApB,CACf,KAAA,CAAKtK,MAAL,CAActX,MAAA,CAAOuiB,MAAP,CAAcljB,KAAd,CAAoBiY,MAApB,CACd,KAAA,CAAKpT,MAAL,CAAclE,MAAA,CAAOuiB,MAAP,CAAcljB,KAAd,CAAoB6E,MAApB,CACd,KAAA,CAAK2B,IAAL,CAAY7F,MAAA,CAAOuiB,MAAP,CAAcljB,KAAd,CAAoBwG,IAApB,CAEZ,KAAA,CAAKgc,OAAL,CAAe,EACf,KAAA,CAAKC,OAAL,CAAe,EACf,KAAA,CAAKzL,SAAL,CAAiB,EAEjB,KAAA,CAAK2L,GAAL;AAAW,CACX,KAAA,CAAKD,MAAL,CAAc,EAAE1iB,KAAA,CAAM4iB,QAAN,CAAe,CAAf,CAChB,KAAA,CAAKA,QAAL,CAAgB5iB,KAAhB,CAAsB4iB,QAEtB,KAAA,CAAKC,OAAL,CAAe7iB,KAAA,CAAM6iB,OAAN,CAAc/G,KAAd,EACf,KAAA,CAAKgH,OAAL,CAAe9iB,KAAA,CAAM8iB,OAAN,CAAchH,KAAd,EACf,KAAA,CAAKiH,OAAL,CAAe/iB,KAAA,CAAM+iB,OAAN,CAAcjH,KAAd,EACf,KAAA,CAAKkH,SAAL,CAAiBhjB,KAAjB,CAAuBgjB,SAvBA,CA2WzBG,QAASA,eAAc,CAAC7oB,IAAD,CAAO,CAC5B,MAAO,CAACN,QAAA,CAASoB,OAAT,CAAiBd,IAAjB,CAAA,CAAyB8oB,WAAzB,CAAuCC,YAAxC,EAAsD/oB,IAAtD,CADqB,CAI9B8oB,QAASA,YAAW,CAACtmB,KAAD,CAAQ,CAI1B,IAHA,IAAMwV,EAAIxV,KAAJwV,CAAUjX,MAAhB,CACIwE,KAAO,GADX,CAGS0S,EAAI,CAAb,CAAgBA,CAAhB,CAAkBD,CAAlB,CAAqB,EAAEC,CAAvB,CAA0B,CACxB,IAAMrX,UAAQ4B,KAAA,CAAMyV,CAAN,CACd1S,KAAA,GAAa,CAAJ,CAAA0S,CAAA,CAAQ,GAAR,CAAc,EAAvB,GACKvY,QAAA,CAASO,QAAT,CAAkBW,SAAlB,CAAA,CACEA,SADF,CACQ8B,MADR,EACkBmmB,cAAA,CAAejoB,SAAf,CADlB,CAEClB,QAAA,CAAS4E,WAAT,CAAqB1D,SAArB,CAHN,CAFwB,CAO1B,MAAO2E,KAAP;AAAc,GAXY,CAc5BwjB,QAASA,aAAY,CAACrH,GAAD,CAAM,CAAA,IACrBnc,KAAO,GADc,CAErB0S,EAAI,CAFiB,CAGrBvW,GAEJ,KAAKA,GAAL,GAAYggB,IAAZ,CAAiB,CACf,IAAA9gB,MAAQ8gB,GAAA,CAAIhgB,GAAJ,CACR6D,KAAA,GAAe,CAAN,CAAA,EAAE0S,CAAF,CAAU,GAAV,CAAgB,EAAzB,EACIvY,QAAA,CAAS4E,WAAT,CAAqB5C,GAArB,CADJ,CACgC,GADhC,EAEKhC,QAAA,CAASO,QAAT,CAAkBW,KAAlB,CAAA,CACEA,KADF,CACQ8B,MADR,EACkBmmB,cAAA,CAAejoB,KAAf,CADlB,CAEClB,QAAA,CAAS4E,WAAT,CAAqB1D,KAArB,CAJN,CAFe,CAQjB,MAAO2E,KAAP,CAAc,GAbW,CAqB3BxD,QAASA,SAAQ,EAAG,CASlB,MAAO,CAELyV,YAAa,oBAFR,CAKLrB,QAAS,CALJ,CASLyR,SAAU,KATL,CAaLoB,WAAY,IAbP,CAiBLze,OAAQ,CACNxI,SAAU,CAACknB,MAAO,CAAC,OAAD,CAAR,CADJ,CAjBH,CAwBL5mB,MAAO,IAxBF,CA4BLE,KAAM,IA5BD,CA6BL2mB,IAAK,CACHtX,KAnCiBuX,SAkCd,CA7BA,CAgCLC,KAAM,CACJxX,KAtCiBuX,SAqCb,CAhCD,CAmCLE,MAAO,IAnCF,CAoCLC,KAAM,CACJxX,OA1CiBqX,SAyCb,CAEJpX,YA5CuBwX,CA0CnB,CApCD,CAwCLtS,KAAM,CACJnF,OA9CiBqX,SA6Cb,CAxCD;AA2CLK,KAAM,CACJ5X,KAjDiBuX,SAgDb,CA3CD,CA8CL7jB,KAAM,CACJwM,OAnDU2X,MAkDN,CA9CD,CAiDL3U,MAAO,CACLhD,OAvDiBqX,SAsDZ,CAjDF,CAoDLO,OAAQ,CACN9X,KA1DiBuX,SAyDX,CAENpU,KAAM,EAFA,CApDH,CAwDLlC,KAAM,CACJjB,KA7DU6X,MA4DN,CAEJzW,KAlEgB2W,YAgEZ,CAGJ1W,SAAU,EAHN,CAxDD,CA6DL2W,MAAO,CACLhY,KAnEiBuX,SAkEZ,CAELpU,KArEuBwU,CAmElB,CA7DF,CAmEL1nB,MAAO,CAEL,cAAe,CACb+P,KA1EQ6X,MAyEK,CAEbzW,KA/Ec2W,YA6ED,CAGb1W,SAAU,EAHG,CAFV,CAQL,cAAe,CACbrB,KAhFQ6X,MA+EK,CAEbzW,KArFc2W,YAmFD,CAGb1W,SAAU,EAHG,CAIbE,WAAY,MAJC,CARV,CAeL,cAAe,CACbvB,KAvFQ6X,MAsFK,CAEbzW,KA5Fc2W,YA0FD,CAGb1W,SAAU,EAHG,CAIbE,WAAY,MAJC,CAfV,CAsBL,iBAAkB,CAChBvB,KA9FQ6X,MA6FQ,CAEhBzW,KAnGc2W,YAiGE,CAGhB1W,SAAU,EAHM,CAtBb,CA4BL4W,MAAO,CACL9U,KAvGoB+U,EAsGf,CAEL/X,YAvGqBwX,CAqGhB,CAGLzU,MAAO,QAHF,CA5BF;AAiCLiV,OAAQ,CACNhV,KA5GoB+U,EA2Gd,CAEN/X,YA5GqBwX,CA0Gf,CAjCH,CAqCLS,OAAQ,CACNjV,KAhHoB+U,EA+Gd,CAEN/X,YAhHqBwX,CA8Gf,CAGNzU,MAAO,QAHD,CArCH,CA2CLmV,KAAM,CACJrY,KAAM,aADF,CAEJE,OAlHYoY,MAgHR,CA3CD,CAnEF,CAqHLrT,MAAO,CACLR,OAAQ,KADH,CAELE,OAAQ,QAFH,CAGLxS,OAAQ,CAHH,CAILomB,gBAAiB,CAJZ,CArHF,CA6HLxE,KAAM,CACJuB,UAAW,CADP,CAEJC,UAAW,GAFP,CAGJiD,aAAc,EAHV,CAIJxe,OAAQ,CAAA,CAJJ,CAKJye,YAAa,CALT,CAMJC,YAtISC,MAgIL,CAOJ1D,KAAM,CAAA,CAPF,CAQJ2D,UAAW,CARP,CASJC,UAxIcP,MA+HV,CAUJ3U,OAAQ,CAAA,CAVJ,CAWJmV,WAAY,CAXR,CAYJrX,WAAY,GAZR,CAaJM,YAAa,CAbT,CAcJgX,aAAc,CAdV,CAeJ/D,MAAO,CAAA,CAfH,CAgBJgE,UAhJSL,MAgIL,CAiBJM,WAAY,CAjBR,CAkBJC,UAAW,CAAA,CAlBP,CAmBJ5H,SAAU,CAnBN,CAoBJ6H,UAAW,CApBP,CAqBJ5L,aAAc,CArBV,CA7HD,CAsJLyG,SAAU,CACRiF,WAAY,GADJ,CAtJL,CA2JL9F,WAAY,CACV7kB,KAAM,UADI,CA3JP;AAgKLud,OAAQ,CACNpH,OAAQ,OADF,CAENF,QAAS,CAFH,CAGN6U,UAAW,MAHL,CAINC,cAAe,EAJT,CAKNC,WAAY,CALN,CAMNtb,gBAAiB,UANX,CAONC,kBAAmB,UAPb,CAQNC,eAAgB,GARV,CASNG,kBAAmB,EATb,CAUNkb,oBA5KcjB,MAkKR,CAWNkB,oBAAqB,CAXf,CAYNxX,oBAAqB,CAZf,CAaN6P,WAAY,MAbN,CAcNC,cAAe,QAdT,CAeNrQ,WAAY,GAfN,CAgBNM,YAAa,CAhBP,CAiBN0X,aAAc,CAAA,CAjBR,CAkBNC,YAAa,EAlBP,CAmBNC,WAAY,QAnBN,CAoBNC,WAAY,GApBN,CAqBNpX,aAAc,CArBR,CAsBNqX,kBAAmB,GAtBb,CAuBN7W,oBAAqB,aAvBf,CAwBNC,sBA3LS0V,MAmKH,CAyBNmB,WAAY,GAzBN,CA0BNC,YAAa,KA1BP;AA2BNxM,aAAc,CA3BR,CA4BNvE,OAAQ,CACN7W,OAAQ,EADF,CAEN4L,UAAW,YAFL,CAGNpP,KAAQ,CAAEoP,UAAW,UAAb,CAHF,CAINnP,MAAQ,CAAEmP,UAAW,UAAb,CAJF,CA5BF,CAhKH,CAqMLlM,MAAO,CACLmoB,SAAU,CACRhd,OAAQ,WADA,CADL,CAILid,QAAS,CACPjd,OAAQ,OADD,CAJJ,CAOLkd,QAAS,CACPld,OAAQ,iBADD,CAPJ,CAULmd,KAAM,CACJnd,OAAQ,OADJ,CAVD,CAaLod,UAAW,CACTpd,OAAQ,YADC,CAETC,OAAQ,CAAC,CAAD,CAAI,CAAJ,CAFC,CAbN,CAiBL6a,OAAQ,oFAAA,CAAA,KAAA,CAAA,GAAA,CAjBH,CArMF,CATW,CA3sHpB,IAAMhY,QAAUA,QAAA,CAAAtR,CAAA,CAAK,CAAA,MAAAV,SAAA,CAASO,QAAT,CAAkBG,CAAlB,CAAA,EAAwB,CAACV,QAAA,CAASoB,OAAT,CAAiBV,CAAjB,CAAzB,CACjBV,QAAA,CAAS8B,MAAT,CAAgB,EAAhB,CAAoBpB,CAApB,CADiB,CAEjB,CAACQ,MAAOR,CAAR,CAFiB,CAArB,CAmIMoD,SAAWA,QAAA,CAAAD,KAAA,CAAS,CAAA,MAAA7D,SAAA,CAAS0F,QAAT,CAAkB7B,KAAlB,CAAA;AAA2B7D,QAAA,CAAS4E,WAAT,CAAqBf,KAArB,CAA3B,CACtBA,KAAA,CAAMb,MAAN,CAAe,GAAf,CAAmBa,KAAnB,CAAyBb,MAAzB,CAAe,GAAf,CACAiC,cAAA,CAAMpB,KAAN,CAFsB,CAnI1B,CA6KMR,OAASA,QAAA,CAAC7C,IAAD,CAAOsR,CAAP,CAAUC,CAAV,CAAawa,CAAb,CACb,CAAA,MAAA,GAAA,CAAI/rB,IAAJ,CAAA,GAAA,CAAY,CAACsR,CAAD,CAAIC,CAAJ,CAAOwa,CAAP,CAAA,CAAU5nB,GAAV,CAAc1B,cAAd,CAAA,CAAqB+B,IAArB,CAA0B,GAA1B,CAAZ,CAAA,OAAA,CA9KF,CAqUMuC,cAAgB,CAAC,OAAD,CAAU,QAAV,CAAoB,MAApB,CAA4B,OAA5B,CAAqC,MAArC,CArUtB,CA0XM4G,YAAcjG,QAAA,CAAS,KAAT,CA1XpB,CAkhBMgD,cAAgB,CACpBrF,KAAM,UADc,CAEpB2mB,IAAK,CAAChsB,KAAM,YAAP,CAAqBU,MAAO,OAA5B,CAFe,CAlhBtB,CAsnBM+a,mBAAYA,QAAA,CAAAhb,IAAA,CAAQ,CAAA,MAAA,SAAA,CAACgF,MAAD,CAAS/E,KAAT,CAAgBmE,MAAhB,CACxB,CAAA,MAjRO,KAAIyC,KAAJ,CAiRC7G,IAjRD,CAiROC,KAjRP,CAiRc+E,MAjRd,EAiRwBjC,IAAAA,EAjRxB,CAiRmCqB,MAjRnC,CAiRP,CADwB,CAtnB1B,CAynBMoJ,UAAYwN,kBAAA,CAAU,WAAV,CAznBlB,CA0nBMoL;AAAYpL,kBAAA,CAAU,WAAV,CA1nBlB,CA2nBMa,MAAQb,kBAAA,CAAU,OAAV,CA3nBd,CA4nBM3O,QAAU2O,kBAAA,CAAU,SAAV,CA5nBhB,CA6nBMwQ,QAAUxQ,kBAAA,CAAU,SAAV,CA7nBhB,CA8nBMZ,SAAWY,kBAAA,CAAU,UAAV,CA9nBjB,CA+nBMF,OAASE,kBAAA,CAAU,QAAV,CA/nBf,CAgoBMyQ,WAAazQ,kBAAA,CAAU,YAAV,CAhoBnB,CAioBM9B,MAAQ8B,kBAAA,CAAU,OAAV,CAjoBd,CAkoBM0Q,MAAQ1Q,kBAAA,CAAU,OAAV,CAloBd,CAmoBM2Q,IAAM3Q,kBAAA,CAAU,KAAV,CAnoBZ,CAooBMqC,cAAgBrC,kBAAA,CAAU,eAAV,CApoBtB,CAqoBMwF,KAAOxF,kBAAA,CAAU,MAAV,CAroBb,CAsoBMT,KAAOS,kBAAA,CAAU,MAAV,CAtoBb,CAuoBMjN,YAAciN,kBAAA,CAAU,aAAV,CAvoBpB;AAwoBMnN,YAAcmN,kBAAA,CAAU,aAAV,CAxoBpB,CAyoBM4B,QAAU5B,kBAAA,CAAU,SAAV,CAzoBhB,CA0oBM7C,OAAS6C,kBAAA,CAAU,QAAV,CA1oBf,CA2oBM/B,SAAW+B,kBAAA,CAAU,UAAV,CA3oBjB,CA4oBM4Q,WAAa5Q,kBAAA,CAAU,YAAV,CA5oBnB,CA6oBM6Q,MAAQ7Q,kBAAA,CAAU,OAAV,CA7oBd,CA8oBMqF,MAAQrF,kBAAA,CAAU,OAAV,CA9oBd,CA+oBMoB,OAASpB,kBAAA,CAAU,QAAV,CA/oBf,CAgpBM8Q,MAAQ9Q,kBAAA,CAAU,OAAV,CAhpBd,CAipBMvO,MAAQuO,kBAAA,CAAU,OAAV,CAjpBd,CAkpBMM,UAAYN,kBAAA,CAAU,WAAV,CAlpBlB,CAmpBMQ,WAAaR,kBAAA,CAAU,YAAV,CAnpBnB,CAopBMvN,OAASuN,kBAAA,CAAU,QAAV,CAppBf,CAspBI7O;AAAe,CAtpBnB,CAwpBMkB,qBAAwB,CAAC0e,IAAK,KAAN,CAAaxnB,IAAK,KAAlB,CAAyBd,MAAO,KAAhC,CAxpB9B,CA89BM8Q,aAAe,uDAAA,CAAA,KAAA,CAAA,GAAA,CA99BrB,CAw+BMnE,KAAO,CACXpQ,KAAM,CADK,CAEXkB,MAAO,CAFI,CAGXwN,YAAa,CAHF,CAx+Bb,CA8+BMkC,cAAO,CAAC3Q,MAAO,CAAR,CA9+Bb,CA++BM+Q,IAAM,CAAC/Q,MAAO,CAAR,CA/+BZ,CAwiCM+e,UAAYnP,UAAA,CAChB9Q,QAAA,CAAS4E,WAAT,CAhHWqoB,MAgHX,CADgB,CAEhBjtB,QAAA,CAAS4E,WAAT,CAhHYuf,OAgHZ,CAFgB,CAGhBnkB,QAAA,CAAS4E,WAAT,CA/GasoB,QA+Gb,CAHgB,CAxiClB,CAk7CMpZ,SAAWhD,UAAA,CAAW,OAAX,CAAoB,UAApB,CAAgC,UAAhC,CAl7CjB,CAo7CMmG,UAAY,2DAAZA,CADYnG,UAAAqc,CAAW,SAAXA,CAAsB,QAAtBA,CAAgC,UAAhCA,CACZlW,CAAY,0JAAZA;AAAyGgJ,SAp7C/G,CAu7CM/I,aAAe,iJAAfA,CAAyEpD,QAAzEoD,CAAe,WAySrBuC,UAAA,CAAU2T,WAAV,CAAwBC,QAAQ,CAACrnB,KAAD,CAAQyO,OAAR,CAAiB,CAC/C,IAAM6D,EAAI7D,OAAJ6D,CAAYjX,MAAlB,CACMwN,OAAS4F,OAAA,CAAQ6D,CAAR,CAAU,CAAV,CADf,CAEMkB,OAAS/E,OAAA,CAAQ6D,CAAR,CAAU,CAAV,CAFf,CAII9K,MAAQiH,OAAA,CAAQ,CAAR,CAJZ,CAKIiF,KAAO,IALX,CAMInB,EAAI,CAEJ/K,MAAJ,EAA4B,MAA5B,GAAaA,KAAb,CAAmBhN,IAAnB,GACEgN,KADF,CACUiH,OAAA,CAAQ,CAAR,CADV,CAMA,KADAzO,KAAA,CAAMwI,GAAN,CAAUiG,OAAA,CAAQ,CAAR,CAAV,CACA,CAAO8D,CAAP,CAASD,CAAT,CAAY,EAAEC,CAAd,CACE9D,OAAA,CAAQ8D,CAAR,CAEA,CAFWtS,MAEX,CAFkBmI,KAElB,CAF0BlJ,YAAA,CAAIuP,OAAA,CAAQ8D,CAAR,CAAU,CAAV,CAAJ,CAE1B,CADAvS,KAAA,CAAMwI,GAAN,CAAUiG,OAAA,CAAQ8D,CAAR,CAAV,CACA,CAAwB,WAAxB,GAAI9D,OAAA,CAAQ8D,CAAR,CAAJ,CAAe/X,IAAf;CAAqCkZ,IAArC,CAA4CjF,OAAA,CAAQ8D,CAAR,CAA5C,CAGF,OAAO,KAAIkB,SAAJ,CAAczT,KAAd,CAAqBwH,KAArB,CAA4BgM,MAA5B,CAAoC3K,MAApC,CAA4C6K,IAA5C,CArBwC,CA0EjDD,UAAA,CAAU6T,SAAV,CAAsB,CACpB,UAAAtf,QAAS,CAAChI,KAAD,CAAQf,KAAR,CAAe4H,IAAf,CAAqB,CAC5B,IACMgN,MADKC,IACLD,CAAW/L,MAAX+L,GADKC,IACLD,CAAyB/L,MAAzB+L,CAAkC,EAAlCA,CADN,CAEMV,EAAIQ,QAAA,CAAS1U,KAAT,CAIV,IAAS,IAAT,EAAIkU,CAAJ,CAAe,CACbnT,KAAA,CAPS8T,IAOT,CAAW9T,KACX,KAAA+C,EAAI8Q,KAAA,CAAMV,CAAN,CAFS,CAKVpQ,CAAL,CAUW8D,IAVX,EAUmBA,IAVnB,CAUwB5H,KAVxB,EAWE2U,YAAA,CAAa5T,KAAb,CAAoB+C,CAApB,CAAsBwkB,GAAtB,CAA0BtnB,MAA1B,CAAkC4G,IAAlC,CAXF,EACEoB,CAQA,CARI,CACFC,QAASlI,KAAA,CAAMkC,QAAN,CAAejD,KAAf,CAAsB,KAAtB,CADP,CAEFmJ,MAAOlJ,YAAA,CAdA4U,IAcA,CAAON,MAAP,CAFL,CAQJ,CAJI3M,IAIJ,EAJYA,IAIZ,CAJiB5H,KAIjB,EAJwB2U,YAAA,CAAa5T,KAAb,CAAoBiI,CAApB,CAAuBpB,IAAvB,CAIxB,CAHApJ,IAGA,CAHIuC,KAAA,CAAMwI,GAAN,CAAUC,SAAA,CAAUR,CAAV,CAAV,CAGJ,CAFAlF,CAEA,CAFI/C,KAAA,CAAMwI,GAAN,CAAUlB,OAAA,CAAQ,CAACc,MAAOlJ,YAAA,CAAIzB,IAAJ,CAAR,CAAR,CAAV,CAEJ,CADAsF,CACA,CADI,CAACwkB,IAAK9pB,IAAN,CAASyB,IAAKA,YAAA,CAAI6D,CAAJ,CAAd,CACJ;AAAS,IAAT,EAAIoQ,CAAJ,GAAeU,KAAA,CAAMV,CAAN,CAAf,CAA0BpQ,CAA1B,CATF,CAcA,OAAOA,EAAP,CAAS7D,GA1BmB,CADV,CA8BpB,UAAAsoB,QAAS,EAAG,CACV,MAAOtoB,aAAA,CAAI,IAAJ,CAAS2J,MAAT,CADG,CA9BQ,CAkCpB,UAAA7B,QAAS,CAAChH,KAAD,CAAQf,KAAR,CAAe,CACtB,MAAO4U,eAAA,CAAM7T,KAAN,CAAa,IAAb,CAAmB,QAAnB,CAA6B,QAA7B,CAAuCf,KAAvC,CAA8C,CAAA,CAA9C,CADe,CAlCJ,CAsCpB,UAAA8H,QAAS,CAAC/G,KAAD,CAAQf,KAAR,CAAe,CACtB,MAAO4U,eAAA,CAAM7T,KAAN,CAAa,IAAb,CAAmB,QAAnB,CAA6B,QAA7B,CAAuCf,KAAvC,CAA8C,CAAA,CAA9C,CADe,CAtCJ,CA0CpB,UAAA0H,QAAS,CAAC3G,KAAD,CAAQf,KAAR,CAAe4H,IAAf,CAAqB,CAC5B,MAAOgN,eAAA,CAAM7T,KAAN,CAAa,IAAb,CAAmB,MAAnB,CAA2B,QAA3B,CAAqCf,KAArC,CAA4C4H,IAA5C,EAAoD,CAAA,CAApD,CADqB,CA1CV,CA8CpB,UAAAoM,QAAS,CAACjT,KAAD,CAAQf,KAAR,CAAe,CACtB,MAAO4U,eAAA,CAAM7T,KAAN,CAAa,IAAb,CAAmB,QAAnB,CAA6B,YAA7B,CAA2Cf,KAA3C,CAAkD,CAAA,CAAlD,CADe,CA9CJ,CAkDpB,UAAAwoB,QAAS,CAACznB,KAAD;AAAQf,KAAR,CAAe,CACtB,MAAO4U,eAAA,CAAM7T,KAAN,CAAa,IAAb,CAAmB,QAAnB,CAA6B,YAA7B,CAA2Cf,KAA3C,CAAkD,CAAA,CAAlD,CAAwD,CAAA,CAAxD,CADe,CAlDJ,CAusBtB,KAAMge,QAAUA,QAAA,CAACtM,MAAD,CAASlT,CAAT,CAAYC,CAAZ,CAAkB,CAAAgF,QAAA,CAASiO,MAAT,CAAA,EAC9B,MA6BqC,CA7BrC,MA6BqC,CA7BrC,MA6BqC,CAAA,CAAA,CAAAuN,MAAA,CACpC2C,MADoC,CACvC,0BADuC,CACRA,MADQ,CACvC,qBADuC,CA7BrCpjB,CA6BqC,CA7BrCC,CA6BqC,CA9BP,EAE9B,CAF8B,CAxjDrB,MA0jDT,GAAA,MAAA,EA3jDQ,KA2jDR,GAAA,MAAA,CAAA,CAAA,CAAA,CAF8B,OAAA,EAAA,CAAlC,CAKM6e,IAAMA,QAAA,CAAC5L,MAAD,CAASlT,CAAT,CAAYC,CAAZ,CAAkB,CAAAgF,QAAA,CAASiO,MAAT,CAAA,EAC1B,MAgB8B,CAhB9B,MAgB8B,CAhB9B,MAgB8B,CAAA,CAAA,CAAA+W,KAAA,CAC7B7G,MAD6B,CAChC,yBADgC,CACFA,MADE,CAChC,wBADgC,CAhB9BpjB,CAgB8B,CAhB9BC,CAgB8B,CAjBJ,EAE1B,CAF0B,CA3jDfghB,QA6jDX,GAAA/N,MAAA,EAhkDQgO,KAgkDR,GAAAhO,MAAA,CAAA,CAAA,CAAA,CAF0B,OAAA,EAAA,CAL9B,CAUM8L,IAAMA,QAAA,CAAC9L,MAAD,CAASlT,CAAT,CAAYC,CAAZ,CAAkB,CAAAgF,QAAA,CAASiO,MAAT,CAAA;CAC1B,MAe8B,CAf9B,MAe8B,CAf9B,MAe8B,CAAA,CAAA,CAAA+W,KAAA,CAC7B7G,MAD6B,CAChC,4BADgC,CACFA,MADE,CAChC,qBADgC,CAf9BpjB,CAe8B,CAf9BC,CAe8B,CAhBJ,EAE1B,CAF0B,CAhkDfghB,QAkkDX,GAAA/N,MAAA,EArkDQgO,KAqkDR,GAAAhO,MAAA,CAAA,CAAA,CAAA,CAF0B,OAAA,EAAA,CAV9B,CAcMyN,MAAQA,QAAA,CAACzN,MAAD,CAASlT,CAAT,CAAYC,CAAZ,CAAkB,CAAA,MAAAgF,SAAA,CAASiO,MAAT,CAAA,CAoBKuN,MAAA,CAnBvBvN,MAmBuB,CAnBhB3T,MAmBgB,CACnC,qBADmC,CAnBRS,CAmBQ,CAnBLC,CAmBK,CApBL,CAvkDpBihB,KAykDR,GAAAhO,MAAA,CAAiB,CAACzV,MAAOuC,CAAR,CAAjB,CAA8B,CAACvC,MAAOwC,CAAR,CAFF,CAdhC,CA0CMgqB,MAAQA,QAAA,CAAC5nB,IAAD,CAAOrC,CAAP,CAAUC,CAAV,CAAgB,CAE5BD,CAAA,CAAS,IAAL,EAAAA,CAAA,CAAYuO,OAAA,CAAQvO,CAAR,CAAZ,CAAyBA,CAC7BC,EAAA,CAAS,IAAL,EAAAA,CAAA,CAAYsO,OAAA,CAAQtO,CAAR,CAAZ,CAAyBA,CAE7B,IAYO,IAZP,EAAaD,CAAb,EAY2C,CAZ3C,GAYekD,MAAA,CAAOC,IAAP,CAZFnD,CAYE,CAZf,CAYgCpC,MAZhC,EAYO,IAZP,EAA4BqC,CAA5B,EAY2C,CAZ3C,GAYeiD,MAAA,CAAOC,IAAP,CAZalD,CAYb,CAZf,CAYgCrC,MAZhC,CAOE,MAAO,CAACrB,QAAA,CAAS8B,MAAT,CAAgB,CAACgE,KAAAA,IAAD,CAAhB,CAAwBrC,CAAxB,CAAD,CAAA,CAA6B2G,MAA7B,CAAoC1G,CAApC,EAAyC,EAAzC,CALPD,EAAA,CAAIA,CAAA,CAAKA,CAAL,CAAOT,MAAP,EAAiBhD,QAAA,CAAS4E,WAAT,CAAqBnB,CAArB,CAAuBvC,KAAvB,CAAjB;AAAkD,IACtDwC,EAAA,CAAIA,CAAA,CAAKA,CAAL,CAAOV,MAAP,EAAiBhD,QAAA,CAAS4E,WAAT,CAAqBlB,CAArB,CAAuBxC,KAAvB,CAAjB,CAAkD,IACtD,OAAO,CAAC8B,OAAW8C,IAAX9C,CAAQ,MAARA,CAAsBS,CAAtBT,CAAQ,OAARA,CAA+BU,CAA/BV,CAAQ,GAAT,CATmB,CA1C9B,CA8DMkhB,OAASA,QAAA,CAACpe,IAAD,CAAOrC,CAAP,CAAUC,CAAV,CAAiB,CAAA,MAAA,CAC9BV,OAAW8C,IAAX9C,CAAQ,MAARA,CAAsB8jB,MAAA,CAAOrjB,CAAP,CAAtBT,CAAQ,OAARA,CAAuC8jB,MAAA,CAAOpjB,CAAP,CAAvCV,CAAQ,GADsB,CAAA,CA9DhC,CA0EM8jB,OAASA,QAAA,CAAA/d,CAAA,CAAK,CAAA,MAAAL,SAAA,CAASK,CAAT,CAAA,CAChBA,CADgB,CACd/F,MADc,CAEX,IAAL,EAAA+F,CAAA,CAAY,IAAZ,CAAmB/I,QAAA,CAAS4E,WAAT,CAAqBmE,CAArB,CAFH,CA1EpB,CAkFMub,MAAQA,QAAA,CAACpjB,KAAD,CAAQysB,IAAR,CAAiB,CAC7B,IAAMnqB,EAAItC,KAAJsC,CAAUR,MAChB,OAAOQ,EAAA,EAAKA,CAAA,CAAEoqB,QAAF,CAAW,QAAX,CAAL,CACH,CAAC5qB,OAAQQ,CAAA,CAAEse,KAAF,CAAQ,CAAR,CAAW,EAAX,CAAR9e,CAAyB2qB,IAAzB3qB,CAA8BA,MAA/B,CADG,CAEH9B,KAJyB,CAgxB/BmnB,QAAA,CAAQiF,SAAR,CAAoBrE,QAApB,CAA6BqE,SAA7B,CAAyC,CACvC,MAAA/mB,QAAK,CAACjG,IAAD,CAAO,CACV,MAAO4kB,WAAA,CAAW5kB,IAAX,CAAiB,IAAjB,CADG,CAD2B,CAKvC,KAAA+Z,QAAI,EAAG,CACL,MAAO,KAAI4O,QAAJ,CAAa,IAAb,CADF,CALgC;AASvC,WAAAje,QAAU,EAAG,CACX,MAAqB,EAArB,CAAO,IAAP,CAAY0d,MADD,CAT0B,CAavC,UAAAjO,QAAS,EAAG,CACV,IAAA,CAAKoT,MAAL,EACA,OAAO,CACL/V,YAAa,IAAbA,CAAkBA,WADb,CAELkF,UAAa,IAAbA,CAAkBA,SAFb,CAGLwL,QAAa,IAAbA,CAAkBA,OAHb,CAILC,QAAa,IAAbA,CAAkBA,OAJb,CAKLH,SAAa,IAAbA,CAAkBA,QALb,CAMLN,YAAa,IAAbA,CAAkBA,WANb,CAOLC,OAAa,IAAbA,CAAkBA,MAPb,CAFG,CAb2B,CA0BvC,GAAAlgB,QAAE,EAAG,CACH,OAAQ,IAAA,CAAK2gB,MAAL,CAAc,IAAd,CAAmBA,MAAnB,CAA4B,GAA5B,CAAkC,CAA1C,EAA+C,IAAA,CAAKC,GAAL,EAD5C,CA1BkC,CA8BvC,IAAAna,QAAG,CAAC/G,EAAD,CAAK,CACN,IAAA,CAAKuV,SAAL,CAAe3V,IAAf,CAAoBI,EAApB,CACAA,GAAA,CAAGM,EAAH,CAAQ,IAAA,CAAKA,EAAL,EAEJN,GAAJ,CAAOQ,IAAP,GACER,EAAA,CAAGQ,IAAH,CAAQlF,OAAR,CAAgB,QAAA,CAAAmC,GAAA,CAAO,CAAEA,GAAA,CAAI8C,IAAJ,CAAWP,EAAX,CAAcM,EAAhB,CAAvB,CACA,CAAAN,EAAA,CAAGQ,IAAH,CAAU,IAFZ,CAIA,OAAOR,GARD,CA9B+B,CAyCvC,MAAA0Q,QAAK,CAAC1Q,EAAD,CAAK,CACFqmB,EAAAA,CAAOrmB,EAAA,WAAcK,MAAd,CAAsB5C,YAAA,CAAIuC,EAAJ,CAAtB;AAAgCA,EAC7C,OAAO,KAAA,CAAK+G,GAAL,CAASse,KAAA,CAAM,CAAC5rB,MAAO4sB,EAAR,CAAN,CAAT,CAFC,CAzC6B,CA8CvC,UAAAjkB,QAAS,CAACZ,MAAD,CAAS,CAChB,IAAA,CAAKuf,OAAL,CAAanhB,IAAb,CAAkB4B,MAAlB,CACAA,OAAA,CAAOlB,EAAP,CAAY,IAAA,CAAKA,EAAL,EACZ,OAAOkB,OAHS,CA9CqB,CAoDvC,UAAAsC,QAAS,CAACjK,MAAD,CAAS,CAChB,IAAA,CAAKmnB,OAAL,CAAaphB,IAAb,CAAkB/F,MAAlB,CACA,OAAOA,OAFS,CApDqB,CA0DvC,OAAAusB,QAAM,EAAG,CAiBPE,QAASA,SAAQ,CAACtmB,EAAD,CAAKxG,IAAL,CAAWT,IAAX,CAAiB,CAE5BiH,EAAJ,GACE+E,EAEA,CAFO/E,EAEP,CAFU+E,IAEV,GAFmB/E,EAEnB,CAFsB+E,IAEtB,CAF6B,EAE7B,EADA7C,IACA,CADO6C,EAAA,CAAKvL,IAAL,CACP,GADsBuL,EAAA,CAAKvL,IAAL,CACtB,CADmC,EACnC,EAAA0I,IAAA,CAAKtC,IAAL,CAAU7G,IAAV,CAHF,CAFgC,CAjB3B,IACHS,aAGA,KAAJ,CAAS6mB,IAAT,GAAe,IAAf,CAAoBA,IAApB,CAAyBA,IAAzB,CAAgC,CAAA,CAAhC,CAGA,KAAK7mB,aAAL,GAAa,KAAb,CAAkBqG,OAAlB,CACE,IAAA,CAAKA,OAAL,CAAarG,aAAb,CAAA,CAAmB+B,MAAnB,CAA4B/B,aAI9B,KAAKA,aAAL,GAAa,KAAb,CAAkBgd,MAAlB,CACE,IAAA,CAAKA,MAAL,CAAYhd,aAAZ,CAAA,CAAkB4C,KAAlB;AAA0B5C,aAY5B,KAAKA,aAAL,GAAa,KAAb,CAAkBuL,IAAlB,CAAwB,CACtB,IAAAsN,GAAK,IAAA,CAAKtN,IAAL,CAAUvL,aAAV,CACL8sB,SAAA,CAASjU,EAAT,CAAYtM,KAAZ,CAAoBvM,aAApB,CAA0B,OAA1B,CACA8sB,SAAA,CAASjU,EAAT,CAAYN,MAAZ,CAAoBvY,aAApB,CAA0B,QAA1B,CACA8sB,SAAA,CAASjU,EAAT,CAAYjL,MAAZ,CAAoB5N,aAApB,CAA0B,QAA1B,CACA,KAAKgE,IAAMA,SAAX,GAAoB6U,GAApB,CAAuB5D,KAAvB,CACE6X,QAAA,CAASjU,EAAA,CAAG5D,KAAH,CAASjR,SAAT,CAAT,CAA0BhE,aAA1B,CAAgC,QAAhC,CAA2CgE,SAA3C,CANoB,CAUxB,MAAO,KAnCA,CA1D8B,CAkGvC,UAAAgY,QAAS,CAACvb,MAAD,CAAS2D,MAAT,CAAiBuK,MAAjB,CAAyB,CAChC,IAAA,CAAKkZ,OAAL,CAAazhB,IAAb,CAAkBnC,YAAA,CAAI,IAAA,CAAKsJ,GAAL,CAASd,KAAA,CAAM,CAACU,MAAO1M,MAAR,CAAN,CAAT,CAAJ,CAAlB,CACA,KAAA,CAAKmnB,OAAL,CAAaxhB,IAAb,CAAkBhC,MAAlB,CACA,KAAA,CAAK0jB,OAAL,CAAa1hB,IAAb,CAAkBuI,MAAA,CAAS1K,YAAA,CAAI,IAAA,CAAKiT,KAAL,CAAWvI,MAAX,CAAJ,CAAT;AAAmC,IAArD,CACA,KAAA,CAAKoZ,SAAL,CAAe3hB,IAAf,CAAoB,EAApB,CAJgC,CAlGK,CAyGvC,SAAA6V,QAAQ,EAAG,CACT,IAAA,CAAK4L,OAAL,CAAahkB,GAAb,EACA,KAAA,CAAK+jB,OAAL,CAAa/jB,GAAb,EACA,KAAA,CAAKikB,OAAL,CAAajkB,GAAb,EACA,KAAA,CAAKkkB,SAAL,CAAelkB,GAAf,EAJS,CAzG4B,CAgHvC,OAAAO,QAAM,EAAG,CACP,MAAOrF,SAAA,CAAS6E,IAAT,CAAc,IAAd,CAAmBgkB,OAAnB,CADA,CAhH8B,CAoHvC,OAAAnnB,QAAM,EAAG,CACP,MAAO1B,SAAA,CAAS6E,IAAT,CAAc,IAAd,CAAmBikB,OAAnB,CADA,CApH8B,CAwHvC,OAAAlZ,QAAM,EAAG,CACP,MAAO5P,SAAA,CAAS6E,IAAT,CAAc,IAAd,CAAmBkkB,OAAnB,CADA,CAxH8B,CA4HvC,SAAAlN,QAAQ,EAAG,CACT,IAAM5N,EAAI,IAAJA,CAAS+a,SACf,OAAO,EAAE/a,CAAA,CAAEA,CAAF,CAAI5M,MAAJ,CAAW,CAAX,CAFA,CA5H4B,CAmIvC,SAAA6G,QAAQ,CAACjD,KAAD,CAAQhE,IAAR,CAAc,CACpB,GAAIjB,QAAA,CAAS0F,QAAT,CAAkBT,KAAlB,CAAJ,CAA8B,MAAOiD,SAAA,CAASjD,KAAT,CAAgBhE,IAAhB,CAChCgE,MAAL,CAAWjC,MAAX,EACEhD,QAAA,CAASyF,KAAT,CAAe,+BAAf;AAAiDzF,QAAA,CAAS4E,WAAT,CAAqBK,KAArB,CAAjD,CAGIzB,MAAAA,CAAIyB,KAAJzB,CAAUR,MAChB,KAAI+K,EAAI,IAAA,CAAK9I,KAAL,CAAWzB,KAAX,CAEHuK,EAAL,GACQ9H,CAEN,CAFe,CAAChF,KAAM,IAAA,CAAKmK,SAAL,CAAe5H,KAAf,CAAP,CAEf,CADIvC,IACJ,GADUgF,CACV,CADiBsI,EACjB,CADsBtN,IACtB,EAAA,IAAA,CAAKgE,KAAL,CAAWzB,KAAX,CAAA,CAAgBuK,CAAhB,CAAoB7I,YAAA,CAAI,IAAA,CAAKsJ,GAAL,CAASme,KAAA,CAAM1mB,CAAN,CAAT,CAAJ,CAHtB,CAKA,OAAO8H,EAda,CAnIiB,CAoJvC,WAAAgL,QAAU,CAACiV,GAAD,CAAM,CAAA,IAAA,aAAA,IAAA,CACVhrB,OAAS,CAAA,CADC,CAGRirB,MAAQA,QAAA,CAAAvtB,CAAA,CAAK,CAAA,MAAAgI,SAAA,CAAShI,CAAT,CAAA,EACdsC,MAAA,CAAS,CAAA,CAAT,CAAe,YAAA,CAAKoI,SAAL,CAAe1K,CAAf,CAAiBsC,MAAjB,CADD,EAERtC,CAAP,EAAOA,CAAP,CAzkGQoG,IAykGR,EAAa9D,MAAA,CAAS,CAAA,CAAT,CAAe,YAAA,CAAKgW,OAAL,CAAatY,CAAb,CAAeoG,IAAf,CAA5B,EACApG,CAHe,CAHL,CAQR2F,OAASrG,QAAA,CAAS8C,KAAT,CAAekrB,GAAf,CAAmB/oB,KAAnB,CAAA,CAA0BN,GAA1B,CAA8BspB,KAA9B,CACTC,IAAAA,CAASluB,QAAA,CAAS8C,KAAT,CAAekrB,GAAf,CAAmB5Z,KAAnB,CAAA,CAA0BzP,GAA1B,CAA8BspB,KAA9B,CAEf,OAAOjrB,OAAA,CACHkC,YAAA,CAAI,IAAA,CAAKsJ,GAAL,CAASie,OAAA,CAAQ,CAACpmB,OAAQA,MAAT;AAAiB6nB,OAAQA,GAAzB,CAAR,CAAT,CAAJ,CADG,CArnGF,CAACC,SAunGS9nB,MAvnGV,CAAmB+nB,OAunGDF,GAvnGlB,CA0mGS,CApJuB,CAoKvC,OAAA7lB,QAAM,CAAChC,MAAD,CAASiC,IAAT,CAAe,CACnB,IAAItF,OAAS,CAAA,CAAb,CAMMqrB,IAAM,IAANA,CAAW/mB,OACjBjB,OAAA,CAASrG,QAAA,CAAS8C,KAAT,CAAeuD,MAAf,CAAA,CAAuB1B,GAAvB,CALKspB,QAAA,CAAAvtB,CAAA,CAAK,CAAA,MAAAgI,SAAA,CAAShI,CAAT,CAAA,EACdsC,MAAA,CAAS,CAAA,CAAT,CAAekC,YAAA,CAAImpB,GAAA,CAAI3tB,CAAJ,CAAMsC,MAAN,CAAJ,CADD,EAEftC,CAFe,CAKV,CAET,OAAOsC,OAAA,CACHkC,YAAA,CAAI,IAAA,CAAKsJ,GAAL,CAASoe,GAAA,CAAI,CAACvmB,OAAQA,MAAT,CAAiBiC,KAAMA,IAAvB,CAAJ,CAAT,CAAJ,CADG,CAEHD,MAAA,CAAOhC,MAAP,CAAeiC,IAAf,CAZe,CApKkB,CAmLvC,QAAAqG,QAAO,CAAC9B,IAAD,CAAO,CACZ,GAAI,CAACA,IAAL,CAAW,MAAOA,KAGlB,KAAMpJ,EAAIgF,SAAA,CAAUoE,IAAV,CAAepF,EAAf,CAAmBoF,IAAnB,CAAwB5H,KAAxB,CACLqpB,KAAAA,CAAIzhB,IAAJyhB,CAASla,KAATka,EAnoGUC,WAqoGf,OAAOD,KAAA,CAAEtrB,MAAF,CACHkC,YAAA,CAAI,IAAA,CAAKsJ,GAAL,CAASie,OAAA,CAAQ,CACnBpmB,OAAQ5C,CADW,CAEnByqB,OAAQ,IAAA,CAAK9iB,SAAL,CAAekjB,IAAf,CAAiBtrB,MAAjB,CAFW,CAAR,CAAT,CAAJ,CADG;AAhpGF,CAACmrB,SAqpGS1qB,CArpGV,CAAmB2qB,OAqpGNE,IArpGb,CAyoGO,CAnLyB,CAoMvC,MAAAvkB,QAAK,CAACP,MAAD,CAAShJ,IAAT,CAAe,CAClB,IAAMwB,IAAMwH,MAANxH,CAAe,GAAfA,CAAqBxB,IAC3B,IAAI,CAAC,IAAA,CAAKqK,MAAL,CAAY7I,GAAZ,CAAL,CAAuB,CACrB,IAAM+F,GAAK,IAAA,CAAKA,EAAL,EACX,KAAA,CAAKygB,OAAL,CAAanhB,IAAb,CAAkB,CAChBU,GAAIA,EADY,CAEhByB,OAAQA,MAFQ,CAGhBhJ,KAAMA,IAHU,CAAlB,CAKA,KAAA,CAAKqK,MAAL,CAAY7I,GAAZ,CAAA,CAAmB+F,EAPE,CASvB,MAAO,KAAA,CAAK8C,MAAL,CAAY7I,GAAZ,CAXW,CApMmB,CAoNvC,aAAAwsB,QAAY,CAACvtB,IAAD,CAAO,CACjB,MAAOjB,SAAA,CAAS6B,cAAT,CAAwB,IAAxB,CAA6ByF,OAA7B,CAAsCrG,IAAtC,CADU,CApNoB,CAwNvC,UAAAyG,QAAS,CAACzG,IAAD,CAAOC,KAAP,CAAc,CACjB,IAAA,CAAKstB,YAAL,CAAkBvtB,IAAlB,CAAJ,EACEjB,QAAA,CAASyF,KAAT,CAAe,yBAAf,CAA2CzF,QAAA,CAAS4E,WAAT,CAAqB3D,IAArB,CAA3C,CAEIwG,MAAAA,CAAKvG,KAAA,WAAiB4G,MAAjB,CAAyB5G,KAAzB,CAAiC,IAAA,CAAKsN,GAAL,CAzsGvC,IAAI1G,KAAJ,CAIQtH,UAJR,CAysGyDU,KAzsGzD,CAysGgD+E,IAAA,EAzsGhD,CAIAZ,IAAA,EAJA,CAysGuC,CAC5C;MAAO,KAAA,CAAKiC,OAAL,CAAarG,IAAb,CAAP,CAA4BwG,KALP,CAxNgB,CAgOvC,UAAAiE,QAAS,CAACzK,IAAD,CAAO,CACT,IAAA,CAAKqG,OAAL,CAAarG,IAAb,CAAL,EACEjB,QAAA,CAASyF,KAAT,CAAe,4BAAf,CAA8CzF,QAAA,CAAS4E,WAAT,CAAqB3D,IAArB,CAA9C,CAEF,OAAO,KAAA,CAAKqG,OAAL,CAAarG,IAAb,CAJO,CAhOuB,CAuOvC,UAAAmK,QAAS,CAAC5H,CAAD,CAAI,CACX,GAAI,IAAA,CAAK8D,OAAL,CAAa9D,CAAb,CAAJ,CACE,MAAO0B,aAAA,CAAI,IAAA,CAAKoC,OAAL,CAAa9D,CAAb,CAAJ,CACGxD,SAAA,CAAS6B,cAAT,CAAwB,IAAxB,CAA6B0mB,OAA7B,CAAsC/kB,CAAtC,CAAL,GACL,IAAA,CAAK+kB,OAAL,CAAa/kB,CAAb,CADK,CACa,IAAA,CAAKgL,GAAL,CAxtGf,IAAI1G,KAAJ,CAIQtH,UAJR,CAwtGiCU,IAxtGjC,CAwtGwB+E,IAAA,EAxtGxB,CAIAZ,IAAA,EAJA,CAwtGe,CADb,CAGP,OAAOH,aAAA,CAAI,IAAA,CAAKqjB,OAAL,CAAa/kB,CAAb,CAAJ,CANI,CAvO0B,CAgPvC,aAAAokB,QAAY,EAAG,CAEb,IADA,IAAM/hB,KAAOc,MAAA,CAAOC,IAAP,CAAY,IAAZ,CAAiB2hB,OAAjB,CAAb,CACShQ,EAAE,CADX,CACcD,EAAEzS,IAAFyS,CAAOjX,MAArB,CAA6BkX,CAA7B,CAA+BD,CAA/B,CAAkC,EAAEC,CAApC,CAAuC,CACrC,IAAM/U,EAAIqC,IAAA,CAAK0S,CAAL,CAAV;AACMxH,EAAI9Q,aAAA,CAAc8G,eAAd,CAA8BvD,CAA9B,CAAiC,IAAjC,CACJiE,EAAAA,CAAK,IAAA,CAAK8gB,OAAL,CAAa/kB,CAAb,CACXiE,EAAA,CAAGxB,MAAH,CAAY8K,CAAZ,CAAc/J,OACdS,EAAA,CAAGnG,MAAH,CAAYyP,CAAZ,CAAcvK,KALuB,CAF1B,CAhPwB,CA2PvC,SAAAtC,QAAQ,CAAC5D,IAAD,CAAO,CACb,MAAOA,KAAA,EAAQA,IAAR,CAAa0C,MAAb,CAAsB,IAAA,CAAKoI,SAAL,CAAe9K,IAAf,CAAoB0C,MAApB,CAAtB,CAAoD1C,IAD9C,CA3PwB,CA+PvC,eAAAoc,QAAc,CAACpc,IAAD,CAAO,CACnB,MAASA,KAAF,EAAWN,QAAA,CAASO,QAAT,CAAkBD,IAAlB,CAAX,CACH,IAAA,CAAK8K,SAAL,CAAe9K,IAAf,CAAoB0C,MAApB,EAA8BmmB,cAAA,CAAe7oB,IAAf,CAA9B,CADG,CAAsCA,IAD1B,CA/PkB,CAoQvC,QAAA0Y,QAAO,CAACnT,IAAD,CAAO5E,IAAP,CAAa,CACZgF,IAAAA,CAAS,CAACa,KAAM7G,aAAA,CAAc8G,eAAd,CAA8BlB,IAA9B,CAAoC,IAApC,CAAP,CACX5E,KAAJ,GAAUgF,IAAV,CAAiBa,IAAjB,CAAsBsB,KAAtB,CAA8BnH,IAA9B,CACA,OAAOiE,aAAA,CAAI,IAAA,CAAKsJ,GAAL,CAASke,UAAA,CAAWzmB,IAAX,CAAT,CAAJ,CAHW,CApQmB,CA0QvC,WAAA4B,QAAU,CAAC5G,IAAD,CAAO2G,IAAP,CAAa,CAChB,IAAL,CAAU0gB,QAAV;AACEtoB,QAAA,CAASyF,KAAT,CAAe,yCAAf,CAA2DzF,QAAA,CAAS4E,WAAT,CAAqB3D,IAArB,CAA3D,CAEF,KAAA,CAAKqnB,QAAL,CAAcjhB,IAAd,CAAmBrH,QAAA,CAAS8B,MAAT,CAAgB,CAACkB,OAAQ/B,IAAT,CAAhB,CAAgC2G,IAAhC,CAAnB,CAJqB,CA1QgB,CAmRvC,aAAA6mB,QAAY,CAACxtB,IAAD,CAAOgb,SAAP,CAAkB,CACxBjc,QAAA,CAAS6B,cAAT,CAAwB,IAAxB,CAA6Boc,MAA7B,CAAqChd,IAArC,CAAJ,EACEjB,QAAA,CAASyF,KAAT,CAAe,sCAAf,CAAwDzF,QAAA,CAAS4E,WAAT,CAAqB3D,IAArB,CAAxD,CAEF,KAAA,CAAKgd,MAAL,CAAYhd,IAAZ,CAAA,CAAoB,IAAA,CAAKuN,GAAL,CAASyN,SAAT,CAJQ,CAnRS,CA0RvC,SAAAuJ,QAAQ,CAACvkB,IAAD,CAAOgF,MAAP,CAAe,CACrB,IAAA,CAAKwoB,YAAL,CAAkBxtB,IAAlB,CAAwB8rB,KAAA,CAAM9mB,MAAN,CAAxB,CADqB,CA1RgB,CA8RvC,cAAAqf,QAAa,CAACrkB,IAAD,CAAOgF,MAAP,CAAe,CAC1B,IAAA,CAAKwoB,YAAL,CAAkBxtB,IAAlB,CAAwB4rB,UAAA,CAAW5mB,MAAX,CAAxB,CAD0B,CA9RW,CAkSvC,SAAAwf,QAAQ,CAACxkB,IAAD,CAAO,CACR,IAAA,CAAKgd,MAAL,CAAYhd,IAAZ,CAAL;AACEjB,QAAA,CAASyF,KAAT,CAAe,2BAAf,CAA6CzF,QAAA,CAAS4E,WAAT,CAAqB3D,IAArB,CAA7C,CAEF,OAAO,KAAA,CAAKgd,MAAL,CAAYhd,IAAZ,CAJM,CAlSwB,CAySvC,SAAA6C,QAAQ,CAAC7C,IAAD,CAAO,CACb,MAAOiE,aAAA,CAAI,IAAA,CAAKugB,QAAL,CAAcxkB,IAAd,CAAJ,CADM,CAzSwB,CA6SvC,UAAAkd,QAAS,CAACld,IAAD,CAAO,CACd,MAAO,KAAA,CAAKwkB,QAAL,CAAcxkB,IAAd,CAAP,CAA2BgF,MAA3B,CAAkCzF,IADpB,CA7SuB,CAiTvC,cAAAqY,QAAa,CAAC5X,IAAD,CAAO,CAClB,MAAO,KAAA,CAAK6C,QAAL,CAAc7C,IAAd,CADW,CAjTmB,CAqTvC,eAAAytB,QAAc,CAACztB,IAAD,CAAO,CACnB,MAAO,KAAA,CAAKkd,SAAL,CAAeld,IAAf,CADY,CArTkB,CA2TvC,QAAAqZ,QAAO,CAACrZ,IAAD,CAAO0tB,SAAP,CAAkB,CACnB3uB,QAAA,CAAS6B,cAAT,CAAwB,IAAxB,CAA6B2K,IAA7B,CAAmCvL,IAAnC,CAAJ,EACEjB,QAAA,CAASyF,KAAT,CAAe,2BAAf,CAA6CzF,QAAA,CAAS4E,WAAT,CAAqB3D,IAArB,CAA7C,CAEF,OAAQ,KAAA,CAAKuL,IAAL,CAAUvL,IAAV,CAAR;AAA0B0tB,SAJH,CA3Tc,CAkUvC,QAAAliB,QAAO,CAACxL,IAAD,CAAO,CACP,IAAA,CAAKuL,IAAL,CAAUvL,IAAV,CAAL,EACEjB,QAAA,CAASyF,KAAT,CAAe,2BAAf,CAA6CzF,QAAA,CAAS4E,WAAT,CAAqB3D,IAArB,CAA7C,CAEF,OAAO,KAAA,CAAKuL,IAAL,CAAUvL,IAAV,CAJK,CAlUyB,CAyUvC,gBAAAwM,QAAe,CAACxM,IAAD,CAAOwT,OAAP,CAAgB,CACzBzU,QAAA,CAAS6B,cAAT,CAAwB,IAAxB,CAA6B2K,IAA7B,CAAmCvL,IAAnC,CAAJ,EACEjB,QAAA,CAASyF,KAAT,CAAe,2BAAf,CAA6CzF,QAAA,CAAS4E,WAAT,CAAqB3D,IAArB,CAA7C,CAEF,OAAO,KAAA,CAAKqZ,OAAL,CAAarZ,IAAb,CAAmBwY,SAAA,CAAU2T,WAAV,CAAsB,IAAtB,CAA4B3Y,OAA5B,CAAnB,CAJsB,CAzUQ,CA8mBzChV,QAAA,CAAQmjB,cAAR,CA74HuBA,aA84HvBnjB,QAAA,CAAQ6jB,YAAR,CA74HqBA,WA84HrB7jB,QAAA,CAAQ8kB,aAAR,CA74HsBA,YA84HtB9kB,QAAA,CAAQkoB,QAAR,CAj5HiBA,MAk5HjBloB,QAAA,CAAQgkB,YAAR;AA94HqBA,WA+4HrBhkB,QAAA,CAAQolB,aAAR,CA94HsBA,YA+4HtBplB,QAAA,CAAQga,SAAR,CAAoBA,SACpBha,QAAA,CAAQiD,SAAR,CAx5HkBA,OAy5HlBjD,QAAA,CAAQwf,eAAR,CA74HwBA,cA84HxBxf,QAAA,CAAQ6U,eAAR,CA54HwBA,cA64HxB7U,QAAA,CAAQ0f,UAAR,CAj5HmBA,QAk5HnB1f,QAAA,CAAQkW,gBAAR,CA74HyBA,eA84HzBlW,QAAA,CAAQ4X,eAAR,CA74HwBA,cA84HxB5X,QAAA,CAAQmD,QAAR,CA/5HiBA,MAg6HjBnD,QAAA,CAAQgK,KAAR,CAAgB4e,OAChB5oB,QAAA,CAAQ4W,SAAR,CA/5HkBA,OAg6HlB5W,QAAA,CAAQ2C,MAAR,CAAiBC,QACjB5C,QAAA,CAAQ8G,KAAR,CA1BAqoB,QAAgB,CAACtuB,IAAD,CAAO8B,MAAP,CAAekJ,OAAf,CAAwB,CACjCtL,QAAA,CAASO,QAAT,CAAkBD,IAAlB,CAAL,EACEN,QAAA,CAASyF,KAAT,CAAe,6CAAf,CAGFrD;MAAA,CAASpC,QAAA,CAAS6uB,WAAT,CAAqBxsB,QAAA,EAArB,CAAiCD,MAAjC,CAAyC9B,IAAzC,CAA8C8B,MAA9C,CACT,OAAOylB,UAAA,CAAUvnB,IAAV,CAAgB,IAAI+nB,OAAJ,CAAYjmB,MAAZ,CAAoBkJ,OAApB,CAAhB,CAAA,CAA8CmP,SAA9C,EAN+B,CA2BxChb,QAAA,CAAQuD,MAAR,CAAiBmE,WACjB1H,QAAA,CAAQqvB,aAAR,CAAwBrjB,kBACxBhM,QAAA,CAAQwJ,MAAR,CAAiBD,WAEjBrC,OAAA,CAAOooB,cAAP,CAAsBtvB,OAAtB,CAA+B,YAA/B,CAA6C,CAAEyB,MAAO,CAAA,CAAT,CAA7C,CA5+H+F,CAJhG,CAD6G;\",\n\"sources\":[\"node_modules/vega-parser/build/vega-parser.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_parser$build$vega_parser\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-functions'), require('vega-event-selector'), require('vega-scale'), require('vega-dataflow')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-functions', 'vega-event-selector', 'vega-scale', 'vega-dataflow'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega, global.vega, global.vega, global.vega));\\n}(this, (function (exports, vegaUtil, vegaFunctions, vegaEventSelector, vegaScale, vegaDataflow) { 'use strict';\\n\\n  function parseAutosize(spec) {\\n    return vegaUtil.isObject(spec) ? spec : {type: spec || 'pad'};\\n  }\\n\\n  const number = _ => +_ || 0;\\n\\n  const paddingObject = _ => ({top: _, bottom: _, left: _, right: _});\\n\\n  function parsePadding(spec) {\\n    return !vegaUtil.isObject(spec) ? paddingObject(number(spec))\\n      : spec.signal ? spec\\n      : {\\n          top:    number(spec.top),\\n          bottom: number(spec.bottom),\\n          left:   number(spec.left),\\n          right:  number(spec.right)\\n        };\\n  }\\n\\n  const encoder = _ => vegaUtil.isObject(_) && !vegaUtil.isArray(_)\\n    ? vegaUtil.extend({}, _)\\n    : {value: _};\\n\\n  function addEncode(object, name, value, set) {\\n    if (value != null) {\\n      const isEncoder = (\\n        (vegaUtil.isObject(value) && !vegaUtil.isArray(value)) ||\\n        (vegaUtil.isArray(value) && value.length && vegaUtil.isObject(value[0]))\\n      );\\n\\n      // Always assign signal to update, even if the signal is from the enter block\\n      if (isEncoder) {\\n        object.update[name] = value;\\n      } else {\\n        object[set || 'enter'][name] = {value: value};\\n      }\\n      return 1;\\n    } else {\\n      return 0;\\n    }\\n  }\\n\\n  function addEncoders(object, enter, update) {\\n    for (const name in enter) {\\n      addEncode(object, name, enter[name]);\\n    }\\n    for (const name in update) {\\n      addEncode(object, name, update[name], 'update');\\n    }\\n  }\\n\\n  function extendEncode(encode, extra, skip) {\\n    for (const name in extra) {\\n      if (skip && vegaUtil.hasOwnProperty(skip, name)) continue;\\n      encode[name] = vegaUtil.extend(encode[name] || {}, extra[name]);\\n    }\\n    return encode;\\n  }\\n\\n  function has(key, encode) {\\n    return encode && (\\n      (encode.enter && encode.enter[key]) ||\\n      (encode.update && encode.update[key])\\n    );\\n  }\\n\\n  const MarkRole = 'mark';\\n  const FrameRole = 'frame';\\n  const ScopeRole = 'scope';\\n\\n  const AxisRole = 'axis';\\n  const AxisDomainRole = 'axis-domain';\\n  const AxisGridRole = 'axis-grid';\\n  const AxisLabelRole = 'axis-label';\\n  const AxisTickRole = 'axis-tick';\\n  const AxisTitleRole = 'axis-title';\\n\\n  const LegendRole = 'legend';\\n  const LegendBandRole = 'legend-band';\\n  const LegendEntryRole = 'legend-entry';\\n  const LegendGradientRole = 'legend-gradient';\\n  const LegendLabelRole = 'legend-label';\\n  const LegendSymbolRole = 'legend-symbol';\\n  const LegendTitleRole = 'legend-title';\\n\\n  const TitleRole = 'title';\\n  const TitleTextRole = 'title-text';\\n  const TitleSubtitleRole = 'title-subtitle';\\n\\n  function applyDefaults(encode, type, role, style, config) {\\n    const defaults = {}, enter = {};\\n    let update, key, skip, props;\\n\\n    // if text mark, apply global lineBreak settings (#2370)\\n    key = 'lineBreak';\\n    if (type === 'text' && config[key] != null && !has(key, encode)) {\\n      applyDefault(defaults, key, config[key]);\\n    }\\n\\n    // ignore legend and axis roles\\n    if (role == 'legend' || String(role).startsWith('axis')) {\\n      role = null;\\n    }\\n\\n    // resolve mark config\\n    props = role === FrameRole ? config.group\\n      : (role === MarkRole) ? vegaUtil.extend({}, config.mark, config[type])\\n      : null;\\n\\n    for (key in props) {\\n      // do not apply defaults if relevant fields are defined\\n      skip = has(key, encode)\\n        || (key === 'fill' || key === 'stroke')\\n        && (has('fill', encode) || has('stroke', encode));\\n\\n      if (!skip) applyDefault(defaults, key, props[key]);\\n    }\\n\\n    // resolve styles, apply with increasing precedence\\n    vegaUtil.array(style).forEach(name => {\\n      const props = config.style && config.style[name];\\n      for (const key in props) {\\n        if (!has(key, encode)) {\\n          applyDefault(defaults, key, props[key]);\\n        }\\n      }\\n    });\\n\\n    encode = vegaUtil.extend({}, encode); // defensive copy\\n    for (key in defaults) {\\n      props = defaults[key];\\n      if (props.signal) {\\n        (update = update || {})[key] = props;\\n      } else {\\n        enter[key] = props;\\n      }\\n    }\\n\\n    encode.enter = vegaUtil.extend(enter, encode.enter);\\n    if (update) encode.update = vegaUtil.extend(update, encode.update);\\n\\n    return encode;\\n  }\\n\\n  function applyDefault(defaults, key, value) {\\n    defaults[key] = value && value.signal\\n      ? {signal: value.signal}\\n      : {value: value};\\n  }\\n\\n  const scaleRef = scale => vegaUtil.isString(scale) ? vegaUtil.stringValue(scale)\\n    : scale.signal ? `(${scale.signal})`\\n    : field(scale);\\n\\n  function entry(enc) {\\n    if (enc.gradient != null) {\\n      return gradient(enc);\\n    }\\n\\n    let value = enc.signal ? `(${enc.signal})`\\n      : enc.color ? color(enc.color)\\n      : enc.field != null ? field(enc.field)\\n      : enc.value !== undefined ? vegaUtil.stringValue(enc.value)\\n      : undefined;\\n\\n    if (enc.scale != null) {\\n      value = scale(enc, value);\\n    }\\n\\n    if (value === undefined) {\\n      value = null;\\n    }\\n\\n    if (enc.exponent != null) {\\n      value = `pow(${value},${property(enc.exponent)})`;\\n    }\\n\\n    if (enc.mult != null) {\\n      value += `*${property(enc.mult)}`;\\n    }\\n\\n    if (enc.offset != null) {\\n      value += `+${property(enc.offset)}`;\\n    }\\n\\n    if (enc.round) {\\n      value = `round(${value})`;\\n    }\\n\\n    return value;\\n  }\\n\\n  const _color = (type, x, y, z) =>\\n    `(${type}(${[x, y, z].map(entry).join(',')})+'')`;\\n\\n  function color(enc) {\\n    return (enc.c) ? _color('hcl', enc.h, enc.c, enc.l)\\n      : (enc.h || enc.s) ? _color('hsl', enc.h, enc.s, enc.l)\\n      : (enc.l || enc.a) ? _color('lab', enc.l, enc.a, enc.b)\\n      : (enc.r || enc.g || enc.b) ? _color('rgb', enc.r, enc.g, enc.b)\\n      : null;\\n  }\\n\\n  function gradient(enc) {\\n    // map undefined to null; expression lang does not allow undefined\\n    const args = [enc.start, enc.stop, enc.count]\\n      .map(_ => _ == null ? null : vegaUtil.stringValue(_));\\n\\n    // trim null inputs from the end\\n    while (args.length && vegaUtil.peek(args) == null) args.pop();\\n\\n    args.unshift(scaleRef(enc.gradient));\\n    return `gradient(${args.join(',')})`;\\n  }\\n\\n  function property(property) {\\n    return vegaUtil.isObject(property) ? '(' + entry(property) + ')' : property;\\n  }\\n\\n  function field(ref) {\\n    return resolveField(vegaUtil.isObject(ref) ? ref : {datum: ref});\\n  }\\n\\n  function resolveField(ref) {\\n    let object, level, field;\\n\\n    if (ref.signal) {\\n      object = 'datum';\\n      field = ref.signal;\\n    } else if (ref.group || ref.parent) {\\n      level = Math.max(1, ref.level || 1);\\n      object = 'item';\\n\\n      while (level-- > 0) {\\n        object += '.mark.group';\\n      }\\n\\n      if (ref.parent) {\\n        field = ref.parent;\\n        object += '.datum';\\n      } else {\\n        field = ref.group;\\n      }\\n    } else if (ref.datum) {\\n      object = 'datum';\\n      field = ref.datum;\\n    } else {\\n      vegaUtil.error('Invalid field reference: ' + vegaUtil.stringValue(ref));\\n    }\\n\\n    if (!ref.signal) {\\n      field = vegaUtil.isString(field)\\n        ? vegaUtil.splitAccessPath(field).map(vegaUtil.stringValue).join('][')\\n        : resolveField(field);\\n    }\\n\\n    return object + '[' + field + ']';\\n  }\\n\\n  function scale(enc, value) {\\n    const scale = scaleRef(enc.scale);\\n\\n    if (enc.range != null) {\\n      // pull value from scale range\\n      value = `lerp(_range(${scale}), ${+enc.range})`;\\n    } else {\\n      // run value through scale and/or pull scale bandwidth\\n      if (value !== undefined) value = `_scale(${scale}, ${value})`;\\n\\n      if (enc.band) {\\n        value = (value ? value + '+' : '')\\n          + `_bandwidth(${scale})`\\n          + (+enc.band === 1 ? '' : '*' + property(enc.band));\\n\\n        if (enc.extra) {\\n          // include logic to handle extraneous elements\\n          value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\\n        }\\n      }\\n\\n      if (value == null) value = '0';\\n    }\\n\\n    return value;\\n  }\\n\\n  function rule(enc) {\\n    let code = '';\\n\\n    enc.forEach(rule => {\\n      const value = entry(rule);\\n      code += rule.test ? `(${rule.test})?${value}:` : value;\\n    });\\n\\n    // if no else clause, terminate with null (#1366)\\n    if (vegaUtil.peek(code) === ':') {\\n      code += 'null';\\n    }\\n\\n    return code;\\n  }\\n\\n  function parseEncode(encode, type, role, style, scope, params) {\\n    const enc = {};\\n    params = params || {};\\n    params.encoders = {$encode: enc};\\n\\n    encode = applyDefaults(encode, type, role, style, scope.config);\\n    for (const key in encode) {\\n      enc[key] = parseBlock(encode[key], type, params, scope);\\n    }\\n\\n    return params;\\n  }\\n\\n  function parseBlock(block, marktype, params, scope) {\\n    const channels = {},\\n          fields = {};\\n\\n    for (const name in block) {\\n      if (block[name] != null) { // skip any null entries\\n        channels[name] = parse(expr(block[name]), scope, params, fields);\\n      }\\n    }\\n\\n    return {\\n      $expr:   {marktype, channels},\\n      $fields: Object.keys(fields),\\n      $output: Object.keys(block)\\n    };\\n  }\\n\\n  function expr(enc) {\\n    return vegaUtil.isArray(enc) ? rule(enc) : entry(enc);\\n  }\\n\\n  function parse(code, scope, params, fields) {\\n    const expr = vegaFunctions.parseExpression(code, scope);\\n    expr.$fields.forEach(name => fields[name] = 1);\\n    vegaUtil.extend(params, expr.$params);\\n    return expr.$expr;\\n  }\\n\\n  const OUTER = 'outer',\\n        OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\\n\\n  function outerError(prefix, name) {\\n    vegaUtil.error(prefix + ' for \\\"outer\\\" push: ' + vegaUtil.stringValue(name));\\n  }\\n\\n  function parseSignal(signal, scope) {\\n    const name = signal.name;\\n\\n    if (signal.push === OUTER) {\\n      // signal must already be defined, raise error if not\\n      if (!scope.signals[name]) outerError('No prior signal definition', name);\\n      // signal push must not use properties reserved for standard definition\\n      OUTER_INVALID.forEach(prop => {\\n        if (signal[prop] !== undefined) outerError('Invalid property ', prop);\\n      });\\n    } else {\\n      // define a new signal in the current scope\\n      const op = scope.addSignal(name, signal.value);\\n      if (signal.react === false) op.react = false;\\n      if (signal.bind) scope.addBinding(name, signal.bind);\\n    }\\n  }\\n\\n  function Entry(type, value, params, parent) {\\n    this.id = -1;\\n    this.type = type;\\n    this.value = value;\\n    this.params = params;\\n    if (parent) this.parent = parent;\\n  }\\n\\n  function entry$1(type, value, params, parent) {\\n    return new Entry(type, value, params, parent);\\n  }\\n\\n  function operator(value, params) {\\n    return entry$1('operator', value, params);\\n  }\\n\\n  // -----\\n\\n  function ref(op) {\\n    const ref = {$ref: op.id};\\n    // if operator not yet registered, cache ref to resolve later\\n    if (op.id < 0) (op.refs = op.refs || []).push(ref);\\n    return ref;\\n  }\\n\\n  function fieldRef(field, name) {\\n    return name ? {$field: field, $name: name} : {$field: field};\\n  }\\n\\n  const keyFieldRef = fieldRef('key');\\n\\n  function compareRef(fields, orders) {\\n    return {$compare: fields, $order: orders};\\n  }\\n\\n  function keyRef(fields, flat) {\\n    const ref = {$key: fields};\\n    if (flat) ref.$flat = true;\\n    return ref;\\n  }\\n\\n  // -----\\n\\n  const Ascending  = 'ascending';\\n\\n  const Descending = 'descending';\\n\\n  function sortKey(sort) {\\n    return !vegaUtil.isObject(sort) ? ''\\n      : (sort.order === Descending ? '-' : '+')\\n        + aggrField(sort.op, sort.field);\\n  }\\n\\n  function aggrField(op, field) {\\n    return (op && op.signal ? '$' + op.signal : op || '')\\n      + (op && field ? '_' : '')\\n      + (field && field.signal ? '$' + field.signal : field || '');\\n  }\\n\\n  // -----\\n\\n  const Scope = 'scope';\\n\\n  const View = 'view';\\n\\n  function isSignal(_) {\\n    return _ && _.signal;\\n  }\\n\\n  function isExpr(_) {\\n    return _ && _.expr;\\n  }\\n\\n  function hasSignal(_) {\\n    if (isSignal(_)) return true;\\n    if (vegaUtil.isObject(_)) for (const key in _) {\\n      if (hasSignal(_[key])) return true;\\n    }\\n    return false;\\n  }\\n\\n  function value(specValue, defaultValue) {\\n    return specValue != null ? specValue : defaultValue;\\n  }\\n\\n  function deref(v) {\\n    return v && v.signal || v;\\n  }\\n\\n  const Timer = 'timer';\\n\\n  function parseStream(stream, scope) {\\n    const method = stream.merge ? mergeStream\\n      : stream.stream ? nestedStream\\n      : stream.type ? eventStream\\n      : vegaUtil.error('Invalid stream specification: ' + vegaUtil.stringValue(stream));\\n\\n    return method(stream, scope);\\n  }\\n\\n  function eventSource(source) {\\n     return source === Scope ? View : (source || View);\\n  }\\n\\n  function mergeStream(stream, scope) {\\n    const list = stream.merge.map(s => parseStream(s, scope)),\\n          entry = streamParameters({merge: list}, stream, scope);\\n    return scope.addStream(entry).id;\\n  }\\n\\n  function nestedStream(stream, scope) {\\n    const id = parseStream(stream.stream, scope),\\n          entry = streamParameters({stream: id}, stream, scope);\\n    return scope.addStream(entry).id;\\n  }\\n\\n  function eventStream(stream, scope) {\\n    let id;\\n    if (stream.type === Timer) {\\n      id = scope.event(Timer, stream.throttle);\\n      stream = {between: stream.between, filter: stream.filter};\\n    } else {\\n      id = scope.event(eventSource(stream.source), stream.type);\\n    }\\n\\n    const entry = streamParameters({stream: id}, stream, scope);\\n    return Object.keys(entry).length === 1\\n      ? id\\n      : scope.addStream(entry).id;\\n  }\\n\\n  function streamParameters(entry, stream, scope) {\\n    let param = stream.between;\\n\\n    if (param) {\\n      if (param.length !== 2) {\\n        vegaUtil.error('Stream \\\"between\\\" parameter must have 2 entries: ' + vegaUtil.stringValue(stream));\\n      }\\n      entry.between = [\\n        parseStream(param[0], scope),\\n        parseStream(param[1], scope)\\n      ];\\n    }\\n\\n    param = stream.filter ? [].concat(stream.filter) : [];\\n    if (stream.marktype || stream.markname || stream.markrole) {\\n      // add filter for mark type, name and/or role\\n      param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\\n    }\\n    if (stream.source === Scope) {\\n      // add filter to limit events from sub-scope only\\n      param.push('inScope(event.item)');\\n    }\\n    if (param.length) {\\n      entry.filter = vegaFunctions.parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\\n    }\\n\\n    if ((param = stream.throttle) != null) {\\n      entry.throttle = +param;\\n    }\\n\\n    if ((param = stream.debounce) != null) {\\n      entry.debounce = +param;\\n    }\\n\\n    if (stream.consume) {\\n      entry.consume = true;\\n    }\\n\\n    return entry;\\n  }\\n\\n  function filterMark(type, name, role) {\\n    const item = 'event.item';\\n    return item\\n      + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\\\'' + type + '\\\\'' : '')\\n      + (role ? '&&' + item + '.mark.role===\\\\'' + role + '\\\\'' : '')\\n      + (name ? '&&' + item + '.mark.name===\\\\'' + name + '\\\\'' : '');\\n  }\\n\\n  // bypass expression parser for internal operator references\\n  const OP_VALUE_EXPR = {\\n    code: '_.$value',\\n    ast: {type: 'Identifier', value: 'value'}\\n  };\\n\\n  function parseUpdate(spec, scope, target) {\\n    const encode = spec.encode,\\n          entry = {target: target};\\n\\n    let events = spec.events,\\n        update = spec.update,\\n        sources = [];\\n\\n    if (!events) {\\n      vegaUtil.error('Signal update missing events specification.');\\n    }\\n\\n    // interpret as an event selector string\\n    if (vegaUtil.isString(events)) {\\n      events = vegaEventSelector.selector(events, scope.isSubscope() ? Scope : View);\\n    }\\n\\n    // separate event streams from signal updates\\n    events = vegaUtil.array(events)\\n      .filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1);\\n\\n    // merge internal operator listeners\\n    if (sources.length > 1) {\\n      sources = [mergeSources(sources)];\\n    }\\n\\n    // merge event streams, include as source\\n    if (events.length) {\\n      sources.push(events.length > 1 ? {merge: events} : events[0]);\\n    }\\n\\n    if (encode != null) {\\n      if (update) vegaUtil.error('Signal encode and update are mutually exclusive.');\\n      update = 'encode(item(),' + vegaUtil.stringValue(encode) + ')';\\n    }\\n\\n    // resolve update value\\n    entry.update = vegaUtil.isString(update) ? vegaFunctions.parseExpression(update, scope)\\n      : update.expr != null ? vegaFunctions.parseExpression(update.expr, scope)\\n      : update.value != null ? update.value\\n      : update.signal != null ? {\\n          $expr:   OP_VALUE_EXPR,\\n          $params: {$value: scope.signalRef(update.signal)}\\n        }\\n      : vegaUtil.error('Invalid signal update specification.');\\n\\n    if (spec.force) {\\n      entry.options = {force: true};\\n    }\\n\\n    sources.forEach(source =>\\n      scope.addUpdate(vegaUtil.extend(streamSource(source, scope), entry))\\n    );\\n  }\\n\\n  function streamSource(stream, scope) {\\n    return {\\n      source: stream.signal ? scope.signalRef(stream.signal)\\n            : stream.scale ? scope.scaleRef(stream.scale)\\n            : parseStream(stream, scope)\\n    };\\n  }\\n\\n  function mergeSources(sources) {\\n    return {\\n      signal: '['\\n        + sources.map(s => s.scale ? 'scale(\\\"' + s.scale + '\\\")' : s.signal)\\n        + ']'\\n    };\\n  }\\n\\n  function parseSignalUpdates(signal, scope) {\\n    const op = scope.getSignal(signal.name);\\n    let expr = signal.update;\\n\\n    if (signal.init) {\\n      if (expr) {\\n        vegaUtil.error('Signals can not include both init and update expressions.');\\n      } else {\\n        expr = signal.init;\\n        op.initonly = true;\\n      }\\n    }\\n\\n    if (expr) {\\n      expr = vegaFunctions.parseExpression(expr, scope);\\n      op.update = expr.$expr;\\n      op.params = expr.$params;\\n    }\\n\\n    if (signal.on) {\\n      signal.on.forEach(_ => parseUpdate(_, scope, op.id));\\n    }\\n  }\\n\\n  const transform = name => (params, value, parent) =>\\n    entry$1(name, value, params || undefined, parent);\\n\\n  const Aggregate = transform('aggregate');\\n  const AxisTicks = transform('axisticks');\\n  const Bound = transform('bound');\\n  const Collect = transform('collect');\\n  const Compare = transform('compare');\\n  const DataJoin = transform('datajoin');\\n  const Encode = transform('encode');\\n  const Expression = transform('expression');\\n  const Facet = transform('facet');\\n  const Field = transform('field');\\n  const Key = transform('key');\\n  const LegendEntries = transform('legendentries');\\n  const Load = transform('load');\\n  const Mark = transform('mark');\\n  const MultiExtent = transform('multiextent');\\n  const MultiValues = transform('multivalues');\\n  const Overlap = transform('overlap');\\n  const Params = transform('params');\\n  const PreFacet = transform('prefacet');\\n  const Projection = transform('projection');\\n  const Proxy = transform('proxy');\\n  const Relay = transform('relay');\\n  const Render = transform('render');\\n  const Scale = transform('scale');\\n  const Sieve = transform('sieve');\\n  const SortItems = transform('sortitems');\\n  const ViewLayout = transform('viewlayout');\\n  const Values = transform('values');\\n\\n  let FIELD_REF_ID = 0;\\n\\n  const MULTIDOMAIN_SORT_OPS  = {min: 'min', max: 'max', count: 'sum'};\\n\\n  function initScale(spec, scope) {\\n    const type = spec.type || 'linear';\\n\\n    if (!vegaScale.isValidScaleType(type)) {\\n      vegaUtil.error('Unrecognized scale type: ' + vegaUtil.stringValue(type));\\n    }\\n\\n    scope.addScale(spec.name, {\\n      type,\\n      domain: undefined\\n    });\\n  }\\n\\n  function parseScale(spec, scope) {\\n    const params = scope.getScale(spec.name).params;\\n    let key;\\n\\n    params.domain = parseScaleDomain(spec.domain, spec, scope);\\n\\n    if (spec.range != null) {\\n      params.range = parseScaleRange(spec, scope, params);\\n    }\\n\\n    if (spec.interpolate != null) {\\n      parseScaleInterpolate(spec.interpolate, params);\\n    }\\n\\n    if (spec.nice != null) {\\n      params.nice = parseScaleNice(spec.nice);\\n    }\\n\\n    if (spec.bins != null) {\\n      params.bins = parseScaleBins(spec.bins, scope);\\n    }\\n\\n    for (key in spec) {\\n      if (vegaUtil.hasOwnProperty(params, key) || key === 'name') continue;\\n      params[key] = parseLiteral(spec[key], scope);\\n    }\\n  }\\n\\n  function parseLiteral(v, scope) {\\n    return !vegaUtil.isObject(v) ? v\\n      : v.signal ? scope.signalRef(v.signal)\\n      : vegaUtil.error('Unsupported object: ' + vegaUtil.stringValue(v));\\n  }\\n\\n  function parseArray(v, scope) {\\n    return v.signal\\n      ? scope.signalRef(v.signal)\\n      : v.map(v => parseLiteral(v, scope));\\n  }\\n\\n  function dataLookupError(name) {\\n    vegaUtil.error('Can not find data set: ' + vegaUtil.stringValue(name));\\n  }\\n\\n  // -- SCALE DOMAIN ----\\n\\n  function parseScaleDomain(domain, spec, scope) {\\n    if (!domain) {\\n      if (spec.domainMin != null || spec.domainMax != null) {\\n        vegaUtil.error('No scale domain defined for domainMin/domainMax to override.');\\n      }\\n      return; // default domain\\n    }\\n\\n    return domain.signal ? scope.signalRef(domain.signal)\\n      : (vegaUtil.isArray(domain) ? explicitDomain\\n      : domain.fields ? multipleDomain\\n      : singularDomain)(domain, spec, scope);\\n  }\\n\\n  function explicitDomain(domain, spec, scope) {\\n    return domain.map(v => parseLiteral(v, scope));\\n  }\\n\\n  function singularDomain(domain, spec, scope) {\\n    const data = scope.getData(domain.data);\\n    if (!data) dataLookupError(domain.data);\\n\\n    return vegaScale.isDiscrete(spec.type)\\n        ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false))\\n        : vegaScale.isQuantile(spec.type) ? data.domainRef(scope, domain.field)\\n        : data.extentRef(scope, domain.field);\\n  }\\n\\n  function multipleDomain(domain, spec, scope) {\\n    const data = domain.data,\\n          fields = domain.fields.reduce((dom, d) => {\\n            d = vegaUtil.isString(d) ? {data: data, field: d}\\n              : (vegaUtil.isArray(d) || d.signal) ? fieldRef$1(d, scope)\\n              : d;\\n            dom.push(d);\\n            return dom;\\n          }, []);\\n\\n    return (vegaScale.isDiscrete(spec.type) ? ordinalMultipleDomain\\n      : vegaScale.isQuantile(spec.type) ? quantileMultipleDomain\\n      : numericMultipleDomain)(domain, scope, fields);\\n  }\\n\\n  function fieldRef$1(data, scope) {\\n    const name = '_:vega:_' + (FIELD_REF_ID++),\\n          coll = Collect({});\\n\\n    if (vegaUtil.isArray(data)) {\\n      coll.value = {$ingest: data};\\n    } else if (data.signal) {\\n      const code = 'setdata(' + vegaUtil.stringValue(name) + ',' + data.signal + ')';\\n      coll.params.input = scope.signalRef(code);\\n    }\\n    scope.addDataPipeline(name, [coll, Sieve({})]);\\n    return {data: name, field: 'data'};\\n  }\\n\\n  function ordinalMultipleDomain(domain, scope, fields) {\\n    const sort = parseSort(domain.sort, true);\\n    let a, v;\\n\\n    // get value counts for each domain field\\n    const counts = fields.map(f => {\\n      const data = scope.getData(f.data);\\n      if (!data) dataLookupError(f.data);\\n      return data.countsRef(scope, f.field, sort);\\n    });\\n\\n    // aggregate the results from each domain field\\n    const p = {groupby: keyFieldRef, pulse: counts};\\n    if (sort) {\\n      a = sort.op || 'count';\\n      v = sort.field ? aggrField(a, sort.field) : 'count';\\n      p.ops = [MULTIDOMAIN_SORT_OPS[a]];\\n      p.fields = [scope.fieldRef(v)];\\n      p.as = [v];\\n    }\\n    a = scope.add(Aggregate(p));\\n\\n    // collect aggregate output\\n    const c = scope.add(Collect({pulse: ref(a)}));\\n\\n    // extract values for combined domain\\n    v = scope.add(Values({\\n      field: keyFieldRef,\\n      sort:  scope.sortRef(sort),\\n      pulse: ref(c)\\n    }));\\n\\n    return ref(v);\\n  }\\n\\n  function parseSort(sort, multidomain) {\\n    if (sort) {\\n      if (!sort.field && !sort.op) {\\n        if (vegaUtil.isObject(sort)) sort.field = 'key';\\n        else sort = {field: 'key'};\\n      } else if (!sort.field && sort.op !== 'count') {\\n        vegaUtil.error('No field provided for sort aggregate op: ' + sort.op);\\n      } else if (multidomain && sort.field) {\\n        if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\\n          vegaUtil.error('Multiple domain scales can not be sorted using ' + sort.op);\\n        }\\n      }\\n    }\\n    return sort;\\n  }\\n\\n  function quantileMultipleDomain(domain, scope, fields) {\\n    // get value arrays for each domain field\\n    const values = fields.map(f => {\\n      const data = scope.getData(f.data);\\n      if (!data) dataLookupError(f.data);\\n      return data.domainRef(scope, f.field);\\n    });\\n\\n    // combine value arrays\\n    return ref(scope.add(MultiValues({values: values})));\\n  }\\n\\n  function numericMultipleDomain(domain, scope, fields) {\\n    // get extents for each domain field\\n    const extents = fields.map(f => {\\n      const data = scope.getData(f.data);\\n      if (!data) dataLookupError(f.data);\\n      return data.extentRef(scope, f.field);\\n    });\\n\\n    // combine extents\\n    return ref(scope.add(MultiExtent({extents: extents})));\\n  }\\n\\n  // -- SCALE BINS -----\\n\\n  function parseScaleBins(v, scope) {\\n    return v.signal || vegaUtil.isArray(v)\\n      ? parseArray(v, scope)\\n      : scope.objectProperty(v);\\n  }\\n\\n  // -- SCALE NICE -----\\n\\n  function parseScaleNice(nice) {\\n    return vegaUtil.isObject(nice)\\n      ? {\\n          interval: parseLiteral(nice.interval),\\n          step: parseLiteral(nice.step)\\n        }\\n      : parseLiteral(nice);\\n  }\\n\\n  // -- SCALE INTERPOLATION -----\\n\\n  function parseScaleInterpolate(interpolate, params) {\\n    params.interpolate = parseLiteral(interpolate.type || interpolate);\\n    if (interpolate.gamma != null) {\\n      params.interpolateGamma = parseLiteral(interpolate.gamma);\\n    }\\n  }\\n\\n  // -- SCALE RANGE -----\\n\\n  function parseScaleRange(spec, scope, params) {\\n    const config = scope.config.range;\\n    let range = spec.range;\\n\\n    if (range.signal) {\\n      return scope.signalRef(range.signal);\\n    } else if (vegaUtil.isString(range)) {\\n      if (config && vegaUtil.hasOwnProperty(config, range)) {\\n        spec = vegaUtil.extend({}, spec, {range: config[range]});\\n        return parseScaleRange(spec, scope, params);\\n      } else if (range === 'width') {\\n        range = [0, {signal: 'width'}];\\n      } else if (range === 'height') {\\n        range = vegaScale.isDiscrete(spec.type)\\n          ? [0, {signal: 'height'}]\\n          : [{signal: 'height'}, 0];\\n      } else {\\n        vegaUtil.error('Unrecognized scale range value: ' + vegaUtil.stringValue(range));\\n      }\\n    } else if (range.scheme) {\\n      params.scheme = vegaUtil.isArray(range.scheme)\\n        ? parseArray(range.scheme, scope)\\n        : parseLiteral(range.scheme, scope);\\n      if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\\n      if (range.count) params.schemeCount = parseLiteral(range.count, scope);\\n      return;\\n    } else if (range.step) {\\n      params.rangeStep = parseLiteral(range.step, scope);\\n      return;\\n    } else if (vegaScale.isDiscrete(spec.type) && !vegaUtil.isArray(range)) {\\n      return parseScaleDomain(range, spec, scope);\\n    } else if (!vegaUtil.isArray(range)) {\\n      vegaUtil.error('Unsupported range type: ' + vegaUtil.stringValue(range));\\n    }\\n\\n    return range.map(v => (vegaUtil.isArray(v) ? parseArray : parseLiteral)(v, scope));\\n  }\\n\\n  function parseProjection(proj, scope) {\\n    const config = scope.config.projection || {},\\n          params = {};\\n\\n    for (const name in proj) {\\n      if (name === 'name') continue;\\n      params[name] = parseParameter(proj[name], name, scope);\\n    }\\n\\n    // apply projection defaults from config\\n    for (const name in config) {\\n      if (params[name] == null) {\\n        params[name] = parseParameter(config[name], name, scope);\\n      }\\n    }\\n\\n    scope.addProjection(proj.name, params);\\n  }\\n\\n  function parseParameter(_, name, scope) {\\n    return vegaUtil.isArray(_) ? _.map(_ => parseParameter(_, name, scope))\\n      : !vegaUtil.isObject(_) ? _\\n      : _.signal ? scope.signalRef(_.signal)\\n      : name === 'fit' ? _\\n      : vegaUtil.error('Unsupported parameter object: ' + vegaUtil.stringValue(_));\\n  }\\n\\n  const Top = 'top';\\n  const Left = 'left';\\n  const Right = 'right';\\n  const Bottom = 'bottom';\\n  const Center = 'center';\\n\\n  const Vertical = 'vertical';\\n\\n  const Start = 'start';\\n  const Middle = 'middle';\\n  const End = 'end';\\n\\n  const Index  = 'index';\\n  const Label  = 'label';\\n  const Offset = 'offset';\\n  const Perc   = 'perc';\\n  const Perc2  = 'perc2';\\n  const Value  = 'value';\\n\\n  const GuideLabelStyle = 'guide-label';\\n  const GuideTitleStyle = 'guide-title';\\n  const GroupTitleStyle = 'group-title';\\n  const GroupSubtitleStyle = 'group-subtitle';\\n\\n  const Symbols = 'symbol';\\n  const Gradient = 'gradient';\\n  const Discrete = 'discrete';\\n\\n  const Size = 'size';\\n  const Shape = 'shape';\\n  const Fill = 'fill';\\n  const Stroke = 'stroke';\\n  const StrokeWidth = 'strokeWidth';\\n  const StrokeDash = 'strokeDash';\\n  const Opacity = 'opacity';\\n\\n  // Encoding channels supported by legends\\n  // In priority order of 'canonical' scale\\n  const LegendScales = [\\n    Size,\\n    Shape,\\n    Fill,\\n    Stroke,\\n    StrokeWidth,\\n    StrokeDash,\\n    Opacity\\n  ];\\n\\n  const Skip = {\\n    name: 1,\\n    style: 1,\\n    interactive: 1\\n  };\\n\\n  const zero = {value: 0};\\n  const one = {value: 1};\\n\\n  const GroupMark = 'group';\\n  const RectMark = 'rect';\\n  const RuleMark = 'rule';\\n  const SymbolMark = 'symbol';\\n  const TextMark = 'text';\\n\\n  function guideGroup(mark) {\\n    mark.type = GroupMark;\\n    mark.interactive = mark.interactive || false;\\n    return mark;\\n  }\\n\\n  function lookup(spec, config) {\\n    const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\\n\\n    _.isVertical = s => Vertical === value(\\n      spec.direction,\\n      config.direction || (s ? config.symbolDirection : config.gradientDirection)\\n    );\\n\\n    _.gradientLength = () => value(\\n      spec.gradientLength,\\n      config.gradientLength || config.gradientWidth\\n    );\\n\\n    _.gradientThickness = () => value(\\n      spec.gradientThickness,\\n      config.gradientThickness || config.gradientHeight\\n    );\\n\\n    _.entryColumns = () => value(\\n      spec.columns,\\n      value(config.columns, +_.isVertical(true))\\n    );\\n\\n    return _;\\n  }\\n\\n  function getEncoding(name, encode) {\\n    const v = encode && (\\n      (encode.update && encode.update[name]) ||\\n      (encode.enter && encode.enter[name])\\n    );\\n    return v && v.signal ? v : v ? v.value : null;\\n  }\\n\\n  function getStyle(name, scope, style) {\\n    const s = scope.config.style[style];\\n    return s && s[name];\\n  }\\n\\n  function anchorExpr(s, e, m) {\\n    return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\\n  }\\n\\n  const alignExpr = anchorExpr(\\n    vegaUtil.stringValue(Left),\\n    vegaUtil.stringValue(Right),\\n    vegaUtil.stringValue(Center)\\n  );\\n\\n  function tickBand(_) {\\n    const v = _('tickBand');\\n    let offset = _('tickOffset'),\\n        band, extra;\\n\\n    if (!v) {\\n      // if no tick band entry, fall back on other properties\\n      band = _('bandPosition');\\n      extra = _('tickExtra');\\n    } else if (v.signal) {\\n      // if signal, augment code to interpret values\\n      band = {signal: `(${v.signal}) === 'extent' ? 1 : 0.5`};\\n      extra = {signal: `(${v.signal}) === 'extent'`};\\n      if (!vegaUtil.isObject(offset)) {\\n        offset = {signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`};\\n      }\\n    } else if (v === 'extent') {\\n      // if constant, simply set values\\n      band = 1;\\n      extra = true;\\n      offset = 0;\\n    } else {\\n      band = 0.5;\\n      extra = false;\\n    }\\n\\n    return {extra, band, offset};\\n  }\\n\\n  function extendOffset(value, offset) {\\n    return !offset ? value\\n      : !value ? offset\\n      : !vegaUtil.isObject(value) ? { value, offset }\\n      : Object.assign({}, value, { offset: extendOffset(value.offset, offset) });\\n  }\\n\\n  function guideMark(mark, extras) {\\n    if (extras) {\\n      mark.name = extras.name;\\n      mark.style = extras.style || mark.style;\\n      mark.interactive = !!extras.interactive;\\n      mark.encode = extendEncode(mark.encode, extras, Skip);\\n    } else {\\n      mark.interactive = false;\\n    }\\n    return mark;\\n  }\\n\\n  function legendGradient(spec, scale, config, userEncode) {\\n    const _ = lookup(spec, config),\\n          vertical = _.isVertical(),\\n          thickness = _.gradientThickness(),\\n          length = _.gradientLength();\\n\\n    let enter, start, stop, width, height;\\n\\n    if (vertical) {\\n      start = [0, 1];\\n      stop = [0, 0];\\n      width = thickness;\\n      height = length;\\n    } else {\\n      start = [0, 0];\\n      stop = [1, 0];\\n      width = length;\\n      height = thickness;\\n    }\\n\\n    const encode = {\\n      enter: enter = {\\n        opacity: zero,\\n        x: zero,\\n        y: zero,\\n        width: encoder(width),\\n        height: encoder(height)\\n      },\\n      update: vegaUtil.extend({}, enter, {\\n        opacity: one,\\n        fill: {gradient: scale, start: start, stop: stop}\\n      }),\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n\\n    addEncoders(encode, {\\n      stroke:      _('gradientStrokeColor'),\\n      strokeWidth: _('gradientStrokeWidth')\\n    }, { // update\\n      opacity:     _('gradientOpacity')\\n    });\\n\\n    return guideMark({\\n      type: RectMark,\\n      role: LegendGradientRole,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function legendGradientDiscrete(spec, scale, config, userEncode, dataRef) {\\n    const _ = lookup(spec, config),\\n          vertical = _.isVertical(),\\n          thickness = _.gradientThickness(),\\n          length = _.gradientLength();\\n\\n    let u, v, uu, vv, adjust = '';\\n\\n    vertical\\n      ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-')\\n      : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\\n\\n    const enter = {\\n      opacity: zero,\\n      fill: {scale: scale, field: Value}\\n    };\\n    enter[u]  = {signal: adjust + 'datum.' + Perc, mult: length};\\n    enter[v]  = zero;\\n    enter[uu] = {signal: adjust + 'datum.' + Perc2, mult: length};\\n    enter[vv] = encoder(thickness);\\n\\n    const encode = {\\n      enter: enter,\\n      update: vegaUtil.extend({}, enter, {opacity: one}),\\n      exit: {opacity: zero}\\n    };\\n\\n    addEncoders(encode, {\\n      stroke:      _('gradientStrokeColor'),\\n      strokeWidth: _('gradientStrokeWidth')\\n    }, { // update\\n      opacity:     _('gradientOpacity')\\n    });\\n\\n    return guideMark({\\n      type: RectMark,\\n      role: LegendBandRole,\\n      key:  Value,\\n      from: dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  const alignExpr$1 = `datum.${Perc}<=0?\\\"${Left}\\\":datum.${Perc}>=1?\\\"${Right}\\\":\\\"${Center}\\\"`,\\n        baselineExpr = `datum.${Perc}<=0?\\\"${Bottom}\\\":datum.${Perc}>=1?\\\"${Top}\\\":\\\"${Middle}\\\"`;\\n\\n  function legendGradientLabels(spec, config, userEncode, dataRef) {\\n    const _ = lookup(spec, config),\\n          vertical = _.isVertical(),\\n          thickness = encoder(_.gradientThickness()),\\n          length = _.gradientLength();\\n\\n    let overlap = _('labelOverlap'),\\n        enter, update, u, v, adjust = '';\\n\\n    const encode = {\\n      enter: enter = {\\n        opacity: zero\\n      },\\n      update: update = {\\n        opacity: one,\\n        text: {field: Label}\\n      },\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n\\n    addEncoders(encode, {\\n      fill:        _('labelColor'),\\n      fillOpacity: _('labelOpacity'),\\n      font:        _('labelFont'),\\n      fontSize:    _('labelFontSize'),\\n      fontStyle:   _('labelFontStyle'),\\n      fontWeight:  _('labelFontWeight'),\\n      limit:       value(spec.labelLimit, config.gradientLabelLimit)\\n    });\\n\\n    if (vertical) {\\n      enter.align = {value: 'left'};\\n      enter.baseline = update.baseline = {signal: baselineExpr};\\n      u = 'y'; v = 'x'; adjust = '1-';\\n    } else {\\n      enter.align = update.align = {signal: alignExpr$1};\\n      enter.baseline = {value: 'top'};\\n      u = 'x'; v = 'y';\\n    }\\n\\n    enter[u] = update[u] = {signal: adjust + 'datum.' + Perc, mult: length};\\n\\n    enter[v] = update[v] = thickness;\\n    thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\\n\\n    overlap = overlap ? {\\n      separation: _('labelSeparation'),\\n      method: overlap,\\n      order: 'datum.' + Index\\n    } : undefined;\\n\\n    // type, role, style, key, dataRef, encode, extras\\n    return guideMark({\\n      type:  TextMark,\\n      role:  LegendLabelRole,\\n      style: GuideLabelStyle,\\n      key:   Value,\\n      from: dataRef,\\n      encode,\\n      overlap\\n    }, userEncode);\\n  }\\n\\n  // userEncode is top-level, includes entries, symbols, labels\\n  function legendSymbolGroups(spec, config, userEncode, dataRef, columns) {\\n    const _ = lookup(spec, config),\\n          entries = userEncode.entries,\\n          interactive = !!(entries && entries.interactive),\\n          name = entries ? entries.name : undefined,\\n          height = _('clipHeight'),\\n          symbolOffset = _('symbolOffset'),\\n          valueRef = {data: 'value'},\\n          xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\\n          yEncode = height ? encoder(height) : {field: Size},\\n          index = `datum.${Index}`,\\n          ncols = `max(1, ${columns})`;\\n\\n    let encode, enter, update, nrows, sort;\\n\\n    yEncode.mult = 0.5;\\n\\n    // -- LEGEND SYMBOLS --\\n    encode = {\\n      enter:  enter = {\\n        opacity: zero,\\n        x: {signal: xSignal, mult: 0.5, offset: symbolOffset},\\n        y: yEncode\\n      },\\n      update: update = {\\n        opacity: one,\\n        x: enter.x,\\n        y: enter.y\\n      },\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n\\n    let baseFill = null,\\n        baseStroke = null;\\n    if (!spec.fill) {\\n      baseFill = config.symbolBaseFillColor;\\n      baseStroke = config.symbolBaseStrokeColor;\\n    }\\n\\n    addEncoders(encode, {\\n      fill:             _('symbolFillColor', baseFill),\\n      shape:            _('symbolType'),\\n      size:             _('symbolSize'),\\n      stroke:           _('symbolStrokeColor', baseStroke),\\n      strokeDash:       _('symbolDash'),\\n      strokeDashOffset: _('symbolDashOffset'),\\n      strokeWidth:      _('symbolStrokeWidth')\\n    }, { // update\\n      opacity:          _('symbolOpacity')\\n    });\\n\\n    LegendScales.forEach(scale => {\\n      if (spec[scale]) {\\n        update[scale] = enter[scale] = {scale: spec[scale], field: Value};\\n      }\\n    });\\n\\n    const symbols = guideMark({\\n      type: SymbolMark,\\n      role: LegendSymbolRole,\\n      key:  Value,\\n      from: valueRef,\\n      clip: height ? true : undefined,\\n      encode\\n    }, userEncode.symbols);\\n\\n    // -- LEGEND LABELS --\\n    const labelOffset = encoder(symbolOffset);\\n    labelOffset.offset = _('labelOffset');\\n\\n    encode = {\\n      enter:  enter = {\\n        opacity: zero,\\n        x: {signal: xSignal, offset: labelOffset},\\n        y: yEncode\\n      },\\n      update: update = {\\n        opacity: one,\\n        text: {field: Label},\\n        x: enter.x,\\n        y: enter.y\\n      },\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n\\n    addEncoders(encode, {\\n      align:       _('labelAlign'),\\n      baseline:    _('labelBaseline'),\\n      fill:        _('labelColor'),\\n      fillOpacity: _('labelOpacity'),\\n      font:        _('labelFont'),\\n      fontSize:    _('labelFontSize'),\\n      fontStyle:   _('labelFontStyle'),\\n      fontWeight:  _('labelFontWeight'),\\n      limit:       _('labelLimit')\\n    });\\n\\n    const labels = guideMark({\\n      type:  TextMark,\\n      role:  LegendLabelRole,\\n      style: GuideLabelStyle,\\n      key:   Value,\\n      from:  valueRef,\\n      encode\\n    }, userEncode.labels);\\n\\n    // -- LEGEND ENTRY GROUPS --\\n    encode = {\\n      enter: {\\n        noBound: {value: !height}, // ignore width/height in bounds calc\\n        width: zero,\\n        height: height ? encoder(height) : zero,\\n        opacity: zero\\n      },\\n      exit: {opacity: zero},\\n      update: update = {\\n        opacity: one,\\n        row: {signal: null},\\n        column: {signal: null}\\n      }\\n    };\\n\\n    // annotate and sort groups to ensure correct ordering\\n    if (_.isVertical(true)) {\\n      nrows = `ceil(item.mark.items.length / ${ncols})`;\\n      update.row.signal = `${index}%${nrows}`;\\n      update.column.signal = `floor(${index} / ${nrows})`;\\n      sort = {field: ['row', index]};\\n    } else {\\n      update.row.signal = `floor(${index} / ${ncols})`;\\n      update.column.signal = `${index} % ${ncols}`;\\n      sort = {field: index};\\n    }\\n    // handle zero column case (implies infinite columns)\\n    update.column.signal = `(${columns})?${update.column.signal}:${index}`;\\n\\n    // facet legend entries into sub-groups\\n    dataRef = {facet: {data: dataRef, name: 'value', groupby: Index}};\\n\\n    return guideGroup({\\n      role:   ScopeRole,\\n      from:   dataRef,\\n      encode: extendEncode(encode, entries, Skip),\\n      marks:  [symbols, labels],\\n      name,\\n      interactive,\\n      sort\\n    });\\n  }\\n\\n  function legendSymbolLayout(spec, config) {\\n    const _ = lookup(spec, config);\\n\\n    // layout parameters for legend entries\\n    return {\\n      align:   _('gridAlign'),\\n      columns: _.entryColumns(),\\n      center:  {\\n        row: true,\\n        column: false\\n      },\\n      padding: {\\n        row:    _('rowPadding'),\\n        column: _('columnPadding')\\n      }\\n    };\\n  }\\n\\n  // expression logic for align, anchor, angle, and baseline calculation\\n  const isL = 'item.orient === \\\"left\\\"',\\n        isR = 'item.orient === \\\"right\\\"',\\n        isLR = `(${isL} || ${isR})`,\\n        isVG = `datum.vgrad && ${isLR}`,\\n        baseline = anchorExpr('\\\"top\\\"', '\\\"bottom\\\"', '\\\"middle\\\"'),\\n        alignFlip = anchorExpr('\\\"right\\\"', '\\\"left\\\"', '\\\"center\\\"'),\\n        exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \\\"left\\\" : ${alignExpr}`,\\n        exprAnchor = `item._anchor || (${isLR} ? \\\"middle\\\" : \\\"start\\\")`,\\n        exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\\n        exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \\\"bottom\\\" : \\\"top\\\") : ${baseline}) : \\\"top\\\"`;\\n\\n  function legendTitle(spec, config, userEncode, dataRef) {\\n    const _ = lookup(spec, config);\\n\\n    const encode = {\\n      enter: {opacity: zero},\\n      update: {\\n        opacity: one,\\n        x: {field: {group: 'padding'}},\\n        y: {field: {group: 'padding'}}\\n      },\\n      exit: {opacity: zero}\\n    };\\n\\n    addEncoders(encode, {\\n      orient:      _('titleOrient'),\\n      _anchor:     _('titleAnchor'),\\n      anchor:      {signal: exprAnchor},\\n      angle:       {signal: exprAngle},\\n      align:       {signal: exprAlign},\\n      baseline:    {signal: exprBaseline},\\n      text:        spec.title,\\n      fill:        _('titleColor'),\\n      fillOpacity: _('titleOpacity'),\\n      font:        _('titleFont'),\\n      fontSize:    _('titleFontSize'),\\n      fontStyle:   _('titleFontStyle'),\\n      fontWeight:  _('titleFontWeight'),\\n      limit:       _('titleLimit'),\\n      lineHeight:  _('titleLineHeight')\\n    }, { // require update\\n      align:       _('titleAlign'),\\n      baseline:    _('titleBaseline')\\n    });\\n\\n    return guideMark({\\n      type:  TextMark,\\n      role:  LegendTitleRole,\\n      style: GuideTitleStyle,\\n      from:  dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function clip(clip, scope) {\\n    let expr;\\n\\n    if (vegaUtil.isObject(clip)) {\\n      if (clip.signal) {\\n        expr = clip.signal;\\n      } else if (clip.path) {\\n        expr = 'pathShape(' + param(clip.path) + ')';\\n      } else if (clip.sphere) {\\n        expr = 'geoShape(' + param(clip.sphere) + ', {type: \\\"Sphere\\\"})';\\n      }\\n    }\\n\\n    return expr\\n      ? scope.signalRef(expr)\\n      : !!clip;\\n  }\\n\\n  function param(value) {\\n    return vegaUtil.isObject(value) && value.signal\\n      ? value.signal\\n      : vegaUtil.stringValue(value);\\n  }\\n\\n  function getRole(spec) {\\n    const role = spec.role || '';\\n    return (!role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title'))\\n      ? role\\n      : spec.type === GroupMark ? ScopeRole : (role || MarkRole);\\n  }\\n\\n  function definition(spec) {\\n    return {\\n      marktype:     spec.type,\\n      name:         spec.name || undefined,\\n      role:         spec.role || getRole(spec),\\n      zindex:       +spec.zindex || undefined,\\n      aria:         spec.aria,\\n      description:  spec.description\\n    };\\n  }\\n\\n  function interactive(spec, scope) {\\n    return spec && spec.signal ? scope.signalRef(spec.signal)\\n      : spec === false ? false\\n      : true;\\n  }\\n\\n  /**\\n   * Parse a data transform specification.\\n   */\\n  function parseTransform(spec, scope) {\\n    const def = vegaDataflow.definition(spec.type);\\n    if (!def) vegaUtil.error('Unrecognized transform type: ' + vegaUtil.stringValue(spec.type));\\n\\n    const t = entry$1(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\\n    if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\\n    t.metadata = def.metadata || {};\\n\\n    return t;\\n  }\\n\\n  /**\\n   * Parse all parameters of a data transform.\\n   */\\n  function parseParameters(def, spec, scope) {\\n    const params = {},\\n          n = def.params.length;\\n\\n    for (let i = 0; i < n; ++i) {\\n      const pdef = def.params[i];\\n      params[pdef.name] = parseParameter$1(pdef, spec, scope);\\n    }\\n    return params;\\n  }\\n\\n  /**\\n   * Parse a data transform parameter.\\n   */\\n  function parseParameter$1(def, spec, scope) {\\n    const type = def.type,\\n          value = spec[def.name];\\n\\n    if (type === 'index') {\\n      return parseIndexParameter(def, spec, scope);\\n    } else if (value === undefined) {\\n      if (def.required) {\\n        vegaUtil.error('Missing required ' + vegaUtil.stringValue(spec.type)\\n            + ' parameter: ' + vegaUtil.stringValue(def.name));\\n      }\\n      return;\\n    } else if (type === 'param') {\\n      return parseSubParameters(def, spec, scope);\\n    } else if (type === 'projection') {\\n      return scope.projectionRef(spec[def.name]);\\n    }\\n\\n    return def.array && !isSignal(value)\\n      ? value.map(v => parameterValue(def, v, scope))\\n      : parameterValue(def, value, scope);\\n  }\\n\\n  /**\\n   * Parse a single parameter value.\\n   */\\n  function parameterValue(def, value, scope) {\\n    const type = def.type;\\n\\n    if (isSignal(value)) {\\n      return isExpr$1(type) ? vegaUtil.error('Expression references can not be signals.')\\n           : isField(type) ? scope.fieldRef(value)\\n           : isCompare(type) ? scope.compareRef(value)\\n           : scope.signalRef(value.signal);\\n    } else {\\n      const expr = def.expr || isField(type);\\n      return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as)\\n           : expr && outerField(value) ? fieldRef(value.field, value.as)\\n           : isExpr$1(type) ? vegaFunctions.parseExpression(value, scope)\\n           : isData(type) ? ref(scope.getData(value).values)\\n           : isField(type) ? fieldRef(value)\\n           : isCompare(type) ? scope.compareRef(value)\\n           : value;\\n    }\\n  }\\n\\n  /**\\n   * Parse parameter for accessing an index of another data set.\\n   */\\n  function parseIndexParameter(def, spec, scope) {\\n    if (!vegaUtil.isString(spec.from)) {\\n      vegaUtil.error('Lookup \\\"from\\\" parameter must be a string literal.');\\n    }\\n    return scope.getData(spec.from).lookupRef(scope, spec.key);\\n  }\\n\\n  /**\\n   * Parse a parameter that contains one or more sub-parameter objects.\\n   */\\n  function parseSubParameters(def, spec, scope) {\\n    const value = spec[def.name];\\n\\n    if (def.array) {\\n      if (!vegaUtil.isArray(value)) { // signals not allowed!\\n        vegaUtil.error('Expected an array of sub-parameters. Instead: ' + vegaUtil.stringValue(value));\\n      }\\n      return value.map(v => parseSubParameter(def, v, scope));\\n    } else {\\n      return parseSubParameter(def, value, scope);\\n    }\\n  }\\n\\n  /**\\n   * Parse a sub-parameter object.\\n   */\\n  function parseSubParameter(def, value, scope) {\\n    const n =def.params.length;\\n    let pdef;\\n\\n    // loop over defs to find matching key\\n    for (let i = 0; i < n; ++i) {\\n      pdef = def.params[i];\\n      for (const k in pdef.key) {\\n        if (pdef.key[k] !== value[k]) { pdef = null; break; }\\n      }\\n      if (pdef) break;\\n    }\\n    // raise error if matching key not found\\n    if (!pdef) vegaUtil.error('Unsupported parameter: ' + vegaUtil.stringValue(value));\\n\\n    // parse params, create Params transform, return ref\\n    const params = vegaUtil.extend(parseParameters(pdef, value, scope), pdef.key);\\n    return ref(scope.add(Params(params)));\\n  }\\n\\n  // -- Utilities -----\\n\\n  const outerExpr = _ => _ && _.expr;\\n\\n  const outerField = _ => _ && _.field;\\n\\n  const isData = _ => _ === 'data';\\n\\n  const isExpr$1 = _ => _ === 'expr';\\n\\n  const isField = _ => _ === 'field';\\n\\n  const isCompare = _ => _ === 'compare';\\n\\n  function parseData(from, group, scope) {\\n    let facet, key, op, dataRef, parent;\\n\\n    // if no source data, generate singleton datum\\n    if (!from) {\\n      dataRef = ref(scope.add(Collect(null, [{}])));\\n    }\\n\\n    // if faceted, process facet specification\\n    else if (facet = from.facet) {\\n      if (!group) vegaUtil.error('Only group marks can be faceted.');\\n\\n      // use pre-faceted source data, if available\\n      if (facet.field != null) {\\n        dataRef = parent = getDataRef(facet, scope);\\n      } else {\\n        // generate facet aggregates if no direct data specification\\n        if (!from.data) {\\n          op = parseTransform(vegaUtil.extend({\\n            type:    'aggregate',\\n            groupby: vegaUtil.array(facet.groupby)\\n          }, facet.aggregate), scope);\\n          op.params.key = scope.keyRef(facet.groupby);\\n          op.params.pulse = getDataRef(facet, scope);\\n          dataRef = parent = ref(scope.add(op));\\n        } else {\\n          parent = ref(scope.getData(from.data).aggregate);\\n        }\\n\\n        key = scope.keyRef(facet.groupby, true);\\n      }\\n    }\\n\\n    // if not yet defined, get source data reference\\n    if (!dataRef) {\\n      dataRef = getDataRef(from, scope);\\n    }\\n\\n    return {\\n      key: key,\\n      pulse: dataRef,\\n      parent: parent\\n    };\\n  }\\n\\n  function getDataRef(from, scope) {\\n    return from.$ref ? from\\n      : from.data && from.data.$ref ? from.data\\n      : ref(scope.getData(from.data).output);\\n  }\\n\\n  function DataScope(scope, input, output, values, aggr) {\\n    this.scope = scope;   // parent scope object\\n    this.input = input;   // first operator in pipeline (tuple input)\\n    this.output = output; // last operator in pipeline (tuple output)\\n    this.values = values; // operator for accessing tuples (but not tuple flow)\\n\\n    // last aggregate in transform pipeline\\n    this.aggregate = aggr;\\n\\n    // lookup table of field indices\\n    this.index = {};\\n  }\\n\\n  DataScope.fromEntries = function(scope, entries) {\\n    const n = entries.length,\\n          values = entries[n-1],\\n          output = entries[n-2];\\n\\n    let input = entries[0],\\n        aggr = null,\\n        i = 1;\\n\\n    if (input && input.type === 'load') {\\n      input = entries[1];\\n    }\\n\\n    // add operator entries to this scope, wire up pulse chain\\n    scope.add(entries[0]);\\n    for (; i<n; ++i) {\\n      entries[i].params.pulse = ref(entries[i-1]);\\n      scope.add(entries[i]);\\n      if (entries[i].type === 'aggregate') aggr = entries[i];\\n    }\\n\\n    return new DataScope(scope, input, output, values, aggr);\\n  };\\n\\n  function fieldKey(field) {\\n    return vegaUtil.isString(field) ? field : null;\\n  }\\n\\n  function addSortField(scope, p, sort) {\\n    const as = aggrField(sort.op, sort.field);\\n    let s;\\n\\n    if (p.ops) {\\n      for (let i = 0, n = p.as.length; i < n; ++i) {\\n        if (p.as[i] === as) return;\\n      }\\n    } else {\\n      p.ops = ['count'];\\n      p.fields = [null];\\n      p.as = ['count'];\\n    }\\n    if (sort.op) {\\n      p.ops.push((s=sort.op.signal) ? scope.signalRef(s) : sort.op);\\n      p.fields.push(scope.fieldRef(sort.field));\\n      p.as.push(as);\\n    }\\n  }\\n\\n  function cache(scope, ds, name, optype, field, counts, index) {\\n    const cache = ds[name] || (ds[name] = {}),\\n          sort = sortKey(counts);\\n\\n    let k = fieldKey(field),\\n        v, op;\\n\\n    if (k != null) {\\n      scope = ds.scope;\\n      k = k + (sort ? '|' + sort : '');\\n      v = cache[k];\\n    }\\n\\n    if (!v) {\\n      const params = counts\\n        ? {field: keyFieldRef, pulse: ds.countsRef(scope, field, counts)}\\n        : {field: scope.fieldRef(field), pulse: ref(ds.output)};\\n      if (sort) params.sort = scope.sortRef(counts);\\n      op = scope.add(entry$1(optype, undefined, params));\\n      if (index) ds.index[field] = op;\\n      v = ref(op);\\n      if (k != null) cache[k] = v;\\n    }\\n    return v;\\n  }\\n\\n  DataScope.prototype = {\\n    countsRef(scope, field, sort) {\\n      const ds = this,\\n            cache = ds.counts || (ds.counts = {}),\\n            k = fieldKey(field);\\n\\n      let v, a, p;\\n\\n      if (k != null) {\\n        scope = ds.scope;\\n        v = cache[k];\\n      }\\n\\n      if (!v) {\\n        p = {\\n          groupby: scope.fieldRef(field, 'key'),\\n          pulse: ref(ds.output)\\n        };\\n        if (sort && sort.field) addSortField(scope, p, sort);\\n        a = scope.add(Aggregate(p));\\n        v = scope.add(Collect({pulse: ref(a)}));\\n        v = {agg: a, ref: ref(v)};\\n        if (k != null) cache[k] = v;\\n      } else if (sort && sort.field) {\\n        addSortField(scope, v.agg.params, sort);\\n      }\\n\\n      return v.ref;\\n    },\\n\\n    tuplesRef() {\\n      return ref(this.values);\\n    },\\n\\n    extentRef(scope, field) {\\n      return cache(scope, this, 'extent', 'extent', field, false);\\n    },\\n\\n    domainRef(scope, field) {\\n      return cache(scope, this, 'domain', 'values', field, false);\\n    },\\n\\n    valuesRef(scope, field, sort) {\\n      return cache(scope, this, 'vals', 'values', field, sort || true);\\n    },\\n\\n    lookupRef(scope, field) {\\n      return cache(scope, this, 'lookup', 'tupleindex', field, false);\\n    },\\n\\n    indataRef(scope, field) {\\n      return cache(scope, this, 'indata', 'tupleindex', field, true, true);\\n    }\\n  };\\n\\n  function parseFacet(spec, scope, group) {\\n    const facet = spec.from.facet,\\n          name = facet.name,\\n          data = getDataRef(facet, scope);\\n    let op;\\n\\n    if (!facet.name) {\\n      vegaUtil.error('Facet must have a name: ' + vegaUtil.stringValue(facet));\\n    }\\n    if (!facet.data) {\\n      vegaUtil.error('Facet must reference a data set: ' + vegaUtil.stringValue(facet));\\n    }\\n\\n    if (facet.field) {\\n      op = scope.add(PreFacet({\\n        field: scope.fieldRef(facet.field),\\n        pulse: data\\n      }));\\n    } else if (facet.groupby) {\\n      op = scope.add(Facet({\\n        key:   scope.keyRef(facet.groupby),\\n        group: ref(scope.proxy(group.parent)),\\n        pulse: data\\n      }));\\n    } else {\\n      vegaUtil.error('Facet must specify groupby or field: ' + vegaUtil.stringValue(facet));\\n    }\\n\\n    // initialize facet subscope\\n    const subscope = scope.fork(),\\n          source = subscope.add(Collect()),\\n          values = subscope.add(Sieve({pulse: ref(source)}));\\n    subscope.addData(name, new DataScope(subscope, source, source, values));\\n    subscope.addSignal('parent', null);\\n\\n    // parse faceted subflow\\n    op.params.subflow = {\\n      $subflow: subscope.parse(spec).toRuntime()\\n    };\\n  }\\n\\n  function parseSubflow(spec, scope, input) {\\n    const op = scope.add(PreFacet({pulse: input.pulse})),\\n          subscope = scope.fork();\\n\\n    subscope.add(Sieve());\\n    subscope.addSignal('parent', null);\\n\\n    // parse group mark subflow\\n    op.params.subflow = {\\n      $subflow: subscope.parse(spec).toRuntime()\\n    };\\n  }\\n\\n  function parseTrigger(spec, scope, name) {\\n    const remove = spec.remove,\\n          insert = spec.insert,\\n          toggle = spec.toggle,\\n          modify = spec.modify,\\n          values = spec.values,\\n          op = scope.add(operator());\\n\\n    const update = 'if(' + spec.trigger + ',modify(\\\"'\\n      + name + '\\\",'\\n      + [insert, remove, toggle, modify, values]\\n          .map(_ => _ == null ? 'null' : _)\\n          .join(',')\\n      + '),0)';\\n\\n    const expr = vegaFunctions.parseExpression(update, scope);\\n    op.update = expr.$expr;\\n    op.params = expr.$params;\\n  }\\n\\n  function parseMark(spec, scope) {\\n    const role = getRole(spec),\\n          group = spec.type === GroupMark,\\n          facet = spec.from && spec.from.facet,\\n          overlap = spec.overlap;\\n\\n    let layout = spec.layout || role === ScopeRole || role === FrameRole,\\n        ops, op, store, enc, name, layoutRef, boundRef;\\n\\n    const nested = role === MarkRole || layout || facet;\\n\\n    // resolve input data\\n    const input = parseData(spec.from, group, scope);\\n\\n    // data join to map tuples to visual items\\n    op = scope.add(DataJoin({\\n      key:   input.key || (spec.key ? fieldRef(spec.key) : undefined),\\n      pulse: input.pulse,\\n      clean: !group\\n    }));\\n    const joinRef = ref(op);\\n\\n    // collect visual items\\n    op = store = scope.add(Collect({pulse: joinRef}));\\n\\n    // connect visual items to scenegraph\\n    op = scope.add(Mark({\\n      markdef:     definition(spec),\\n      interactive: interactive(spec.interactive, scope),\\n      clip:        clip(spec.clip, scope),\\n      context:     {$context: true},\\n      groups:      scope.lookup(),\\n      parent:      scope.signals.parent ? scope.signalRef('parent') : null,\\n      index:       scope.markpath(),\\n      pulse:       ref(op)\\n    }));\\n    const markRef = ref(op);\\n\\n    // add visual encoders\\n    op = enc = scope.add(Encode(parseEncode(\\n      spec.encode, spec.type, role, spec.style, scope,\\n      {mod: false, pulse: markRef}\\n    )));\\n\\n    // monitor parent marks to propagate changes\\n    op.params.parent = scope.encode();\\n\\n    // add post-encoding transforms, if defined\\n    if (spec.transform) {\\n      spec.transform.forEach(_ => {\\n        const tx = parseTransform(_, scope),\\n              md = tx.metadata;\\n        if (md.generates || md.changes) {\\n          vegaUtil.error('Mark transforms should not generate new data.');\\n        }\\n        if (!md.nomod) enc.params.mod = true; // update encode mod handling\\n        tx.params.pulse = ref(op);\\n        scope.add(op = tx);\\n      });\\n    }\\n\\n    // if item sort specified, perform post-encoding\\n    if (spec.sort) {\\n      op = scope.add(SortItems({\\n        sort:  scope.compareRef(spec.sort),\\n        pulse: ref(op)\\n      }));\\n    }\\n\\n    const encodeRef = ref(op);\\n\\n    // add view layout operator if needed\\n    if (facet || layout) {\\n      layout = scope.add(ViewLayout({\\n        layout:   scope.objectProperty(spec.layout),\\n        legends:  scope.legends,\\n        mark:     markRef,\\n        pulse:    encodeRef\\n      }));\\n      layoutRef = ref(layout);\\n    }\\n\\n    // compute bounding boxes\\n    const bound = scope.add(Bound({mark: markRef, pulse: layoutRef || encodeRef}));\\n    boundRef = ref(bound);\\n\\n    // if group mark, recurse to parse nested content\\n    if (group) {\\n      // juggle layout & bounds to ensure they run *after* any faceting transforms\\n      if (nested) { ops = scope.operators; ops.pop(); if (layout) ops.pop(); }\\n\\n      scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\\n      facet ? parseFacet(spec, scope, input)          // explicit facet\\n          : nested ? parseSubflow(spec, scope, input) // standard mark group\\n          : scope.parse(spec); // guide group, we can avoid nested scopes\\n      scope.popState();\\n\\n      if (nested) { if (layout) ops.push(layout); ops.push(bound); }\\n    }\\n\\n    // if requested, add overlap removal transform\\n    if (overlap) {\\n      boundRef = parseOverlap(overlap, boundRef, scope);\\n    }\\n\\n    // render / sieve items\\n    const render = scope.add(Render({pulse: boundRef})),\\n          sieve = scope.add(Sieve({pulse: ref(render)}, undefined, scope.parent()));\\n\\n    // if mark is named, make accessible as reactive geometry\\n    // add trigger updates if defined\\n    if (spec.name != null) {\\n      name = spec.name;\\n      scope.addData(name, new DataScope(scope, store, render, sieve));\\n      if (spec.on) spec.on.forEach(on => {\\n        if (on.insert || on.remove || on.toggle) {\\n          vegaUtil.error('Marks only support modify triggers.');\\n        }\\n        parseTrigger(on, scope, name);\\n      });\\n    }\\n  }\\n\\n  function parseOverlap(overlap, source, scope) {\\n    const method = overlap.method,\\n          bound = overlap.bound,\\n          sep = overlap.separation;\\n\\n    const params = {\\n      separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\\n      method: isSignal(method) ? scope.signalRef(method.signal) : method,\\n      pulse:  source\\n    };\\n\\n    if (overlap.order) {\\n      params.sort = scope.compareRef({field: overlap.order});\\n    }\\n\\n    if (bound) {\\n      const tol = bound.tolerance;\\n      params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\\n      params.boundScale = scope.scaleRef(bound.scale);\\n      params.boundOrient = bound.orient;\\n    }\\n\\n    return ref(scope.add(Overlap(params)));\\n  }\\n\\n  function parseLegend(spec, scope) {\\n    const config = scope.config.legend,\\n          encode = spec.encode || {},\\n          _ = lookup(spec, config),\\n          legendEncode = encode.legend || {},\\n          name = legendEncode.name || undefined,\\n          interactive = legendEncode.interactive,\\n          style = legendEncode.style,\\n          scales = {};\\n\\n    let scale = 0, entryLayout, params, children;\\n\\n    // resolve scales and 'canonical' scale name\\n    LegendScales.forEach(s => spec[s]\\n      ? (scales[s] = spec[s], scale = scale || spec[s]) : 0\\n    );\\n    if (!scale) vegaUtil.error('Missing valid scale for legend.');\\n\\n    // resolve legend type (symbol, gradient, or discrete gradient)\\n    const type = legendType(spec, scope.scaleType(scale));\\n\\n    // single-element data source for legend group\\n    const datum = {\\n      title:  spec.title != null,\\n      scales: scales,\\n      type:   type,\\n      vgrad:  type !== 'symbol' &&  _.isVertical()\\n    };\\n    const dataRef = ref(scope.add(Collect(null, [datum])));\\n\\n    // encoding properties for legend entry sub-group\\n    const entryEncode = {enter: {x: {value: 0}, y: {value: 0}}};\\n\\n    // data source for legend values\\n    const entryRef = ref(scope.add(LegendEntries(params = {\\n      type:    type,\\n      scale:   scope.scaleRef(scale),\\n      count:   scope.objectProperty(_('tickCount')),\\n      limit:   scope.property(_('symbolLimit')),\\n      values:  scope.objectProperty(spec.values),\\n      minstep: scope.property(spec.tickMinStep),\\n      formatType: scope.property(spec.formatType),\\n      formatSpecifier: scope.property(spec.format)\\n    })));\\n\\n    // continuous gradient legend\\n    if (type === Gradient) {\\n      children = [\\n        legendGradient(spec, scale, config, encode.gradient),\\n        legendGradientLabels(spec, config, encode.labels, entryRef)\\n      ];\\n      // adjust default tick count based on the gradient length\\n      params.count = params.count || scope.signalRef(\\n        `max(2,2*floor((${deref(_.gradientLength())})/100))`\\n      );\\n    }\\n\\n    // discrete gradient legend\\n    else if (type === Discrete) {\\n      children = [\\n        legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef),\\n        legendGradientLabels(spec, config, encode.labels, entryRef)\\n      ];\\n    }\\n\\n    // symbol legend\\n    else {\\n      // determine legend symbol group layout\\n      entryLayout = legendSymbolLayout(spec, config);\\n      children = [\\n        legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))\\n      ];\\n      // pass symbol size information to legend entry generator\\n      params.size = sizeExpression(spec, scope, children[0].marks);\\n    }\\n\\n    // generate legend marks\\n    children = [\\n      guideGroup({\\n        role: LegendEntryRole,\\n        from: dataRef,\\n        encode: entryEncode,\\n        marks: children,\\n        layout: entryLayout,\\n        interactive\\n      })\\n    ];\\n\\n    // include legend title if defined\\n    if (datum.title) {\\n      children.push(legendTitle(spec, config, encode.title, dataRef));\\n    }\\n\\n    // parse legend specification\\n    return parseMark(\\n      guideGroup({\\n        role:        LegendRole,\\n        from:        dataRef,\\n        encode:      extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\\n        marks:       children,\\n        aria:        _('aria'),\\n        description: _('description'),\\n        zindex:      _('zindex'),\\n        name,\\n        interactive,\\n        style\\n      }),\\n      scope\\n    );\\n  }\\n\\n  function legendType(spec, scaleType) {\\n    let type = spec.type || Symbols;\\n\\n    if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\\n      type = vegaScale.isContinuous(scaleType) ? Gradient\\n        : vegaScale.isDiscretizing(scaleType) ? Discrete\\n        : Symbols;\\n    }\\n\\n    return type !== Gradient ? type\\n      : vegaScale.isDiscretizing(scaleType) ? Discrete\\n      : Gradient;\\n  }\\n\\n  function scaleCount(spec) {\\n    return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\\n  }\\n\\n  function buildLegendEncode(_, spec, config) {\\n    const encode = {enter: {}, update: {}};\\n\\n    addEncoders(encode, {\\n      orient:       _('orient'),\\n      offset:       _('offset'),\\n      padding:      _('padding'),\\n      titlePadding: _('titlePadding'),\\n      cornerRadius: _('cornerRadius'),\\n      fill:         _('fillColor'),\\n      stroke:       _('strokeColor'),\\n      strokeWidth:  config.strokeWidth,\\n      strokeDash:   config.strokeDash,\\n      x:            _('legendX'),\\n      y:            _('legendY'),\\n\\n      // accessibility support\\n      format:       spec.format,\\n      formatType:   spec.formatType\\n    });\\n\\n    return encode;\\n  }\\n\\n  function sizeExpression(spec, scope, marks) {\\n    const size = deref(getChannel('size', spec, marks)),\\n          strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\\n          fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\\n\\n    return vegaFunctions.parseExpression(\\n      `max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`,\\n      scope\\n    );\\n  }\\n\\n  function getChannel(name, spec, marks) {\\n    return spec[name]\\n      ? `scale(\\\"${spec[name]}\\\",datum)`\\n      : getEncoding(name, marks[0].encode);\\n  }\\n\\n  function getFontSize(encode, scope, style) {\\n    return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\\n  }\\n\\n  const angleExpr = `item.orient===\\\"${Left}\\\"?-90:item.orient===\\\"${Right}\\\"?90:0`;\\n\\n  function parseTitle(spec, scope) {\\n    spec = vegaUtil.isString(spec) ? {text: spec} : spec;\\n\\n    const _ = lookup(spec, scope.config.title),\\n          encode = spec.encode || {},\\n          userEncode = encode.group || {},\\n          name = userEncode.name || undefined,\\n          interactive = userEncode.interactive,\\n          style = userEncode.style,\\n          children = [];\\n\\n    // single-element data source for group title\\n    const datum = {},\\n          dataRef = ref(scope.add(Collect(null, [datum])));\\n\\n    // include title text\\n    children.push(buildTitle(spec, _, titleEncode(spec), dataRef));\\n\\n    // include subtitle text\\n    if (spec.subtitle) {\\n      children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\\n    }\\n\\n    // parse title specification\\n    return parseMark(\\n      guideGroup({\\n        role:        TitleRole,\\n        from:        dataRef,\\n        encode:      groupEncode(_, userEncode),\\n        marks:       children,\\n        aria:        _('aria'),\\n        description: _('description'),\\n        zindex:      _('zindex'),\\n        name,\\n        interactive,\\n        style\\n      }),\\n      scope\\n    );\\n  }\\n\\n  // provide backwards-compatibility for title custom encode;\\n  // the top-level encode block has been *deprecated*.\\n  function titleEncode(spec) {\\n    const encode = spec.encode;\\n    return (encode && encode.title) || vegaUtil.extend({\\n      name: spec.name,\\n      interactive: spec.interactive,\\n      style: spec.style\\n    }, encode);\\n  }\\n\\n  function groupEncode(_, userEncode) {\\n    const encode = {enter: {}, update: {}};\\n\\n    addEncoders(encode, {\\n      orient:      _('orient'),\\n      anchor:      _('anchor'),\\n      align:       {signal: alignExpr},\\n      angle:       {signal: angleExpr},\\n      limit:       _('limit'),\\n      frame:       _('frame'),\\n      offset:      _('offset') || 0,\\n      padding:     _('subtitlePadding')\\n    });\\n\\n    return extendEncode(encode, userEncode, Skip);\\n  }\\n\\n  function buildTitle(spec, _, userEncode, dataRef) {\\n    const zero = {value: 0},\\n          text = spec.text,\\n          encode = {\\n            enter: {opacity: zero},\\n            update: {opacity: {value: 1}},\\n            exit: {opacity: zero}\\n          };\\n\\n    addEncoders(encode, {\\n      text:       text,\\n      align:      {signal: 'item.mark.group.align'},\\n      angle:      {signal: 'item.mark.group.angle'},\\n      limit:      {signal: 'item.mark.group.limit'},\\n      baseline:   'top',\\n      dx:         _('dx'),\\n      dy:         _('dy'),\\n      fill:       _('color'),\\n      font:       _('font'),\\n      fontSize:   _('fontSize'),\\n      fontStyle:  _('fontStyle'),\\n      fontWeight: _('fontWeight'),\\n      lineHeight: _('lineHeight')\\n    }, { // update\\n      align:      _('align'),\\n      angle:      _('angle'),\\n      baseline:   _('baseline')\\n    });\\n\\n    return guideMark({\\n      type: TextMark,\\n      role: TitleTextRole,\\n      style: GroupTitleStyle,\\n      from: dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function buildSubTitle(spec, _, userEncode, dataRef) {\\n    const zero = {value: 0},\\n          text = spec.subtitle,\\n          encode = {\\n            enter: {opacity: zero},\\n            update: {opacity: {value: 1}},\\n            exit: {opacity: zero}\\n          };\\n\\n    addEncoders(encode, {\\n      text:       text,\\n      align:      {signal: 'item.mark.group.align'},\\n      angle:      {signal: 'item.mark.group.angle'},\\n      limit:      {signal: 'item.mark.group.limit'},\\n      baseline:   'top',\\n      dx:         _('dx'),\\n      dy:         _('dy'),\\n      fill:       _('subtitleColor'),\\n      font:       _('subtitleFont'),\\n      fontSize:   _('subtitleFontSize'),\\n      fontStyle:  _('subtitleFontStyle'),\\n      fontWeight: _('subtitleFontWeight'),\\n      lineHeight: _('subtitleLineHeight')\\n    }, { // update\\n      align:      _('align'),\\n      angle:      _('angle'),\\n      baseline:   _('baseline')\\n    });\\n\\n    return guideMark({\\n      type:  TextMark,\\n      role:  TitleSubtitleRole,\\n      style: GroupSubtitleStyle,\\n      from:  dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function parseData$1(data, scope) {\\n    const transforms = [];\\n\\n    if (data.transform) {\\n      data.transform.forEach(tx => {\\n        transforms.push(parseTransform(tx, scope));\\n      });\\n    }\\n\\n    if (data.on) {\\n      data.on.forEach(on => {\\n        parseTrigger(on, scope, data.name);\\n      });\\n    }\\n\\n    scope.addDataPipeline(data.name, analyze(data, scope, transforms));\\n  }\\n\\n  /**\\n   * Analyze a data pipeline, add needed operators.\\n   */\\n  function analyze(data, scope, ops) {\\n    const output = [];\\n    let source = null,\\n        modify = false,\\n        generate = false,\\n        upstream, i, n, t, m;\\n\\n    if (data.values) {\\n      // hard-wired input data set\\n      if (hasSignal(data.values) || hasSignal(data.format)) {\\n        // if either values or format has signal, use dynamic loader\\n        output.push(load(scope, data));\\n        output.push(source = collect());\\n      } else {\\n        // otherwise, ingest upon dataflow init\\n        output.push(source = collect({\\n          $ingest: data.values,\\n          $format: data.format\\n        }));\\n      }\\n    } else if (data.url) {\\n      // load data from external source\\n      if (hasSignal(data.url) || hasSignal(data.format)) {\\n        // if either url or format has signal, use dynamic loader\\n        output.push(load(scope, data));\\n        output.push(source = collect());\\n      } else {\\n        // otherwise, request load upon dataflow init\\n        output.push(source = collect({\\n          $request: data.url,\\n          $format: data.format\\n        }));\\n      }\\n    } else if (data.source) {\\n      // derives from one or more other data sets\\n      source = upstream = vegaUtil.array(data.source)\\n        .map(d => ref(scope.getData(d).output));\\n      output.push(null); // populate later\\n    }\\n\\n    // scan data transforms, add collectors as needed\\n    for (i=0, n=ops.length; i<n; ++i) {\\n      t = ops[i];\\n      m = t.metadata;\\n\\n      if (!source && !m.source) {\\n        output.push(source = collect());\\n      }\\n      output.push(t);\\n\\n      if (m.generates) generate = true;\\n      if (m.modifies && !generate) modify = true;\\n\\n      if (m.source) source = t;\\n      else if (m.changes) source = null;\\n    }\\n\\n    if (upstream) {\\n      n = upstream.length - 1;\\n      output[0] = Relay({\\n        derive: modify,\\n        pulse: n ? upstream : upstream[0]\\n      });\\n      if (modify || n) {\\n        // collect derived and multi-pulse tuples\\n        output.splice(1, 0, collect());\\n      }\\n    }\\n\\n    if (!source) output.push(collect());\\n    output.push(Sieve({}));\\n    return output;\\n  }\\n\\n  function collect(values) {\\n    const s = Collect({}, values);\\n    s.metadata = {source: true};\\n    return s;\\n  }\\n\\n  function load(scope, data) {\\n    return Load({\\n      url:    data.url ? scope.property(data.url) : undefined,\\n      async:  data.async ? scope.property(data.async) : undefined,\\n      values: data.values ? scope.property(data.values) : undefined,\\n      format: scope.objectProperty(data.format)\\n    });\\n  }\\n\\n  const isX = orient => orient === Bottom || orient === Top;\\n\\n  // get sign coefficient based on axis orient\\n  const getSign = (orient, a, b) => isSignal(orient)\\n    ? ifLeftTopExpr(orient.signal, a, b)\\n    : orient === Left || orient === Top ? a : b;\\n\\n  // condition on axis x-direction\\n  const ifX = (orient, a, b) => isSignal(orient)\\n    ? ifXEnc(orient.signal, a, b)\\n    : isX(orient) ? a : b;\\n\\n  // condition on axis y-direction\\n  const ifY = (orient, a, b) => isSignal(orient)\\n    ? ifYEnc(orient.signal, a, b)\\n    : isX(orient) ? b : a;\\n\\n  const ifTop = (orient, a, b) => isSignal(orient)\\n    ? ifTopExpr(orient.signal, a, b)\\n    : orient === Top ? {value: a} : {value: b};\\n\\n  const ifRight = (orient, a, b) => isSignal(orient)\\n    ? ifRightExpr(orient.signal, a, b)\\n    : orient === Right ? {value: a} : {value: b};\\n\\n  const ifXEnc = ($orient, a, b) => ifEnc(\\n    `${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b\\n  );\\n\\n  const ifYEnc = ($orient, a, b) => ifEnc(\\n    `${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b\\n  );\\n\\n  const ifLeftTopExpr = ($orient, a, b) => ifExpr(\\n    `${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b\\n  );\\n\\n  const ifTopExpr = ($orient, a, b) => ifExpr(\\n    `${$orient} === '${Top}'`, a, b\\n  );\\n\\n  const ifRightExpr = ($orient, a, b) => ifExpr(\\n    `${$orient} === '${Right}'`, a, b\\n  );\\n\\n  const ifEnc = (test, a, b) => {\\n    // ensure inputs are encoder objects (or null)\\n    a = a != null ? encoder(a) : a;\\n    b = b != null ? encoder(b) : b;\\n\\n    if (isSimple(a) && isSimple(b)) {\\n      // if possible generate simple signal expression\\n      a = a ? (a.signal || vegaUtil.stringValue(a.value)) : null;\\n      b = b ? (b.signal || vegaUtil.stringValue(b.value)) : null;\\n      return {signal: `${test} ? (${a}) : (${b})`};\\n    } else {\\n      // otherwise generate rule set\\n      return [vegaUtil.extend({test}, a)].concat(b || []);\\n    }\\n  };\\n\\n  const isSimple = enc => (\\n    enc == null || Object.keys(enc).length === 1\\n  );\\n\\n  const ifExpr = (test, a, b) => ({\\n    signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\\n  });\\n\\n  const ifOrient = ($orient, t, b, l, r) => ({\\n    signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '')\\n          + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '')\\n          + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '')\\n          + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '')\\n          + '(null)'\\n  });\\n\\n  const toExpr = v => isSignal(v)\\n    ? v.signal\\n    : v == null ? null : vegaUtil.stringValue(v);\\n\\n  const mult = (sign, value) => value === 0 ? 0 : isSignal(sign)\\n    ? {signal: `(${sign.signal}) * ${value}`}\\n    : {value: sign * value};\\n\\n  const patch = (value, base) => {\\n    const s = value.signal;\\n    return s && s.endsWith('(null)')\\n      ? {signal: s.slice(0, -6) + base.signal}\\n      : value;\\n  };\\n\\n  function fallback(prop, config, axisConfig, style) {\\n    let styleProp;\\n\\n    if (config && vegaUtil.hasOwnProperty(config, prop)) {\\n      return config[prop];\\n    }\\n    else if (vegaUtil.hasOwnProperty(axisConfig, prop)) {\\n      return axisConfig[prop];\\n    }\\n    else if (prop.startsWith('title')) {\\n      switch (prop) {\\n        case 'titleColor':\\n          styleProp = 'fill';\\n          break;\\n        case 'titleFont':\\n        case 'titleFontSize':\\n        case 'titleFontWeight':\\n          styleProp = prop[5].toLowerCase() + prop.slice(6);\\n      }\\n      return style[GuideTitleStyle][styleProp];\\n    }\\n    else if (prop.startsWith('label')) {\\n      switch (prop) {\\n        case 'labelColor':\\n          styleProp = 'fill';\\n          break;\\n        case 'labelFont':\\n        case 'labelFontSize':\\n          styleProp = prop[5].toLowerCase() + prop.slice(6);\\n      }\\n      return style[GuideLabelStyle][styleProp];\\n    }\\n\\n    return null;\\n  }\\n\\n  function keys(objects) {\\n    const map = {};\\n    for (const obj of objects) {\\n      if (!obj) continue;\\n      for (const key in obj) map[key] = 1;\\n    }\\n    return Object.keys(map);\\n  }\\n\\n  function axisConfig(spec, scope) {\\n    var config = scope.config,\\n        style = config.style,\\n        axis = config.axis,\\n        band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\\n        orient = spec.orient,\\n        xy, or, key;\\n\\n    if (isSignal(orient)) {\\n      const xyKeys = keys([\\n              config.axisX, config.axisY\\n            ]),\\n            orientKeys = keys([\\n              config.axisTop, config.axisBottom,\\n              config.axisLeft, config.axisRight\\n            ]);\\n\\n      xy = {};\\n      for (key of xyKeys) {\\n        xy[key] = ifX(\\n          orient,\\n          fallback(key, config.axisX, axis, style),\\n          fallback(key, config.axisY, axis, style)\\n        );\\n      }\\n\\n      or = {};\\n      for (key of orientKeys) {\\n        or[key] = ifOrient(\\n          orient.signal,\\n          fallback(key, config.axisTop, axis, style),\\n          fallback(key, config.axisBottom, axis, style),\\n          fallback(key, config.axisLeft, axis, style),\\n          fallback(key, config.axisRight, axis, style)\\n        );\\n      }\\n    } else {\\n      xy = (orient === Top || orient === Bottom) ? config.axisX : config.axisY;\\n      or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\\n    }\\n\\n    var result = (xy || or || band)\\n      ? vegaUtil.extend({}, axis, xy, or, band)\\n      : axis;\\n\\n    return result;\\n  }\\n\\n  function axisDomain(spec, config, userEncode, dataRef) {\\n    const _ = lookup(spec, config),\\n          orient = spec.orient;\\n\\n    let enter, update;\\n    const encode = {\\n      enter: enter = {opacity: zero},\\n      update: update = {opacity: one},\\n      exit: {opacity: zero}\\n    };\\n\\n    addEncoders(encode, {\\n      stroke:           _('domainColor'),\\n      strokeCap:        _('domainCap'),\\n      strokeDash:       _('domainDash'),\\n      strokeDashOffset: _('domainDashOffset'),\\n      strokeWidth:      _('domainWidth'),\\n      strokeOpacity:    _('domainOpacity')\\n    });\\n\\n    const pos0 = position(spec, 0);\\n    const pos1 = position(spec, 1);\\n\\n    enter.x = update.x = ifX(orient, pos0, zero);\\n    enter.x2 = update.x2 = ifX(orient, pos1);\\n\\n    enter.y = update.y = ifY(orient, pos0, zero);\\n    enter.y2 = update.y2 = ifY(orient, pos1);\\n\\n    return guideMark({\\n      type: RuleMark,\\n      role: AxisDomainRole,\\n      from: dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function position(spec, pos) {\\n    return {scale: spec.scale, range: pos};\\n  }\\n\\n  function axisGrid(spec, config, userEncode, dataRef, band) {\\n    const _ = lookup(spec, config),\\n          orient = spec.orient,\\n          vscale = spec.gridScale,\\n          sign = getSign(orient, 1, -1),\\n          offset = offsetValue(spec.offset, sign);\\n\\n    let enter, exit, update;\\n    const encode = {\\n      enter: enter = {opacity: zero},\\n      update: update = {opacity: one},\\n      exit: exit = {opacity: zero}\\n    };\\n\\n    addEncoders(encode, {\\n      stroke:           _('gridColor'),\\n      strokeCap:        _('gridCap'),\\n      strokeDash:       _('gridDash'),\\n      strokeDashOffset: _('gridDashOffset'),\\n      strokeOpacity:    _('gridOpacity'),\\n      strokeWidth:      _('gridWidth')\\n    });\\n\\n    const tickPos = {\\n      scale:  spec.scale,\\n      field:  Value,\\n      band:   band.band,\\n      extra:  band.extra,\\n      offset: band.offset,\\n      round:  _('tickRound')\\n    };\\n\\n    const sz = ifX(orient, {signal: 'height'}, {signal: 'width'});\\n\\n    const gridStart = vscale\\n      ? {scale: vscale, range: 0, mult: sign, offset: offset}\\n      : {value: 0, offset: offset};\\n\\n    const gridEnd = vscale\\n      ? {scale: vscale, range: 1, mult: sign, offset: offset}\\n      : vegaUtil.extend(sz, {mult: sign, offset: offset});\\n\\n    enter.x = update.x = ifX(orient, tickPos, gridStart);\\n    enter.y = update.y = ifY(orient, tickPos, gridStart);\\n    enter.x2 = update.x2 = ifY(orient, gridEnd);\\n    enter.y2 = update.y2 = ifX(orient, gridEnd);\\n    exit.x = ifX(orient, tickPos);\\n    exit.y = ifY(orient, tickPos);\\n\\n    return guideMark({\\n      type: RuleMark,\\n      role: AxisGridRole,\\n      key:  Value,\\n      from: dataRef,\\n      encode\\n     }, userEncode);\\n  }\\n\\n  function offsetValue(offset, sign)  {\\n    if (sign === 1) ; else if (!vegaUtil.isObject(offset)) {\\n      offset = isSignal(sign)\\n        ? {signal: `(${sign.signal}) * (${offset || 0})`}\\n        : sign * (offset || 0);\\n    } else {\\n      let entry = offset = vegaUtil.extend({}, offset);\\n      while (entry.mult != null) {\\n        if (!vegaUtil.isObject(entry.mult)) {\\n          entry.mult = isSignal(sign) // no offset if sign === 1\\n            ? {signal: `(${entry.mult}) * (${sign.signal})`}\\n            : entry.mult * sign;\\n          return offset;\\n        } else {\\n          entry = entry.mult = vegaUtil.extend({}, entry.mult);\\n        }\\n      }\\n      entry.mult = sign;\\n    }\\n\\n    return offset;\\n  }\\n\\n  function axisTicks(spec, config, userEncode, dataRef, size, band) {\\n    const _ = lookup(spec, config),\\n          orient = spec.orient,\\n          sign = getSign(orient, -1, 1);\\n\\n    let enter, exit, update;\\n    const encode = {\\n      enter: enter = {opacity: zero},\\n      update: update = {opacity: one},\\n      exit: exit = {opacity: zero}\\n    };\\n\\n    addEncoders(encode, {\\n      stroke:           _('tickColor'),\\n      strokeCap:        _('tickCap'),\\n      strokeDash:       _('tickDash'),\\n      strokeDashOffset: _('tickDashOffset'),\\n      strokeOpacity:    _('tickOpacity'),\\n      strokeWidth:      _('tickWidth')\\n    });\\n\\n    const tickSize = encoder(size);\\n    tickSize.mult = sign;\\n\\n    const tickPos = {\\n      scale:  spec.scale,\\n      field:  Value,\\n      band:   band.band,\\n      extra:  band.extra,\\n      offset: band.offset,\\n      round:  _('tickRound')\\n    };\\n\\n    update.y = enter.y = ifX(orient, zero, tickPos);\\n    update.y2 = enter.y2 = ifX(orient, tickSize);\\n    exit.x = ifX(orient, tickPos);\\n\\n    update.x = enter.x = ifY(orient, zero, tickPos);\\n    update.x2 = enter.x2 = ifY(orient, tickSize);\\n    exit.y = ifY(orient, tickPos);\\n\\n    return guideMark({\\n      type: RuleMark,\\n      role: AxisTickRole,\\n      key:  Value,\\n      from: dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function flushExpr(scale, threshold, a, b, c) {\\n    return {\\n      signal: 'flush(range(\\\"' + scale + '\\\"), '\\n        + 'scale(\\\"' + scale + '\\\", datum.value), '\\n        + threshold + ',' + a + ',' + b + ',' + c + ')'\\n    };\\n  }\\n\\n  function axisLabels(spec, config, userEncode, dataRef, size, band) {\\n    const _ = lookup(spec, config),\\n          orient = spec.orient,\\n          scale = spec.scale,\\n          sign = getSign(orient, -1, 1),\\n          flush = deref(_('labelFlush')),\\n          flushOffset = deref(_('labelFlushOffset')),\\n          labelAlign = _('labelAlign'),\\n          labelBaseline = _('labelBaseline');\\n\\n    let flushOn = flush === 0 || !!flush,\\n        update;\\n\\n    const tickSize = encoder(size);\\n    tickSize.mult = sign;\\n    tickSize.offset = encoder(_('labelPadding') || 0);\\n    tickSize.offset.mult = sign;\\n\\n    const tickPos = {\\n      scale:  scale,\\n      field:  Value,\\n      band:   0.5,\\n      offset: extendOffset(band.offset, _('labelOffset'))\\n    };\\n\\n    const align = ifX(orient,\\n      flushOn\\n        ? flushExpr(scale, flush, '\\\"left\\\"', '\\\"right\\\"', '\\\"center\\\"')\\n        : {value: 'center'},\\n      ifRight(orient, 'left', 'right')\\n    );\\n\\n    const baseline = ifX(orient,\\n      ifTop(orient, 'bottom', 'top'),\\n      flushOn\\n        ? flushExpr(scale, flush, '\\\"top\\\"', '\\\"bottom\\\"', '\\\"middle\\\"')\\n        : {value: 'middle'}\\n    );\\n\\n    const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\\n    flushOn = flushOn && flushOffset;\\n\\n    const enter = {\\n      opacity: zero,\\n      x: ifX(orient, tickPos, tickSize),\\n      y: ifY(orient, tickPos, tickSize)\\n    };\\n\\n    const encode = {\\n      enter: enter,\\n      update: update = {\\n        opacity: one,\\n        text: {field: Label},\\n        x: enter.x,\\n        y: enter.y,\\n        align,\\n        baseline\\n      },\\n      exit: {\\n        opacity: zero,\\n        x: enter.x,\\n        y: enter.y\\n      }\\n    };\\n\\n    addEncoders(encode, {\\n      dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\\n      dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\\n    });\\n\\n    addEncoders(encode, {\\n      angle:       _('labelAngle'),\\n      fill:        _('labelColor'),\\n      fillOpacity: _('labelOpacity'),\\n      font:        _('labelFont'),\\n      fontSize:    _('labelFontSize'),\\n      fontWeight:  _('labelFontWeight'),\\n      fontStyle:   _('labelFontStyle'),\\n      limit:       _('labelLimit'),\\n      lineHeight:  _('labelLineHeight')\\n    }, {\\n      align:       labelAlign,\\n      baseline:    labelBaseline\\n    });\\n\\n    const bound   = _('labelBound');\\n    let overlap = _('labelOverlap');\\n\\n    // if overlap method or bound defined, request label overlap removal\\n    overlap = overlap || bound ? {\\n      separation: _('labelSeparation'),\\n      method: overlap,\\n      order: 'datum.index',\\n      bound: bound ? {scale, orient, tolerance: bound} : null\\n    } : undefined;\\n\\n    if (update.align !== align) {\\n      update.align = patch(update.align, align);\\n    }\\n    if (update.baseline !== baseline) {\\n      update.baseline = patch(update.baseline, baseline);\\n    }\\n\\n    return guideMark({\\n      type:  TextMark,\\n      role:  AxisLabelRole,\\n      style: GuideLabelStyle,\\n      key:   Value,\\n      from:  dataRef,\\n      encode,\\n      overlap\\n    }, userEncode);\\n  }\\n\\n  function axisTitle(spec, config, userEncode, dataRef) {\\n    const _ = lookup(spec, config),\\n          orient = spec.orient,\\n          sign = getSign(orient, -1, 1);\\n\\n    let enter, update;\\n    const encode = {\\n      enter: enter = {\\n        opacity: zero,\\n        anchor: encoder(_('titleAnchor', null)),\\n        align: {signal: alignExpr}\\n      },\\n      update: update = vegaUtil.extend({}, enter, {\\n        opacity: one,\\n        text: encoder(spec.title)\\n      }),\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n\\n    const titlePos = {\\n      signal: `lerp(range(\\\"${spec.scale}\\\"), ${anchorExpr(0, 1, 0.5)})`\\n    };\\n\\n    update.x = ifX(orient, titlePos);\\n    update.y = ifY(orient, titlePos);\\n    enter.angle = ifX(orient, zero, mult(sign, 90));\\n    enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {value: Bottom});\\n    update.angle = enter.angle;\\n    update.baseline = enter.baseline;\\n\\n    addEncoders(encode, {\\n      fill:        _('titleColor'),\\n      fillOpacity: _('titleOpacity'),\\n      font:        _('titleFont'),\\n      fontSize:    _('titleFontSize'),\\n      fontStyle:   _('titleFontStyle'),\\n      fontWeight:  _('titleFontWeight'),\\n      limit:       _('titleLimit'),\\n      lineHeight:  _('titleLineHeight')\\n    }, { // require update\\n      align:       _('titleAlign'),\\n      angle:       _('titleAngle'),\\n      baseline:    _('titleBaseline')\\n    });\\n\\n    autoLayout(_, orient, encode, userEncode);\\n    encode.update.align = patch(encode.update.align, enter.align);\\n    encode.update.angle = patch(encode.update.angle, enter.angle);\\n    encode.update.baseline = patch(encode.update.baseline, enter.baseline);\\n\\n    return guideMark({\\n      type:  TextMark,\\n      role:  AxisTitleRole,\\n      style: GuideTitleStyle,\\n      from:  dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function autoLayout(_, orient, encode, userEncode) {\\n    const auto = (value, dim) => value != null\\n      ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false)\\n      : !has(dim, userEncode) ? true : false;\\n\\n    const autoY = auto(_('titleX'), 'x'),\\n          autoX = auto(_('titleY'), 'y');\\n\\n    encode.enter.auto = autoX === autoY\\n      ? encoder(autoX)\\n      : ifX(orient, encoder(autoX), encoder(autoY));\\n  }\\n\\n  function parseAxis(spec, scope) {\\n    const config = axisConfig(spec, scope),\\n          encode = spec.encode || {},\\n          axisEncode = encode.axis || {},\\n          name = axisEncode.name || undefined,\\n          interactive = axisEncode.interactive,\\n          style = axisEncode.style,\\n          _ = lookup(spec, config),\\n          band = tickBand(_);\\n\\n    // single-element data source for axis group\\n    const datum = {\\n      scale:  spec.scale,\\n      ticks:  !!_('ticks'),\\n      labels: !!_('labels'),\\n      grid:   !!_('grid'),\\n      domain: !!_('domain'),\\n      title:  spec.title != null\\n    };\\n    const dataRef = ref(scope.add(Collect({}, [datum])));\\n\\n    // data source for axis ticks\\n    const ticksRef = ref(scope.add(AxisTicks({\\n      scale:   scope.scaleRef(spec.scale),\\n      extra:   scope.property(band.extra),\\n      count:   scope.objectProperty(spec.tickCount),\\n      values:  scope.objectProperty(spec.values),\\n      minstep: scope.property(spec.tickMinStep),\\n      formatType: scope.property(spec.formatType),\\n      formatSpecifier: scope.property(spec.format)\\n    })));\\n\\n    // generate axis marks\\n    const children = [];\\n    let size;\\n\\n    // include axis gridlines if requested\\n    if (datum.grid) {\\n      children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\\n    }\\n\\n    // include axis ticks if requested\\n    if (datum.ticks) {\\n      size = _('tickSize');\\n      children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\\n    }\\n\\n    // include axis labels if requested\\n    if (datum.labels) {\\n      size = datum.ticks ? size : 0;\\n      children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\\n    }\\n\\n    // include axis domain path if requested\\n    if (datum.domain) {\\n      children.push(axisDomain(spec, config, encode.domain, dataRef));\\n    }\\n\\n    // include axis title if defined\\n    if (datum.title) {\\n      children.push(axisTitle(spec, config, encode.title, dataRef));\\n    }\\n\\n    // parse axis specification\\n    return parseMark(\\n      guideGroup({\\n        role:        AxisRole,\\n        from:        dataRef,\\n        encode:      extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\\n        marks:       children,\\n        aria:        _('aria'),\\n        description: _('description'),\\n        zindex:      _('zindex'),\\n        name,\\n        interactive,\\n        style\\n      }),\\n      scope\\n    );\\n  }\\n\\n  function buildAxisEncode(_, spec) {\\n    const encode = {enter: {}, update: {}};\\n\\n    addEncoders(encode, {\\n      orient:       _('orient'),\\n      offset:       _('offset') || 0,\\n      position:     value(spec.position, 0),\\n      titlePadding: _('titlePadding'),\\n      minExtent:    _('minExtent'),\\n      maxExtent:    _('maxExtent'),\\n      range:        {signal: `abs(span(range(\\\"${spec.scale}\\\")))`},\\n      translate:    _('translate'),\\n\\n      // accessibility support\\n      format:       spec.format,\\n      formatType:   spec.formatType\\n    });\\n\\n    return encode;\\n  }\\n\\n  function parseScope(spec, scope, preprocessed) {\\n    const signals = vegaUtil.array(spec.signals),\\n          scales = vegaUtil.array(spec.scales);\\n\\n    // parse signal definitions, if not already preprocessed\\n    if (!preprocessed) signals.forEach(_ => parseSignal(_, scope));\\n\\n    // parse cartographic projection definitions\\n    vegaUtil.array(spec.projections).forEach(_ => parseProjection(_, scope));\\n\\n    // initialize scale references\\n    scales.forEach(_ => initScale(_, scope));\\n\\n    // parse data sources\\n    vegaUtil.array(spec.data).forEach(_ => parseData$1(_, scope));\\n\\n    // parse scale definitions\\n    scales.forEach(_ => parseScale(_, scope));\\n\\n    // parse signal updates\\n    (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope));\\n\\n    // parse axis definitions\\n    vegaUtil.array(spec.axes).forEach(_ => parseAxis(_, scope));\\n\\n    // parse mark definitions\\n    vegaUtil.array(spec.marks).forEach(_ => parseMark(_, scope));\\n\\n    // parse legend definitions\\n    vegaUtil.array(spec.legends).forEach(_ => parseLegend(_, scope));\\n\\n    // parse title, if defined\\n    if (spec.title) parseTitle(spec.title, scope);\\n\\n    // parse collected lambda (anonymous) expressions\\n    scope.parseLambdas();\\n\\n    return scope;\\n  }\\n\\n  const rootEncode = spec => extendEncode(\\n    {\\n      enter: {\\n        x: {value: 0},\\n        y: {value: 0}\\n      },\\n      update: {\\n        width: {signal: 'width'},\\n        height: {signal: 'height'}\\n      }\\n    },\\n    spec\\n  );\\n\\n  function parseView(spec, scope) {\\n    const config = scope.config;\\n\\n    // add scenegraph root\\n    const root = ref(scope.root = scope.add(operator()));\\n\\n    // parse top-level signal definitions\\n    const signals = collectSignals(spec, config);\\n    signals.forEach(_ => parseSignal(_, scope));\\n\\n    // assign description, event, legend, and locale configuration\\n    scope.description = spec.description || config.description;\\n    scope.eventConfig = config.events;\\n    scope.legends = scope.objectProperty(config.legend && config.legend.layout);\\n    scope.locale = config.locale;\\n\\n    // store root group item\\n    const input = scope.add(Collect());\\n\\n    // encode root group item\\n    const encode = scope.add(Encode(parseEncode(\\n      rootEncode(spec.encode), GroupMark, FrameRole,\\n      spec.style, scope, {pulse: ref(input)}\\n    )));\\n\\n    // perform view layout\\n    const parent = scope.add(ViewLayout({\\n      layout:   scope.objectProperty(spec.layout),\\n      legends:  scope.legends,\\n      autosize: scope.signalRef('autosize'),\\n      mark:     root,\\n      pulse:    ref(encode)\\n    }));\\n    scope.operators.pop();\\n\\n    // parse remainder of specification\\n    scope.pushState(ref(encode), ref(parent), null);\\n    parseScope(spec, scope, signals);\\n    scope.operators.push(parent);\\n\\n    // bound / render / sieve root item\\n    let op = scope.add(Bound({mark: root, pulse: ref(parent)}));\\n    op = scope.add(Render({pulse: ref(op)}));\\n    op = scope.add(Sieve({pulse: ref(op)}));\\n\\n    // track metadata for root item\\n    scope.addData('root', new DataScope(scope, input, input, op));\\n\\n    return scope;\\n  }\\n\\n  function signalObject(name, value) {\\n    return value && value.signal\\n      ? { name, update: value.signal }\\n      : { name, value };\\n  }\\n\\n  /**\\n   * Collect top-level signals, merging values as needed. Signals\\n   * defined in the config signals arrays are added only if that\\n   * signal is not explicitly defined in the specification.\\n   * Built-in signals (autosize, background, padding, width, height)\\n   * receive special treatment. They are initialized using the\\n   * top-level spec property, or, if undefined in the spec, using\\n   * the corresponding top-level config property. If this property\\n   * is a signal reference object, the signal expression maps to the\\n   * signal 'update' property. If the spec's top-level signal array\\n   * contains an entry that matches a built-in signal, that entry\\n   * will be merged with the built-in specification, potentially\\n   * overwriting existing 'value' or 'update' properties.\\n   */\\n  function collectSignals(spec, config) {\\n    const _ = name => value(spec[name], config[name]),\\n          signals = [\\n            signalObject('background', _('background')),\\n            signalObject('autosize', parseAutosize(_('autosize'))),\\n            signalObject('padding', parsePadding(_('padding'))),\\n            signalObject('width', _('width') || 0),\\n            signalObject('height', _('height') || 0)\\n          ],\\n          pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\\n          map = {};\\n\\n    // add spec signal array\\n    vegaUtil.array(spec.signals).forEach(s => {\\n      if (vegaUtil.hasOwnProperty(pre, s.name)) {\\n        // merge if built-in signal\\n        s = vegaUtil.extend(pre[s.name], s);\\n      } else {\\n        // otherwise add to signal list\\n        signals.push(s);\\n      }\\n      map[s.name] = s;\\n    });\\n\\n    // add config signal array\\n    vegaUtil.array(config.signals).forEach(s => {\\n      if (!vegaUtil.hasOwnProperty(map, s.name) && !vegaUtil.hasOwnProperty(pre, s.name)) {\\n        // add to signal list if not already defined\\n        signals.push(s);\\n      }\\n    });\\n\\n    return signals;\\n  }\\n\\n  function Scope$1(config, options) {\\n    this.config = config || {};\\n    this.options = options || {};\\n\\n    this.bindings = [];\\n    this.field = {};\\n    this.signals = {};\\n    this.lambdas = {};\\n    this.scales = {};\\n    this.events = {};\\n    this.data = {};\\n\\n    this.streams = [];\\n    this.updates = [];\\n    this.operators = [];\\n    this.eventConfig = null;\\n    this.locale = null;\\n\\n    this._id = 0;\\n    this._subid = 0;\\n    this._nextsub = [0];\\n\\n    this._parent = [];\\n    this._encode = [];\\n    this._lookup = [];\\n    this._markpath = [];\\n  }\\n\\n  function Subscope(scope) {\\n    this.config = scope.config;\\n    this.options = scope.options;\\n    this.legends = scope.legends;\\n\\n    this.field = Object.create(scope.field);\\n    this.signals = Object.create(scope.signals);\\n    this.lambdas = Object.create(scope.lambdas);\\n    this.scales = Object.create(scope.scales);\\n    this.events = Object.create(scope.events);\\n    this.data = Object.create(scope.data);\\n\\n    this.streams = [];\\n    this.updates = [];\\n    this.operators = [];\\n\\n    this._id = 0;\\n    this._subid = ++scope._nextsub[0];\\n    this._nextsub = scope._nextsub;\\n\\n    this._parent = scope._parent.slice();\\n    this._encode = scope._encode.slice();\\n    this._lookup = scope._lookup.slice();\\n    this._markpath = scope._markpath;\\n  }\\n\\n  Scope$1.prototype = Subscope.prototype = {\\n    parse(spec) {\\n      return parseScope(spec, this);\\n    },\\n\\n    fork() {\\n      return new Subscope(this);\\n    },\\n\\n    isSubscope() {\\n      return this._subid > 0;\\n    },\\n\\n    toRuntime() {\\n      this.finish();\\n      return {\\n        description: this.description,\\n        operators:   this.operators,\\n        streams:     this.streams,\\n        updates:     this.updates,\\n        bindings:    this.bindings,\\n        eventConfig: this.eventConfig,\\n        locale:      this.locale\\n      };\\n    },\\n\\n    id() {\\n      return (this._subid ? this._subid + ':' : 0) + this._id++;\\n    },\\n\\n    add(op) {\\n      this.operators.push(op);\\n      op.id = this.id();\\n      // if pre-registration references exist, resolve them now\\n      if (op.refs) {\\n        op.refs.forEach(ref => { ref.$ref = op.id; });\\n        op.refs = null;\\n      }\\n      return op;\\n    },\\n\\n    proxy(op) {\\n      const vref = op instanceof Entry ? ref(op) : op;\\n      return this.add(Proxy({value: vref}));\\n    },\\n\\n    addStream(stream) {\\n      this.streams.push(stream);\\n      stream.id = this.id();\\n      return stream;\\n    },\\n\\n    addUpdate(update) {\\n      this.updates.push(update);\\n      return update;\\n    },\\n\\n    // Apply metadata\\n    finish() {\\n      let name, ds;\\n\\n      // annotate root\\n      if (this.root) this.root.root = true;\\n\\n      // annotate signals\\n      for (name in this.signals) {\\n        this.signals[name].signal = name;\\n      }\\n\\n      // annotate scales\\n      for (name in this.scales) {\\n        this.scales[name].scale = name;\\n      }\\n\\n      // annotate data sets\\n      function annotate(op, name, type) {\\n        let data, list;\\n        if (op) {\\n          data = op.data || (op.data = {});\\n          list = data[name] || (data[name] = []);\\n          list.push(type);\\n        }\\n      }\\n      for (name in this.data) {\\n        ds = this.data[name];\\n        annotate(ds.input,  name, 'input');\\n        annotate(ds.output, name, 'output');\\n        annotate(ds.values, name, 'values');\\n        for (const field in ds.index) {\\n          annotate(ds.index[field], name, 'index:' + field);\\n        }\\n      }\\n\\n      return this;\\n    },\\n\\n    // ----\\n\\n    pushState(encode, parent, lookup) {\\n      this._encode.push(ref(this.add(Sieve({pulse: encode}))));\\n      this._parent.push(parent);\\n      this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\\n      this._markpath.push(-1);\\n    },\\n\\n    popState() {\\n      this._encode.pop();\\n      this._parent.pop();\\n      this._lookup.pop();\\n      this._markpath.pop();\\n    },\\n\\n    parent() {\\n      return vegaUtil.peek(this._parent);\\n    },\\n\\n    encode() {\\n      return vegaUtil.peek(this._encode);\\n    },\\n\\n    lookup() {\\n      return vegaUtil.peek(this._lookup);\\n    },\\n\\n    markpath() {\\n      const p = this._markpath;\\n      return ++p[p.length-1];\\n    },\\n\\n    // ----\\n\\n    fieldRef(field, name) {\\n      if (vegaUtil.isString(field)) return fieldRef(field, name);\\n      if (!field.signal) {\\n        vegaUtil.error('Unsupported field reference: ' + vegaUtil.stringValue(field));\\n      }\\n\\n      const s = field.signal;\\n      let f = this.field[s];\\n\\n      if (!f) {\\n        const params = {name: this.signalRef(s)};\\n        if (name) params.as = name;\\n        this.field[s] = f = ref(this.add(Field(params)));\\n      }\\n      return f;\\n    },\\n\\n    compareRef(cmp) {\\n      let signal = false;\\n\\n      const check = _ => isSignal(_)\\n        ? (signal = true, this.signalRef(_.signal))\\n        : isExpr(_) ? (signal = true, this.exprRef(_.expr))\\n        : _;\\n\\n      const fields = vegaUtil.array(cmp.field).map(check),\\n            orders = vegaUtil.array(cmp.order).map(check);\\n\\n      return signal\\n        ? ref(this.add(Compare({fields: fields, orders: orders})))\\n        : compareRef(fields, orders);\\n    },\\n\\n    keyRef(fields, flat) {\\n      let signal = false;\\n\\n      const check = _ => isSignal(_)\\n        ? (signal = true, ref(sig[_.signal]))\\n        : _;\\n\\n      const sig = this.signals;\\n      fields = vegaUtil.array(fields).map(check);\\n\\n      return signal\\n        ? ref(this.add(Key({fields: fields, flat: flat})))\\n        : keyRef(fields, flat);\\n    },\\n\\n    sortRef(sort) {\\n      if (!sort) return sort;\\n\\n      // including id ensures stable sorting\\n      const a = aggrField(sort.op, sort.field),\\n           o = sort.order || Ascending;\\n\\n      return o.signal\\n        ? ref(this.add(Compare({\\n            fields: a,\\n            orders: this.signalRef(o.signal)\\n          })))\\n        : compareRef(a, o);\\n    },\\n\\n    // ----\\n\\n    event(source, type) {\\n      const key = source + ':' + type;\\n      if (!this.events[key]) {\\n        const id = this.id();\\n        this.streams.push({\\n          id: id,\\n          source: source,\\n          type: type\\n        });\\n        this.events[key] = id;\\n      }\\n      return this.events[key];\\n    },\\n\\n    // ----\\n\\n    hasOwnSignal(name) {\\n      return vegaUtil.hasOwnProperty(this.signals, name);\\n    },\\n\\n    addSignal(name, value) {\\n      if (this.hasOwnSignal(name)) {\\n        vegaUtil.error('Duplicate signal name: ' + vegaUtil.stringValue(name));\\n      }\\n      const op = value instanceof Entry ? value : this.add(operator(value));\\n      return this.signals[name] = op;\\n    },\\n\\n    getSignal(name) {\\n      if (!this.signals[name]) {\\n        vegaUtil.error('Unrecognized signal name: ' + vegaUtil.stringValue(name));\\n      }\\n      return this.signals[name];\\n    },\\n\\n    signalRef(s) {\\n      if (this.signals[s]) {\\n        return ref(this.signals[s]);\\n      } else if (!vegaUtil.hasOwnProperty(this.lambdas, s)) {\\n        this.lambdas[s] = this.add(operator(null));\\n      }\\n      return ref(this.lambdas[s]);\\n    },\\n\\n    parseLambdas() {\\n      const code = Object.keys(this.lambdas);\\n      for (let i=0, n=code.length; i<n; ++i) {\\n        const s = code[i],\\n              e = vegaFunctions.parseExpression(s, this),\\n              op = this.lambdas[s];\\n        op.params = e.$params;\\n        op.update = e.$expr;\\n      }\\n    },\\n\\n    property(spec) {\\n      return spec && spec.signal ? this.signalRef(spec.signal) : spec;\\n    },\\n\\n    objectProperty(spec) {\\n      return (!spec || !vegaUtil.isObject(spec)) ? spec\\n        : this.signalRef(spec.signal || propertyLambda(spec));\\n    },\\n\\n    exprRef(code, name) {\\n      const params = {expr: vegaFunctions.parseExpression(code, this)};\\n      if (name) params.expr.$name = name;\\n      return ref(this.add(Expression(params)));\\n    },\\n\\n    addBinding(name, bind) {\\n      if (!this.bindings) {\\n        vegaUtil.error('Nested signals do not support binding: ' + vegaUtil.stringValue(name));\\n      }\\n      this.bindings.push(vegaUtil.extend({signal: name}, bind));\\n    },\\n\\n    // ----\\n\\n    addScaleProj(name, transform) {\\n      if (vegaUtil.hasOwnProperty(this.scales, name)) {\\n        vegaUtil.error('Duplicate scale or projection name: ' + vegaUtil.stringValue(name));\\n      }\\n      this.scales[name] = this.add(transform);\\n    },\\n\\n    addScale(name, params) {\\n      this.addScaleProj(name, Scale(params));\\n    },\\n\\n    addProjection(name, params) {\\n      this.addScaleProj(name, Projection(params));\\n    },\\n\\n    getScale(name) {\\n      if (!this.scales[name]) {\\n        vegaUtil.error('Unrecognized scale name: ' + vegaUtil.stringValue(name));\\n      }\\n      return this.scales[name];\\n    },\\n\\n    scaleRef(name) {\\n      return ref(this.getScale(name));\\n    },\\n\\n    scaleType(name) {\\n      return this.getScale(name).params.type;\\n    },\\n\\n    projectionRef(name) {\\n      return this.scaleRef(name);\\n    },\\n\\n    projectionType(name) {\\n      return this.scaleType(name);\\n    },\\n\\n    // ----\\n\\n    addData(name, dataScope) {\\n      if (vegaUtil.hasOwnProperty(this.data, name)) {\\n        vegaUtil.error('Duplicate data set name: ' + vegaUtil.stringValue(name));\\n      }\\n      return (this.data[name] = dataScope);\\n    },\\n\\n    getData(name) {\\n      if (!this.data[name]) {\\n        vegaUtil.error('Undefined data set name: ' + vegaUtil.stringValue(name));\\n      }\\n      return this.data[name];\\n    },\\n\\n    addDataPipeline(name, entries) {\\n      if (vegaUtil.hasOwnProperty(this.data, name)) {\\n        vegaUtil.error('Duplicate data set name: ' + vegaUtil.stringValue(name));\\n      }\\n      return this.addData(name, DataScope.fromEntries(this, entries));\\n    }\\n  };\\n\\n  function propertyLambda(spec) {\\n    return (vegaUtil.isArray(spec) ? arrayLambda : objectLambda)(spec);\\n  }\\n\\n  function arrayLambda(array) {\\n    const n = array.length;\\n    let code = '[';\\n\\n    for (let i = 0; i<n; ++i) {\\n      const value = array[i];\\n      code += (i > 0 ? ',' : '')\\n        + (vegaUtil.isObject(value)\\n          ? (value.signal || propertyLambda(value))\\n          : vegaUtil.stringValue(value));\\n    }\\n    return code + ']';\\n  }\\n\\n  function objectLambda(obj) {\\n    let code = '{',\\n        i = 0,\\n        key, value;\\n\\n    for (key in obj) {\\n      value = obj[key];\\n      code += (++i > 1 ? ',' : '')\\n        + vegaUtil.stringValue(key) + ':'\\n        + (vegaUtil.isObject(value)\\n          ? (value.signal || propertyLambda(value))\\n          : vegaUtil.stringValue(value));\\n    }\\n    return code + '}';\\n  }\\n\\n  /**\\n   * Standard configuration defaults for Vega specification parsing.\\n   * Users can provide their own (sub-)set of these default values\\n   * by passing in a config object to the top-level parse method.\\n   */\\n  function defaults() {\\n    const defaultFont = 'sans-serif',\\n          defaultSymbolSize = 30,\\n          defaultStrokeWidth = 2,\\n          defaultColor = '#4c78a8',\\n          black = '#000',\\n          gray = '#888',\\n          lightGray = '#ddd';\\n\\n    return {\\n      // default visualization description\\n      description: 'Vega visualization',\\n\\n      // default padding around visualization\\n      padding: 0,\\n\\n      // default for automatic sizing; options: 'none', 'pad', 'fit'\\n      // or provide an object (e.g., {'type': 'pad', 'resize': true})\\n      autosize: 'pad',\\n\\n      // default view background color\\n      // covers the entire view component\\n      background: null,\\n\\n      // default event handling configuration\\n      // preventDefault for view-sourced event types except 'wheel'\\n      events: {\\n        defaults: {allow: ['wheel']}\\n      },\\n\\n      // defaults for top-level group marks\\n      // accepts mark properties (fill, stroke, etc)\\n      // covers the data rectangle within group width/height\\n      group: null,\\n\\n      // defaults for basic mark types\\n      // each subset accepts mark properties (fill, stroke, etc)\\n      mark: null,\\n      arc: {\\n        fill: defaultColor\\n      },\\n      area: {\\n        fill: defaultColor\\n      },\\n      image: null,\\n      line: {\\n        stroke: defaultColor,\\n        strokeWidth: defaultStrokeWidth\\n      },\\n      path: {\\n        stroke: defaultColor\\n      },\\n      rect: {\\n        fill: defaultColor\\n      },\\n      rule: {\\n        stroke: black\\n      },\\n      shape: {\\n        stroke: defaultColor\\n      },\\n      symbol: {\\n        fill: defaultColor,\\n        size: 64\\n      },\\n      text: {\\n        fill: black,\\n        font: defaultFont,\\n        fontSize: 11\\n      },\\n      trail: {\\n        fill: defaultColor,\\n        size: defaultStrokeWidth\\n      },\\n\\n      // style definitions\\n      style: {\\n        // axis & legend labels\\n        'guide-label': {\\n          fill: black,\\n          font: defaultFont,\\n          fontSize: 10\\n        },\\n        // axis & legend titles\\n        'guide-title': {\\n          fill: black,\\n          font: defaultFont,\\n          fontSize: 11,\\n          fontWeight: 'bold'\\n        },\\n        // headers, including chart title\\n        'group-title': {\\n          fill: black,\\n          font: defaultFont,\\n          fontSize: 13,\\n          fontWeight: 'bold'\\n        },\\n        // chart subtitle\\n        'group-subtitle': {\\n          fill: black,\\n          font: defaultFont,\\n          fontSize: 12\\n        },\\n        // defaults for styled point marks in Vega-Lite\\n        point: {\\n          size: defaultSymbolSize,\\n          strokeWidth: defaultStrokeWidth,\\n          shape: 'circle'\\n        },\\n        circle: {\\n          size: defaultSymbolSize,\\n          strokeWidth: defaultStrokeWidth\\n        },\\n        square: {\\n          size: defaultSymbolSize,\\n          strokeWidth: defaultStrokeWidth,\\n          shape: 'square'\\n        },\\n        // defaults for styled group marks in Vega-Lite\\n        cell: {\\n          fill: 'transparent',\\n          stroke: lightGray\\n        }\\n      },\\n\\n      // defaults for title\\n      title: {\\n        orient: 'top',\\n        anchor: 'middle',\\n        offset: 4,\\n        subtitlePadding: 3\\n      },\\n\\n      // defaults for axes\\n      axis: {\\n        minExtent: 0,\\n        maxExtent: 200,\\n        bandPosition: 0.5,\\n        domain: true,\\n        domainWidth: 1,\\n        domainColor: gray,\\n        grid: false,\\n        gridWidth: 1,\\n        gridColor: lightGray,\\n        labels: true,\\n        labelAngle: 0,\\n        labelLimit: 180,\\n        labelOffset: 0,\\n        labelPadding: 2,\\n        ticks: true,\\n        tickColor: gray,\\n        tickOffset: 0,\\n        tickRound: true,\\n        tickSize: 5,\\n        tickWidth: 1,\\n        titlePadding: 4\\n      },\\n\\n      // correction for centering bias\\n      axisBand: {\\n        tickOffset: -0.5\\n      },\\n\\n      // defaults for cartographic projection\\n      projection: {\\n        type: 'mercator'\\n      },\\n\\n      // defaults for legends\\n      legend: {\\n        orient: 'right',\\n        padding: 0,\\n        gridAlign: 'each',\\n        columnPadding: 10,\\n        rowPadding: 2,\\n        symbolDirection: 'vertical',\\n        gradientDirection: 'vertical',\\n        gradientLength: 200,\\n        gradientThickness: 16,\\n        gradientStrokeColor: lightGray,\\n        gradientStrokeWidth: 0,\\n        gradientLabelOffset: 2,\\n        labelAlign: 'left',\\n        labelBaseline: 'middle',\\n        labelLimit: 160,\\n        labelOffset: 4,\\n        labelOverlap: true,\\n        symbolLimit: 30,\\n        symbolType: 'circle',\\n        symbolSize: 100,\\n        symbolOffset: 0,\\n        symbolStrokeWidth: 1.5,\\n        symbolBaseFillColor: 'transparent',\\n        symbolBaseStrokeColor: gray,\\n        titleLimit: 180,\\n        titleOrient: 'top',\\n        titlePadding: 5,\\n        layout: {\\n          offset: 18,\\n          direction: 'horizontal',\\n          left:   { direction: 'vertical' },\\n          right:  { direction: 'vertical' }\\n        }\\n      },\\n\\n      // defaults for scale ranges\\n      range: {\\n        category: {\\n          scheme: 'tableau10'\\n        },\\n        ordinal: {\\n          scheme: 'blues'\\n        },\\n        heatmap: {\\n          scheme: 'yellowgreenblue'\\n        },\\n        ramp: {\\n          scheme: 'blues'\\n        },\\n        diverging: {\\n          scheme: 'blueorange',\\n          extent: [1, 0]\\n        },\\n        symbol: [\\n          'circle',\\n          'square',\\n          'triangle-up',\\n          'cross',\\n          'diamond',\\n          'triangle-right',\\n          'triangle-down',\\n          'triangle-left'\\n        ]\\n      }\\n    };\\n  }\\n\\n  function parse$1(spec, config, options) {\\n    if (!vegaUtil.isObject(spec)) {\\n      vegaUtil.error('Input Vega specification must be an object.');\\n    }\\n\\n    config = vegaUtil.mergeConfig(defaults(), config, spec.config);\\n    return parseView(spec, new Scope$1(config, options)).toRuntime();\\n  }\\n\\n  exports.AxisDomainRole = AxisDomainRole;\\n  exports.AxisGridRole = AxisGridRole;\\n  exports.AxisLabelRole = AxisLabelRole;\\n  exports.AxisRole = AxisRole;\\n  exports.AxisTickRole = AxisTickRole;\\n  exports.AxisTitleRole = AxisTitleRole;\\n  exports.DataScope = DataScope;\\n  exports.FrameRole = FrameRole;\\n  exports.LegendEntryRole = LegendEntryRole;\\n  exports.LegendLabelRole = LegendLabelRole;\\n  exports.LegendRole = LegendRole;\\n  exports.LegendSymbolRole = LegendSymbolRole;\\n  exports.LegendTitleRole = LegendTitleRole;\\n  exports.MarkRole = MarkRole;\\n  exports.Scope = Scope$1;\\n  exports.ScopeRole = ScopeRole;\\n  exports.config = defaults;\\n  exports.parse = parse$1;\\n  exports.signal = parseSignal;\\n  exports.signalUpdates = parseSignalUpdates;\\n  exports.stream = parseStream;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"vegaUtil\",\"vegaFunctions\",\"vegaEventSelector\",\"vegaScale\",\"vegaDataflow\",\"parseAutosize\",\"spec\",\"isObject\",\"type\",\"parsePadding\",\"_\",\"top\",\"bottom\",\"left\",\"right\",\"addEncode\",\"object\",\"name\",\"value\",\"set\",\"isArray\",\"length\",\"update\",\"addEncoders\",\"enter\",\"extendEncode\",\"encode\",\"extra\",\"skip\",\"hasOwnProperty\",\"extend\",\"has\",\"key\",\"applyDefaults\",\"role\",\"style\",\"config\",\"defaults\",\"applyDefault\",\"String\",\"startsWith\",\"props\",\"FrameRole\",\"group\",\"MarkRole\",\"mark\",\"array\",\"forEach\",\"signal\",\"entry\",\"enc\",\"gradient\",\"c\",\"_color\",\"h\",\"l\",\"s\",\"a\",\"b\",\"r\",\"g\",\"scale\",\"scaleRef\",\"range\",\"undefined\",\"band\",\"property\",\"exponent\",\"mult\",\"offset\",\"round\",\"args\",\"start\",\"stop\",\"count\",\"map\",\"stringValue\",\"peek\",\"pop\",\"unshift\",\"join\",\"field\",\"ref\",\"resolveField\",\"datum\",\"parent\",\"level\",\"Math\",\"max\",\"error\",\"isString\",\"splitAccessPath\",\"rule\",\"code\",\"test\",\"parseEncode\",\"scope\",\"params\",\"encoders\",\"$encode\",\"channels\",\"fields\",\"block\",\"parse\",\"$expr\",\"marktype\",\"$fields\",\"Object\",\"keys\",\"$output\",\"expr\",\"parseExpression\",\"$params\",\"outerError\",\"prefix\",\"parseSignal\",\"OUTER\",\"push\",\"signals\",\"OUTER_INVALID\",\"prop\",\"op\",\"addSignal\",\"react\",\"bind\",\"addBinding\",\"Entry\",\"id\",\"$ref\",\"refs\",\"fieldRef\",\"$field\",\"$name\",\"keyRef\",\"flat\",\"$key\",\"$flat\",\"aggrField\",\"isSignal\",\"hasSignal\",\"specValue\",\"defaultValue\",\"deref\",\"v\",\"parseStream\",\"stream\",\"method\",\"merge\",\"mergeStream\",\"nestedStream\",\"eventStream\",\"eventSource\",\"source\",\"Scope\",\"View\",\"list\",\"streamParameters\",\"addStream\",\"Timer\",\"event\",\"throttle\",\"between\",\"filter\",\"param\",\"concat\",\"markname\",\"markrole\",\"filterMark\",\"debounce\",\"consume\",\"item\",\"parseUpdate\",\"target\",\"events\",\"sources\",\"selector\",\"isSubscope\",\"mergeSources\",\"OP_VALUE_EXPR\",\"$value\",\"signalRef\",\"force\",\"options\",\"addUpdate\",\"streamSource\",\"parseSignalUpdates\",\"getSignal\",\"init\",\"initonly\",\"on\",\"parseLiteral\",\"parseArray\",\"dataLookupError\",\"parseScaleDomain\",\"domain\",\"explicitDomain\",\"multipleDomain\",\"singularDomain\",\"domainMin\",\"domainMax\",\"data\",\"getData\",\"isDiscrete\",\"valuesRef\",\"parseSort\",\"sort\",\"isQuantile\",\"domainRef\",\"extentRef\",\"reduce\",\"dom\",\"d\",\"FIELD_REF_ID\",\"coll\",\"Collect\",\"$ingest\",\"input\",\"addDataPipeline\",\"Sieve\",\"ordinalMultipleDomain\",\"quantileMultipleDomain\",\"numericMultipleDomain\",\"counts\",\"f\",\"countsRef\",\"p\",\"groupby\",\"keyFieldRef\",\"pulse\",\"ops\",\"MULTIDOMAIN_SORT_OPS\",\"as\",\"add\",\"Aggregate\",\"Values\",\"sortRef\",\"multidomain\",\"values\",\"MultiValues\",\"extents\",\"MultiExtent\",\"parseScaleRange\",\"scheme\",\"extent\",\"schemeExtent\",\"schemeCount\",\"step\",\"rangeStep\",\"parseParameter\",\"guideGroup\",\"GroupMark\",\"interactive\",\"lookup\",\"dflt\",\"isVertical\",\"_.isVertical\",\"Vertical\",\"direction\",\"symbolDirection\",\"gradientDirection\",\"gradientLength\",\"_.gradientLength\",\"gradientWidth\",\"gradientThickness\",\"_.gradientThickness\",\"gradientHeight\",\"entryColumns\",\"_.entryColumns\",\"columns\",\"getEncoding\",\"anchorExpr\",\"e\",\"m\",\"extendOffset\",\"assign\",\"guideMark\",\"extras\",\"Skip\",\"legendGradient\",\"userEncode\",\"vertical\",\"thickness\",\"width\",\"height\",\"opacity\",\"zero\",\"x\",\"y\",\"encoder\",\"one\",\"fill\",\"exit\",\"stroke\",\"strokeWidth\",\"RectMark\",\"LegendGradientRole\",\"legendGradientDiscrete\",\"dataRef\",\"u\",\"uu\",\"vv\",\"adjust\",\"Value\",\"LegendBandRole\",\"from\",\"legendGradientLabels\",\"overlap\",\"text\",\"Label\",\"fillOpacity\",\"font\",\"fontSize\",\"fontStyle\",\"fontWeight\",\"limit\",\"labelLimit\",\"gradientLabelLimit\",\"align\",\"baseline\",\"baselineExpr\",\"alignExpr$1\",\"labelOffset\",\"gradientLabelOffset\",\"separation\",\"order\",\"TextMark\",\"LegendLabelRole\",\"GuideLabelStyle\",\"legendSymbolGroups\",\"entries\",\"symbolOffset\",\"valueRef\",\"xSignal\",\"yEncode\",\"Size\",\"ncols\",\"baseFill\",\"baseStroke\",\"symbolBaseFillColor\",\"symbolBaseStrokeColor\",\"shape\",\"size\",\"strokeDash\",\"strokeDashOffset\",\"LegendScales\",\"symbols\",\"SymbolMark\",\"LegendSymbolRole\",\"clip\",\"labels\",\"noBound\",\"row\",\"column\",\"nrows\",\"index\",\"facet\",\"Index\",\"ScopeRole\",\"marks\",\"legendSymbolLayout\",\"center\",\"padding\",\"legendTitle\",\"orient\",\"_anchor\",\"anchor\",\"exprAnchor\",\"angle\",\"exprAngle\",\"exprAlign\",\"exprBaseline\",\"title\",\"lineHeight\",\"LegendTitleRole\",\"GuideTitleStyle\",\"path\",\"sphere\",\"getRole\",\"indexOf\",\"definition\",\"zindex\",\"aria\",\"description\",\"parseTransform\",\"def\",\"toLowerCase\",\"parseParameters\",\"proxy\",\"t\",\"metadata\",\"n\",\"i\",\"pdef\",\"parseParameter$1\",\"parseIndexParameter\",\"required\",\"parseSubParameters\",\"projectionRef\",\"parameterValue\",\"compareRef\",\"exprRef\",\"lookupRef\",\"parseSubParameter\",\"k\",\"Params\",\"parseData\",\"getDataRef\",\"aggregate\",\"output\",\"DataScope\",\"aggr\",\"fieldKey\",\"addSortField\",\"cache\",\"ds\",\"optype\",\"Descending\",\"parseFacet\",\"PreFacet\",\"Facet\",\"subscope\",\"fork\",\"addData\",\"subflow\",\"$subflow\",\"toRuntime\",\"parseSubflow\",\"parseTrigger\",\"remove\",\"insert\",\"toggle\",\"modify\",\"trigger\",\"parseMark\",\"layout\",\"store\",\"nested\",\"DataJoin\",\"clean\",\"joinRef\",\"Mark\",\"markdef\",\"context\",\"$context\",\"groups\",\"markpath\",\"markRef\",\"Encode\",\"mod\",\"transform\",\"tx\",\"md\",\"generates\",\"changes\",\"nomod\",\"SortItems\",\"encodeRef\",\"ViewLayout\",\"objectProperty\",\"legends\",\"layoutRef\",\"bound\",\"Bound\",\"boundRef\",\"operators\",\"pushState\",\"popState\",\"parseOverlap\",\"render\",\"Render\",\"sieve\",\"sep\",\"tol\",\"tolerance\",\"boundTolerance\",\"boundScale\",\"boundOrient\",\"Overlap\",\"parseLegend\",\"legend\",\"legendEncode\",\"scales\",\"legendType\",\"scaleType\",\"vgrad\",\"entryRef\",\"LegendEntries\",\"minstep\",\"tickMinStep\",\"formatType\",\"formatSpecifier\",\"format\",\"Gradient\",\"children\",\"Discrete\",\"entryLayout\",\"sizeExpression\",\"LegendEntryRole\",\"entryEncode\",\"LegendRole\",\"buildLegendEncode\",\"Symbols\",\"scaleCount\",\"isContinuous\",\"isDiscretizing\",\"titlePadding\",\"cornerRadius\",\"getChannel\",\"parseTitle\",\"buildTitle\",\"titleEncode\",\"subtitle\",\"buildSubTitle\",\"alignExpr\",\"angleExpr\",\"frame\",\"TitleRole\",\"dx\",\"dy\",\"TitleTextRole\",\"GroupTitleStyle\",\"TitleSubtitleRole\",\"GroupSubtitleStyle\",\"parseData$1\",\"transforms\",\"analyze\",\"generate\",\"upstream\",\"load\",\"collect\",\"$format\",\"url\",\"$request\",\"modifies\",\"Relay\",\"derive\",\"splice\",\"Load\",\"async\",\"fallback\",\"axisConfig\",\"styleProp\",\"slice\",\"objects\",\"obj\",\"axisDomain\",\"strokeCap\",\"strokeOpacity\",\"pos0\",\"pos\",\"pos1\",\"ifX\",\"x2\",\"ifY\",\"y2\",\"RuleMark\",\"AxisDomainRole\",\"axisGrid\",\"vscale\",\"gridScale\",\"sign\",\"getSign\",\"tickPos\",\"sz\",\"gridStart\",\"gridEnd\",\"AxisGridRole\",\"axisTicks\",\"tickSize\",\"AxisTickRole\",\"flushExpr\",\"threshold\",\"axisLabels\",\"flush\",\"flushOffset\",\"labelAlign\",\"labelBaseline\",\"flushOn\",\"ifExpr\",\"Right\",\"ifTop\",\"offsetExpr\",\"patch\",\"AxisLabelRole\",\"axisTitle\",\"titlePos\",\"Bottom\",\"Top\",\"autoLayout\",\"AxisTitleRole\",\"auto\",\"dim\",\"autoY\",\"autoX\",\"parseScope\",\"preprocessed\",\"projections\",\"projection\",\"addProjection\",\"isValidScaleType\",\"addScale\",\"getScale\",\"interpolate\",\"gamma\",\"interpolateGamma\",\"nice\",\"interval\",\"bins\",\"axes\",\"axis\",\"axisBand\",\"xyKeys\",\"axisX\",\"axisY\",\"orientKeys\",\"axisTop\",\"axisBottom\",\"axisLeft\",\"axisRight\",\"xy\",\"or\",\"$orient\",\"toExpr\",\"toUpperCase\",\"result\",\"axisEncode\",\"ticks\",\"grid\",\"ticksRef\",\"AxisTicks\",\"tickCount\",\"position\",\"minExtent\",\"maxExtent\",\"translate\",\"AxisRole\",\"parseLambdas\",\"parseView\",\"root\",\"collectSignals\",\"eventConfig\",\"locale\",\"autosize\",\"signalObject\",\"pre\",\"Scope$1\",\"bindings\",\"lambdas\",\"streams\",\"updates\",\"_subid\",\"_id\",\"_nextsub\",\"_parent\",\"_encode\",\"_lookup\",\"_markpath\",\"Subscope\",\"create\",\"propertyLambda\",\"arrayLambda\",\"objectLambda\",\"background\",\"allow\",\"arc\",\"defaultColor\",\"area\",\"image\",\"line\",\"defaultStrokeWidth\",\"rect\",\"black\",\"symbol\",\"defaultFont\",\"trail\",\"point\",\"defaultSymbolSize\",\"circle\",\"square\",\"cell\",\"lightGray\",\"subtitlePadding\",\"bandPosition\",\"domainWidth\",\"domainColor\",\"gray\",\"gridWidth\",\"gridColor\",\"labelAngle\",\"labelPadding\",\"tickColor\",\"tickOffset\",\"tickRound\",\"tickWidth\",\"gridAlign\",\"columnPadding\",\"rowPadding\",\"gradientStrokeColor\",\"gradientStrokeWidth\",\"labelOverlap\",\"symbolLimit\",\"symbolType\",\"symbolSize\",\"symbolStrokeWidth\",\"titleLimit\",\"titleOrient\",\"category\",\"ordinal\",\"heatmap\",\"ramp\",\"diverging\",\"z\",\"ast\",\"Compare\",\"Expression\",\"Field\",\"Key\",\"Projection\",\"Proxy\",\"Scale\",\"min\",\"Left\",\"Center\",\"alignFlip\",\"fromEntries\",\"DataScope.fromEntries\",\"prototype\",\"agg\",\"tuplesRef\",\"indataRef\",\"ifEnc\",\"base\",\"endsWith\",\"finish\",\"vref\",\"annotate\",\"cmp\",\"check\",\"orders\",\"$compare\",\"$order\",\"sig\",\"o\",\"Ascending\",\"hasOwnSignal\",\"addScaleProj\",\"projectionType\",\"dataScope\",\"parse$1\",\"mergeConfig\",\"signalUpdates\",\"defineProperty\"]\n}\n"]