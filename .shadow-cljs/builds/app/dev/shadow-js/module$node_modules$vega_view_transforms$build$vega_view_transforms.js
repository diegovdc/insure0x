["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-view-transforms/build/vega-view-transforms.js"],"~:js","shadow$provide.module$node_modules$vega_view_transforms$build$vega_view_transforms=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_dataflow$build$vega_dataflow\"),require(\"module$node_modules$vega_scenegraph$build$vega_scenegraph\"),require(\"module$node_modules$vega_util$build$vega_util\")):\"function\"===typeof define&&define.amd?define([\"exports\",\n\"vega-dataflow\",\"vega-scenegraph\",\"vega-util\"],factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory((global.vega=global.vega||{},global.vega.transforms={}),global.vega,global.vega,global.vega))})(this,function(exports,vegaDataflow,vegaScenegraph,vegaUtil){function Bound(params){vegaDataflow.Transform.call(this,null,params)}function boundItem(item,bound,opt){return bound(item.bounds.clear(),item,opt)}function Identifier(params){vegaDataflow.Transform.call(this,0,params)}\nfunction getCounter(view){return view._signals[\":vega_identifier:\"]||(view._signals[\":vega_identifier:\"]=view.add(0))}function Mark(params){vegaDataflow.Transform.call(this,null,params)}function lookup(_){var g=_.groups;_=_.parent;return g&&1===g.size?g.get(Object.keys(g.object)[0]):g&&_?g.lookup(_):null}function Overlap(params){vegaDataflow.Transform.call(this,null,params)}function Render(params){vegaDataflow.Transform.call(this,null,params)}function set(item,property,value){return item[property]===\nvalue?0:(item[property]=value,1)}function isYAxis(mark){mark=mark.items[0].orient;return\"left\"===mark||\"right\"===mark}function axisLayout(view,axis,width,height){axis=axis.items[0];var datum=axis.datum,delta=null!=axis.translate?axis.translate:.5,orient=axis.orient,index=+datum.grid;var indices=[datum.ticks?index++:-1,datum.labels?index++:-1,index+ +datum.domain];index=axis.range;var offset=axis.offset,position=axis.position,minExtent=axis.minExtent,maxExtent=axis.maxExtent;datum=datum.title&&axis.items[indices[2]].items[0];\nvar titlePadding=axis.titlePadding,bounds=axis.bounds,dl=datum&&vegaScenegraph.multiLineOffset(datum),i;tempBounds.clear().union(bounds);bounds.clear();-1<(i=indices[0])&&bounds.union(axis.items[i].bounds);-1<(i=indices[1])&&bounds.union(axis.items[i].bounds);switch(orient){case \"top\":width=position||0;height=-offset;minExtent=Math.max(minExtent,Math.min(maxExtent,-bounds.y1));bounds.add(0,-minExtent).add(index,0);datum&&axisTitleLayout(view,datum,minExtent,titlePadding,dl,0,-1,bounds);break;case \"left\":width=\n-offset;height=position||0;minExtent=Math.max(minExtent,Math.min(maxExtent,-bounds.x1));bounds.add(-minExtent,0).add(0,index);datum&&axisTitleLayout(view,datum,minExtent,titlePadding,dl,1,-1,bounds);break;case \"right\":width+=offset;height=position||0;minExtent=Math.max(minExtent,Math.min(maxExtent,bounds.x2));bounds.add(0,0).add(minExtent,index);datum&&axisTitleLayout(view,datum,minExtent,titlePadding,dl,1,1,bounds);break;case \"bottom\":width=position||0;height+=offset;minExtent=Math.max(minExtent,\nMath.min(maxExtent,bounds.y2));bounds.add(0,0).add(index,minExtent);datum&&axisTitleLayout(view,datum,minExtent,titlePadding,0,0,1,bounds);break;default:width=axis.x,height=axis.y}vegaScenegraph.boundStroke(bounds.translate(width,height),axis);set(axis,\"x\",width+delta)|set(axis,\"y\",height+delta)&&(axis.bounds=tempBounds,view.dirty(axis),axis.bounds=bounds,view.dirty(axis));return axis.mark.bounds.clear().union(bounds)}function axisTitleLayout(view,title,offset,pad,dl,isYAxis,sign,bounds){var b=title.bounds;\ntitle.auto&&(offset=sign*(offset+dl+pad),dl=pad=0,view.dirty(title),isYAxis?pad=(title.x||0)-(title.x=offset):dl=(title.y||0)-(title.y=offset),title.mark.bounds.clear().union(b.translate(-pad,-dl)),view.dirty(title));bounds.union(b)}function bboxFlush(item){return(new vegaScenegraph.Bounds).set(0,0,item.width||0,item.height||0)}function bboxFull(item){var b=item.bounds.clone();return b.empty()?b.set(0,0,0,0):b.translate(-(item.x||0),-(item.y||0))}function get(opt,key,d){opt=vegaUtil.isObject(opt)?\nopt[key]:opt;return null!=opt?opt:void 0!==d?d:0}function offsetValue(v){return 0>v?Math.ceil(-v):0}function gridLayout(view,groups,opt){var dirty=!opt.nodirty,bbox=\"flush\"===opt.bounds?bboxFlush:bboxFull,bounds=tempBounds.set(0,0,0,0),alignCol=get(opt.align,\"column\"),alignRow=get(opt.align,\"row\"),padCol=get(opt.padding,\"column\"),padRow=get(opt.padding,\"row\"),ncols=opt.columns||groups.length,nrows=0>=ncols?1:Math.ceil(groups.length/ncols),n=groups.length,xOffset=Array(n),xExtent=Array(ncols),xMax=\n0,yOffset=Array(n),yExtent=Array(nrows),yMax=0,dx=Array(n),dy=Array(n),boxes=Array(n),i,px,py;for(i=0;i<ncols;++i)xExtent[i]=0;for(i=0;i<nrows;++i)yExtent[i]=0;for(i=0;i<n;++i){var m=groups[i];var b=boxes[i]=bbox(m);m.x=m.x||0;dx[i]=0;m.y=m.y||0;dy[i]=0;m=i%ncols;var r=~~(i/ncols);xMax=Math.max(xMax,px=Math.ceil(b.x2));yMax=Math.max(yMax,py=Math.ceil(b.y2));xExtent[m]=Math.max(xExtent[m],px);yExtent[r]=Math.max(yExtent[r],py);xOffset[i]=padCol+offsetValue(b.x1);yOffset[i]=padRow+offsetValue(b.y1);\ndirty&&view.dirty(groups[i])}for(i=0;i<n;++i)0===i%ncols&&(xOffset[i]=0),i<ncols&&(yOffset[i]=0);if(\"each\"===alignCol)for(m=1;m<ncols;++m){bbox=0;for(i=m;i<n;i+=ncols)bbox<xOffset[i]&&(bbox=xOffset[i]);for(i=m;i<n;i+=ncols)xOffset[i]=bbox+xExtent[m-1]}else if(\"all\"===alignCol){for(i=bbox=0;i<n;++i)i%ncols&&bbox<xOffset[i]&&(bbox=xOffset[i]);for(i=0;i<n;++i)i%ncols&&(xOffset[i]=bbox+xMax)}else for(alignCol=!1,m=1;m<ncols;++m)for(i=m;i<n;i+=ncols)xOffset[i]+=xExtent[m-1];if(\"each\"===alignRow)for(r=\n1;r<nrows;++r){bbox=0;i=r*ncols;for(m=i+ncols;i<m;++i)bbox<yOffset[i]&&(bbox=yOffset[i]);for(i=r*ncols;i<m;++i)yOffset[i]=bbox+yExtent[r-1]}else if(\"all\"===alignRow){bbox=0;for(i=ncols;i<n;++i)bbox<yOffset[i]&&(bbox=yOffset[i]);for(i=ncols;i<n;++i)yOffset[i]=bbox+yMax}else for(alignRow=!1,r=1;r<nrows;++r)for(i=r*ncols,m=i+ncols;i<m;++i)yOffset[i]+=yExtent[r-1];for(i=r=0;i<n;++i)r=xOffset[i]+(i%ncols?r:0),dx[i]+=r-groups[i].x;for(m=0;m<ncols;++m)for(xOffset=0,i=m;i<n;i+=ncols)xOffset+=yOffset[i],dy[i]+=\nxOffset-groups[i].y;if(alignCol&&get(opt.center,\"column\")&&1<nrows)for(i=0;i<n;++i)b=\"all\"===alignCol?xMax:xExtent[i%ncols],r=b-boxes[i].x2-groups[i].x-dx[i],0<r&&(dx[i]+=r/2);if(alignRow&&get(opt.center,\"row\")&&1!==ncols)for(i=0;i<n;++i)b=\"all\"===alignRow?yMax:yExtent[~~(i/ncols)],xOffset=b-boxes[i].y2-groups[i].y-dy[i],0<xOffset&&(dy[i]+=xOffset/2);for(i=0;i<n;++i)bounds.union(boxes[i].translate(dx[i],dy[i]));r=get(opt.anchor,\"x\");xOffset=get(opt.anchor,\"y\");switch(get(opt.anchor,\"column\")){case \"end\":r-=\nbounds.width();break;case \"middle\":r-=bounds.width()/2}switch(get(opt.anchor,\"row\")){case \"end\":xOffset-=bounds.height();break;case \"middle\":xOffset-=bounds.height()/2}r=Math.round(r);xOffset=Math.round(xOffset);bounds.clear();for(i=0;i<n;++i)groups[i].mark.bounds.clear();for(i=0;i<n;++i)m=groups[i],m.x+=dx[i]+=r,m.y+=dy[i]+=xOffset,bounds.union(m.mark.bounds.union(m.bounds.translate(dx[i],dy[i]))),dirty&&view.dirty(m);return bounds}function boundFlush(item,field){return\"x1\"===field?item.x||0:\"y1\"===\nfield?item.y||0:\"x2\"===field?(item.x||0)+(item.width||0):\"y2\"===field?(item.y||0)+(item.height||0):void 0}function boundFull(item,field){return item.bounds[field]}function layoutHeaders(view,headers,groups,ncols,limit,offset,agg,isX,bound,bf,start,stride,back,band){var n=groups.length,edge=ncols=0,i,g;if(!n)return ncols;for(i=start;i<n;i+=stride)groups[i]&&(ncols=agg(ncols,bound(groups[i],bf)));if(!headers.length)return ncols;headers.length>limit&&(view.warn(\"Grid headers exceed limit: \"+limit),headers=\nheaders.slice(0,limit));ncols+=offset;limit=0;for(offset=headers.length;limit<offset;++limit)view.dirty(headers[limit]),headers[limit].mark.bounds.clear();i=start;limit=0;for(offset=headers.length;limit<offset;++limit,i+=stride){bound=headers[limit];start=bound.mark.bounds;for(n=i;0<=n&&null==(g=groups[n]);n-=back);if(isX){n=null==band?g.x:Math.round(g.bounds.x1+band*g.bounds.width());var y=ncols}else n=ncols,y=null==band?g.y:Math.round(g.bounds.y1+band*g.bounds.height());start.union(bound.bounds.translate(n-\n(bound.x||0),y-(bound.y||0)));bound.x=n;bound.y=y;view.dirty(bound);edge=agg(edge,start[bf])}return edge}function layoutTitle(view,g,offset,isX,bounds,band){if(g){view.dirty(g);var x=offset;isX?x=Math.round(bounds.x1+band*bounds.width()):offset=Math.round(bounds.y1+band*bounds.height());g.bounds.translate(x-(g.x||0),offset-(g.y||0));g.mark.bounds.clear().union(g.bounds);g.x=x;g.y=offset;view.dirty(g)}}function lookup$1(config,orient){var opt=config[orient]||{};return function(key,d){return null!=\nopt[key]?opt[key]:null!=config[key]?config[key]:d}}function offsets(legends,value){var max=-Infinity;legends.forEach(function(item){null!=item.offset&&(max=Math.max(max,item.offset))});return-Infinity<max?max:value}function legendParams(g,orient,config,xb,yb,w,h){var _=lookup$1(config,orient);config=offsets(g,_(\"offset\",0));var anchor=_(\"anchor\",\"start\"),mult=\"end\"===anchor?1:\"middle\"===anchor?.5:0;g={align:\"each\",bounds:_(\"bounds\",\"flush\"),columns:\"vertical\"===_(\"direction\")?1:g.length,padding:_(\"margin\",\n8),center:_(\"center\"),nodirty:!0};switch(orient){case \"left\":g.anchor={x:Math.floor(xb.x1)-config,column:\"end\",y:mult*(h||xb.height()+2*xb.y1),row:anchor};break;case \"right\":g.anchor={x:Math.ceil(xb.x2)+config,y:mult*(h||xb.height()+2*xb.y1),row:anchor};break;case \"top\":g.anchor={y:Math.floor(yb.y1)-config,row:\"end\",x:mult*(w||yb.width()+2*yb.x1),column:anchor};break;case \"bottom\":g.anchor={y:Math.ceil(yb.y2)+config,x:mult*(w||yb.width()+2*yb.x1),column:anchor};break;case \"top-left\":g.anchor={x:config,\ny:config};break;case \"top-right\":g.anchor={x:w-config,y:config,column:\"end\"};break;case \"bottom-left\":g.anchor={x:config,y:h-config,row:\"end\"};break;case \"bottom-right\":g.anchor={x:w-config,y:h-config,column:\"end\",row:\"end\"}}return g}function legendLayout(view,legend){legend=legend.items[0];var datum=legend.datum,orient=legend.orient,bounds=legend.bounds,x=legend.x,y=legend.y;legend._bounds?legend._bounds.clear().union(bounds):legend._bounds=bounds.clone();bounds.clear();var h=legend.items[0].items[0];\nvar pad=legend.padding,ex=pad-h.x,ey=pad-h.y;if(legend.datum.title){var title=legend.items[1].items[0],anchor=title.anchor,tpad=legend.titlePadding||0,tx=pad-title.x,ty=pad-title.y;switch(title.orient){case \"left\":ex+=Math.ceil(title.bounds.width())+tpad;break;case \"right\":case \"bottom\":break;default:ey+=title.bounds.height()+tpad}(ex||ey)&&translate(view,h,ex,ey);switch(title.orient){case \"left\":ty+=legendTitleOffset(legend,h,title,anchor,1,1);break;case \"right\":tx+=legendTitleOffset(legend,h,title,\n\"end\",0,0)+tpad;ty+=legendTitleOffset(legend,h,title,anchor,1,1);break;case \"bottom\":tx+=legendTitleOffset(legend,h,title,anchor,0,0);ty+=legendTitleOffset(legend,h,title,\"end\",-1,0,1)+tpad;break;default:tx+=legendTitleOffset(legend,h,title,anchor,0,0)}(tx||ty)&&translate(view,title,tx,ty);0>(tx=Math.round(title.bounds.x1-pad))&&(translate(view,h,-tx,0),translate(view,title,-tx,0))}else(ex||ey)&&translate(view,h,ex,ey);bounds=legendBounds(legend,bounds);view=2*legend.padding;h=2*legend.padding;bounds.empty()||\n(view=Math.ceil(bounds.width()+view),h=Math.ceil(bounds.height()+h));\"symbol\"===datum.type&&legendEntryLayout(legend.items[0].items[0].items[0].items);\"none\"!==orient&&(legend.x=x=0,legend.y=y=0);legend.width=view;legend.height=h;vegaScenegraph.boundStroke(bounds.set(x,y,x+view,y+h),legend);legend.mark.bounds.clear().union(bounds);return legend}function legendBounds(item,b){item.items.forEach(function(_){return b.union(_.bounds)});b.x1=item.padding;b.y1=item.padding;return b}function legendTitleOffset(item,\nentry,title,anchor,y,lr,noBar){var vgrad=title.datum.vgrad;item=(\"symbol\"===item.datum.type||!lr&&vgrad||noBar?entry:entry.items[0]).bounds[y?\"y2\":\"x2\"]-item.padding;entry=vgrad&&lr?item:0;lr=vgrad&&lr?0:item;title=0>=y?0:vegaScenegraph.multiLineOffset(title);return Math.round(\"start\"===anchor?entry:\"end\"===anchor?lr-title:.5*(item-title))}function translate(view,item,dx,dy){item.x+=dx;item.y+=dy;item.bounds.translate(dx,dy);item.mark.bounds.translate(dx,dy);view.dirty(item)}function legendEntryLayout(entries){var widths=\nentries.reduce(function(w,g){w[g.column]=Math.max(g.bounds.x2-g.x,w[g.column]||0);return w},{});entries.forEach(function(g){g.width=widths[g.column];g.height=g.bounds.y2-g.y})}function titleLayout(view,mark,width,height,viewBounds){var group=mark.items[0],orient=group.orient,anchor=group.anchor,offset=group.offset,padding=group.padding,title=group.items[0].items[0],subtitle=group.items[1]&&group.items[1].items[0],end=\"left\"===orient||\"right\"===orient?height:width,start=0,sy=width=0;\"group\"!==group.frame?\n\"left\"===orient?(start=viewBounds.y2,end=viewBounds.y1):\"right\"===orient?(start=viewBounds.y1,end=viewBounds.y2):(start=viewBounds.x1,end=viewBounds.x2):\"left\"===orient&&(start=height,end=0);height=\"start\"===anchor?start:\"end\"===anchor?end:(start+end)/2;if(subtitle&&subtitle.text){switch(orient){case \"top\":case \"bottom\":sy=title.bounds.height()+padding;break;case \"left\":width=title.bounds.width()+padding;break;case \"right\":width=-title.bounds.width()-padding}tempBounds.clear().union(subtitle.bounds);\ntempBounds.translate(width-(subtitle.x||0),sy-(subtitle.y||0));set(subtitle,\"x\",width)|set(subtitle,\"y\",sy)&&(view.dirty(subtitle),subtitle.bounds.clear().union(tempBounds),subtitle.mark.bounds.clear().union(tempBounds),view.dirty(subtitle));tempBounds.clear().union(subtitle.bounds)}else tempBounds.clear();tempBounds.union(title.bounds);switch(orient){case \"top\":orient=height;viewBounds=viewBounds.y1-tempBounds.height()-offset;break;case \"left\":orient=viewBounds.x1-tempBounds.width()-offset;viewBounds=\nheight;break;case \"right\":orient=viewBounds.x2+tempBounds.width()+offset;viewBounds=height;break;case \"bottom\":orient=height;viewBounds=viewBounds.y2+offset;break;default:orient=group.x,viewBounds=group.y}set(group,\"x\",orient)|set(group,\"y\",viewBounds)&&(tempBounds.translate(orient,viewBounds),view.dirty(group),group.bounds.clear().union(tempBounds),mark.bounds.clear().union(tempBounds),view.dirty(group));return group.bounds}function ViewLayout(params){vegaDataflow.Transform.call(this,null,params)}\nfunction shouldReflow(group){return group&&\"legend-entry\"!==group.mark.role}function layoutGroup(view,group,_){var items=group.items,width=Math.max(0,group.width||0),height=Math.max(0,group.height||0),viewBounds=(new vegaScenegraph.Bounds).set(0,0,width,height),xBounds=viewBounds.clone(),yBounds=viewBounds.clone(),legends=[],orient,n;var i=0;for(n=items.length;i<n;++i){var mark=items[i];switch(mark.role){case \"axis\":var b$jscomp$0=isYAxis(mark)?xBounds:yBounds;b$jscomp$0.union(axisLayout(view,mark,\nwidth,height));break;case \"title\":var title=mark;break;case \"legend\":legends.push(legendLayout(view,mark));break;case \"frame\":case \"scope\":case \"row-header\":case \"row-footer\":case \"row-title\":case \"column-header\":case \"column-footer\":case \"column-title\":xBounds.union(mark.bounds);yBounds.union(mark.bounds);break;default:viewBounds.union(mark.bounds)}}if(legends.length){var l={};legends.forEach(function(item){orient=item.orient||\"right\";\"none\"!==orient&&(l[orient]||(l[orient]=[])).push(item)});for(var orient$353 in l)items=\nl[orient$353],gridLayout(view,items,legendParams(items,orient$353,_.legends,xBounds,yBounds,width,height));legends.forEach(function(item){var b=item.bounds;b.equals(item._bounds)||(item.bounds=item._bounds,view.dirty(item),item.bounds=b,view.dirty(item));if(_.autosize&&\"fit\"===_.autosize.type)switch(item.orient){case \"left\":case \"right\":viewBounds.add(b.x1,0).add(b.x2,0);break;case \"top\":case \"bottom\":viewBounds.add(0,b.y1).add(0,b.y2)}else viewBounds.union(b)})}viewBounds.union(xBounds).union(yBounds);\ntitle&&viewBounds.union(titleLayout(view,title,width,height,viewBounds));group.clip&&viewBounds.set(0,0,group.width||0,group.height||0);viewSizeLayout(view,group,viewBounds,_)}function viewSizeLayout(view,group,viewBounds,_){_=_.autosize||{};var type=_.type;if(!(1>view._autosize)&&type){var viewWidth=view._width,viewHeight=view._height,width=Math.max(0,group.width||0),left=Math.max(0,Math.ceil(-viewBounds.x1));group=Math.max(0,group.height||0);var top=Math.max(0,Math.ceil(-viewBounds.y1)),right=Math.max(0,\nMath.ceil(viewBounds.x2-width));viewBounds=Math.max(0,Math.ceil(viewBounds.y2-group));if(\"padding\"===_.contains){var padding=view.padding();viewWidth-=padding.left+padding.right;viewHeight-=padding.top+padding.bottom}\"none\"===type?(top=left=0,width=viewWidth,group=viewHeight):\"fit\"===type?(width=Math.max(0,viewWidth-left-right),group=Math.max(0,viewHeight-top-viewBounds)):\"fit-x\"===type?(width=Math.max(0,viewWidth-left-right),viewHeight=group+top+viewBounds):\"fit-y\"===type?(viewWidth=width+left+right,\ngroup=Math.max(0,viewHeight-top-viewBounds)):\"pad\"===type&&(viewWidth=width+left+right,viewHeight=group+top+viewBounds);view._resizeView(viewWidth,viewHeight,width,group,[left,top],_.resize)}}vegaUtil.inherits(Bound,vegaDataflow.Transform,{transform:function(_,pulse){var view=pulse.dataflow,mark=_.mark,type=mark.marktype,entry=vegaScenegraph.Marks[type],bound=entry.bound,markBounds=mark.bounds;if(entry.nested)mark.items.length&&view.dirty(mark.items[0]),markBounds=boundItem(mark,bound),mark.items.forEach(function(item){item.bounds.clear().union(markBounds)});\nelse if(\"group\"===type||_.modified())switch(pulse.visit(pulse.MOD,function(item){return view.dirty(item)}),markBounds.clear(),mark.items.forEach(function(item){return markBounds.union(boundItem(item,bound))}),mark.role){case \"axis\":case \"legend\":case \"title\":pulse.reflow()}else{var rebound=pulse.changed(pulse.REM);pulse.visit(pulse.ADD,function(item){markBounds.union(boundItem(item,bound))});pulse.visit(pulse.MOD,function(item){rebound=rebound||markBounds.alignsWith(item.bounds);view.dirty(item);\nmarkBounds.union(boundItem(item,bound))});rebound&&(markBounds.clear(),mark.items.forEach(function(item){return markBounds.union(item.bounds)}))}vegaScenegraph.boundClip(mark);return pulse.modifies(\"bounds\")}});Identifier.Definition={type:\"Identifier\",metadata:{modifies:!0},params:[{name:\"as\",type:\"string\",required:!0}]};vegaUtil.inherits(Identifier,vegaDataflow.Transform,{transform:function(_,pulse){var counter=getCounter(pulse.dataflow),as=_.as,id=counter.value;pulse.visit(pulse.ADD,function(t){return t[as]=\nt[as]||++id});counter.set(this.value=id);return pulse}});vegaUtil.inherits(Mark,vegaDataflow.Transform,{transform:function(_,pulse){var mark=this.value;mark||(mark=pulse.dataflow.scenegraph().mark(_.markdef,lookup(_),_.index),mark.group.context=_.context,_.context.group||(_.context.group=mark.group),mark.source=this.source,mark.clip=_.clip,mark.interactive=_.interactive,this.value=mark);var Init=\"group\"===mark.marktype?vegaScenegraph.GroupItem:vegaScenegraph.Item;pulse.visit(pulse.ADD,function(item){return Init.call(item,\nmark)});if(_.modified(\"clip\")||_.modified(\"interactive\"))mark.clip=_.clip,mark.interactive=!!_.interactive,mark.zdirty=!0,pulse.reflow();mark.items=pulse.source;return pulse}});var methods={parity:function(items){return items.filter(function(item,i){return i%2?item.opacity=0:1})},greedy:function(items,sep){var a;return items.filter(function(b,i){return i&&intersect(a.bounds,b.bounds,sep)?b.opacity=0:(a=b,1)})}},intersect=function(a,b,sep){return sep>Math.max(b.x1-a.x2,a.x1-b.x2,b.y1-a.y2,a.y1-b.y2)},\nhasOverlap=function(items,pad){for(var i=1,n=items.length,a=items[0].bounds;i<n;++i)if(intersect(a,a=items[i].bounds,pad))return!0},hasBounds=function(item){item=item.bounds;return 1<item.width()&&1<item.height()},boundTest=function(scale,orient,tolerance){scale=scale.range();var b=new vegaScenegraph.Bounds;\"top\"===orient||\"bottom\"===orient?b.set(scale[0],-Infinity,scale[1],Infinity):b.set(-Infinity,scale[0],Infinity,scale[1]);b.expand(tolerance||1);return function(item){return b.encloses(item.bounds)}},\nreset=function(source){source.forEach(function(item){return item.opacity=1});return source};vegaUtil.inherits(Overlap,vegaDataflow.Transform,{transform:function(_,pulse){var reduce=methods[_.method]||methods.parity,sep=_.separation||0,source=pulse.materialize(pulse.SOURCE).source;if(source&&source.length){if(!_.method)return _.modified(\"method\")&&(reset(source),pulse=pulse.reflow(_.modified()).modifies(\"opacity\")),pulse;source=source.filter(hasBounds);if(source.length){_.sort&&(source=source.slice().sort(_.sort));\nvar items=reset(source);pulse=pulse.reflow(_.modified()).modifies(\"opacity\");if(3<=items.length&&hasOverlap(items,sep)){do items=reduce(items,sep);while(3<=items.length&&hasOverlap(items,sep));3>items.length&&!vegaUtil.peek(source).opacity&&(1<items.length&&(vegaUtil.peek(items).opacity=0),vegaUtil.peek(source).opacity=1)}if(_.boundScale&&0<=_.boundTolerance){var test=boundTest(_.boundScale,_.boundOrient,+_.boundTolerance);source.forEach(function(item){test(item)||(item.opacity=0)})}var bounds=items[0].mark.bounds.clear();\nsource.forEach(function(item){item.opacity&&bounds.union(item.bounds)});return pulse}}}});vegaUtil.inherits(Render,vegaDataflow.Transform,{transform:function(_,pulse){var view=pulse.dataflow;pulse.visit(pulse.ALL,function(item){return view.dirty(item)});pulse.fields&&pulse.fields.zindex&&(_=pulse.source&&pulse.source[0])&&(_.mark.zdirty=!0)}});var tempBounds=new vegaScenegraph.Bounds,min=function(a,b){return Math.floor(Math.min(a,b))},max$jscomp$0=function(a,b){return Math.ceil(Math.max(a,b))};vegaUtil.inherits(ViewLayout,\nvegaDataflow.Transform,{transform:function(_,pulse){var view=pulse.dataflow;_.mark.items.forEach(function(group){if(_.layout){for(var opt=_.layout,groups=group.items,n=groups.length,i=0,mark,items,JSCompiler_object_inline_marks_2922=[],JSCompiler_object_inline_rowheaders_2923=[],JSCompiler_object_inline_rowfooters_2924=[],JSCompiler_object_inline_colheaders_2925=[],JSCompiler_object_inline_colfooters_2926=[],JSCompiler_object_inline_rowtitle_2927=null,JSCompiler_object_inline_coltitle_2928=null;i<\nn;++i)if(mark=groups[i],items=mark.items,\"group\"===mark.marktype)switch(mark.role){case \"axis\":case \"legend\":case \"title\":break;case \"row-header\":JSCompiler_object_inline_rowheaders_2923.push.apply(JSCompiler_object_inline_rowheaders_2923,$jscomp.arrayFromIterable(items));break;case \"row-footer\":JSCompiler_object_inline_rowfooters_2924.push.apply(JSCompiler_object_inline_rowfooters_2924,$jscomp.arrayFromIterable(items));break;case \"column-header\":JSCompiler_object_inline_colheaders_2925.push.apply(JSCompiler_object_inline_colheaders_2925,\n$jscomp.arrayFromIterable(items));break;case \"column-footer\":JSCompiler_object_inline_colfooters_2926.push.apply(JSCompiler_object_inline_colfooters_2926,$jscomp.arrayFromIterable(items));break;case \"row-title\":JSCompiler_object_inline_rowtitle_2927=items[0];break;case \"column-title\":JSCompiler_object_inline_coltitle_2928=items[0];break;default:JSCompiler_object_inline_marks_2922.push.apply(JSCompiler_object_inline_marks_2922,$jscomp.arrayFromIterable(items))}mark=\"flush\"===opt.bounds?boundFlush:\nboundFull;groups=opt.offset;items=opt.columns||JSCompiler_object_inline_marks_2922.length;var nrows=0>=items?1:Math.ceil(JSCompiler_object_inline_marks_2922.length/items),cells=nrows*items;n=gridLayout(view,JSCompiler_object_inline_marks_2922,opt);n.empty()&&n.set(0,0,0,0);if(JSCompiler_object_inline_rowheaders_2923){i=get(opt.headerBand,\"row\",null);var x=layoutHeaders(view,JSCompiler_object_inline_rowheaders_2923,JSCompiler_object_inline_marks_2922,items,nrows,-get(groups,\"rowHeader\"),min,0,mark,\n\"x1\",0,items,1,i)}if(JSCompiler_object_inline_colheaders_2925){i=get(opt.headerBand,\"column\",null);var y=layoutHeaders(view,JSCompiler_object_inline_colheaders_2925,JSCompiler_object_inline_marks_2922,items,items,-get(groups,\"columnHeader\"),min,1,mark,\"y1\",0,1,items,i)}if(JSCompiler_object_inline_rowfooters_2924){i=get(opt.footerBand,\"row\",null);var x2=layoutHeaders(view,JSCompiler_object_inline_rowfooters_2924,JSCompiler_object_inline_marks_2922,items,nrows,get(groups,\"rowFooter\"),max$jscomp$0,0,\nmark,\"x2\",items-1,items,1,i)}if(JSCompiler_object_inline_colfooters_2926){i=get(opt.footerBand,\"column\",null);var y2=layoutHeaders(view,JSCompiler_object_inline_colfooters_2926,JSCompiler_object_inline_marks_2922,items,items,get(groups,\"columnFooter\"),max$jscomp$0,1,mark,\"y2\",cells-items,1,items,i)}JSCompiler_object_inline_rowtitle_2927&&(JSCompiler_object_inline_rowheaders_2923=get(opt.titleAnchor,\"row\"),JSCompiler_object_inline_marks_2922=get(groups,\"rowTitle\"),JSCompiler_object_inline_marks_2922=\n\"end\"===JSCompiler_object_inline_rowheaders_2923?x2+JSCompiler_object_inline_marks_2922:x-JSCompiler_object_inline_marks_2922,i=get(opt.titleBand,\"row\",.5),layoutTitle(view,JSCompiler_object_inline_rowtitle_2927,JSCompiler_object_inline_marks_2922,0,n,i));JSCompiler_object_inline_coltitle_2928&&(JSCompiler_object_inline_rowheaders_2923=get(opt.titleAnchor,\"column\"),JSCompiler_object_inline_marks_2922=get(groups,\"columnTitle\"),JSCompiler_object_inline_marks_2922=\"end\"===JSCompiler_object_inline_rowheaders_2923?\ny2+JSCompiler_object_inline_marks_2922:y-JSCompiler_object_inline_marks_2922,i=get(opt.titleBand,\"column\",.5),layoutTitle(view,JSCompiler_object_inline_coltitle_2928,JSCompiler_object_inline_marks_2922,1,n,i))}layoutGroup(view,group,_)});return shouldReflow(_.mark.group)?pulse.reflow():pulse}});exports.bound=Bound;exports.identifier=Identifier;exports.mark=Mark;exports.overlap=Overlap;exports.render=Render;exports.viewlayout=ViewLayout;Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_view_transforms$build$vega_view_transforms\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-dataflow'), require('vega-scenegraph'), require('vega-util')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-dataflow', 'vega-scenegraph', 'vega-util'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.vega));\n}(this, (function (exports, vegaDataflow, vegaScenegraph, vegaUtil) { 'use strict';\n\n  const Top = 'top';\n  const Left = 'left';\n  const Right = 'right';\n  const Bottom = 'bottom';\n\n  const TopLeft = 'top-left';\n  const TopRight = 'top-right';\n  const BottomLeft = 'bottom-left';\n  const BottomRight = 'bottom-right';\n\n  const Start = 'start';\n  const Middle = 'middle';\n  const End = 'end';\n\n  const X = 'x';\n  const Y = 'y';\n\n  const Group = 'group';\n\n  const AxisRole = 'axis';\n  const TitleRole = 'title';\n  const FrameRole = 'frame';\n  const ScopeRole = 'scope';\n  const LegendRole = 'legend';\n\n  const RowHeader = 'row-header';\n  const RowFooter = 'row-footer';\n  const RowTitle  = 'row-title';\n  const ColHeader = 'column-header';\n  const ColFooter = 'column-footer';\n  const ColTitle  = 'column-title';\n\n  const Padding = 'padding';\n\n  const Symbols = 'symbol';\n\n  const Fit  = 'fit';\n  const FitX = 'fit-x';\n  const FitY = 'fit-y';\n  const Pad  = 'pad';\n  const None = 'none';\n\n  const All = 'all';\n  const Each = 'each';\n  const Flush = 'flush';\n\n  const Column = 'column';\n  const Row = 'row';\n\n  /**\n   * Calculate bounding boxes for scenegraph items.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {object} params.mark - The scenegraph mark instance to bound.\n   */\n  function Bound(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  vegaUtil.inherits(Bound, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const view = pulse.dataflow,\n            mark = _.mark,\n            type = mark.marktype,\n            entry = vegaScenegraph.Marks[type],\n            bound = entry.bound;\n\n      let markBounds = mark.bounds, rebound;\n\n      if (entry.nested) {\n        // multi-item marks have a single bounds instance\n        if (mark.items.length) view.dirty(mark.items[0]);\n        markBounds = boundItem(mark, bound);\n        mark.items.forEach(item => {\n          item.bounds.clear().union(markBounds);\n        });\n      }\n\n      else if (type === Group || _.modified()) {\n        // operator parameters modified -> re-bound all items\n        // updates group bounds in response to modified group content\n        pulse.visit(pulse.MOD, item => view.dirty(item));\n        markBounds.clear();\n        mark.items.forEach(item => markBounds.union(boundItem(item, bound)));\n\n        // force reflow for axes/legends/titles to propagate any layout changes\n        switch (mark.role) {\n          case AxisRole:\n          case LegendRole:\n          case TitleRole:\n            pulse.reflow();\n        }\n      }\n\n      else {\n        // incrementally update bounds, re-bound mark as needed\n        rebound = pulse.changed(pulse.REM);\n\n        pulse.visit(pulse.ADD, item => {\n          markBounds.union(boundItem(item, bound));\n        });\n\n        pulse.visit(pulse.MOD, item => {\n          rebound = rebound || markBounds.alignsWith(item.bounds);\n          view.dirty(item);\n          markBounds.union(boundItem(item, bound));\n        });\n\n        if (rebound) {\n          markBounds.clear();\n          mark.items.forEach(item => markBounds.union(item.bounds));\n        }\n      }\n\n      // ensure mark bounds do not exceed any clipping region\n      vegaScenegraph.boundClip(mark);\n\n      return pulse.modifies('bounds');\n    }\n  });\n\n  function boundItem(item, bound, opt) {\n    return bound(item.bounds.clear(), item, opt);\n  }\n\n  const COUNTER_NAME = ':vega_identifier:';\n\n  /**\n   * Adds a unique identifier to all added tuples.\n   * This transform creates a new signal that serves as an id counter.\n   * As a result, the id counter is shared across all instances of this\n   * transform, generating unique ids across multiple data streams. In\n   * addition, this signal value can be included in a snapshot of the\n   * dataflow state, enabling correct resumption of id allocation.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {string} params.as - The field name for the generated identifier.\n   */\n  function Identifier(params) {\n    vegaDataflow.Transform.call(this, 0, params);\n  }\n\n  Identifier.Definition = {\n    'type': 'Identifier',\n    'metadata': {'modifies': true},\n    'params': [\n      { 'name': 'as', 'type': 'string', 'required': true }\n    ]\n  };\n\n  vegaUtil.inherits(Identifier, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const counter = getCounter(pulse.dataflow),\n            as = _.as;\n      let id = counter.value;\n\n      pulse.visit(pulse.ADD, t => (t[as] = t[as] || ++id));\n      counter.set(this.value = id);\n      return pulse;\n    }\n  });\n\n  function getCounter(view) {\n    return view._signals[COUNTER_NAME]\n       || (view._signals[COUNTER_NAME] = view.add(0));\n  }\n\n  /**\n   * Bind scenegraph items to a scenegraph mark instance.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {object} params.markdef - The mark definition for creating the mark.\n   *   This is an object of legal scenegraph mark properties which *must* include\n   *   the 'marktype' property.\n   */\n  function Mark(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  vegaUtil.inherits(Mark, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      let mark = this.value;\n\n      // acquire mark on first invocation, bind context and group\n      if (!mark) {\n        mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);\n        mark.group.context = _.context;\n        if (!_.context.group) _.context.group = mark.group;\n        mark.source = this.source; // point to upstream collector\n        mark.clip = _.clip;\n        mark.interactive = _.interactive;\n        this.value = mark;\n      }\n\n      // initialize entering items\n      const Init = mark.marktype === Group ? vegaScenegraph.GroupItem : vegaScenegraph.Item;\n      pulse.visit(pulse.ADD, item => Init.call(item, mark));\n\n      // update clipping and/or interactive status\n      if (_.modified('clip') || _.modified('interactive')) {\n        mark.clip = _.clip;\n        mark.interactive = !!_.interactive;\n        mark.zdirty = true; // force scenegraph re-eval\n        pulse.reflow();\n      }\n\n      // bind items array to scenegraph mark\n      mark.items = pulse.source;\n      return pulse;\n    }\n  });\n\n  function lookup(_) {\n    const g = _.groups, p = _.parent;\n    return g && g.size === 1 ? g.get(Object.keys(g.object)[0])\n      : g && p ? g.lookup(p)\n      : null;\n  }\n\n  /**\n   * Analyze items for overlap, changing opacity to hide items with\n   * overlapping bounding boxes. This transform will preserve at least\n   * two items (e.g., first and last) even if overlap persists.\n   * @param {object} params - The parameters for this operator.\n   * @param {function(*,*): number} [params.sort] - A comparator\n   *   function for sorting items.\n   * @param {object} [params.method] - The overlap removal method to apply.\n   *   One of 'parity' (default, hide every other item until there is no\n   *   more overlap) or 'greedy' (sequentially scan and hide and items that\n   *   overlap with the last visible item).\n   * @param {object} [params.boundScale] - A scale whose range should be used\n   *   to bound the items. Items exceeding the bounds of the scale range\n   *   will be treated as overlapping. If null or undefined, no bounds check\n   *   will be applied.\n   * @param {object} [params.boundOrient] - The orientation of the scale\n   *   (top, bottom, left, or right) used to bound items. This parameter is\n   *   ignored if boundScale is null or undefined.\n   * @param {object} [params.boundTolerance] - The tolerance in pixels for\n   *   bound inclusion testing (default 1). This specifies by how many pixels\n   *   an item's bounds may exceed the scale range bounds and not be culled.\n   * @constructor\n   */\n  function Overlap(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  const methods = {\n    parity: items =>\n      items.filter((item, i) => i % 2 ? (item.opacity = 0) : 1),\n    greedy: (items, sep) => {\n      let a;\n      return items.filter((b, i) =>\n        (!i || !intersect(a.bounds, b.bounds, sep))\n          ? (a = b, 1)\n          : (b.opacity = 0)\n      );\n    }\n  };\n\n  // compute bounding box intersection\n  // including padding pixels of separation\n  const intersect = (a, b, sep) =>\n    sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\n\n  const hasOverlap = (items, pad) => {\n    for (var i=1, n=items.length, a=items[0].bounds, b; i<n; a=b, ++i) {\n      if (intersect(a, b = items[i].bounds, pad)) return true;\n    }\n  };\n\n  const hasBounds = item => {\n    var b = item.bounds;\n    return b.width() > 1 && b.height() > 1;\n  };\n\n  const boundTest = (scale, orient, tolerance) => {\n    var range = scale.range(),\n        b = new vegaScenegraph.Bounds();\n\n    if (orient === Top || orient === Bottom) {\n      b.set(range[0], -Infinity, range[1], +Infinity);\n    } else {\n      b.set(-Infinity, range[0], +Infinity, range[1]);\n    }\n    b.expand(tolerance || 1);\n\n    return item => b.encloses(item.bounds);\n  };\n\n  // reset all items to be fully opaque\n  const reset = source => {\n    source.forEach(item => item.opacity = 1);\n    return source;\n  };\n\n  // add all tuples to mod, fork pulse if parameters were modified\n  // fork prevents cross-stream tuple pollution (e.g., pulse from scale)\n  const reflow = (pulse, _) =>\n    pulse.reflow(_.modified()).modifies('opacity');\n\n  vegaUtil.inherits(Overlap, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const reduce = methods[_.method] || methods.parity,\n            sep = _.separation || 0;\n\n      let source = pulse.materialize(pulse.SOURCE).source,\n          items, test;\n\n      if (!source || !source.length) return;\n\n      if (!_.method) {\n        // early exit if method is falsy\n        if (_.modified('method')) {\n          reset(source);\n          pulse = reflow(pulse, _);\n        }\n        return pulse;\n      }\n\n      // skip labels with no content\n      source = source.filter(hasBounds);\n\n      // early exit, nothing to do\n      if (!source.length) return;\n\n      if (_.sort) {\n        source = source.slice().sort(_.sort);\n      }\n\n      items = reset(source);\n      pulse = reflow(pulse, _);\n\n      if (items.length >= 3 && hasOverlap(items, sep)) {\n        do {\n          items = reduce(items, sep);\n        } while (items.length >= 3 && hasOverlap(items, sep));\n\n        if (items.length < 3 && !vegaUtil.peek(source).opacity) {\n          if (items.length > 1) vegaUtil.peek(items).opacity = 0;\n          vegaUtil.peek(source).opacity = 1;\n        }\n      }\n\n      if (_.boundScale && _.boundTolerance >= 0) {\n        test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n        source.forEach(item => {\n          if (!test(item)) item.opacity = 0;\n        });\n      }\n\n      // re-calculate mark bounds\n      const bounds = items[0].mark.bounds.clear();\n      source.forEach(item => {\n        if (item.opacity) bounds.union(item.bounds);\n      });\n\n      return pulse;\n    }\n  });\n\n  /**\n   * Queue modified scenegraph items for rendering.\n   * @constructor\n   */\n  function Render(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  vegaUtil.inherits(Render, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const view = pulse.dataflow;\n\n      pulse.visit(pulse.ALL, item => view.dirty(item));\n\n      // set z-index dirty flag as needed\n      if (pulse.fields && pulse.fields['zindex']) {\n        var item = pulse.source && pulse.source[0];\n        if (item) item.mark.zdirty = true;\n      }\n    }\n  });\n\n  const tempBounds = new vegaScenegraph.Bounds();\n\n  function set(item, property, value) {\n    return item[property] === value ? 0\n      : (item[property] = value, 1);\n  }\n\n  function isYAxis(mark) {\n    var orient = mark.items[0].orient;\n    return orient === Left || orient === Right;\n  }\n\n  function axisIndices(datum) {\n    var index = +datum.grid;\n    return [\n      datum.ticks  ? index++ : -1, // ticks index\n      datum.labels ? index++ : -1, // labels index\n      index + (+datum.domain)      // title index\n    ];\n  }\n\n  function axisLayout(view, axis, width, height) {  \n    var item = axis.items[0],\n        datum = item.datum,\n        delta = item.translate != null ? item.translate : 0.5,\n        orient = item.orient,\n        indices = axisIndices(datum),\n        range = item.range,\n        offset = item.offset,\n        position = item.position,\n        minExtent = item.minExtent,\n        maxExtent = item.maxExtent,\n        title = datum.title && item.items[indices[2]].items[0],\n        titlePadding = item.titlePadding,\n        bounds = item.bounds,\n        dl = title && vegaScenegraph.multiLineOffset(title),\n        x = 0, y = 0, i, s;\n\n    tempBounds.clear().union(bounds);\n    bounds.clear();\n    if ((i=indices[0]) > -1) bounds.union(item.items[i].bounds);\n    if ((i=indices[1]) > -1) bounds.union(item.items[i].bounds);\n\n    // position axis group and title\n    switch (orient) {\n      case Top:\n        x = position || 0;\n        y = -offset;\n        s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n        bounds.add(0, -s).add(range, 0);\n        if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);\n        break;\n      case Left:\n        x = -offset;\n        y = position || 0;\n        s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n        bounds.add(-s, 0).add(0, range);\n        if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);\n        break;\n      case Right:\n        x = width + offset;\n        y = position || 0;\n        s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n        bounds.add(0, 0).add(s, range);\n        if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);\n        break;\n      case Bottom:\n        x = position || 0;\n        y = height + offset;\n        s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n        bounds.add(0, 0).add(range, s);\n        if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);\n        break;\n      default:\n        x = item.x;\n        y = item.y;\n    }\n\n    // update bounds\n    vegaScenegraph.boundStroke(bounds.translate(x, y), item);\n\n    if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {\n      item.bounds = tempBounds;\n      view.dirty(item);\n      item.bounds = bounds;\n      view.dirty(item);\n    }\n\n    return item.mark.bounds.clear().union(bounds);\n  }\n\n  function axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {\n    const b = title.bounds;\n\n    if (title.auto) {\n      const v = sign * (offset + dl + pad);\n      let dx = 0, dy = 0;\n\n      view.dirty(title);\n      isYAxis\n        ? dx = (title.x || 0) - (title.x = v)\n        : dy = (title.y || 0) - (title.y = v);\n      title.mark.bounds.clear().union(b.translate(-dx, -dy));\n      view.dirty(title);\n    }\n\n    bounds.union(b);\n  }\n\n  // aggregation functions for grid margin determination\n  const min = (a, b) => Math.floor(Math.min(a, b));\n  const max = (a, b) => Math.ceil(Math.max(a, b));\n\n  function gridLayoutGroups(group) {\n    var groups = group.items,\n        n = groups.length,\n        i = 0, mark, items;\n\n    var views = {\n      marks:      [],\n      rowheaders: [],\n      rowfooters: [],\n      colheaders: [],\n      colfooters: [],\n      rowtitle: null,\n      coltitle: null\n    };\n\n    // layout axes, gather legends, collect bounds\n    for (; i<n; ++i) {\n      mark = groups[i];\n      items = mark.items;\n      if (mark.marktype === Group) {\n        switch (mark.role) {\n          case AxisRole:\n          case LegendRole:\n          case TitleRole:\n            break;\n          case RowHeader: views.rowheaders.push(...items); break;\n          case RowFooter: views.rowfooters.push(...items); break;\n          case ColHeader: views.colheaders.push(...items); break;\n          case ColFooter: views.colfooters.push(...items); break;\n          case RowTitle:  views.rowtitle = items[0]; break;\n          case ColTitle:  views.coltitle = items[0]; break;\n          default:        views.marks.push(...items);\n        }\n      }\n    }\n\n    return views;\n  }\n\n  function bboxFlush(item) {\n    return new vegaScenegraph.Bounds().set(0, 0, item.width || 0, item.height || 0);\n  }\n\n  function bboxFull(item) {\n    var b = item.bounds.clone();\n    return b.empty()\n      ? b.set(0, 0, 0, 0)\n      : b.translate(-(item.x || 0), -(item.y || 0));\n  }\n\n  function get(opt, key, d) {\n    var v = vegaUtil.isObject(opt) ? opt[key] : opt;\n    return v != null ? v : (d !== undefined ? d : 0);\n  }\n\n  function offsetValue(v) {\n    return v < 0 ? Math.ceil(-v) : 0;\n  }\n\n  function gridLayout(view, groups, opt) {\n    var dirty = !opt.nodirty,\n        bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n        bounds = tempBounds.set(0, 0, 0, 0),\n        alignCol = get(opt.align, Column),\n        alignRow = get(opt.align, Row),\n        padCol = get(opt.padding, Column),\n        padRow = get(opt.padding, Row),\n        ncols = opt.columns || groups.length,\n        nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n        n = groups.length,\n        xOffset = Array(n), xExtent = Array(ncols), xMax = 0,\n        yOffset = Array(n), yExtent = Array(nrows), yMax = 0,\n        dx = Array(n), dy = Array(n), boxes = Array(n),\n        m, i, c, r, b, g, px, py, x, y, offset;\n\n    for (i=0; i<ncols; ++i) xExtent[i] = 0;\n    for (i=0; i<nrows; ++i) yExtent[i] = 0;\n\n    // determine offsets for each group\n    for (i=0; i<n; ++i) {\n      g = groups[i];\n      b = boxes[i] = bbox(g);\n      g.x = g.x || 0; dx[i] = 0;\n      g.y = g.y || 0; dy[i] = 0;\n      c = i % ncols;\n      r = ~~(i / ncols);\n      xMax = Math.max(xMax, px = Math.ceil(b.x2));\n      yMax = Math.max(yMax, py = Math.ceil(b.y2));\n      xExtent[c] = Math.max(xExtent[c], px);\n      yExtent[r] = Math.max(yExtent[r], py);\n      xOffset[i] = padCol + offsetValue(b.x1);\n      yOffset[i] = padRow + offsetValue(b.y1);\n      if (dirty) view.dirty(groups[i]);\n    }\n\n    // set initial alignment offsets\n    for (i=0; i<n; ++i) {\n      if (i % ncols === 0) xOffset[i] = 0;\n      if (i < ncols) yOffset[i] = 0;\n    }\n\n    // enforce column alignment constraints\n    if (alignCol === Each) {\n      for (c=1; c<ncols; ++c) {\n        for (offset=0, i=c; i<n; i += ncols) {\n          if (offset < xOffset[i]) offset = xOffset[i];\n        }\n        for (i=c; i<n; i += ncols) {\n          xOffset[i] = offset + xExtent[c-1];\n        }\n      }\n    } else if (alignCol === All) {\n      for (offset=0, i=0; i<n; ++i) {\n        if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n      }\n      for (i=0; i<n; ++i) {\n        if (i % ncols) xOffset[i] = offset + xMax;\n      }\n    } else {\n      for (alignCol=false, c=1; c<ncols; ++c) {\n        for (i=c; i<n; i += ncols) {\n          xOffset[i] += xExtent[c-1];\n        }\n      }\n    }\n\n    // enforce row alignment constraints\n    if (alignRow === Each) {\n      for (r=1; r<nrows; ++r) {\n        for (offset=0, i=r*ncols, m=i+ncols; i<m; ++i) {\n          if (offset < yOffset[i]) offset = yOffset[i];\n        }\n        for (i=r*ncols; i<m; ++i) {\n          yOffset[i] = offset + yExtent[r-1];\n        }\n      }\n    } else if (alignRow === All) {\n      for (offset=0, i=ncols; i<n; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n      for (i=ncols; i<n; ++i) {\n        yOffset[i] = offset + yMax;\n      }\n    } else {\n      for (alignRow=false, r=1; r<nrows; ++r) {\n        for (i=r*ncols, m=i+ncols; i<m; ++i) {\n          yOffset[i] += yExtent[r-1];\n        }\n      }\n    }\n\n    // perform horizontal grid layout\n    for (x=0, i=0; i<n; ++i) {\n      x = xOffset[i] + (i % ncols ? x : 0);\n      dx[i] += x - groups[i].x;\n    }\n\n    // perform vertical grid layout\n    for (c=0; c<ncols; ++c) {\n      for (y=0, i=c; i<n; i += ncols) {\n        y += yOffset[i];\n        dy[i] += y - groups[i].y;\n      }\n    }\n\n    // perform horizontal centering\n    if (alignCol && get(opt.center, Column) && nrows > 1) {\n      for (i=0; i<n; ++i) {\n        b = alignCol === All ? xMax : xExtent[i % ncols];\n        x = b - boxes[i].x2 - groups[i].x - dx[i];\n        if (x > 0) dx[i] += x / 2;\n      }\n    }\n\n    // perform vertical centering\n    if (alignRow && get(opt.center, Row) && ncols !== 1) {\n      for (i=0; i<n; ++i) {\n        b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n        y = b - boxes[i].y2 - groups[i].y - dy[i];\n        if (y > 0) dy[i] += y / 2;\n      }\n    }\n\n    // position grid relative to anchor\n    for (i=0; i<n; ++i) {\n      bounds.union(boxes[i].translate(dx[i], dy[i]));\n    }\n    x = get(opt.anchor, X);\n    y = get(opt.anchor, Y);\n    switch (get(opt.anchor, Column)) {\n      case End:    x -= bounds.width(); break;\n      case Middle: x -= bounds.width() / 2;\n    }\n    switch (get(opt.anchor, Row)) {\n      case End:    y -= bounds.height(); break;\n      case Middle: y -= bounds.height() / 2;\n    }\n    x = Math.round(x);\n    y = Math.round(y);\n\n    // update mark positions, bounds, dirty\n    bounds.clear();\n    for (i=0; i<n; ++i) {\n      groups[i].mark.bounds.clear();\n    }\n    for (i=0; i<n; ++i) {\n      g = groups[i];\n      g.x += (dx[i] += x);\n      g.y += (dy[i] += y);\n      bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n      if (dirty) view.dirty(g);\n    }\n\n    return bounds;\n  }\n\n  function trellisLayout(view, group, opt) {\n    var views = gridLayoutGroups(group),\n        groups = views.marks,\n        bbox = opt.bounds === Flush ? boundFlush : boundFull,\n        off = opt.offset,\n        ncols = opt.columns || groups.length,\n        nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n        cells = nrows * ncols,\n        x, y, x2, y2, anchor, band, offset;\n\n    // -- initial grid layout\n    const bounds = gridLayout(view, groups, opt);\n    if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid\n\n    // -- layout grid headers and footers --\n\n    // perform row header layout\n    if (views.rowheaders) {\n      band = get(opt.headerBand, Row, null);\n      x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n    }\n\n    // perform column header layout\n    if (views.colheaders) {\n      band = get(opt.headerBand, Column, null);\n      y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n    }\n\n    // perform row footer layout\n    if (views.rowfooters) {\n      band = get(opt.footerBand, Row, null);\n      x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows,  get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols-1, ncols, 1, band);\n    }\n\n    // perform column footer layout\n    if (views.colfooters) {\n      band = get(opt.footerBand, Column, null);\n      y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols,  get(off, 'columnFooter'), max, 1, bbox, 'y2', cells-ncols, 1, ncols, band);\n    }\n\n    // perform row title layout\n    if (views.rowtitle) {\n      anchor = get(opt.titleAnchor, Row);\n      offset = get(off, 'rowTitle');\n      offset = anchor === End ? x2 + offset : x - offset;\n      band = get(opt.titleBand, Row, 0.5);\n      layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n    }\n\n    // perform column title layout\n    if (views.coltitle) {\n      anchor = get(opt.titleAnchor, Column);\n      offset = get(off, 'columnTitle');\n      offset = anchor === End ? y2 + offset : y - offset;\n      band = get(opt.titleBand, Column, 0.5);\n      layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n    }\n  }\n\n  function boundFlush(item, field) {\n    return field === 'x1' ? (item.x || 0)\n      : field === 'y1' ? (item.y || 0)\n      : field === 'x2' ? (item.x || 0) + (item.width || 0)\n      : field === 'y2' ? (item.y || 0) + (item.height || 0)\n      : undefined;\n  }\n\n  function boundFull(item, field) {\n    return item.bounds[field];\n  }\n\n  function layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n    var n = groups.length,\n        init = 0,\n        edge = 0,\n        i, j, k, m, b, h, g, x, y;\n\n    // if no groups, early exit and return 0\n    if (!n) return init;\n\n    // compute margin\n    for (i=start; i<n; i+=stride) {\n      if (groups[i]) init = agg(init, bound(groups[i], bf));\n    }\n\n    // if no headers, return margin calculation\n    if (!headers.length) return init;\n\n    // check if number of headers exceeds number of rows or columns\n    if (headers.length > limit) {\n      view.warn('Grid headers exceed limit: ' + limit);\n      headers = headers.slice(0, limit);\n    }\n\n    // apply offset\n    init += offset;\n\n    // clear mark bounds for all headers\n    for (j=0, m=headers.length; j<m; ++j) {\n      view.dirty(headers[j]);\n      headers[j].mark.bounds.clear();\n    }\n\n    // layout each header\n    for (i=start, j=0, m=headers.length; j<m; ++j, i+=stride) {\n      h = headers[j];\n      b = h.mark.bounds;\n\n      // search for nearest group to align to\n      // necessary if table has empty cells\n      for (k=i; k >= 0 && (g = groups[k]) == null; k-=back);\n\n      // assign coordinates and update bounds\n      if (isX) {\n        x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n        y = init;\n      } else {\n        x = init;\n        y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n      }\n      b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n      h.x = x;\n      h.y = y;\n      view.dirty(h);\n\n      // update current edge of layout bounds\n      edge = agg(edge, b[bf]);\n    }\n\n    return edge;\n  }\n\n  function layoutTitle(view, g, offset, isX, bounds, band) {\n    if (!g) return;\n    view.dirty(g);\n\n    // compute title coordinates\n    var x = offset, y = offset;\n    isX\n      ? (x = Math.round(bounds.x1 + band * bounds.width()))\n      : (y = Math.round(bounds.y1 + band * bounds.height()));\n\n    // assign coordinates and update bounds\n    g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n    g.mark.bounds.clear().union(g.bounds);\n    g.x = x;\n    g.y = y;\n\n    // queue title for redraw\n    view.dirty(g);\n  }\n\n  // utility for looking up legend layout configuration\n  function lookup$1(config, orient) {\n    const opt = config[orient] || {};\n    return (key, d) => opt[key] != null ? opt[key]\n      : config[key] != null ? config[key]\n      : d;\n  }\n\n  // if legends specify offset directly, use the maximum specified value\n  function offsets(legends, value) {\n    var max = -Infinity;\n    legends.forEach(item => {\n      if (item.offset != null) max = Math.max(max, item.offset);\n    });\n    return max > -Infinity ? max : value;\n  }\n\n  function legendParams(g, orient, config, xb, yb, w, h) {\n    const _ = lookup$1(config, orient),\n          offset = offsets(g, _('offset', 0)),\n          anchor = _('anchor', Start),\n          mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n\n    const p = {\n      align:   Each,\n      bounds:  _('bounds', Flush),\n      columns: _('direction') === 'vertical' ? 1 : g.length,\n      padding: _('margin', 8),\n      center:  _('center'),\n      nodirty: true\n    };\n\n    switch (orient) {\n      case Left:\n        p.anchor = {\n          x: Math.floor(xb.x1) - offset, column: End,\n          y: mult * (h || xb.height() + 2 * xb.y1), row: anchor\n        };\n        break;\n      case Right:\n        p.anchor = {\n          x: Math.ceil(xb.x2) + offset,\n          y: mult * (h || xb.height() + 2 * xb.y1), row: anchor\n        };\n        break;\n      case Top:\n        p.anchor = {\n          y: Math.floor(yb.y1) - offset, row: End,\n          x: mult * (w || yb.width() + 2 * yb.x1), column: anchor\n        };\n        break;\n      case Bottom:\n        p.anchor = {\n          y: Math.ceil(yb.y2) + offset,\n          x: mult * (w || yb.width() + 2 * yb.x1), column: anchor\n        };\n        break;\n      case TopLeft:\n        p.anchor = {x: offset, y: offset};\n        break;\n      case TopRight:\n        p.anchor = {x: w - offset, y: offset, column: End};\n        break;\n      case BottomLeft:\n        p.anchor = {x: offset, y: h - offset, row: End};\n        break;\n      case BottomRight:\n        p.anchor = {x: w - offset, y: h - offset, column: End, row: End};\n        break;\n    }\n\n    return p;\n  }\n\n  function legendLayout(view, legend) {\n    var item = legend.items[0],\n        datum = item.datum,\n        orient = item.orient,\n        bounds = item.bounds,\n        x = item.x, y = item.y, w, h;\n\n    // cache current bounds for later comparison\n    item._bounds\n      ? item._bounds.clear().union(bounds)\n      : item._bounds = bounds.clone();\n    bounds.clear();\n\n    // adjust legend to accommodate padding and title\n    legendGroupLayout(view, item, item.items[0].items[0]);\n\n    // aggregate bounds to determine size, and include origin\n    bounds = legendBounds(item, bounds);\n    w = 2 * item.padding;\n    h = 2 * item.padding;\n    if (!bounds.empty()) {\n      w = Math.ceil(bounds.width() + w);\n      h = Math.ceil(bounds.height() + h);\n    }\n\n    if (datum.type === Symbols) {\n      legendEntryLayout(item.items[0].items[0].items[0].items);\n    }\n\n    if (orient !== None) {\n      item.x = x = 0;\n      item.y = y = 0;\n    }\n    item.width = w;\n    item.height = h;\n    vegaScenegraph.boundStroke(bounds.set(x, y, x + w, y + h), item);\n    item.mark.bounds.clear().union(bounds);\n\n    return item;\n  }\n\n  function legendBounds(item, b) {\n    // aggregate item bounds\n    item.items.forEach(_ => b.union(_.bounds));\n\n    // anchor to legend origin\n    b.x1 = item.padding;\n    b.y1 = item.padding;\n\n    return b;\n  }\n\n  function legendGroupLayout(view, item, entry) {\n    var pad = item.padding,\n        ex = pad - entry.x,\n        ey = pad - entry.y;\n\n    if (!item.datum.title) {\n      if (ex || ey) translate(view, entry, ex, ey);\n    } else {\n      var title = item.items[1].items[0],\n          anchor = title.anchor,\n          tpad = item.titlePadding || 0,\n          tx = pad - title.x,\n          ty = pad - title.y;\n\n      switch (title.orient) {\n        case Left:\n          ex += Math.ceil(title.bounds.width()) + tpad;\n          break;\n        case Right:\n        case Bottom:\n          break;\n        default:\n          ey += title.bounds.height() + tpad;\n      }\n      if (ex || ey) translate(view, entry, ex, ey);\n\n      switch (title.orient) {\n        case Left:\n          ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n          break;\n        case Right:\n          tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n          ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n          break;\n        case Bottom:\n          tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n          ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n          break;\n        default:\n          tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n      }\n      if (tx || ty) translate(view, title, tx, ty);\n\n      // translate legend if title pushes into negative coordinates\n      if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n        translate(view, entry, -tx, 0);\n        translate(view, title, -tx, 0);\n      }\n    }\n  }\n\n  function legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n    const grad = item.datum.type !== 'symbol',\n          vgrad = title.datum.vgrad,\n          e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n          s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n          u = vgrad && lr ? s : 0,\n          v = vgrad && lr ? 0 : s,\n          o = y <= 0 ? 0 : vegaScenegraph.multiLineOffset(title);\n\n    return Math.round(anchor === Start ? u\n      : anchor === End ? (v - o)\n      : 0.5 * (s - o));\n  }\n\n  function translate(view, item, dx, dy) {\n    item.x += dx;\n    item.y += dy;\n    item.bounds.translate(dx, dy);\n    item.mark.bounds.translate(dx, dy);\n    view.dirty(item);\n  }\n\n  function legendEntryLayout(entries) {\n    // get max widths for each column\n    var widths = entries.reduce((w, g) => {\n      w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n      return w;\n    }, {});\n\n    // set dimensions of legend entry groups\n    entries.forEach(g => {\n      g.width  = widths[g.column];\n      g.height = g.bounds.y2 - g.y;\n    });\n  }\n\n  function titleLayout(view, mark, width, height, viewBounds) {\n    var group = mark.items[0],\n        frame = group.frame,\n        orient = group.orient,\n        anchor = group.anchor,\n        offset = group.offset,\n        padding = group.padding,\n        title = group.items[0].items[0],\n        subtitle = group.items[1] && group.items[1].items[0],\n        end = (orient === Left || orient === Right) ? height : width,\n        start = 0, x = 0, y = 0, sx = 0, sy = 0, pos;\n\n    if (frame !== Group) {\n      orient === Left ? (start = viewBounds.y2, end = viewBounds.y1)\n        : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2)\n        : (start = viewBounds.x1, end = viewBounds.x2);\n    } else if (orient === Left) {\n      start = height, end = 0;\n    }\n\n    pos = (anchor === Start) ? start\n      : (anchor === End) ? end\n      : (start + end) / 2;\n\n    if (subtitle && subtitle.text) {\n      // position subtitle\n      switch (orient) {\n        case Top:\n        case Bottom:\n          sy = title.bounds.height() + padding;\n          break;\n        case Left:\n          sx = title.bounds.width() + padding;\n          break;\n        case Right:\n          sx = -title.bounds.width() - padding;\n          break;\n      }\n\n      tempBounds.clear().union(subtitle.bounds);\n      tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));\n      if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {\n        view.dirty(subtitle);\n        subtitle.bounds.clear().union(tempBounds);\n        subtitle.mark.bounds.clear().union(tempBounds);\n        view.dirty(subtitle);\n      }\n\n      tempBounds.clear().union(subtitle.bounds);\n    } else {\n      tempBounds.clear();\n    }\n    tempBounds.union(title.bounds);\n\n    // position title group\n    switch (orient) {\n      case Top:\n        x = pos;\n        y = viewBounds.y1 - tempBounds.height() - offset;\n        break;\n      case Left:\n        x = viewBounds.x1 - tempBounds.width() - offset;\n        y = pos;\n        break;\n      case Right:\n        x = viewBounds.x2 + tempBounds.width() + offset;\n        y = pos;\n        break;\n      case Bottom:\n        x = pos;\n        y = viewBounds.y2 + offset;\n        break;\n      default:\n        x = group.x;\n        y = group.y;\n    }\n\n    if (set(group, 'x', x) | set(group, 'y', y)) {\n      tempBounds.translate(x, y);\n      view.dirty(group);\n      group.bounds.clear().union(tempBounds);\n      mark.bounds.clear().union(tempBounds);\n      view.dirty(group);\n    }\n    return group.bounds;\n  }\n\n  /**\n   * Layout view elements such as axes and legends.\n   * Also performs size adjustments.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {object} params.mark - Scenegraph mark of groups to layout.\n   */\n  function ViewLayout(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  vegaUtil.inherits(ViewLayout, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const view = pulse.dataflow;\n      _.mark.items.forEach(group => {\n        if (_.layout) trellisLayout(view, group, _.layout);\n        layoutGroup(view, group, _);\n      });\n      return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;\n    }\n  });\n\n  function shouldReflow(group) {\n    // We typically should reflow if layout is invoked (#2568), as child items\n    // may have resized and reflow ensures group bounds are re-calculated.\n    // However, legend entries have a special exception to avoid instability.\n    // For example, if a selected legend symbol gains a stroke on hover,\n    // we don't want to re-position subsequent elements in the legend.\n    return group && group.mark.role !== 'legend-entry';\n  }\n\n  function layoutGroup(view, group, _) {\n    var items = group.items,\n        width = Math.max(0, group.width || 0),\n        height = Math.max(0, group.height || 0),\n        viewBounds = new vegaScenegraph.Bounds().set(0, 0, width, height),\n        xBounds = viewBounds.clone(),\n        yBounds = viewBounds.clone(),\n        legends = [], title,\n        mark, orient, b, i, n;\n\n    // layout axes, gather legends, collect bounds\n    for (i=0, n=items.length; i<n; ++i) {\n      mark = items[i];\n      switch (mark.role) {\n        case AxisRole:\n          b = isYAxis(mark) ? xBounds : yBounds;\n          b.union(axisLayout(view, mark, width, height));\n          break;\n        case TitleRole:\n          title = mark;\n          break;\n        case LegendRole:\n          legends.push(legendLayout(view, mark));\n          break;\n        case FrameRole:\n        case ScopeRole:\n        case RowHeader:\n        case RowFooter:\n        case RowTitle:\n        case ColHeader:\n        case ColFooter:\n        case ColTitle:\n          xBounds.union(mark.bounds);\n          yBounds.union(mark.bounds);\n          break;\n        default:\n          viewBounds.union(mark.bounds);\n      }\n    }\n\n    // layout legends, adjust viewBounds\n    if (legends.length) {\n      // group legends by orient\n      const l = {};\n      legends.forEach(item => {\n        orient = item.orient || Right;\n        if (orient !== None) (l[orient] || (l[orient] = [])).push(item);\n      });\n\n      // perform grid layout for each orient group\n      for (const orient in l) {\n        const g = l[orient];\n        gridLayout(view, g, legendParams(\n          g, orient, _.legends, xBounds, yBounds, width, height\n        ));\n      }\n\n      // update view bounds\n      legends.forEach(item => {\n        const b = item.bounds;\n\n        if (!b.equals(item._bounds)) {\n          item.bounds = item._bounds;\n          view.dirty(item); // dirty previous location\n          item.bounds = b;\n          view.dirty(item);\n        }\n\n        if (_.autosize && _.autosize.type === Fit) {\n          // For autosize fit, incorporate the orthogonal dimension only.\n          // Legends that overrun the chart area will then be clipped;\n          // otherwise the chart area gets reduced to nothing!\n          switch(item.orient) {\n            case Left:\n            case Right:\n              viewBounds.add(b.x1, 0).add(b.x2, 0);\n              break;\n            case Top:\n            case Bottom:\n              viewBounds.add(0, b.y1).add(0, b.y2);\n          }\n        } else {\n          viewBounds.union(b);\n        }\n      });\n    }\n\n    // combine bounding boxes\n    viewBounds.union(xBounds).union(yBounds);\n\n    // layout title, adjust bounds\n    if (title) {\n      viewBounds.union(titleLayout(view, title, width, height, viewBounds));\n    }\n\n    // override aggregated view bounds if content is clipped\n    if (group.clip) {\n      viewBounds.set(0, 0, group.width || 0, group.height || 0);\n    }\n\n    // perform size adjustment\n    viewSizeLayout(view, group, viewBounds, _);\n  }\n\n  function viewSizeLayout(view, group, viewBounds, _) {\n    const auto = _.autosize || {},\n          type = auto.type;\n\n    if (view._autosize < 1 || !type) return;\n\n    let viewWidth = view._width,\n        viewHeight = view._height,\n        width  = Math.max(0, group.width || 0),\n        left   = Math.max(0, Math.ceil(-viewBounds.x1)),\n        height = Math.max(0, group.height || 0),\n        top    = Math.max(0, Math.ceil(-viewBounds.y1));\n\n    const right  = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n          bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n\n    if (auto.contains === Padding) {\n      const padding = view.padding();\n      viewWidth -= padding.left + padding.right;\n      viewHeight -= padding.top + padding.bottom;\n    }\n\n    if (type === None) {\n      left = 0;\n      top = 0;\n      width = viewWidth;\n      height = viewHeight;\n    }\n\n    else if (type === Fit) {\n      width = Math.max(0, viewWidth - left - right);\n      height = Math.max(0, viewHeight - top - bottom);\n    }\n\n    else if (type === FitX) {\n      width = Math.max(0, viewWidth - left - right);\n      viewHeight = height + top + bottom;\n    }\n\n    else if (type === FitY) {\n      viewWidth = width + left + right;\n      height = Math.max(0, viewHeight - top - bottom);\n    }\n\n    else if (type === Pad) {\n      viewWidth = width + left + right;\n      viewHeight = height + top + bottom;\n    }\n\n    view._resizeView(\n      viewWidth, viewHeight,\n      width, height,\n      [left, top],\n      auto.resize\n    );\n  }\n\n  exports.bound = Bound;\n  exports.identifier = Identifier;\n  exports.mark = Mark;\n  exports.overlap = Overlap;\n  exports.render = Render;\n  exports.viewlayout = ViewLayout;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vega_dataflow$build$vega_dataflow","~$shadow.js","~$module$node_modules$vega_scenegraph$build$vega_scenegraph","~$module$node_modules$vega_util$build$vega_util"]],"~:properties",["^5",["interactive","y1","width","align","x1","columns","height","viewlayout","group","clip","zdirty","x","overlap","__esModule","padding","transform","vega","anchor","nodirty","value","items","center","context","identifier","greedy","column","source","row","render","y","parity","Definition","transforms","bound","bounds","_bounds","mark","opacity"]],"~:compiled-at",1600144479911,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_view_transforms$build$vega_view_transforms.js\",\n\"lineCount\":50,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-view-transforms/build/vega-view-transforms.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_view_transforms$build$vega_view_transforms\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-dataflow'), require('vega-scenegraph'), require('vega-util')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-dataflow', 'vega-scenegraph', 'vega-util'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.vega));\\n}(this, (function (exports, vegaDataflow, vegaScenegraph, vegaUtil) { 'use strict';\\n\\n  const Top = 'top';\\n  const Left = 'left';\\n  const Right = 'right';\\n  const Bottom = 'bottom';\\n\\n  const TopLeft = 'top-left';\\n  const TopRight = 'top-right';\\n  const BottomLeft = 'bottom-left';\\n  const BottomRight = 'bottom-right';\\n\\n  const Start = 'start';\\n  const Middle = 'middle';\\n  const End = 'end';\\n\\n  const X = 'x';\\n  const Y = 'y';\\n\\n  const Group = 'group';\\n\\n  const AxisRole = 'axis';\\n  const TitleRole = 'title';\\n  const FrameRole = 'frame';\\n  const ScopeRole = 'scope';\\n  const LegendRole = 'legend';\\n\\n  const RowHeader = 'row-header';\\n  const RowFooter = 'row-footer';\\n  const RowTitle  = 'row-title';\\n  const ColHeader = 'column-header';\\n  const ColFooter = 'column-footer';\\n  const ColTitle  = 'column-title';\\n\\n  const Padding = 'padding';\\n\\n  const Symbols = 'symbol';\\n\\n  const Fit  = 'fit';\\n  const FitX = 'fit-x';\\n  const FitY = 'fit-y';\\n  const Pad  = 'pad';\\n  const None = 'none';\\n\\n  const All = 'all';\\n  const Each = 'each';\\n  const Flush = 'flush';\\n\\n  const Column = 'column';\\n  const Row = 'row';\\n\\n  /**\\n   * Calculate bounding boxes for scenegraph items.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {object} params.mark - The scenegraph mark instance to bound.\\n   */\\n  function Bound(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  vegaUtil.inherits(Bound, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const view = pulse.dataflow,\\n            mark = _.mark,\\n            type = mark.marktype,\\n            entry = vegaScenegraph.Marks[type],\\n            bound = entry.bound;\\n\\n      let markBounds = mark.bounds, rebound;\\n\\n      if (entry.nested) {\\n        // multi-item marks have a single bounds instance\\n        if (mark.items.length) view.dirty(mark.items[0]);\\n        markBounds = boundItem(mark, bound);\\n        mark.items.forEach(item => {\\n          item.bounds.clear().union(markBounds);\\n        });\\n      }\\n\\n      else if (type === Group || _.modified()) {\\n        // operator parameters modified -> re-bound all items\\n        // updates group bounds in response to modified group content\\n        pulse.visit(pulse.MOD, item => view.dirty(item));\\n        markBounds.clear();\\n        mark.items.forEach(item => markBounds.union(boundItem(item, bound)));\\n\\n        // force reflow for axes/legends/titles to propagate any layout changes\\n        switch (mark.role) {\\n          case AxisRole:\\n          case LegendRole:\\n          case TitleRole:\\n            pulse.reflow();\\n        }\\n      }\\n\\n      else {\\n        // incrementally update bounds, re-bound mark as needed\\n        rebound = pulse.changed(pulse.REM);\\n\\n        pulse.visit(pulse.ADD, item => {\\n          markBounds.union(boundItem(item, bound));\\n        });\\n\\n        pulse.visit(pulse.MOD, item => {\\n          rebound = rebound || markBounds.alignsWith(item.bounds);\\n          view.dirty(item);\\n          markBounds.union(boundItem(item, bound));\\n        });\\n\\n        if (rebound) {\\n          markBounds.clear();\\n          mark.items.forEach(item => markBounds.union(item.bounds));\\n        }\\n      }\\n\\n      // ensure mark bounds do not exceed any clipping region\\n      vegaScenegraph.boundClip(mark);\\n\\n      return pulse.modifies('bounds');\\n    }\\n  });\\n\\n  function boundItem(item, bound, opt) {\\n    return bound(item.bounds.clear(), item, opt);\\n  }\\n\\n  const COUNTER_NAME = ':vega_identifier:';\\n\\n  /**\\n   * Adds a unique identifier to all added tuples.\\n   * This transform creates a new signal that serves as an id counter.\\n   * As a result, the id counter is shared across all instances of this\\n   * transform, generating unique ids across multiple data streams. In\\n   * addition, this signal value can be included in a snapshot of the\\n   * dataflow state, enabling correct resumption of id allocation.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {string} params.as - The field name for the generated identifier.\\n   */\\n  function Identifier(params) {\\n    vegaDataflow.Transform.call(this, 0, params);\\n  }\\n\\n  Identifier.Definition = {\\n    'type': 'Identifier',\\n    'metadata': {'modifies': true},\\n    'params': [\\n      { 'name': 'as', 'type': 'string', 'required': true }\\n    ]\\n  };\\n\\n  vegaUtil.inherits(Identifier, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const counter = getCounter(pulse.dataflow),\\n            as = _.as;\\n      let id = counter.value;\\n\\n      pulse.visit(pulse.ADD, t => (t[as] = t[as] || ++id));\\n      counter.set(this.value = id);\\n      return pulse;\\n    }\\n  });\\n\\n  function getCounter(view) {\\n    return view._signals[COUNTER_NAME]\\n       || (view._signals[COUNTER_NAME] = view.add(0));\\n  }\\n\\n  /**\\n   * Bind scenegraph items to a scenegraph mark instance.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {object} params.markdef - The mark definition for creating the mark.\\n   *   This is an object of legal scenegraph mark properties which *must* include\\n   *   the 'marktype' property.\\n   */\\n  function Mark(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  vegaUtil.inherits(Mark, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      let mark = this.value;\\n\\n      // acquire mark on first invocation, bind context and group\\n      if (!mark) {\\n        mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);\\n        mark.group.context = _.context;\\n        if (!_.context.group) _.context.group = mark.group;\\n        mark.source = this.source; // point to upstream collector\\n        mark.clip = _.clip;\\n        mark.interactive = _.interactive;\\n        this.value = mark;\\n      }\\n\\n      // initialize entering items\\n      const Init = mark.marktype === Group ? vegaScenegraph.GroupItem : vegaScenegraph.Item;\\n      pulse.visit(pulse.ADD, item => Init.call(item, mark));\\n\\n      // update clipping and/or interactive status\\n      if (_.modified('clip') || _.modified('interactive')) {\\n        mark.clip = _.clip;\\n        mark.interactive = !!_.interactive;\\n        mark.zdirty = true; // force scenegraph re-eval\\n        pulse.reflow();\\n      }\\n\\n      // bind items array to scenegraph mark\\n      mark.items = pulse.source;\\n      return pulse;\\n    }\\n  });\\n\\n  function lookup(_) {\\n    const g = _.groups, p = _.parent;\\n    return g && g.size === 1 ? g.get(Object.keys(g.object)[0])\\n      : g && p ? g.lookup(p)\\n      : null;\\n  }\\n\\n  /**\\n   * Analyze items for overlap, changing opacity to hide items with\\n   * overlapping bounding boxes. This transform will preserve at least\\n   * two items (e.g., first and last) even if overlap persists.\\n   * @param {object} params - The parameters for this operator.\\n   * @param {function(*,*): number} [params.sort] - A comparator\\n   *   function for sorting items.\\n   * @param {object} [params.method] - The overlap removal method to apply.\\n   *   One of 'parity' (default, hide every other item until there is no\\n   *   more overlap) or 'greedy' (sequentially scan and hide and items that\\n   *   overlap with the last visible item).\\n   * @param {object} [params.boundScale] - A scale whose range should be used\\n   *   to bound the items. Items exceeding the bounds of the scale range\\n   *   will be treated as overlapping. If null or undefined, no bounds check\\n   *   will be applied.\\n   * @param {object} [params.boundOrient] - The orientation of the scale\\n   *   (top, bottom, left, or right) used to bound items. This parameter is\\n   *   ignored if boundScale is null or undefined.\\n   * @param {object} [params.boundTolerance] - The tolerance in pixels for\\n   *   bound inclusion testing (default 1). This specifies by how many pixels\\n   *   an item's bounds may exceed the scale range bounds and not be culled.\\n   * @constructor\\n   */\\n  function Overlap(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  const methods = {\\n    parity: items =>\\n      items.filter((item, i) => i % 2 ? (item.opacity = 0) : 1),\\n    greedy: (items, sep) => {\\n      let a;\\n      return items.filter((b, i) =>\\n        (!i || !intersect(a.bounds, b.bounds, sep))\\n          ? (a = b, 1)\\n          : (b.opacity = 0)\\n      );\\n    }\\n  };\\n\\n  // compute bounding box intersection\\n  // including padding pixels of separation\\n  const intersect = (a, b, sep) =>\\n    sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\\n\\n  const hasOverlap = (items, pad) => {\\n    for (var i=1, n=items.length, a=items[0].bounds, b; i<n; a=b, ++i) {\\n      if (intersect(a, b = items[i].bounds, pad)) return true;\\n    }\\n  };\\n\\n  const hasBounds = item => {\\n    var b = item.bounds;\\n    return b.width() > 1 && b.height() > 1;\\n  };\\n\\n  const boundTest = (scale, orient, tolerance) => {\\n    var range = scale.range(),\\n        b = new vegaScenegraph.Bounds();\\n\\n    if (orient === Top || orient === Bottom) {\\n      b.set(range[0], -Infinity, range[1], +Infinity);\\n    } else {\\n      b.set(-Infinity, range[0], +Infinity, range[1]);\\n    }\\n    b.expand(tolerance || 1);\\n\\n    return item => b.encloses(item.bounds);\\n  };\\n\\n  // reset all items to be fully opaque\\n  const reset = source => {\\n    source.forEach(item => item.opacity = 1);\\n    return source;\\n  };\\n\\n  // add all tuples to mod, fork pulse if parameters were modified\\n  // fork prevents cross-stream tuple pollution (e.g., pulse from scale)\\n  const reflow = (pulse, _) =>\\n    pulse.reflow(_.modified()).modifies('opacity');\\n\\n  vegaUtil.inherits(Overlap, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const reduce = methods[_.method] || methods.parity,\\n            sep = _.separation || 0;\\n\\n      let source = pulse.materialize(pulse.SOURCE).source,\\n          items, test;\\n\\n      if (!source || !source.length) return;\\n\\n      if (!_.method) {\\n        // early exit if method is falsy\\n        if (_.modified('method')) {\\n          reset(source);\\n          pulse = reflow(pulse, _);\\n        }\\n        return pulse;\\n      }\\n\\n      // skip labels with no content\\n      source = source.filter(hasBounds);\\n\\n      // early exit, nothing to do\\n      if (!source.length) return;\\n\\n      if (_.sort) {\\n        source = source.slice().sort(_.sort);\\n      }\\n\\n      items = reset(source);\\n      pulse = reflow(pulse, _);\\n\\n      if (items.length >= 3 && hasOverlap(items, sep)) {\\n        do {\\n          items = reduce(items, sep);\\n        } while (items.length >= 3 && hasOverlap(items, sep));\\n\\n        if (items.length < 3 && !vegaUtil.peek(source).opacity) {\\n          if (items.length > 1) vegaUtil.peek(items).opacity = 0;\\n          vegaUtil.peek(source).opacity = 1;\\n        }\\n      }\\n\\n      if (_.boundScale && _.boundTolerance >= 0) {\\n        test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\\n        source.forEach(item => {\\n          if (!test(item)) item.opacity = 0;\\n        });\\n      }\\n\\n      // re-calculate mark bounds\\n      const bounds = items[0].mark.bounds.clear();\\n      source.forEach(item => {\\n        if (item.opacity) bounds.union(item.bounds);\\n      });\\n\\n      return pulse;\\n    }\\n  });\\n\\n  /**\\n   * Queue modified scenegraph items for rendering.\\n   * @constructor\\n   */\\n  function Render(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  vegaUtil.inherits(Render, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const view = pulse.dataflow;\\n\\n      pulse.visit(pulse.ALL, item => view.dirty(item));\\n\\n      // set z-index dirty flag as needed\\n      if (pulse.fields && pulse.fields['zindex']) {\\n        var item = pulse.source && pulse.source[0];\\n        if (item) item.mark.zdirty = true;\\n      }\\n    }\\n  });\\n\\n  const tempBounds = new vegaScenegraph.Bounds();\\n\\n  function set(item, property, value) {\\n    return item[property] === value ? 0\\n      : (item[property] = value, 1);\\n  }\\n\\n  function isYAxis(mark) {\\n    var orient = mark.items[0].orient;\\n    return orient === Left || orient === Right;\\n  }\\n\\n  function axisIndices(datum) {\\n    var index = +datum.grid;\\n    return [\\n      datum.ticks  ? index++ : -1, // ticks index\\n      datum.labels ? index++ : -1, // labels index\\n      index + (+datum.domain)      // title index\\n    ];\\n  }\\n\\n  function axisLayout(view, axis, width, height) {  \\n    var item = axis.items[0],\\n        datum = item.datum,\\n        delta = item.translate != null ? item.translate : 0.5,\\n        orient = item.orient,\\n        indices = axisIndices(datum),\\n        range = item.range,\\n        offset = item.offset,\\n        position = item.position,\\n        minExtent = item.minExtent,\\n        maxExtent = item.maxExtent,\\n        title = datum.title && item.items[indices[2]].items[0],\\n        titlePadding = item.titlePadding,\\n        bounds = item.bounds,\\n        dl = title && vegaScenegraph.multiLineOffset(title),\\n        x = 0, y = 0, i, s;\\n\\n    tempBounds.clear().union(bounds);\\n    bounds.clear();\\n    if ((i=indices[0]) > -1) bounds.union(item.items[i].bounds);\\n    if ((i=indices[1]) > -1) bounds.union(item.items[i].bounds);\\n\\n    // position axis group and title\\n    switch (orient) {\\n      case Top:\\n        x = position || 0;\\n        y = -offset;\\n        s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\\n        bounds.add(0, -s).add(range, 0);\\n        if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);\\n        break;\\n      case Left:\\n        x = -offset;\\n        y = position || 0;\\n        s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\\n        bounds.add(-s, 0).add(0, range);\\n        if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);\\n        break;\\n      case Right:\\n        x = width + offset;\\n        y = position || 0;\\n        s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\\n        bounds.add(0, 0).add(s, range);\\n        if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);\\n        break;\\n      case Bottom:\\n        x = position || 0;\\n        y = height + offset;\\n        s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\\n        bounds.add(0, 0).add(range, s);\\n        if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);\\n        break;\\n      default:\\n        x = item.x;\\n        y = item.y;\\n    }\\n\\n    // update bounds\\n    vegaScenegraph.boundStroke(bounds.translate(x, y), item);\\n\\n    if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {\\n      item.bounds = tempBounds;\\n      view.dirty(item);\\n      item.bounds = bounds;\\n      view.dirty(item);\\n    }\\n\\n    return item.mark.bounds.clear().union(bounds);\\n  }\\n\\n  function axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {\\n    const b = title.bounds;\\n\\n    if (title.auto) {\\n      const v = sign * (offset + dl + pad);\\n      let dx = 0, dy = 0;\\n\\n      view.dirty(title);\\n      isYAxis\\n        ? dx = (title.x || 0) - (title.x = v)\\n        : dy = (title.y || 0) - (title.y = v);\\n      title.mark.bounds.clear().union(b.translate(-dx, -dy));\\n      view.dirty(title);\\n    }\\n\\n    bounds.union(b);\\n  }\\n\\n  // aggregation functions for grid margin determination\\n  const min = (a, b) => Math.floor(Math.min(a, b));\\n  const max = (a, b) => Math.ceil(Math.max(a, b));\\n\\n  function gridLayoutGroups(group) {\\n    var groups = group.items,\\n        n = groups.length,\\n        i = 0, mark, items;\\n\\n    var views = {\\n      marks:      [],\\n      rowheaders: [],\\n      rowfooters: [],\\n      colheaders: [],\\n      colfooters: [],\\n      rowtitle: null,\\n      coltitle: null\\n    };\\n\\n    // layout axes, gather legends, collect bounds\\n    for (; i<n; ++i) {\\n      mark = groups[i];\\n      items = mark.items;\\n      if (mark.marktype === Group) {\\n        switch (mark.role) {\\n          case AxisRole:\\n          case LegendRole:\\n          case TitleRole:\\n            break;\\n          case RowHeader: views.rowheaders.push(...items); break;\\n          case RowFooter: views.rowfooters.push(...items); break;\\n          case ColHeader: views.colheaders.push(...items); break;\\n          case ColFooter: views.colfooters.push(...items); break;\\n          case RowTitle:  views.rowtitle = items[0]; break;\\n          case ColTitle:  views.coltitle = items[0]; break;\\n          default:        views.marks.push(...items);\\n        }\\n      }\\n    }\\n\\n    return views;\\n  }\\n\\n  function bboxFlush(item) {\\n    return new vegaScenegraph.Bounds().set(0, 0, item.width || 0, item.height || 0);\\n  }\\n\\n  function bboxFull(item) {\\n    var b = item.bounds.clone();\\n    return b.empty()\\n      ? b.set(0, 0, 0, 0)\\n      : b.translate(-(item.x || 0), -(item.y || 0));\\n  }\\n\\n  function get(opt, key, d) {\\n    var v = vegaUtil.isObject(opt) ? opt[key] : opt;\\n    return v != null ? v : (d !== undefined ? d : 0);\\n  }\\n\\n  function offsetValue(v) {\\n    return v < 0 ? Math.ceil(-v) : 0;\\n  }\\n\\n  function gridLayout(view, groups, opt) {\\n    var dirty = !opt.nodirty,\\n        bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\\n        bounds = tempBounds.set(0, 0, 0, 0),\\n        alignCol = get(opt.align, Column),\\n        alignRow = get(opt.align, Row),\\n        padCol = get(opt.padding, Column),\\n        padRow = get(opt.padding, Row),\\n        ncols = opt.columns || groups.length,\\n        nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\\n        n = groups.length,\\n        xOffset = Array(n), xExtent = Array(ncols), xMax = 0,\\n        yOffset = Array(n), yExtent = Array(nrows), yMax = 0,\\n        dx = Array(n), dy = Array(n), boxes = Array(n),\\n        m, i, c, r, b, g, px, py, x, y, offset;\\n\\n    for (i=0; i<ncols; ++i) xExtent[i] = 0;\\n    for (i=0; i<nrows; ++i) yExtent[i] = 0;\\n\\n    // determine offsets for each group\\n    for (i=0; i<n; ++i) {\\n      g = groups[i];\\n      b = boxes[i] = bbox(g);\\n      g.x = g.x || 0; dx[i] = 0;\\n      g.y = g.y || 0; dy[i] = 0;\\n      c = i % ncols;\\n      r = ~~(i / ncols);\\n      xMax = Math.max(xMax, px = Math.ceil(b.x2));\\n      yMax = Math.max(yMax, py = Math.ceil(b.y2));\\n      xExtent[c] = Math.max(xExtent[c], px);\\n      yExtent[r] = Math.max(yExtent[r], py);\\n      xOffset[i] = padCol + offsetValue(b.x1);\\n      yOffset[i] = padRow + offsetValue(b.y1);\\n      if (dirty) view.dirty(groups[i]);\\n    }\\n\\n    // set initial alignment offsets\\n    for (i=0; i<n; ++i) {\\n      if (i % ncols === 0) xOffset[i] = 0;\\n      if (i < ncols) yOffset[i] = 0;\\n    }\\n\\n    // enforce column alignment constraints\\n    if (alignCol === Each) {\\n      for (c=1; c<ncols; ++c) {\\n        for (offset=0, i=c; i<n; i += ncols) {\\n          if (offset < xOffset[i]) offset = xOffset[i];\\n        }\\n        for (i=c; i<n; i += ncols) {\\n          xOffset[i] = offset + xExtent[c-1];\\n        }\\n      }\\n    } else if (alignCol === All) {\\n      for (offset=0, i=0; i<n; ++i) {\\n        if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\\n      }\\n      for (i=0; i<n; ++i) {\\n        if (i % ncols) xOffset[i] = offset + xMax;\\n      }\\n    } else {\\n      for (alignCol=false, c=1; c<ncols; ++c) {\\n        for (i=c; i<n; i += ncols) {\\n          xOffset[i] += xExtent[c-1];\\n        }\\n      }\\n    }\\n\\n    // enforce row alignment constraints\\n    if (alignRow === Each) {\\n      for (r=1; r<nrows; ++r) {\\n        for (offset=0, i=r*ncols, m=i+ncols; i<m; ++i) {\\n          if (offset < yOffset[i]) offset = yOffset[i];\\n        }\\n        for (i=r*ncols; i<m; ++i) {\\n          yOffset[i] = offset + yExtent[r-1];\\n        }\\n      }\\n    } else if (alignRow === All) {\\n      for (offset=0, i=ncols; i<n; ++i) {\\n        if (offset < yOffset[i]) offset = yOffset[i];\\n      }\\n      for (i=ncols; i<n; ++i) {\\n        yOffset[i] = offset + yMax;\\n      }\\n    } else {\\n      for (alignRow=false, r=1; r<nrows; ++r) {\\n        for (i=r*ncols, m=i+ncols; i<m; ++i) {\\n          yOffset[i] += yExtent[r-1];\\n        }\\n      }\\n    }\\n\\n    // perform horizontal grid layout\\n    for (x=0, i=0; i<n; ++i) {\\n      x = xOffset[i] + (i % ncols ? x : 0);\\n      dx[i] += x - groups[i].x;\\n    }\\n\\n    // perform vertical grid layout\\n    for (c=0; c<ncols; ++c) {\\n      for (y=0, i=c; i<n; i += ncols) {\\n        y += yOffset[i];\\n        dy[i] += y - groups[i].y;\\n      }\\n    }\\n\\n    // perform horizontal centering\\n    if (alignCol && get(opt.center, Column) && nrows > 1) {\\n      for (i=0; i<n; ++i) {\\n        b = alignCol === All ? xMax : xExtent[i % ncols];\\n        x = b - boxes[i].x2 - groups[i].x - dx[i];\\n        if (x > 0) dx[i] += x / 2;\\n      }\\n    }\\n\\n    // perform vertical centering\\n    if (alignRow && get(opt.center, Row) && ncols !== 1) {\\n      for (i=0; i<n; ++i) {\\n        b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\\n        y = b - boxes[i].y2 - groups[i].y - dy[i];\\n        if (y > 0) dy[i] += y / 2;\\n      }\\n    }\\n\\n    // position grid relative to anchor\\n    for (i=0; i<n; ++i) {\\n      bounds.union(boxes[i].translate(dx[i], dy[i]));\\n    }\\n    x = get(opt.anchor, X);\\n    y = get(opt.anchor, Y);\\n    switch (get(opt.anchor, Column)) {\\n      case End:    x -= bounds.width(); break;\\n      case Middle: x -= bounds.width() / 2;\\n    }\\n    switch (get(opt.anchor, Row)) {\\n      case End:    y -= bounds.height(); break;\\n      case Middle: y -= bounds.height() / 2;\\n    }\\n    x = Math.round(x);\\n    y = Math.round(y);\\n\\n    // update mark positions, bounds, dirty\\n    bounds.clear();\\n    for (i=0; i<n; ++i) {\\n      groups[i].mark.bounds.clear();\\n    }\\n    for (i=0; i<n; ++i) {\\n      g = groups[i];\\n      g.x += (dx[i] += x);\\n      g.y += (dy[i] += y);\\n      bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\\n      if (dirty) view.dirty(g);\\n    }\\n\\n    return bounds;\\n  }\\n\\n  function trellisLayout(view, group, opt) {\\n    var views = gridLayoutGroups(group),\\n        groups = views.marks,\\n        bbox = opt.bounds === Flush ? boundFlush : boundFull,\\n        off = opt.offset,\\n        ncols = opt.columns || groups.length,\\n        nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\\n        cells = nrows * ncols,\\n        x, y, x2, y2, anchor, band, offset;\\n\\n    // -- initial grid layout\\n    const bounds = gridLayout(view, groups, opt);\\n    if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid\\n\\n    // -- layout grid headers and footers --\\n\\n    // perform row header layout\\n    if (views.rowheaders) {\\n      band = get(opt.headerBand, Row, null);\\n      x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\\n    }\\n\\n    // perform column header layout\\n    if (views.colheaders) {\\n      band = get(opt.headerBand, Column, null);\\n      y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\\n    }\\n\\n    // perform row footer layout\\n    if (views.rowfooters) {\\n      band = get(opt.footerBand, Row, null);\\n      x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows,  get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols-1, ncols, 1, band);\\n    }\\n\\n    // perform column footer layout\\n    if (views.colfooters) {\\n      band = get(opt.footerBand, Column, null);\\n      y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols,  get(off, 'columnFooter'), max, 1, bbox, 'y2', cells-ncols, 1, ncols, band);\\n    }\\n\\n    // perform row title layout\\n    if (views.rowtitle) {\\n      anchor = get(opt.titleAnchor, Row);\\n      offset = get(off, 'rowTitle');\\n      offset = anchor === End ? x2 + offset : x - offset;\\n      band = get(opt.titleBand, Row, 0.5);\\n      layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\\n    }\\n\\n    // perform column title layout\\n    if (views.coltitle) {\\n      anchor = get(opt.titleAnchor, Column);\\n      offset = get(off, 'columnTitle');\\n      offset = anchor === End ? y2 + offset : y - offset;\\n      band = get(opt.titleBand, Column, 0.5);\\n      layoutTitle(view, views.coltitle, offset, 1, bounds, band);\\n    }\\n  }\\n\\n  function boundFlush(item, field) {\\n    return field === 'x1' ? (item.x || 0)\\n      : field === 'y1' ? (item.y || 0)\\n      : field === 'x2' ? (item.x || 0) + (item.width || 0)\\n      : field === 'y2' ? (item.y || 0) + (item.height || 0)\\n      : undefined;\\n  }\\n\\n  function boundFull(item, field) {\\n    return item.bounds[field];\\n  }\\n\\n  function layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\\n    var n = groups.length,\\n        init = 0,\\n        edge = 0,\\n        i, j, k, m, b, h, g, x, y;\\n\\n    // if no groups, early exit and return 0\\n    if (!n) return init;\\n\\n    // compute margin\\n    for (i=start; i<n; i+=stride) {\\n      if (groups[i]) init = agg(init, bound(groups[i], bf));\\n    }\\n\\n    // if no headers, return margin calculation\\n    if (!headers.length) return init;\\n\\n    // check if number of headers exceeds number of rows or columns\\n    if (headers.length > limit) {\\n      view.warn('Grid headers exceed limit: ' + limit);\\n      headers = headers.slice(0, limit);\\n    }\\n\\n    // apply offset\\n    init += offset;\\n\\n    // clear mark bounds for all headers\\n    for (j=0, m=headers.length; j<m; ++j) {\\n      view.dirty(headers[j]);\\n      headers[j].mark.bounds.clear();\\n    }\\n\\n    // layout each header\\n    for (i=start, j=0, m=headers.length; j<m; ++j, i+=stride) {\\n      h = headers[j];\\n      b = h.mark.bounds;\\n\\n      // search for nearest group to align to\\n      // necessary if table has empty cells\\n      for (k=i; k >= 0 && (g = groups[k]) == null; k-=back);\\n\\n      // assign coordinates and update bounds\\n      if (isX) {\\n        x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\\n        y = init;\\n      } else {\\n        x = init;\\n        y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\\n      }\\n      b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\\n      h.x = x;\\n      h.y = y;\\n      view.dirty(h);\\n\\n      // update current edge of layout bounds\\n      edge = agg(edge, b[bf]);\\n    }\\n\\n    return edge;\\n  }\\n\\n  function layoutTitle(view, g, offset, isX, bounds, band) {\\n    if (!g) return;\\n    view.dirty(g);\\n\\n    // compute title coordinates\\n    var x = offset, y = offset;\\n    isX\\n      ? (x = Math.round(bounds.x1 + band * bounds.width()))\\n      : (y = Math.round(bounds.y1 + band * bounds.height()));\\n\\n    // assign coordinates and update bounds\\n    g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\\n    g.mark.bounds.clear().union(g.bounds);\\n    g.x = x;\\n    g.y = y;\\n\\n    // queue title for redraw\\n    view.dirty(g);\\n  }\\n\\n  // utility for looking up legend layout configuration\\n  function lookup$1(config, orient) {\\n    const opt = config[orient] || {};\\n    return (key, d) => opt[key] != null ? opt[key]\\n      : config[key] != null ? config[key]\\n      : d;\\n  }\\n\\n  // if legends specify offset directly, use the maximum specified value\\n  function offsets(legends, value) {\\n    var max = -Infinity;\\n    legends.forEach(item => {\\n      if (item.offset != null) max = Math.max(max, item.offset);\\n    });\\n    return max > -Infinity ? max : value;\\n  }\\n\\n  function legendParams(g, orient, config, xb, yb, w, h) {\\n    const _ = lookup$1(config, orient),\\n          offset = offsets(g, _('offset', 0)),\\n          anchor = _('anchor', Start),\\n          mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\\n\\n    const p = {\\n      align:   Each,\\n      bounds:  _('bounds', Flush),\\n      columns: _('direction') === 'vertical' ? 1 : g.length,\\n      padding: _('margin', 8),\\n      center:  _('center'),\\n      nodirty: true\\n    };\\n\\n    switch (orient) {\\n      case Left:\\n        p.anchor = {\\n          x: Math.floor(xb.x1) - offset, column: End,\\n          y: mult * (h || xb.height() + 2 * xb.y1), row: anchor\\n        };\\n        break;\\n      case Right:\\n        p.anchor = {\\n          x: Math.ceil(xb.x2) + offset,\\n          y: mult * (h || xb.height() + 2 * xb.y1), row: anchor\\n        };\\n        break;\\n      case Top:\\n        p.anchor = {\\n          y: Math.floor(yb.y1) - offset, row: End,\\n          x: mult * (w || yb.width() + 2 * yb.x1), column: anchor\\n        };\\n        break;\\n      case Bottom:\\n        p.anchor = {\\n          y: Math.ceil(yb.y2) + offset,\\n          x: mult * (w || yb.width() + 2 * yb.x1), column: anchor\\n        };\\n        break;\\n      case TopLeft:\\n        p.anchor = {x: offset, y: offset};\\n        break;\\n      case TopRight:\\n        p.anchor = {x: w - offset, y: offset, column: End};\\n        break;\\n      case BottomLeft:\\n        p.anchor = {x: offset, y: h - offset, row: End};\\n        break;\\n      case BottomRight:\\n        p.anchor = {x: w - offset, y: h - offset, column: End, row: End};\\n        break;\\n    }\\n\\n    return p;\\n  }\\n\\n  function legendLayout(view, legend) {\\n    var item = legend.items[0],\\n        datum = item.datum,\\n        orient = item.orient,\\n        bounds = item.bounds,\\n        x = item.x, y = item.y, w, h;\\n\\n    // cache current bounds for later comparison\\n    item._bounds\\n      ? item._bounds.clear().union(bounds)\\n      : item._bounds = bounds.clone();\\n    bounds.clear();\\n\\n    // adjust legend to accommodate padding and title\\n    legendGroupLayout(view, item, item.items[0].items[0]);\\n\\n    // aggregate bounds to determine size, and include origin\\n    bounds = legendBounds(item, bounds);\\n    w = 2 * item.padding;\\n    h = 2 * item.padding;\\n    if (!bounds.empty()) {\\n      w = Math.ceil(bounds.width() + w);\\n      h = Math.ceil(bounds.height() + h);\\n    }\\n\\n    if (datum.type === Symbols) {\\n      legendEntryLayout(item.items[0].items[0].items[0].items);\\n    }\\n\\n    if (orient !== None) {\\n      item.x = x = 0;\\n      item.y = y = 0;\\n    }\\n    item.width = w;\\n    item.height = h;\\n    vegaScenegraph.boundStroke(bounds.set(x, y, x + w, y + h), item);\\n    item.mark.bounds.clear().union(bounds);\\n\\n    return item;\\n  }\\n\\n  function legendBounds(item, b) {\\n    // aggregate item bounds\\n    item.items.forEach(_ => b.union(_.bounds));\\n\\n    // anchor to legend origin\\n    b.x1 = item.padding;\\n    b.y1 = item.padding;\\n\\n    return b;\\n  }\\n\\n  function legendGroupLayout(view, item, entry) {\\n    var pad = item.padding,\\n        ex = pad - entry.x,\\n        ey = pad - entry.y;\\n\\n    if (!item.datum.title) {\\n      if (ex || ey) translate(view, entry, ex, ey);\\n    } else {\\n      var title = item.items[1].items[0],\\n          anchor = title.anchor,\\n          tpad = item.titlePadding || 0,\\n          tx = pad - title.x,\\n          ty = pad - title.y;\\n\\n      switch (title.orient) {\\n        case Left:\\n          ex += Math.ceil(title.bounds.width()) + tpad;\\n          break;\\n        case Right:\\n        case Bottom:\\n          break;\\n        default:\\n          ey += title.bounds.height() + tpad;\\n      }\\n      if (ex || ey) translate(view, entry, ex, ey);\\n\\n      switch (title.orient) {\\n        case Left:\\n          ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\\n          break;\\n        case Right:\\n          tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\\n          ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\\n          break;\\n        case Bottom:\\n          tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\\n          ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\\n          break;\\n        default:\\n          tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\\n      }\\n      if (tx || ty) translate(view, title, tx, ty);\\n\\n      // translate legend if title pushes into negative coordinates\\n      if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\\n        translate(view, entry, -tx, 0);\\n        translate(view, title, -tx, 0);\\n      }\\n    }\\n  }\\n\\n  function legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\\n    const grad = item.datum.type !== 'symbol',\\n          vgrad = title.datum.vgrad,\\n          e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\\n          s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\\n          u = vgrad && lr ? s : 0,\\n          v = vgrad && lr ? 0 : s,\\n          o = y <= 0 ? 0 : vegaScenegraph.multiLineOffset(title);\\n\\n    return Math.round(anchor === Start ? u\\n      : anchor === End ? (v - o)\\n      : 0.5 * (s - o));\\n  }\\n\\n  function translate(view, item, dx, dy) {\\n    item.x += dx;\\n    item.y += dy;\\n    item.bounds.translate(dx, dy);\\n    item.mark.bounds.translate(dx, dy);\\n    view.dirty(item);\\n  }\\n\\n  function legendEntryLayout(entries) {\\n    // get max widths for each column\\n    var widths = entries.reduce((w, g) => {\\n      w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\\n      return w;\\n    }, {});\\n\\n    // set dimensions of legend entry groups\\n    entries.forEach(g => {\\n      g.width  = widths[g.column];\\n      g.height = g.bounds.y2 - g.y;\\n    });\\n  }\\n\\n  function titleLayout(view, mark, width, height, viewBounds) {\\n    var group = mark.items[0],\\n        frame = group.frame,\\n        orient = group.orient,\\n        anchor = group.anchor,\\n        offset = group.offset,\\n        padding = group.padding,\\n        title = group.items[0].items[0],\\n        subtitle = group.items[1] && group.items[1].items[0],\\n        end = (orient === Left || orient === Right) ? height : width,\\n        start = 0, x = 0, y = 0, sx = 0, sy = 0, pos;\\n\\n    if (frame !== Group) {\\n      orient === Left ? (start = viewBounds.y2, end = viewBounds.y1)\\n        : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2)\\n        : (start = viewBounds.x1, end = viewBounds.x2);\\n    } else if (orient === Left) {\\n      start = height, end = 0;\\n    }\\n\\n    pos = (anchor === Start) ? start\\n      : (anchor === End) ? end\\n      : (start + end) / 2;\\n\\n    if (subtitle && subtitle.text) {\\n      // position subtitle\\n      switch (orient) {\\n        case Top:\\n        case Bottom:\\n          sy = title.bounds.height() + padding;\\n          break;\\n        case Left:\\n          sx = title.bounds.width() + padding;\\n          break;\\n        case Right:\\n          sx = -title.bounds.width() - padding;\\n          break;\\n      }\\n\\n      tempBounds.clear().union(subtitle.bounds);\\n      tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));\\n      if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {\\n        view.dirty(subtitle);\\n        subtitle.bounds.clear().union(tempBounds);\\n        subtitle.mark.bounds.clear().union(tempBounds);\\n        view.dirty(subtitle);\\n      }\\n\\n      tempBounds.clear().union(subtitle.bounds);\\n    } else {\\n      tempBounds.clear();\\n    }\\n    tempBounds.union(title.bounds);\\n\\n    // position title group\\n    switch (orient) {\\n      case Top:\\n        x = pos;\\n        y = viewBounds.y1 - tempBounds.height() - offset;\\n        break;\\n      case Left:\\n        x = viewBounds.x1 - tempBounds.width() - offset;\\n        y = pos;\\n        break;\\n      case Right:\\n        x = viewBounds.x2 + tempBounds.width() + offset;\\n        y = pos;\\n        break;\\n      case Bottom:\\n        x = pos;\\n        y = viewBounds.y2 + offset;\\n        break;\\n      default:\\n        x = group.x;\\n        y = group.y;\\n    }\\n\\n    if (set(group, 'x', x) | set(group, 'y', y)) {\\n      tempBounds.translate(x, y);\\n      view.dirty(group);\\n      group.bounds.clear().union(tempBounds);\\n      mark.bounds.clear().union(tempBounds);\\n      view.dirty(group);\\n    }\\n    return group.bounds;\\n  }\\n\\n  /**\\n   * Layout view elements such as axes and legends.\\n   * Also performs size adjustments.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {object} params.mark - Scenegraph mark of groups to layout.\\n   */\\n  function ViewLayout(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n\\n  vegaUtil.inherits(ViewLayout, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      const view = pulse.dataflow;\\n      _.mark.items.forEach(group => {\\n        if (_.layout) trellisLayout(view, group, _.layout);\\n        layoutGroup(view, group, _);\\n      });\\n      return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;\\n    }\\n  });\\n\\n  function shouldReflow(group) {\\n    // We typically should reflow if layout is invoked (#2568), as child items\\n    // may have resized and reflow ensures group bounds are re-calculated.\\n    // However, legend entries have a special exception to avoid instability.\\n    // For example, if a selected legend symbol gains a stroke on hover,\\n    // we don't want to re-position subsequent elements in the legend.\\n    return group && group.mark.role !== 'legend-entry';\\n  }\\n\\n  function layoutGroup(view, group, _) {\\n    var items = group.items,\\n        width = Math.max(0, group.width || 0),\\n        height = Math.max(0, group.height || 0),\\n        viewBounds = new vegaScenegraph.Bounds().set(0, 0, width, height),\\n        xBounds = viewBounds.clone(),\\n        yBounds = viewBounds.clone(),\\n        legends = [], title,\\n        mark, orient, b, i, n;\\n\\n    // layout axes, gather legends, collect bounds\\n    for (i=0, n=items.length; i<n; ++i) {\\n      mark = items[i];\\n      switch (mark.role) {\\n        case AxisRole:\\n          b = isYAxis(mark) ? xBounds : yBounds;\\n          b.union(axisLayout(view, mark, width, height));\\n          break;\\n        case TitleRole:\\n          title = mark;\\n          break;\\n        case LegendRole:\\n          legends.push(legendLayout(view, mark));\\n          break;\\n        case FrameRole:\\n        case ScopeRole:\\n        case RowHeader:\\n        case RowFooter:\\n        case RowTitle:\\n        case ColHeader:\\n        case ColFooter:\\n        case ColTitle:\\n          xBounds.union(mark.bounds);\\n          yBounds.union(mark.bounds);\\n          break;\\n        default:\\n          viewBounds.union(mark.bounds);\\n      }\\n    }\\n\\n    // layout legends, adjust viewBounds\\n    if (legends.length) {\\n      // group legends by orient\\n      const l = {};\\n      legends.forEach(item => {\\n        orient = item.orient || Right;\\n        if (orient !== None) (l[orient] || (l[orient] = [])).push(item);\\n      });\\n\\n      // perform grid layout for each orient group\\n      for (const orient in l) {\\n        const g = l[orient];\\n        gridLayout(view, g, legendParams(\\n          g, orient, _.legends, xBounds, yBounds, width, height\\n        ));\\n      }\\n\\n      // update view bounds\\n      legends.forEach(item => {\\n        const b = item.bounds;\\n\\n        if (!b.equals(item._bounds)) {\\n          item.bounds = item._bounds;\\n          view.dirty(item); // dirty previous location\\n          item.bounds = b;\\n          view.dirty(item);\\n        }\\n\\n        if (_.autosize && _.autosize.type === Fit) {\\n          // For autosize fit, incorporate the orthogonal dimension only.\\n          // Legends that overrun the chart area will then be clipped;\\n          // otherwise the chart area gets reduced to nothing!\\n          switch(item.orient) {\\n            case Left:\\n            case Right:\\n              viewBounds.add(b.x1, 0).add(b.x2, 0);\\n              break;\\n            case Top:\\n            case Bottom:\\n              viewBounds.add(0, b.y1).add(0, b.y2);\\n          }\\n        } else {\\n          viewBounds.union(b);\\n        }\\n      });\\n    }\\n\\n    // combine bounding boxes\\n    viewBounds.union(xBounds).union(yBounds);\\n\\n    // layout title, adjust bounds\\n    if (title) {\\n      viewBounds.union(titleLayout(view, title, width, height, viewBounds));\\n    }\\n\\n    // override aggregated view bounds if content is clipped\\n    if (group.clip) {\\n      viewBounds.set(0, 0, group.width || 0, group.height || 0);\\n    }\\n\\n    // perform size adjustment\\n    viewSizeLayout(view, group, viewBounds, _);\\n  }\\n\\n  function viewSizeLayout(view, group, viewBounds, _) {\\n    const auto = _.autosize || {},\\n          type = auto.type;\\n\\n    if (view._autosize < 1 || !type) return;\\n\\n    let viewWidth = view._width,\\n        viewHeight = view._height,\\n        width  = Math.max(0, group.width || 0),\\n        left   = Math.max(0, Math.ceil(-viewBounds.x1)),\\n        height = Math.max(0, group.height || 0),\\n        top    = Math.max(0, Math.ceil(-viewBounds.y1));\\n\\n    const right  = Math.max(0, Math.ceil(viewBounds.x2 - width)),\\n          bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\\n\\n    if (auto.contains === Padding) {\\n      const padding = view.padding();\\n      viewWidth -= padding.left + padding.right;\\n      viewHeight -= padding.top + padding.bottom;\\n    }\\n\\n    if (type === None) {\\n      left = 0;\\n      top = 0;\\n      width = viewWidth;\\n      height = viewHeight;\\n    }\\n\\n    else if (type === Fit) {\\n      width = Math.max(0, viewWidth - left - right);\\n      height = Math.max(0, viewHeight - top - bottom);\\n    }\\n\\n    else if (type === FitX) {\\n      width = Math.max(0, viewWidth - left - right);\\n      viewHeight = height + top + bottom;\\n    }\\n\\n    else if (type === FitY) {\\n      viewWidth = width + left + right;\\n      height = Math.max(0, viewHeight - top - bottom);\\n    }\\n\\n    else if (type === Pad) {\\n      viewWidth = width + left + right;\\n      viewHeight = height + top + bottom;\\n    }\\n\\n    view._resizeView(\\n      viewWidth, viewHeight,\\n      width, height,\\n      [left, top],\\n      auto.resize\\n    );\\n  }\\n\\n  exports.bound = Bound;\\n  exports.identifier = Identifier;\\n  exports.mark = Mark;\\n  exports.overlap = Overlap;\\n  exports.render = Render;\\n  exports.viewlayout = ViewLayout;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"transforms\",\"vegaDataflow\",\"vegaScenegraph\",\"vegaUtil\",\"Bound\",\"params\",\"Transform\",\"call\",\"boundItem\",\"item\",\"bound\",\"opt\",\"bounds\",\"clear\",\"Identifier\",\"getCounter\",\"view\",\"_signals\",\"COUNTER_NAME\",\"add\",\"Mark\",\"lookup\",\"_\",\"g\",\"groups\",\"p\",\"parent\",\"size\",\"get\",\"Object\",\"keys\",\"object\",\"Overlap\",\"Render\",\"set\",\"property\",\"value\",\"isYAxis\",\"mark\",\"orient\",\"items\",\"Left\",\"Right\",\"axisLayout\",\"axis\",\"width\",\"height\",\"datum\",\"delta\",\"translate\",\"index\",\"grid\",\"ticks\",\"labels\",\"domain\",\"range\",\"offset\",\"position\",\"minExtent\",\"maxExtent\",\"title\",\"indices\",\"titlePadding\",\"dl\",\"multiLineOffset\",\"i\",\"tempBounds\",\"union\",\"Top\",\"x\",\"y\",\"s\",\"Math\",\"max\",\"min\",\"y1\",\"axisTitleLayout\",\"x1\",\"x2\",\"Bottom\",\"y2\",\"boundStroke\",\"dirty\",\"pad\",\"sign\",\"b\",\"auto\",\"v\",\"dy\",\"dx\",\"bboxFlush\",\"Bounds\",\"bboxFull\",\"clone\",\"empty\",\"key\",\"d\",\"isObject\",\"undefined\",\"offsetValue\",\"ceil\",\"gridLayout\",\"nodirty\",\"bbox\",\"Flush\",\"alignCol\",\"align\",\"Column\",\"alignRow\",\"Row\",\"padCol\",\"padding\",\"padRow\",\"ncols\",\"columns\",\"length\",\"nrows\",\"n\",\"xOffset\",\"Array\",\"xExtent\",\"xMax\",\"yOffset\",\"yExtent\",\"yMax\",\"boxes\",\"px\",\"py\",\"c\",\"r\",\"Each\",\"All\",\"m\",\"center\",\"anchor\",\"X\",\"Y\",\"End\",\"Middle\",\"round\",\"boundFlush\",\"field\",\"boundFull\",\"layoutHeaders\",\"headers\",\"limit\",\"agg\",\"isX\",\"bf\",\"start\",\"stride\",\"back\",\"band\",\"edge\",\"init\",\"warn\",\"slice\",\"j\",\"h\",\"k\",\"layoutTitle\",\"lookup$1\",\"config\",\"offsets\",\"legends\",\"Infinity\",\"forEach\",\"legendParams\",\"xb\",\"yb\",\"w\",\"Start\",\"mult\",\"floor\",\"column\",\"row\",\"TopLeft\",\"TopRight\",\"BottomLeft\",\"BottomRight\",\"legendLayout\",\"legend\",\"_bounds\",\"ex\",\"entry\",\"ey\",\"tpad\",\"tx\",\"ty\",\"legendTitleOffset\",\"legendBounds\",\"Symbols\",\"type\",\"legendEntryLayout\",\"None\",\"lr\",\"noBar\",\"vgrad\",\"e\",\"u\",\"o\",\"entries\",\"widths\",\"reduce\",\"titleLayout\",\"viewBounds\",\"group\",\"subtitle\",\"end\",\"sy\",\"sx\",\"Group\",\"frame\",\"pos\",\"text\",\"ViewLayout\",\"shouldReflow\",\"role\",\"layoutGroup\",\"xBounds\",\"yBounds\",\"AxisRole\",\"TitleRole\",\"LegendRole\",\"push\",\"FrameRole\",\"ScopeRole\",\"RowHeader\",\"RowFooter\",\"RowTitle\",\"ColHeader\",\"ColFooter\",\"ColTitle\",\"l\",\"equals\",\"autosize\",\"Fit\",\"clip\",\"viewSizeLayout\",\"_autosize\",\"viewWidth\",\"_width\",\"viewHeight\",\"_height\",\"left\",\"top\",\"right\",\"bottom\",\"Padding\",\"contains\",\"FitX\",\"FitY\",\"Pad\",\"_resizeView\",\"resize\",\"inherits\",\"transform\",\"pulse\",\"dataflow\",\"marktype\",\"Marks\",\"markBounds\",\"nested\",\"modified\",\"visit\",\"MOD\",\"reflow\",\"rebound\",\"changed\",\"REM\",\"ADD\",\"alignsWith\",\"boundClip\",\"modifies\",\"Definition\",\"counter\",\"as\",\"id\",\"t\",\"scenegraph\",\"markdef\",\"context\",\"source\",\"interactive\",\"Init\",\"GroupItem\",\"Item\",\"zdirty\",\"methods\",\"parity\",\"filter\",\"opacity\",\"greedy\",\"sep\",\"a\",\"intersect\",\"hasOverlap\",\"hasBounds\",\"boundTest\",\"scale\",\"tolerance\",\"expand\",\"encloses\",\"reset\",\"method\",\"separation\",\"materialize\",\"SOURCE\",\"sort\",\"peek\",\"boundScale\",\"boundTolerance\",\"test\",\"boundOrient\",\"ALL\",\"fields\",\"layout\",\"rowheaders\",\"rowfooters\",\"colheaders\",\"colfooters\",\"rowtitle\",\"coltitle\",\"marks\",\"off\",\"cells\",\"headerBand\",\"footerBand\",\"titleAnchor\",\"titleBand\",\"identifier\",\"overlap\",\"render\",\"viewlayout\",\"defineProperty\"]\n}\n"]